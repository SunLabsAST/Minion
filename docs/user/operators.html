<html>
<head>
<title>Minion Query Operators</title>
<link rel="stylesheet" type="text/css" href="doc.css">
</head>

<body>
<div class="pageHeader">
Query Operators
</div>
<div class="mainDoc">
Minion provides many query operators.  The operators range from simple
boolean "and" and "or" operators to more complex field and passage
operators.  This page describes the operators, and how they may be used
in the Strict grammar.  Some operators may be available in other
grammars as well.

<p>
<div class="subHeader">Default Operator</div>

If no operator is specified between terms, a default implicit operator
is assumed.  Unless otherwise specified, the default operator that is
inserted is <a href="#pand">PAND</a>.

<p>
<div class="subHeader">Operator Precedence</div>

In the strict grammar, the AND operator has the highest precedence.  It
is followed by the implicit operator, then the OR operator.  Since the
strict grammar allows a mix of infix, prefix, group, binary, and unary
operators, the use of parentheses to group terms is recommended for all
but the simplest queries.  In the case of prefix operators, parentheses
are required.

<p>
<div class="subHeader">Operator Syntax</div>

The strict grammar's operators are enclosed inside of angle brackets
like so: <span class="query">&lt;AND&gt;</span>.  Operators may be
specified using all uppercase or all lowercase letters.  Mixed case is
not allowed.

<p>
<div class="subHeader">Quotation and Special Characters</div>

Words in the strict grammar are separated by whitespace.  Quotation
marks are used to specify a phrase.  Single tick marks can be used to
identify a set of characters that should be treated as a single word and
not tokenized such as <span class="query">'F.B.I.'</span>.  This is only
needed when querying a field that was not tokenized.  Single tick marks
are also used to quote terms that contain wildcard characters (<span
class="query">*</span>, <span class="query">?</span>) but should not be
treated as wildcard expressions.  Since single ticks have a special
meaning, they must be escaped with <span class="query">\</span> when
used as a regular character.  To get the expected behavior, <span
class="query">can't</span> must either be written as <span
class="query">can\'t</span> or it may be enclosed in quotation marks as
<span class="query">"can't"</span>.  Parentheses (<span
class="query">(</span> and <span class="query">)</span>) follow the same
rule -- they must be escaped, or enclosed in a quotation.  For
convenience, the characters that don't need to be escaped inside a
quotation may also be escaped inside the quotation without changing the
meaning of the quotation.  <span class="query">\</span> and <span
class="query">=</span> must always be prefaced with a backslash when
they are not being used as part of the grammar, regardless of where they
occur.


<p>
<div class="subHeader"><a name="morphexp">Morphological Expansion</a></div>

--needs edits--<br>
By default, morphological expansion is applied to all query terms.
The default engine used for morphological expansion is known as
LiteMorph.  LiteMorph is a rule-based system for generating potential
morphological variants of terms.  The variants are based on the
structure of the word only, and not on any understanding of the word.
For a more sophisticated morphology engine, see FullMorph.

<p>
<div class="subHeader">Operators</div>

Query operators are divided up into a few different groups.  The regular
operators help describe terms that are to be evaluated against whole
documents.  The field operators work on specific fields of documents.
The "Contains" operator will limit most regular queries to operate on a
specific field.  The argument is a term or an expression.  The modifier
operators (below) may be used on the term.  The other field operators
work on saved fields.  The arguments are interpreted strings, so the
term modifiers and regular operators may not be used in conjuction with
them.  Modifier operators work specifically on terms to modify their
usage during query evaluation.
</div>
<div class="contents">
Regular operators:
<ul>
    <li><a href="#and">And</a></li>
    <li><a href="#or">Or</a></li>
    <li><a href="#not">Not</a></li>
    <li><a href="#pand">PAnd</a></li>
    <li><a href="#near">Near</a></li>
    <li><a href="#nearn">Near/n</a></li>
    <li><a href="#passage">Passage</a></li>
    <li><a href="#phrase">Phrase</a></li>
    <li><a href="#tor">TOr</a></li>
    <li><a href="#if">If</a></li>
    <li><a href="#weight">Weight</a></li>
    <li><a href="#hide">Hide</a></li>
    <li><a href="#undefined">Undefined</a></li>
    <li><a href="#sequence">Sequence</a></li>
</ul>
Field operators:
<ul>
    <li><a href="#contains">Contains</a></li>
    <li><a href="#starts">Starts</a></li>
    <li><a href="#ends">Ends</a></li>
    <li><a href="#matches">Matches</a></li>
    <li><a href="#similar">Similar</a></li>
    <li><a href="#substring">Substring</a></li>
    <li><a href="#lessthan">Less Than</a></li>
    <li><a href="#greaterthan">Greater Than</a></li>
    <li><a href="#lessequal">Less Than or Equal To</a></li>
    <li><a href="#greaterequal">Greater Than or Equal To</a></li>
    <li><a href="#equals">Equals</a></li>
    <li><a href="#notequals">Not Equals</a></li>
</ul>
Term Modifiers:
<ul>
    <li><a href="#exact">Exact</a></li>
    <li><a href="#morph">Morph</a></li>
    <li><a href="#stem">Stem</a></li>
    <li><a href="#expand">Expand</a></li>
    <li><a href="#case">Case</a></li>
</ul>
</div>

<div class="mainHeader"><a name="and">And</a></div>
<dl>
<dt>Description</dt>
<dd>
The AND operator performs a simple boolean AND of terms.  Any term
that occurs as an operand for AND is a mandatory term -- that is, it
must be in a matching document to satisfy the AND condition.  AND may be
used as either an infix or a prefix operator.  Documents are ranked
according to how important the operands are to the document.
</dd>
<dt>Examples</dt>
<dd>
<span class="query">apples &lt;AND&gt; oranges &lt;AND&gt; peaches</span><br>
<span class="query">(&lt;AND&gt; apples oranges peaches)</span><br>
Finds documents contains "apples", "oranges", and peaches anywhere in the
document and in any order.  Documents that contain fewer than all three
words are left out.
</dd>
</dl>

<div class="mainHeader"><a name="or">Or</a></div>
<dl>
<dt>Description</dt>
<dd>
The OR operator performs a simple boolean OR of terms.  The system will
match documents that contain any of the terms that are operands of the
OR.  OR may be used as either an infix or a prefix operator.  Documents
are ranked according to how import the operands are to the document.
</dd>
<dt>Examples</dt>
<dd>
<span class="query">apples &lt;OR&gt; oranges &lt;OR&gt; peaches</span><br>
<span class="query">(&lt;OR&gt; apples oranges peaches)</span><br>
Finds documents containing any of "apples", "oranges", or "peaches".
</dd>
</dl>

<div class="mainHeader"><a name="not">Not</a></div>
<dl>
<dt>Description</dt>
<dd>
The unary NOT operator specifies a term or set of terms that are to be
avoided in finding documents.  Documents that contain any terms prefixed
with the NOT operator are excluded.
</dd>
<dt>Examples</dt>
<dd>
<span class="query">surf &lt;AND&gt; &lt;NOT&gt; channel</span><br>
Finds documents that do contain the word "surf", but excludes any of
those documents that also contain the word "channel".<br><br>
<span class="query">surf &lt;AND&gt; &lt;NOT&gt; (channel &lt;OR&gt; web)</span><br>
Finds documents that do contain the word "surf" but do not contain any
or "web" or "channel".<br><br>
<span class="query">surf &lt;AND&gt; &lt;NOT&gt; (channel &lt;AND&gt; web)</span><br>
Finds documents that do contain the word "surf" but do not contain both
"web" and "channel" (a document with only "surf" and "web" but not
"channel" would be included in the results).
</dd>
</dl>


<div class="mainHeader"><a name="pand">PAnd</a></div>
<dl>
<dt>Description</dt>
<dd>

PAND stands for "Passage And".  This operator works similarly to the AND
operator in that all operands are considered to be required terms.  The
difference between AND and PAND is that PAND requests that its operands
be treated as a passage.  The same documents that would be returned for
AND are returned for PAND, excluding documents that don't have at least
half of the operands together in a passage.  The maximum allowed length
of qualifying passages is based on the number of operands provided (100
+ (numOperands * 25)).  Unlike AND, the scoring is performed based on
Minion's relaxation ranking passage retrieval algorithm.  Minion ranks
documents according to which documents have the provided operands...

<ul>
<li>in the order in which they were specified
<li>with the fewest morphological variations
<li>and with the fewest intervening words
</ul><br>

Documents that have the exact words as an exact phrase will be ranked
the highest.  Documents that have the words but with variations or with
words in between will be penalized and given lower scores.  The severity
of the penalty is relative to the amount of deviation from the original
query.  Morphological changes are penalized the least, followed by
intervening text, then word order.  The actual penalties per deviation
have been chosen to allow, for example, the penalty for many words of
intervening text to outway a single word order penalty.<p>

PAND is the default operator, unless otherwise specified.
</dd>
<dt>Examples</dt>
<dd>
<span class="query">rock and roll</span><br>
<span class="query">rock &lt;PAND&gt; and &lt;PAND&gt; roll</span><br>
<span class="query">(&lt;PAND&gt; rock and roll)</span><br>

These three queries are all evaluated the same way.  Documents must
contain "rock", "and", and "roll" (or morphological variations of those
terms) to be returned.  Documents that contain the exact phrase "rock
and roll" will be scored the highest, while a document containing the
phrase "rocking and rolling" will be penalized slightly since
morphological variations were needed to match the passage.  A document
containing "rock the boat and you might roll over" will be penalized
more for the intervening words.  A document containing the phrase "and
rolling is what will happen if you rock the boat" will be penalized even
further since the words were out of order, had intervening text, and the
word "rolling" was used instead of "roll".

</dd>
</dl>


<div class="mainHeader"><a name="near">Near</a></div>
<dl>
<dt>Description</dt>
<dd>

The NEAR operator is a proximity operator similar to <a
href="#pand">PAND</a> but with more constraints.  All the operands
provided must appear in a passage in a document in order for that
document to be included in the result, and each operand must be within
1000 words of each other operand.  The length does not vary with the
number of operands.  Results are scored according to the relaxation
ranking passage retrieval algorithm described in <a
href="#pand">PAND</a>.  NEAR may be used as a prefix or an infix
operator.

</dd>
<dt>Examples</dt>
<dd>
<span class="query">minion &lt;NEAR&gt; engine</span><br>
Finds documents containing both the words "minion" and "engine", with no
more than 1000 words between and ranks them according to the passage
retrieval ranking algorithm.
</dd>
</dl>


<div class="mainHeader"><a name="nearn">Near/n</a></div>
<dl>
<dt>Description</dt>
<dd>
The NEAR/n operator functions identically to the <a
href="#near">NEAR</a> operator, but with an addition that specifies how
near the operands must be to each other.  The <span
class="query">&lt;NEAR&gt;</span> operator could be expressed as <span
class="query">&lt;NEAR/1000&gt;</span>.
</dd>
<dt>Examples</dt>
<dd>
<span class="query">buy &lt;NEAR/3&gt; sell</span><br>
Finds documents that contain both the word "buy" and the word "sell" in
which those words occur withing three words of eachother.  For example,
a document containing the phrase "buy low and sell high" would be
returned, but a document containing "buy at the market high, sell at the
market low" would not.
</dd>
</dl>


<div class="mainHeader"><a name="passage">Passage</a></div>
<dl>
<dt>Description</dt>
<dd>
The PASSAGE operator functions similarly to the <a href="#pand">PAND</a>
operator, but it is constructed around OR instead of AND.  PASSAGE
retrieves documents that contain any of its operands, but only returns
those that contain a passage with at least half of the operands
present.  The scoring of the documents is performed using the relaxation
ranking algorithm described in <a href="#pand">PAND</a>.<p>

PASSAGE is a prefix-only operator.  There is no infix form.
</dd>
<dt>Examples</dt>
<dd>
<span class="query">(&lt;PASSAGE&gt; the rain in spain is mainly in the
plain)</span><br>
Retrieves documents with this passage or similar passages.  For example,
a document containing "the snow in france is mainly in the alps" would
be returned, while a document containing "snow in france often falls
in the alps" would not.
</dd>
</dl>


<div class="mainHeader"><a name="phrase">Phrase</a></div>
<dl>
<dt>Description</dt>
<dd>
The PHRASE operator finds exact phrases that match its operands.
Keep in mind that morphological variations are allowed by default.  An
exact phrase is one in which the operands occur in the order specified
with no intervening text.  Unlike the <a href="#pand">PAND</a> operator,
documents that fail to meet those constraints are not returned at all.
PHRASE is available as either an infix or a prefix operator, and also by
the short-hand of using a quoted string.
</dd>
<dt>Examples</dt>
<dd>
<span class="query">rock &lt;PHRASE&gt; and &lt;PHRASE&gt;
roll</span><br>
<span class="query">(&lt;PHRASE&gt; rock and roll)</span><br>
<span class="query">"rock and roll"</span><br>
All three of these return only the documents that have "rock and roll",
allowing for morphological variations.<p>
<span class="query">&lt;EXACT&gt; "rock and roll"</span><br>
<span class="query">&lt;EXACT&gt; rock &lt;PHRASE&gt; &lt;EXACT&gt; and
&lt;PHRASE&gt; &lt;EXACT&gt; roll</span></br>
This query will disable morphological expansion and return only those
documents that contain the exact phrase "rock and roll", no ifs, ands, or
buts.  The <a href="#exact">EXACT</a> modifier may only be used directly
with the "quoted string" form of the PHRASE operator.  To use it with
the other forms of the operator, the EXACT modifier must precede each
operand.
</dd>
</dl>


<div class="mainHeader"><a name="tor">TOr</a></div>
<dl>
<dt>Description</dt>
<dd>
TOR is the "term" OR.  The TOR applies only to specific terms, in
context whereas the <a href="#or">OR</a> applies restrictions at the
document level.  This allows a set of terms to be given as options in a
passage as in the examples below.  A regular OR would not be considered
to be part of a passage.
</dd>
<dt>Examples</dt>
<dd>
<span class="query">(&lt;passage&gt; (dog &lt;tor&gt; cat) bites man)</span><br>
In this example, the passages "dog bites man" and "cat bites man" are
given equal consideration when evaluating results.<p>
<span class="query">(&lt;passage&gt; (dog &lt;or&gt; cat) bites man)</span><br>
In this example, "dog" and "cat" are not considered as part of the
passage.  The expression <span class="query">(dog &lt;or&gt; cat)</span>
will constrain which documents are included in the results, but only the
passage "bites man" will be considered during ranking.
</dd>
</dl>


<div class="mainHeader"><a name="if">If</a></div>
<dl>
<dt>Description</dt>
<dd>
The IF operator causes either a term or a sub-expression to be evaluated
as a purely boolean operation, ignoring the weights/scores that are
determined from the terms.  IF is a unary operator.  It may precede
either a single term or an expression in parentheses.
</dd>
<dt>Examples</dt>
<dd>
<span class="query">earth &lt;AND&gt; &lt;IF&gt; planet</span><br>
Finds documents that contain both the words "earth" and "planet", but
weights the documents only according to the term "earth".  This would
eliminate documents about "earth worms" without changing the weights
that a query just for "earth" would use.
</dd>
</dl>


<div class="mainHeader"><a name="weight">Weight</a></div>
<dl>
<dt>Description</dt>
<dd>
The WEIGHT operator modifies the relative weight of a sub-expression.
It may be specified as the start of an expression in parentheses.
WEIGHT is a prefix operator that takes a weight multiplier as its first
argument, followed by any number of arguments for which the weight
multiplier should apply.  All components of the expression will have
their weight multiplied by the provided weight multiplier before being
used for comparison.
</dd>
<dt>Examples</dt>
<dd>
<span class="query">web surfing &lt;AND&gt; (&lt;WEIGHT&gt; 1.2 title
&lt;CONTAINS&gt; (web surfing))</span><br>
Finds documents that contain "web" and "surfing" anywhere in the
document, but also give higher weight to those documents for which "web"
and "surfing" occur in the title of the document.
</dd>
</dl>


<div class="mainHeader"><a name="hide">Hide</a></div>
<dl>
<dt>Description</dt>
<dd>
The HIDE operator causes either a term or a sub-expression to be hidden
from the passage retrieval function.  This may be used to specify terms
that are important to the query but are unlikely to be part of the same
passage as the rest of the query.  HIDE is a unary operator.  It takes
either a single term or an expression in parentheses as its argument.
</dd>
<dt>Examples</dt>
<dd>
??
</dd>
</dl>


<div class="mainHeader"><a name="undefined">Undefined</a></div>
<dl>
<dt>Description</dt>
<dd>
The UNDEFINED operator is a special operator that queries for documents
in which a particular field is not defined (has no value).  This is
different from a field that has been assigned a blank value.  UNDEFINED
is a unary operator and has a shortened form of UNDEF.  It takes a field
name as its argument.
</dd>
<dt>Examples</dt>
<dd>
<span class="query">&lt;UNDEFINED&gt; title</span><br>
<span class="query">&lt;UNDEF&gt; title</span><br>
Finds all documents for which a title was not provided.  This will not
return documents for which the title is "".
</dd>
</dl>


<div class="mainHeader"><a name="sequence">Sequence</a></div>
<dl>
<dt>Description</dt>
<dd>
The SEQUENCE prefix operator sets a requirement that the terms in its
sub-expression must occur in the document in the same order in which
they occur in the query.  This is used to modify the behavior of the
proximity-based operators that consider term order as part of their
scoring criteria.  When SEQUENCE is specified, documents that contain
the query terms out of order will not be returned.
</dd>
<dt>Examples</dt>
<dd>
<span class="query">(&lt;SEQUENCE&gt; moon rock)</span><br>
Finds all documents that contain "moon" and "rock", in that order and
somewhat near eachother.  Since the default operator is PAND, this
attempts to find a passage containing "moon" and "rock".  Documents that
have such a passage and have the query terms in the correct order will
be returned in the results.
</dd>
</dl>


<div class="mainHeader"><a name="contains">Contains</a></div>
<dl>
<dt>Description</dt>
<dd>
CONTAINS is the field operator that operates on an indexed field.
CONTAINS is an infix-only operator with two operands.  The first (left)
is the name of the field to operate on and the second (right) is either
a term or a sub-expression (in parentheses).  Any of the regular
operators may be used in the sub-expression and their scope will be
confined to the specified field.
</dd>
<dt>Examples</dt>
<dd>
<span class="query">title &lt;CONTAINS&gt; surf</span><br>
Finds all documents that have a title field that contains the word
"surf" or a morphological variation of "surf".<p>
<span class="query">title &lt;CONTAINS&gt; (surf &lt;AND&gt; &lt;NOT&gt;
web)</span><br>
Finds all documents that have "surf" in the title, but not "web" (again,
including morphological variations of those words).  A title of "channel
surfing" would case a document to be returned, whereas a title of "web
surfing" would not.
</dd>
</dl>


<div class="mainHeader"><a name="starts">Starts</a></div>
<dl>
<dt>Description</dt>
<dd>
The STARTS operator is used to find documents in which a field starts
with a certain string of characters.  STARTS is an infix-only operator
(with two operands) that works only on saved fields.  The first (left)
operand is the name of the field to operate on and the second (right) is
the initial string that must be matched.  Since STARTS takes only a
single string as its second operand, an initial string that includes
whitespace should be enclosed in quotation marks.<p>

Note that the second operand is interpreted simply as a string.
Morphological variations on the string are not included.  A string
provided in all the same case is considered to be case-insensitive.  A
mixed-case string is considered to be case-sensitive.  However, if the
index is case-insensitive, any string will be considered to be
case-insensitive.
</dd>
<dt>Examples</dt>
<dd>
<span class="query">title &lt;STARTS&gt; min</span><br>
Finds all documents with titles starting with the string "min",
regardless of case.  Documents with titles "Min", "minimum
requirements", and "Minion" would all be returned.<p>
<span class="query">title &lt;STARTS&gt; "Min "</span><br>
Finds all documents with titles starting with the string "min " (with the
space character included).  None of the titles in the previous example
would be returned.  A document with title "Min Requirements" would be
found, but a document with title "min requirements" would not be
returned since the query was case sensitive.
</dd>
</dl>


<div class="mainHeader"><a name="ends">Ends</a></div>
<dl>
<dt>Description</dt>
<dd>

The ENDS operator is used to find documents in which a field ends with a
certain string of characters.  ENDS is an infix-only operator (with two
operands) that works only on saved fields.  The first (left) operand is
the name of the field to operate on and the second (right) is the
trailing string that must be matched.  Since ENDS takes only a single
string as its second operand, a trailing string that includes whitespace
should be enclosed in quotation marks.<p>

Note that the second operand is interpreted simply as a string.
Morphological variations on the string are not included.  A string
provided in all the same case is considered to be case-insensitive.  A
mixed-case string is considered to be case-sensitive.  However, if the
index is case-insensitive, any string will be considered to be
case-insensitive.

</dd>
<dt>Examples</dt>
<dd>
<span class="query">title &lt;ENDS&gt; surf<span><br>
Finds all documents with titles ending with the string "surf",
regardless of case.  Documents with titles "Web Surf", "surf", and
"Channel surf" would all be returned.<p>
<span class="query">title &lt;ENDS&gt; Surfing<span><br>
Finds all documents with titles ending with the string "Surfing".  None
of the documents from the previous example would be returned.  A
document with the title "Wind Surfing" would be found, but a document
with title "web surfer" would not be returned.
</dd>
</dl>


<div class="mainHeader"><a name="matches">Matches</a></div>
<dl>
<dt>Description</dt>
<dd>
The MATCHES operator is used to find documents in which a field contains
a specified pattern of characters.  MATCHES is different from <a
href="#contains">CONTAINS</a> in that it operates by matching a string
literal rather than a term.  Where <a href="#contains">CONTAINS</a>
operates by finding terms in an indexed field's dictionary, MATCHES
works by using simple string and wildcard matching on a saved field's
values.  The wildcard characters "*" (match 0 or more characters) and
"?" (match exactly 0 or 1 characters) are permitted.  A string with no
wildcard characters performs an exact character for character match.
MATCHES is an infix-only operator with two operands.  The first (left)
operand is the name of the field to operate on and the second (right) is
the wildcard string that must be matched.  Since MATCHES takes only a
single string as its second operand, a string that includes whitespace
should be enclosed in quotation marks.<p>

Note that the second operand is interpreted simply as a string.
Morphological variations on the string are not included.  A string
provided in all the same case is considered to be case-insensitive.  A
mixed-case string is considered to be case-sensitive.  However, if the
index is case-insensitive, any string will be considered to be
case-insensitive.
</dd>
<dt>Examples</dt>
<dd>
<span class="query">title &lt;MATCHES&gt; *comp*</span><br>
Finds all documents with titles matching the wildcard expression
"*comp*".  This will match any titles with the letter sequence "comp"
anywhere in the title.  Documents with titles "comp", "computer", and
"incompetent" will all be returned.<p>
<span class="query">title &lt;MATCHES&gt; "Minion Operators"</span><br>
Finds all documents with titles exactly matching "Minion Operators".
Only documents with that title character for character and in the
provided case are returned.
</dd>
</dl>


<div class="mainHeader"><a name="similar">Similar</a></div>
<dl>
<dt>Description</dt>
<dd>
The SIMILAR operator is used to find documents in which a field value is
similar to the provided value.  The resulting documents are ranked by the
provided field value's
<a href="http://en.wikipedia.org/wiki/Levenshtein_distance">Levenshtein Edit
Distance</a> from the resulting document's field value.  The closer the string
values, the higher the document is ranked.  The first (left)
operand is the name of the field to operate on and the second (right) is
the string to search for.  Since SIMILAR takes only a
single string as its second operand, a string that includes whitespace
should be enclosed in quotation marks.<p>

Note that the second operand is interpreted simply as a string.
Morphological variations on the string are not included.  A string
provided in all the same case is considered to be case-insensitive.  A
mixed-case string is considered to be case-sensitive.  However, if the
index is case-insensitive, any string will be considered to be
case-insensitive.
</dd>
<dt>Examples</dt>
<dd>
<span class="query">author &lt;SIMILAR&gt; "neil stephenson"</span><br>
Finds all documents with author similar to the string "neil stephenson".
In this example, documents with an author of "Neal Stephenson" (the correct
spelling of Neal in the case of this author) will be matched and returned.
Many more documents will be returned than would otherwise, but the documents
will be ranked based on field similarity.  In this case, "Neil Gaimon" would be
included in the result set, but ranked lower since "Neal Stephenson" is more
similar to the original query.<p>
</dd>
</dl>


<div class="mainHeader"><a name="substring">Substring</a></div>
<dl>
<dt>Description</dt>
<dd>
The SUBSTRING operator is used to find documents in which a saved field
contains a specified substring.  SUBSTRING is similar to the <a
href="#matches">MATCHES</a> operator, but wildcard characters are not
allowed and the specified string is considered to be a substring rather
than a complete string.  SUBSTRING is an infix-only operator with two
operands.  The first (left) operand is the name of the field to operate
on and the second (right) is the substring that must be matched.  Since
SUBSTRING takes only a single string as its second operand, a string
that includes whitespace should be enclosed in quotation marks.<p>

Note that the second operand is interpreted simply as a string.
Morphological variations on the string are not included.  A string
provided in all the same case is considered to be case-insensitive.  A
mixed-case string is considered to be case-sensitive.  However, if the
index is case-insensitive, any string will be considered to be
case-insensitive.
</dd>
<dt>Examples</dt>
<dd>
<span class="query">title &lt;SUBSTRING&gt; comp</span><br>
Finds all documents with titles that contain the exact substring "comp",
regardless of case.  This will match any titles with the character
sequence "comp" anywhere in the title.  Documents with titles "comp",
"Computer", and "incompetent" will all be returned.  A document titled
"communication" would not be returned since it does not have the
complete string "comp" as a substring.<p>
</dd>
</dl>


<div class="mainHeader"><a name="lessthan">Less Than</a></div>
<dl>
<dt>Description</dt>
<dd>
The LESS operator is used to find documents in which a saved field value
is less than a specified value.  For Integer and Float fields, the
comparison is simply numerical.  String fields are compared based on the
natural ordering of the values; that is alphabetically with upper case
letters coming before lower case, and symbols generally coming before
letters.  Dates are compared based on time.  For the purpose of "Less
Than", a date given as a day without a time will be treated as midnight
on the given day.  LESS is an infix-only operator with two operands.
The first (left) operand is the name of the field to operate on and the
second (right) is the value to compare to.  Since LESS takes only a
single string as its second operand, a string (or date representation)
that includes whitespace should be enclosed in quotation marks.  The
symbol <span class="query">"&lt;"</span> may be used as a short-hand for
the LESS operator in the strict grammar.<p>

Ranges may be specified by combining the LESS, <a
href="#greaterthan">GREATER</a>, and <a href="#and">AND</a> operators.
When specified together with no intervening operators, the query
optimizer will construct the expression as a range, which will reduce
evaluation time.  See the example below.
</dd>
<dt>Examples</dt>
<dd>
<span class="query">title &lt;LESS&gt; aardvark</span><br>
Returns all documents with titles "alphabetically" before aardvark.  In
Java/Unicode-speak this would include any titles that start with most
common punctuation, numbers, and upper case letters.<p>
<span class="query">mod-date &lt;LESS&gt; 02/23/05</span><br>
Finds all documents that have been modified before midnight on February
23rd, 2005.<p>
<span class="query">mod-date &lt; "02/23/05 16:00:00"</span><br>
Finds all documents that have been modified before 4pm on February 23rd,
2005.<p>
<span class="query">contributors &lt; 10</span><br>
Finds all documents that have fewer than 10 contributors.<p>
<span class="query">contributors &lt; 10 &lt;AND&gt; contributors &gt;
4</span><br>
Finds all documents that have fewer than 10 contributors and more than 4
contributors.  The query is evaluated by stepping only through documents
with contributors between 4 and 10, rather than collecting all documents
with contributors less than 10, then collecting all documents with
contributors greater than 4 and performing an intersection of the two
sets.
</dd>
</dl>


<div class="mainHeader"><a name="greater">Greater</a></div>
<dl>
<dt>Description</dt>
<dd>
The GREATER operator is used to find documents in which a saved field
value is greater than a specified value.  For Integer and Float fields,
the comparison is simply numerical.  String fields are compared based on
the natural ordering of the values; that is alphabetically with lower
case letters coming after upper case, and symbols generally coming
before letters.  Dates are compared based on time.  For the purpose of
"Greater Than", a date given as a day without a time will be treated as
the end of the day, 23:59:59, on the given day.  GREATER is an
infix-only operator with two operands.  The first (left operand is the
name of the field to operate on and the second (right) operand is the
value to compare to.  Since GREATER takes only a single string as its
second operand, a string (or date representation) that includes
whitespace should be enclosed in quotation marks.  The symbol <span
class="query>"&gt;"</span> may be used as a short-hand for the GREATER
operator in the strict grammar.<p>

Ranges may be specified by combining GREATER, <a
href="#lessthan">LESS</a>, and <a href="#and">AND</a> operators.  When
specified together with no intervening operators, the query optimizer
will construct the expression as a range, which will reduce evaluation
time.  See the example below.
</dd>
<dt>Examples</dt>
<dd>
<span class="query">title &lt;GREATER&gt; aardvark</span><br>
Returns all documents with titles "alphabetically" after aardvark.  In
Java/Unicode-speak this would include most titles that start with a
lowercase letter.<p>
<span class="query">mod-date &lt;GREATER&gt; 02/23/05</span><br>
Finds all documents that have been modified after 23:59:59 on February
23rd, 2005.<p>
<span class="query">mod-date &gt; "02/23/05 16:00:00"</span><br>
Finds all documents that have been modified after 4pm on February 23rd,
2005.<p>
<span class="query">contributors &gt; 4</span><br>
Finds all documents that have greater than 4 contributors.<p>
<span class="query">contributors &gt; 4 &lt;AND&gt; contributors &lt;
10</span><br>
Finds all documents that have fewer than 10 contributors and more than 4
contributors.  The query is evaluated by stepping only through documents
with contributors between 4 and 10, rather than collecting all documents
with contributors less than 10, then collecting all documents with
contributors greater than 4 and performing an intersection of the two
sets.
</dd>
</dl>


<div class="mainHeader"><a name="lessequal">Less Than or Equal To</a></div>
<dl>
<dt>Description</dt>
<dd>
The LEQ operator is used to find documents in which a saved field value
is less than or equal to a specified value.  For Integer and Float
fields, the comparison is simply numerical.  String fields are compared
based on the natural ordering of the values; that is alphabetically with
upper case letters coming before lower case, and symbols generally
coming before letters.  Dates are compared based on time.  For the
purpose of "Less Than or Equal To", a date given as a day without a time
will be treated as the end of the day, 23:59:59, on the given day in
order to include the whole day.  LEQ is an infix-only operator with two
operands.  The first (left) operand is the name of the field to operate
on and the second (right) is the value to compare to.  Since LEQ takes
only a single string as its second operand, a string (or date
representation) that includes whitespace should be enclosed in quotation
marks.  The symbol <span class="query">"&lt;="</span> may be used as a
short-hand for the LEQ operator in the strict grammar.<p>

Ranges may be specified by combining the LEQ, <a
href="#greaterthan">GEQ</a>, <a href="#lessthan">LESS</a>, <a
href="#greater">GREATER</a>, and <a href="#and">AND</a> operators.  When
specified together with no intervening operators, the query optimizer
will construct the expression as a range, which will reduce evaluation
time.  See the example below.
</dd>
<dt>Examples</dt>
<dd>
<span class="query">title &lt;LEQ&gt; aardvark</span><br>
Returns all documents with titles "alphabetically" before aardvark and
documents with the exact title "aardvark".  In Java/Unicode-speak this
would include any titles that start with most common punctuation,
numbers, and upper case letters.<p>
<span class="query">mod-date &lt;LEQ&gt; 02/23/05</span><br>
Finds all documents that have been modified before or at the end of the day,
23:59:59, on February 23rd, 2005.<p>
<span class="query">mod-date &lt;= "02/23/05 16:00:00"</span><br>
Finds all documents that have been modified before or at 4pm on February 23rd,
2005.<p>
<span class="query">contributors &lt;= 10</span><br>
Finds all documents that have 10 or fewer contributors.<p>
<span class="query">contributors &lt;= 10 &lt;AND&gt; contributors &gt;=
4</span><br>
Finds all documents that have between 4 and 10, inclusive, contributors.
The query is evaluated by stepping only through documents with
contributors between 4 and 10, rather than collecting all documents with
contributors less than or equal to 10, then collecting all documents
with contributors greater than or equal to 4 and performing an
intersection of the two sets.
</dd>
</dl>


<div class="mainHeader"><a name="greaterequal">Greater Than or Equal To</a></div>
<dl>
<dt>Description</dt>
<dd>
The GEQ operator is used to find documents in which a saved field value
is greater than or equal to a specified value.  For Integer and Float
fields, the comparison is simply numerical.  String fields are compared
based on the natural ordering of the values; that is alphabetically with
lower case letters coming after upper case, and symbols generally coming
before letters.  Dates are compared based on time.  For the purpose of
"Greater Than or Equal To", a date given as a day without a time will be
treated as midnight on the given day.  GEQ is an infix-only operator
with two operands.  The first (left) operand is the name of the field to
operate on and the second (right) operand is the value to compare to.
Since GEQ takes only a single string as its second operand, a string (or
date representation) that includes whitespace should be enclosed in
quotation marks.  The symbol <span class="query>"&gt;="</span> may be
used as a short-hand for the GEQ operator in the strict grammar.<p>

Ranges may be specified by combining the GEQ, <a
href="#lessthan">LEQ</a>, <a href="#lessthan">LESS</a>, <a
href="#greater">GREATER</a>, and <a href="#and">AND</a> operators.  When
specified together with no intervening operators, the query optimizer
will construct the expression as a range, which will reduce evaluation
time.  See the example below.
</dd>
<dt>Examples</dt>
<dd>
<span class="query">title &lt;GEQ&gt; aardvark</span><br>
Returns all documents with titles "alphabetically" after aardvark or
that have exactly the title "aardvark".  In Java/Unicode-speak this
would include most titles that start with a lowercase letter.<p>
<span class="query">mod-date &lt;GEQ&gt; 02/23/05</span><br>
Finds all documents that have been modified at or after midnight on
February 23rd, 2005.<p>
<span class="query">mod-date &gt;= "02/23/05 16:00:00"</span><br>
Finds all documents that have been modified at or after 4pm on February
23rd, 2005.<p>
<span class="query">contributors &gt;= 4</span><br>
Finds all documents that have greater than 4 contributors.<p>
<span class="query">contributors &gt;= 4 &lt;AND&gt; contributors &lt;=
10</span><br>
Finds all documents that have between 4 and 10, inclusive, contributors.
The query is evaluated by stepping only through documents with
contributors between 4 and 10, rather than collecting all documents with
contributors less than or equal to 10, then collecting all documents
with contributors greater than or equal to 4 and performing an
intersection of the two sets.
sets.
</dd>
</dl>


<div class="mainHeader"><a name="equals">Equals</a></div>
<dl>
<dt>Description</dt>
<dd>
The EQUALS operator is used to find documents in which a saved field
value equals exactly a specified value.  Equals behaves differently
depending on the type of saved field that is operated on.  Strings,
Floats, and Integers are all compared literally.  Documents that match
exactly are returned.  Dates are interpreted depending on the
specificity of the date string.  A date only (with no time) will mean
any time on that day (a range query will actually be issued),
and a date with a time will mean that time specifically.  EQUALS is an
infix-only operator with two operands.  The first (left) operand is the
name of the field to operate on and the second (right) operand is the
value to compare to.  Since EQUALS takes only a single string as its
second operand, a string (or date representation) that includes
whitespace should be enclosed in quotation marks.  The symbol <span
class="query">"="</span> may be used as a short-hand for the EQUALS
operator in the strict grammar.<p>
</dd>
<dt>Examples</dt>
<dd>
<span class="query">title &lt;EQUALS&gt; "My Summer Vacation"</span><br>
Finds all documents that have the exact, case sensitive, title "My
Summer Vacation".<p>
<span class="query">title &lt;EQUALS&gt; "my summer vacation"</span><br>
Finds all documents that have the title "my summer vacation", case
insensitive.<p>
<span class="query">mod-date &lt;EQUALS&gt; 01/01/99</span><br>
Finds all documents modified at any time on New Year's Day, 1999.<p>
<span class="query">mod-date = "01/01/99 00:00:00"</span><br>
Finds all documents modified exactly at midnight at the start of
1999.<p>
<span class="query">contributors = 2</span><br>
Finds all documents with exactly 2 contributors.
</dd>
</dl>


<div class="mainHeader"><a name="notequals">Not Equals</a></div>
<dl>
<dt>Description</dt>
<dd>
The NOT EQUAL operator exists to provide the short-hand form <span
class="query">!=</span>.  The query <span class="query">a != b</span>
will automatically be interpreted as <span class="query">(<NOT> (a
<EQUALS> b))</span>.  See the <a href="#equals">EQUALS</a> operator.
</dd>
<dt>Examples</dt>
<dd>
<span class="query">author &lt;NOT EQUAL&gt; "william gibson"</span><br>
<span class="query">author != "william gibson"</span><br>
Finds all documents that do not have an author field with the value
"william gibson", case insensitive.<p>
</dd>
</dl>


<div class="mainHeader"><a name="exact">Exact</a></div>
<dl>
<dt>Description</dt>
<dd>
EXACT is a term modifier that disables the default behavior of including
morphological variants of a particular query term in the query.  It is a
unary operator that takes a term as its argument.  The query will be
evaluated only for the exact term entered without variants.  The case
sensitivity of the query is determined in the usual manner -- same-case
queries are treated as case insensitive while mixed-case queries are
treated as case sensitive.  EXACT may not be used in combination with <a
href="#morph">MORPH</a>, <a href="#stem">STEM</a>, or <a
href="#expand">EXPAND</a>.  EXACT may be combined with other term
modifiers.
</dd>
<dt>Examples</dt>
<dd>
<span class="query">&lt;EXACT&gt; surf</span><br>
Finds all documents that contain the word "surf", case insensitive.
Words such as "surfer", "surfing", and "surfs" are not considered to be
part of the query.<p>
<span class="query">&lt;EXACT&gt; &lt;CASE&gt; surf</span><br>
Finds all documents that contain the word "surf", all in lower case.
(See <a href="#case">CASE</a>)  Words such as "surfer", "surfing", and
"surfs" are not considered to be part of the query.
</dd>
</dl>


<div class="mainHeader"><a name="morph">Morph</a></div>
<dl>
<dt>Description</dt>
<dd>
The MORPH term modifier enables the inclusion of morphological variants
of a term into the query.  This is the default modifier.  MORPH is a
unary operator that takes a term as its argument.  If <a
href="#exact">EXACT</a>, <a href="#stem">STEM</a>, or <a
href="#expand">EXPAND</a> are specified, MORPH will be disabled.  To use
MORPH with STEM, add the MORPH modifier back in.
</dd>
<dt>Examples</dt>
<dd>
<span class="query">surf</span><br>
<span class="query">&lt;MORPH&gt; surf</span><br>
Finds all documents that contain "surf", or any of the automatically
generated morphological variations of the term.  In the case of "surf",
the variants that are generated are: "surfs", "surfed", "surfest",
"surfly", "surfness", "surfers", "surfings", "surfless", "surfing",
"surfment", "surfer", "surfful", "surfnesses", and "surfments".  The
variants that come out to invalid words generally won't be found in the
collection and hence will be ignored.<p>
<span class="query">&lt;MORPH&gt; &lt;STEM&gt; surf</span><br>
Finds all documents that contain any of the words from the previous
example, plus any words that match the stem "sur", such as "sur" and
"sure".
</dd>
</dl>


<div class="mainHeader"><a name="stem">Stem</a></div>
<dl>
<dt>Description</dt>
<dd>
The STEM term modifier enables the inclusion of terms into the query
that match the stem of the term specified.  The specified term is
stemmed, then the terms in the index that match the stem are included as
terms in the query.  This allows stemming-style queries to be run
against an index that has not been stemmed.  STEM is a unary operator
that takes a term as its argument.  STEM may not be used in
conjunction with <a href="#exact">EXACT</a>.
</dd>
<dt>Examples</dt>
<dd>
<span class="query">&lt;STEM&gt; computer</span><br>
Finds all documents with terms that share the same stem as "computer".
These will be terms such as "compute", "computers", "computing", and
"computed".
<span class="query">title &lt;CONTAINS&gt; &lt;STEM&gt;
computer</span><br>
Finds all documents with terms that share the same stem as "computer" in
the document title.  This functions the same as the previous example,
but restricts the query terms so that they must occur in the title of
the document to be included in the results.
</dd>
</dl>


<div class="mainHeader"><a name="expand">Expand</a></div>
<dl>
<dt>Description</dt>
<dd>
The EXPAND term modifier uses the taxonomy provided to the search engine
to include semantic variants of the specified term.  The specified term
will be looked up in the taxonomy and all terms (up to a max number)
that are subsumed by that term are included into the query.  EXPAND is a
unary operator that takes a term as its argument.
</dd>
<dt>Examples</dt>
<dd>
<span class="query">&lt;EXPAND&gt; dog</span><br>
Finds all documents with the term "dog" and also any terms subsumed by
dog in a taxonomy.  In an English taxonomy, this would mean that words
that were types of dog would be included such as "hound", "mutt",
"pooch", "canine", "greyhound", and "poodle".
</dd>
</dl>


<div class="mainHeader"><a name="case">Case</a></div>
<dl>
<dt>Description</dt>
<dd>
The CASE term modifier specifies that a given term should be treated as
case sensitive.  This is only useful in a case sensitive index.  By
default, terms that are all in upper or lower case are treated as case
insensitive and terms that are in mixed case are treated as case
sensitive.  CASE will cause all terms, regardless of case, to be case
sensitive.
</dd>
<dt>Examples</dt>
<dd>
<span class="query">&lt;CASE&gt; earth</span><br>
Finds all documents in which the term "earth" occurs, in lower case
only.  This might help differentiate the usage of Earth (the planet) and
earth (soil).
</dd>
</dl>

</div>
</body>
</html>
