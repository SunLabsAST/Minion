/*
 * Copyright 2007-2008 Sun Microsystems, Inc. All Rights Reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER
 * 
 * This code is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2
 * only, as published by the Free Software Foundation.
 * 
 * This code is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * General Public License version 2 for more details (a copy is
 * included in the LICENSE file that accompanied this code).
 * 
 * You should have received a copy of the GNU General Public License
 * version 2 along with this work; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA
 * 
 * Please contact Sun Microsystems, Inc., 16 Network Circle, Menlo
 * Park, CA 94025 or visit www.sun.com if you need additional
 * information or have any questions.
 */

package com.sun.labs.minion.lexmorph;

import java.util.Vector;
import java.util.Hashtable;
import java.util.HashSet;

import java.util.concurrent.ConcurrentHashMap;

//import Lexicon;

/*
; copyright (c) by W.A. Woods.  All rights reserved.
; The following software was created in 1989, 1990, 1991, 1992, 1993, 1994,
; 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, and 2004,
; but has not been published within the meaning of the copyright law.
; This file may be made available by the author to selected individuals
; for specific research projects, but may not to be copied, distributed, or
; used for other purposes without explicit permission from the author.

; This software is licensed "as is." The author expressly disclaims any
; warranties of any kind and accepts no liabilities resulting from its use.
*/

/**
 * This is an English specialization of MorphEngFns, which extends
 * MorphEngFrame, which extends MorphEngine.
 *
 * @author W. A. Woods
 * 
 * @version	1.0
 * 
 * The rules for this system were developed by W. A. Woods
 * 
 * @see MorphEngine
 */

public class Morph_en extends MorphEngFns {

  protected static Hashtable varTable = new Hashtable(100, (float)0.7);
  protected HashSet nonChemicalConstituents; //pm 8apr04
  protected HashSet chemPrefixes;  //pm 8apr04
  protected HashSet chemicalSuffixes;  //ww 9May04
  protected String[] sp_knownWordList = null;
  protected String sp_knownWordFile = null;
  protected static MorphCompoundRule[] convertedMorphCompoundRules = null;

  public Morph_en () {

  // Define variables for use in rules: (must be done before rules are defined
  // with r method)
  // defVar adds these variables to the varTable Hashtable.

    defVar("$Any", "abcdefghijklmnopqrstuvwxyz?????????????????????????????-'/");
    defVar("$Consonant", "bcdfghjklmnpqrstvwxyz???");
    defVar("$Vowel", "aeiou??????????????????????????");

  }

  /**
   * Method for returning the first set of morphological rules to start with.
   */

  public MorphRule[] getFirstRuleSet() { //returns the rule set to start with
    return rootRules;
    }

  /**
   * Method for returning the set of prefix rules.
   */

  public MorphRule[] getPrefixRuleSet() { //returns the prefix rule set
    return prefixDispatch;
    }

  protected static MorphRule[] emptyRuleSet = new MorphRule[0];

  private static ConcurrentHashMap prefixRuleSetMap = null;

  public MorphRule[] getPrefixRuleSet(Atom ruleSetName) {
    // Returns the specified prefix rule set (specified by name as an atom).
    // hacked pmartin 11apr04 to maintain concurrency but show better speed
    if (prefixRuleSetMap == null){
        ConcurrentHashMap prsm = new ConcurrentHashMap();

        prsm.put(atom_U$Prefixes, uPrefixes); // Translator's name for it.
        prsm.put(atom_uPrefixes, uPrefixes); // Test this one first
        prsm.put(atom_morphDispatch, morphDispatch);
        prsm.put(atom_sBlock, sBlock);
        prsm.put(atom_dBlock, dBlock);
        prsm.put(atom_eBlock, eBlock);
        prsm.put(atom_gBlock, gBlock);
        prsm.put(atom_lBlock, lBlock);
        prsm.put(atom_mBlock, mBlock);
        prsm.put(atom_nBlock, nBlock);
        prsm.put(atom_rBlock, rBlock);
        prsm.put(atom_tBlock, tBlock);
        prsm.put(atom_yBlock, yBlock);
        prsm.put(atom_cBlock, cBlock);
        prsm.put(atom_miscBlock, miscBlock);
        prsm.put(atom_tionBlock, tionBlock);
        prsm.put(atom_estBlock, estBlock);
        prsm.put(atom_iformBlock, iformBlock);
        prsm.put(atom_defaultRule, defaultRule);
        prsm.put(atom_prefixDispatch, prefixDispatch);
        prsm.put(atom_aPrefixes, aPrefixes);
        prsm.put(atom_bPrefixes, bPrefixes);
        prsm.put(atom_cPrefixes, cPrefixes);
        prsm.put(atom_dPrefixes, dPrefixes);
        prsm.put(atom_ePrefixes, ePrefixes);
        prsm.put(atom_hPrefixes, hPrefixes);
        prsm.put(atom_iPrefixes, iPrefixes);
        prsm.put(atom_mPrefixes, mPrefixes);
        prsm.put(atom_nPrefixes, nPrefixes);
        prsm.put(atom_oPrefixes, oPrefixes);
        prsm.put(atom_pPrefixes, pPrefixes);
        prsm.put(atom_rPrefixes, rPrefixes);
        prsm.put(atom_sPrefixes, sPrefixes);
        prsm.put(atom_tPrefixes, tPrefixes);
        prsm.put(atom_miscPrefixes, miscPrefixes);
        prsm.put(atom_lexicalPrefixRules, lexicalPrefixRules);
        prsm.put(atom_morphCompoundRules, morphCompoundRules);
        prsm.put(atom_ordinalRules, ordinalRules);
        prsm.put(atom_pluralRule, pluralRule);
        prsm.put(atom_thirdSingRule, thirdSingRule);
        prsm.put(atom_pastRule, pastRule);
        prsm.put(atom_ingRule, ingRule);
        prsm.put(atom_doerRule, doerRule);
        prsm.put(atom_comparativeRule, comparativeRule);
        prsm.put(atom_superlativeRule, superlativeRule);
        prsm.put(atom_adverbRule, adverbRule);
        prsm.put(atom_nessRule, nessRule);
        prsm.put(atom_ableRule, ableRule);

        prefixRuleSetMap = prsm; // we should not have to make table again.
    }
    MorphRule[] mr = (MorphRule[])prefixRuleSetMap.get(ruleSetName);
    if (mr == null) return emptyRuleSet;
    else return mr;
  }



  /**
   * Method for returning the Lexicon associated with this MorphEngine.
   */

  public Lexicon getMorphDict() { //returns the language-specific dictionary
    return dict;
    }

  /**
   * Method for returning the Hashtable of variable values used in morphological
   * rules in this class.
   */

  public static Hashtable getVarTable() { //returns the language specific variable table
    return varTable;
    }

  /**
   * Method for creating defined variables for rule patterns
   */

  protected static void defVar(String varName, String valString) {
    getVarTable().put(varName, valString);
  }

//methods for making morphological rule instances:

  /**
   * Method for creating a morphological rule.
   */

  public static MorphRule r(String expression, String ruleName) {
    MorphRule newRule = new MorphRule(expression, ruleName, getVarTable());
    return newRule;
  }

  /**
   * Method for creating a morphological rule that has values for features:
   * p1def, indicating that the rule is definitely phase-one,
   * p1cond, indicating that the rule is phase-one if the root is known,
   * splitFlag, indicating that the rule may generate more than one
   * syntactic word sense, each with its own root-features information.
   */

  public static MorphRule r(String expression, String ruleName,
                                   boolean p1def, boolean p1cond,
                                   boolean splitFlag) {
    MorphRule newRule = new MorphRule(expression, ruleName, getVarTable());
    newRule.definitePhaseOne = p1def;
    newRule.conditionalPhaseOne = p1cond;
    newRule.possibleSplitRule = splitFlag;
    return newRule;
  }

  // Define the rules:

  public static MorphRule[] rootRules = {//":unnamed",  // starting rule list

/*
 ((() (try ordinal-rules suffix))
  (() (try morph-precheck-rules compute))
  (() (try phase-one-rules suffix))
  (() (try prefix-rules prefix))
  (() (try compound-rules compound))
  (() (try phase-two-rules suffix))
  )
*/

  r(" -> 1", ":unnamed"), //TRY(:ordinal-rules) // suffix
  r(" -> 2", ":unnamed"), //TRY(!morph-precheck)
  r(" -> 3", ":unnamed"), //TRY(:phase-one-rules) //  " -> 3", //TRY(:morph-dispatch)
  r(" -> 4", ":unnamed"), //TRY(:prefix-rules) // prefix-dispatch
  r(" -> 5", ":unnamed"), //TRY(!compound-rules) // morph-compound-rules
  r(" -> 6", ":unnamed"), //TRY(:phase-two-rules)

  };

// insert Lisp-generated defs for ruleSets here

 protected static MorphRule[] morphDispatch = {//":morph-dispatch"
  r("s # -> 7",
  // morph-dispatch-1, phase-one
    // act7 = (DO S-BLOCK)
    ":morph-dispatch", true, false, false),
  r("d # -> 8",
  // morph-dispatch-2, phase-one
    // act8 = (DO D-BLOCK)
    ":morph-dispatch", true, false, false),
  r("e # -> 9",
  // morph-dispatch-3, phase-one
    // act9 = (DO E-BLOCK)
    ":morph-dispatch", true, false, false),
  r("g # -> 10",
  // morph-dispatch-4, phase-one
    // act10 = (DO G-BLOCK)
    ":morph-dispatch", true, false, false),
  r("l # -> 11",
  // morph-dispatch-5, phase-one
    // act11 = (DO L-BLOCK)
    ":morph-dispatch", true, false, false),
  r("m # -> 12",
  // morph-dispatch-6, phase-one
    // act12 = (DO M-BLOCK)
    ":morph-dispatch", true, false, false),
  r("n # -> 13",
  // morph-dispatch-7, phase-one
    // act13 = (DO N-BLOCK)
    ":morph-dispatch", true, false, false),
  r("r # -> 14",
  // morph-dispatch-8, phase-one
    // act14 = (DO R-BLOCK)
    ":morph-dispatch", true, false, false),
  r("t # -> 15",
  // morph-dispatch-9, phase-one
    // act15 = (DO T-BLOCK)
    ":morph-dispatch", true, false, false),
  r("y # -> 16",
  // morph-dispatch-10, phase-one
    // act16 = (DO Y-BLOCK)
    ":morph-dispatch", true, false, false),
  r("c # -> 17",
  // morph-dispatch-11, phase-one
    // act17 = (DO C-BLOCK)
    ":morph-dispatch", true, false, false),
  r(" -> 18",
  // morph-dispatch-12, phase-one
    // act18 = (DO MISC-BLOCK)
    ":morph-dispatch", true, false, false),
 };

 protected static MorphRule[] sBlock = {//":s-block"
  r("c e s # -> 19,20,21",
  // s-block-1, conditional phase-one
    // act19 = (KILL 3)
    // act20 = (ADD X)
    // act21 = (CAT N (AND (MORPH-ROOT STATE) (TEST-ICODE ROOT 'N '-CES)) E...
    ":s-block", false, true, false),
  r("d e s # -> 19,22,23",
  // s-block-2, conditional phase-one
    // act19 = (KILL 3)
    // act22 = (ADD S)
    // act23 = (CAT N (AND (MORPH-ROOT STATE) (TEST-ICODE ROOT 'N '-DES)) E...
    ":s-block", false, true, false),
  r("v e s # -> 24,25,26,27,19,28,29,19,30,29",
  // s-block-3, conditional phase-one
    // act24 = (KILL 1)
    // act25 = (SETQ SUFFIX 'S)
    // act26 = (CAT V (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'V)) EVA...
    // act27 = (CAT N (AND (MORPH-ROOT STATE) (TEST-ICODE ROOT 'N '-S)) EVA...
    // act19 = (KILL 3)
    // act28 = (ADD F)
    // act29 = (CAT N (AND (MORPH-ROOT STATE) (TEST-ICODE ROOT 'N '-VES)) E...
    // act19 = (KILL 3)
    // act30 = (ADD F E)
    // act29 = (CAT N (AND (MORPH-ROOT STATE) (TEST-ICODE ROOT 'N '-VES)) E...
    ":s-block", false, true, true),
  r("consonant i c s # -> 19,31,32,33,34",
  // s-block-4, conditional phase-one
    // act19 = (KILL 3)
    // act31 = (ADD Y)
    // act32 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-KNOW...
    // act33 = (SETQ SUFFIX 'ICS)
    // act34 = (CAT NM (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'N)) EV...
    ":s-block", false, true, false),
  r("i c s # -> 24,35,25,36",
  // s-block-5, conditional phase-one
    // act24 = (KILL 1)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act25 = (SETQ SUFFIX 'S)
    // act36 = (CAT NM (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADJ) (...
    ":s-block", false, true, false),
  r("i a s # -> 19,37,38,39",
  // s-block-6, 
    // act19 = (KILL 3)
    // act37 = (ADD O)
    // act38 = (TEST (AND (MORPH-ROOT STATE) (IS-COMPOUND-CAT ROOT 'PREFIX)...
    // act39 = (CAT N T EVAL (PROGN (MARK-DICT LEX 'KINDOF 'ANIMAL T T) (MA...
    ":s-block"),
  r("o s # -> 24,38,39",
  // s-block-7, 
    // act24 = (KILL 1)
    // act38 = (TEST (AND (MORPH-ROOT STATE) (IS-COMPOUND-CAT ROOT 'PREFIX)...
    // act39 = (CAT N T EVAL (PROGN (MARK-DICT LEX 'KINDOF 'ANIMAL T T) (MA...
    ":s-block"),
  r("p u s # -> 19,40,41",
  // s-block-8, conditional phase-one
    // act19 = (KILL 3)
    // act40 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-ROOT...
    // act41 = (CAT N T EVAL (PROGN (MARK-DICT LEX 'FALSE-ROOT ROOT T T) (M...
    ":s-block", false, true, false),
  r("m a s # -> 19,42,43",
  // s-block-9, phase-one
    // act19 = (KILL 3)
    // act42 = (TEST (AND (POLYSYLLABIC ROOT) (OR *KNOWN-WORD-FILE* *KNOWN-...
    // act43 = (CAT N T EVAL (PROGN (MARK-DICT LEX 'FALSE-ROOT ROOT T T) (M...
    ":s-block", true, false, false),
  r("i e s # -> 24,25,44,45,46,19,31,47,45,48",
  // s-block-10, conditional phase-one
    // act24 = (KILL 1)
    // act25 = (SETQ SUFFIX 'S)
    // act44 = (TEST (AND (MORPH-ROOT STATE) (TEST-ICODE ROOT 'V 'S-D)))
    // act45 = (CAT V T EVAL (LIST ROOT '(TNS PRESENT) '(AGR 3SG)))
    // act46 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'N) (NOT...
    // act19 = (KILL 3)
    // act31 = (ADD Y)
    // act47 = (TEST (AND (MORPH-ROOT STATE) (TEST-ICODE ROOT 'V 'IES-IED))...
    // act45 = (CAT V T EVAL (LIST ROOT '(TNS PRESENT) '(AGR 3SG)))
    // act48 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'N) (NOT...
    ":s-block", false, true, true),
  r("i e s # -> 24,44,45,49",
  // s-block-11, conditional phase-one
    // act24 = (KILL 1)
    // act44 = (TEST (AND (MORPH-ROOT STATE) (TEST-ICODE ROOT 'V 'S-D)))
    // act45 = (CAT V T EVAL (LIST ROOT '(TNS PRESENT) '(AGR 3SG)))
    // act49 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'N) (NOT...
    ":s-block", false, true, false),
  r("e s # -> 50,25,51,45,52,24,44,45,53,50,54,55,56",
  // s-block-12, conditional phase-one
    // act50 = (KILL 2)
    // act25 = (SETQ SUFFIX 'S)
    // act51 = (TEST (AND (MORPH-ROOT STATE) (TEST-ICODE ROOT 'V '(ES-ED ES...
    // act45 = (CAT V T EVAL (LIST ROOT '(TNS PRESENT) '(AGR 3SG)))
    // act52 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'N) (NOT...
    // act24 = (KILL 1)
    // act44 = (TEST (AND (MORPH-ROOT STATE) (TEST-ICODE ROOT 'V 'S-D)))
    // act45 = (CAT V T EVAL (LIST ROOT '(TNS PRESENT) '(AGR 3SG)))
    // act53 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'N) (NOT...
    // act50 = (KILL 2)
    // act54 = (ADD I S)
    // act55 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (PATTERN-CHECK ROOT '(S I S...
    // act56 = (CAT N T EVAL (LIST ROOT '(NUMBER PL)))
    ":s-block", false, true, true),
  r("consonant i n e s s # -> 57,31,35,58,59",
  // s-block-13, phase-one
    // act57 = (KILL 5)
    // act31 = (ADD Y)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act58 = (SETQ SUFFIX 'NESS)
    // act59 = (CAT NM (AND (MORPH-ROOT STATE) (OR (IS-FORM-OF-CAT ROOT 'AD...
    ":s-block", true, false, false),
  r("consonant i n e s s # -> 57,35,58,60",
  // s-block-14, phase-one
    // act57 = (KILL 5)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act58 = (SETQ SUFFIX 'NESS)
    // act60 = (CAT NM (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(N V))...
    ":s-block", true, false, false),
  r("n e s s # -> 61,62,58,63",
  // s-block-15, phase-one
    // act61 = (KILL 4)
    // act62 = (TEST (AND (MORPH-ROOT STATE) (OR (PLAUSIBLE-ROOT ROOT) (IS-...
    // act58 = (SETQ SUFFIX 'NESS)
    // act63 = (CAT NM (AND (MORPH-ROOT STATE) (OR (IS-FORM-OF-CAT ROOT '(A...
    ":s-block", true, false, false),
  r("n e s s # -> 61,35,58,64",
  // s-block-16, phase-one
    // act61 = (KILL 4)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act58 = (SETQ SUFFIX 'NESS)
    // act64 = (CAT NM (AND (MORPH-ROOT STATE) (MORPH-COMPOUND-TEST ROOT 'A...
    ":s-block", true, false, false),
  r("consonant i l e s s # -> 57,31,35,65,66,67",
  // s-block-17, conditional phase-one
    // act57 = (KILL 5)
    // act31 = (ADD Y)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act65 = (SETQ SUFFIX 'LESS)
    // act66 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(V N)...
    // act67 = (CAT ADV (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(N)) ...
    ":s-block", false, true, false),
  r("l l - l e s s # -> 57,35,65,66,67",
  // s-block-18, conditional phase-one
    // act57 = (KILL 5)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act65 = (SETQ SUFFIX 'LESS)
    // act66 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(V N)...
    // act67 = (CAT ADV (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(N)) ...
    ":s-block", false, true, false),
  r("l e s s # -> 61,35,65,66,67",
  // s-block-19, conditional phase-one
    // act61 = (KILL 4)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act65 = (SETQ SUFFIX 'LESS)
    // act66 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(V N)...
    // act67 = (CAT ADV (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(N)) ...
    ":s-block", false, true, false),
  r("l e s s # -> 61,68,35,65,66,67",
  // s-block-20, conditional phase-one
    // act61 = (KILL 4)
    // act68 = (ADD E)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act65 = (SETQ SUFFIX 'LESS)
    // act66 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(V N)...
    // act67 = (CAT ADV (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(N)) ...
    ":s-block", false, true, false),
  r("consonant r e s s # -> 61,69,35,70,71",
  // s-block-21, conditional phase-one
    // act61 = (KILL 4)
    // act69 = (ADD O R)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act70 = (SETQ SUFFIX 'ESS)
    // act71 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'NN) (NO...
    ":s-block", false, true, false),
  r("consonant r e s s # -> 61,72,35,70,71",
  // s-block-22, conditional phase-one
    // act61 = (KILL 4)
    // act72 = (ADD E R)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act70 = (SETQ SUFFIX 'ESS)
    // act71 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'NN) (NO...
    ":s-block", false, true, false),
  r("consonant r e s s # -> 61,73,74,71",
  // s-block-23, conditional phase-one
    // act61 = (KILL 4)
    // act73 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (PA...
    // act74 = (SETQ SUFFIX 'RESS)
    // act71 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'NN) (NO...
    ":s-block", false, true, false),
  r("vowel consonant r e s s # -> 61,68,35,74,71",
  // s-block-24, conditional phase-one
    // act61 = (KILL 4)
    // act68 = (ADD E)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act74 = (SETQ SUFFIX 'RESS)
    // act71 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'NN) (NO...
    ":s-block", false, true, false),
  r("consonant r e s s # -> 19,31,32,70,71",
  // s-block-25, conditional phase-one
    // act19 = (KILL 3)
    // act31 = (ADD Y)
    // act32 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-KNOW...
    // act70 = (SETQ SUFFIX 'ESS)
    // act71 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'NN) (NO...
    ":s-block", false, true, false),
  r("e s s # -> 19,72,35,70,71",
  // s-block-26, conditional phase-one
    // act19 = (KILL 3)
    // act72 = (ADD E R)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act70 = (SETQ SUFFIX 'ESS)
    // act71 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'NN) (NO...
    ":s-block", false, true, false),
  r("e s s # -> 19,35,70,71",
  // s-block-27, conditional phase-one
    // act19 = (KILL 3)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act70 = (SETQ SUFFIX 'ESS)
    // act71 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'NN) (NO...
    ":s-block", false, true, false),
  r("e s s # -> 50,35,70,71",
  // s-block-28, conditional phase-one
    // act50 = (KILL 2)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act70 = (SETQ SUFFIX 'ESS)
    // act71 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'NN) (NO...
    ":s-block", false, true, false),
  r("s # -> 24,75,45,76",
  // s-block-29, conditional phase-one
    // act24 = (KILL 1)
    // act75 = (TEST (AND (MORPH-ROOT STATE) (NOT (PATTERN-CHECK ROOT '((S ...
    // act45 = (CAT V T EVAL (LIST ROOT '(TNS PRESENT) '(AGR 3SG)))
    // act76 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'N) (NOT...
    ":s-block", false, true, false),
  r("i e s # -> 24,25,46,77,19,31,78,79",
  // s-block-30, conditional phase-one
    // act24 = (KILL 1)
    // act25 = (SETQ SUFFIX 'S)
    // act46 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'N) (NOT...
    // act77 = (CAT V (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'V) (NOT...
    // act19 = (KILL 3)
    // act31 = (ADD Y)
    // act78 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'N) (NOT...
    // act79 = (CAT V (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'V) (NOT...
    ":s-block", false, true, true),
  r("consonant i e s # -> 19,31,80,56,79",
  // s-block-31, conditional phase-one
    // act19 = (KILL 3)
    // act31 = (ADD Y)
    // act80 = (TEST (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'N) (MAKE...
    // act56 = (CAT N T EVAL (LIST ROOT '(NUMBER PL)))
    // act79 = (CAT V (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'V) (NOT...
    ":s-block", false, true, false),
  r("i e s # -> 24,81,56,82",
  // s-block-32, conditional phase-one
    // act24 = (KILL 1)
    // act81 = (TEST (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'N) (MAKE...
    // act56 = (CAT N T EVAL (LIST ROOT '(NUMBER PL)))
    // act82 = (CAT V (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'V) (NOT...
    ":s-block", false, true, false),
  r("e s # -> 50,25,83,56,84,24,85,56,77,50,54,55,56",
  // s-block-33, conditional phase-one
    // act50 = (KILL 2)
    // act25 = (SETQ SUFFIX 'S)
    // act83 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-ROOT...
    // act56 = (CAT N T EVAL (LIST ROOT '(NUMBER PL)))
    // act84 = (CAT V (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'V) (NOT...
    // act24 = (KILL 1)
    // act85 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-ROOT...
    // act56 = (CAT N T EVAL (LIST ROOT '(NUMBER PL)))
    // act77 = (CAT V (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'V) (NOT...
    // act50 = (KILL 2)
    // act54 = (ADD I S)
    // act55 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (PATTERN-CHECK ROOT '(S I S...
    // act56 = (CAT N T EVAL (LIST ROOT '(NUMBER PL)))
    ":s-block", false, true, true),
  r("s # -> 24,86,87,88",
  // s-block-34, conditional phase-one
    // act24 = (KILL 1)
    // act86 = (TEST (AND (MORPH-ROOT STATE) (NOT (PATTERN-CHECK ROOT '((S ...
    // act87 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'N)) EVA...
    // act88 = (CAT V (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'V) (NOT...
    ":s-block", false, true, false),
  r("' s # -> 50,89,90,56,91",
  // s-block-35, conditional phase-one
    // act50 = (KILL 2)
    // act89 = (TEST (AND (MORPH-ROOT STATE) (OR (IS-FORM-OF-CAT ROOT 'N) (...
    // act90 = (CAT N T EVAL (LIST ROOT '(POSS) '(PENALTY 1)))
    // act56 = (CAT N T EVAL (LIST ROOT '(NUMBER PL)))
    // act91 = (CAT V (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'V) (NOT...
    ":s-block", false, true, false),
  r("' s # -> 50,92",
  // s-block-36, phase-one
    // act50 = (KILL 2)
    // act92 = (CAT N T EVAL (LIST ROOT '(POSS)))
    ":s-block", true, false, false),
  r("i e s # -> 24,25,35,46,77,19,31,78,79",
  // s-block-37, conditional phase-one
    // act24 = (KILL 1)
    // act25 = (SETQ SUFFIX 'S)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act46 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'N) (NOT...
    // act77 = (CAT V (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'V) (NOT...
    // act19 = (KILL 3)
    // act31 = (ADD Y)
    // act78 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'N) (NOT...
    // act79 = (CAT V (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'V) (NOT...
    ":s-block", false, true, true),
  r("e s # -> 50,25,35,93,94,24,95,77,50,54,96",
  // s-block-38, conditional phase-one
    // act50 = (KILL 2)
    // act25 = (SETQ SUFFIX 'S)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act93 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'N) (NOT...
    // act94 = (CAT V (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'V) (OR ...
    // act24 = (KILL 1)
    // act95 = (CAT N (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-ROO...
    // act77 = (CAT V (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'V) (NOT...
    // act50 = (KILL 2)
    // act54 = (ADD I S)
    // act96 = (CAT N (AND (PATTERN-CHECK ROOT '(S I S)) (POLYSYLLABIC ROOT...
    ":s-block", false, true, true),
  r("s # -> 24,35,97,77",
  // s-block-39, conditional phase-one
    // act24 = (KILL 1)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act97 = (CAT N (AND (MORPH-ROOT STATE) (NOT (PATTERN-CHECK ROOT '((S...
    // act77 = (CAT V (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'V) (NOT...
    ":s-block", false, true, false),
  r("consonant i e s # -> 24,25,35,26,46,19,31,35,26,78",
  // s-block-40, conditional phase-one
    // act24 = (KILL 1)
    // act25 = (SETQ SUFFIX 'S)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act26 = (CAT V (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'V)) EVA...
    // act46 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'N) (NOT...
    // act19 = (KILL 3)
    // act31 = (ADD Y)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act26 = (CAT V (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'V)) EVA...
    // act78 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'N) (NOT...
    ":s-block", false, true, true),
  r("i e s # -> 24,25,32,56,19,31,32,56",
  // s-block-41, conditional phase-one
    // act24 = (KILL 1)
    // act25 = (SETQ SUFFIX 'S)
    // act32 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-KNOW...
    // act56 = (CAT N T EVAL (LIST ROOT '(NUMBER PL)))
    // act19 = (KILL 3)
    // act31 = (ADD Y)
    // act32 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-KNOW...
    // act56 = (CAT N T EVAL (LIST ROOT '(NUMBER PL)))
    ":s-block", false, true, true),
  r("e s # -> 50,25,98,56,24,32,56,50,54,99,56",
  // s-block-42, conditional phase-one
    // act50 = (KILL 2)
    // act25 = (SETQ SUFFIX 'S)
    // act98 = (TEST (AND (MORPH-ROOT STATE) (IS-KNOWN-WORD ROOT) (PLAUSIBL...
    // act56 = (CAT N T EVAL (LIST ROOT '(NUMBER PL)))
    // act24 = (KILL 1)
    // act32 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-KNOW...
    // act56 = (CAT N T EVAL (LIST ROOT '(NUMBER PL)))
    // act50 = (KILL 2)
    // act54 = (ADD I S)
    // act99 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (POLYSYLLABIC ROOT) (PATTER...
    // act56 = (CAT N T EVAL (LIST ROOT '(NUMBER PL)))
    ":s-block", false, true, true),
  r("any & e s # -> 19,100,56,101,45",
  // s-block-43, conditional phase-one
    // act19 = (KILL 3)
    // act100 = (TEST (AND (MORPH-ROOT STATE) (TEST-ICODE ROOT 'N '-*ES)))
    // act56 = (CAT N T EVAL (LIST ROOT '(NUMBER PL)))
    // act101 = (TEST (AND (MORPH-ROOT STATE) (TEST-ICODE ROOT 'V '*ES-*ED))...
    // act45 = (CAT V T EVAL (LIST ROOT '(TNS PRESENT) '(AGR 3SG)))
    ":s-block", false, true, false),
  r("i t i o u s # -> 102,35,103,104",
  // s-block-44, conditional phase-one
    // act102 = (KILL 6)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act103 = (SETQ SUFFIX 'ITIOUS)
    // act104 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(N V)...
    ":s-block", false, true, false),
  r("vowel consonant i o u s # -> 61,68,105,106,104",
  // s-block-45, conditional phase-one
    // act61 = (KILL 4)
    // act68 = (ADD E)
    // act105 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (NEED-FINAL-E ROOT)))
    // act106 = (SETQ SUFFIX 'OUS)
    // act104 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(N V)...
    ":s-block", false, true, false),
  r("consonant i o u s # -> 61,35,106,104",
  // s-block-46, conditional phase-one
    // act61 = (KILL 4)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act106 = (SETQ SUFFIX 'OUS)
    // act104 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(N V)...
    ":s-block", false, true, false),
  r("consonant i o u s # -> 50,107,32,106,104",
  // s-block-47, conditional phase-one
    // act50 = (KILL 2)
    // act107 = (ADD N)
    // act32 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-KNOW...
    // act106 = (SETQ SUFFIX 'OUS)
    // act104 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(N V)...
    ":s-block", false, true, false),
  r("consonant i o u s # -> 61,31,32,106,104",
  // s-block-48, conditional phase-one
    // act61 = (KILL 4)
    // act31 = (ADD Y)
    // act32 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-KNOW...
    // act106 = (SETQ SUFFIX 'OUS)
    // act104 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(N V)...
    ":s-block", false, true, false),
  r("vowel consonant i o u s # -> 61,108,32,106,109",
  // s-block-49, conditional phase-one
    // act61 = (KILL 4)
    // act108 = (ADD I T Y)
    // act32 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-KNOW...
    // act106 = (SETQ SUFFIX 'OUS)
    // act109 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'N)) E...
    ":s-block", false, true, false),
  r("p a r o u s # -> 102,110",
  // s-block-50, conditional phase-one
    // act102 = (KILL 6)
    // act110 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'PREFI...
    ":s-block", false, true, false),
  r("consonant vowel b|d|g|k|l|m|n|p|r|t & i f e r o u s # -> 111,112",
  // s-block-51, conditional phase-one
    // act111 = (KILL 8)
    // act112 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(N PR...
    ":s-block", false, true, false),
  r("i f e r o u s # -> 113,112",
  // s-block-52, conditional phase-one
    // act113 = (KILL 7)
    // act112 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(N PR...
    ":s-block", false, true, false),
  r("consonant o u s # -> 19,31,114,106,115",
  // s-block-53, conditional phase-one
    // act19 = (KILL 3)
    // act31 = (ADD Y)
    // act114 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (POLYSYLLABIC ROOT) (MORPH-...
    // act106 = (SETQ SUFFIX 'OUS)
    // act115 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'NN)) ...
    ":s-block", false, true, false),
  r("consonant o u s # -> 19,116,114,106,115",
  // s-block-54, conditional phase-one
    // act19 = (KILL 3)
    // act116 = (ADD U M)
    // act114 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (POLYSYLLABIC ROOT) (MORPH-...
    // act106 = (SETQ SUFFIX 'OUS)
    // act115 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'NN)) ...
    ":s-block", false, true, false),
  r("consonant o u s # -> 19,117,114,106,115",
  // s-block-55, conditional phase-one
    // act19 = (KILL 3)
    // act117 = (ADD A)
    // act114 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (POLYSYLLABIC ROOT) (MORPH-...
    // act106 = (SETQ SUFFIX 'OUS)
    // act115 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'NN)) ...
    ":s-block", false, true, false),
  r("consonant o u s # -> 19,118,114,106,119",
  // s-block-56, conditional phase-one
    // act19 = (KILL 3)
    // act118 = (ADD I C)
    // act114 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (POLYSYLLABIC ROOT) (MORPH-...
    // act106 = (SETQ SUFFIX 'OUS)
    // act119 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADJ))...
    ":s-block", false, true, false),
  r("consonant o u s # -> 19,120,114,106,119",
  // s-block-57, conditional phase-one
    // act19 = (KILL 3)
    // act120 = (ADD A L)
    // act114 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (POLYSYLLABIC ROOT) (MORPH-...
    // act106 = (SETQ SUFFIX 'OUS)
    // act119 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADJ))...
    ":s-block", false, true, false),
  r("consonant o u s # -> 19,121,114,106,119",
  // s-block-58, conditional phase-one
    // act19 = (KILL 3)
    // act121 = (ADD E N T)
    // act114 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (POLYSYLLABIC ROOT) (MORPH-...
    // act106 = (SETQ SUFFIX 'OUS)
    // act119 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADJ))...
    ":s-block", false, true, false),
  r("a t o u s # -> 61,35,106,109",
  // s-block-59, conditional phase-one
    // act61 = (KILL 4)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act106 = (SETQ SUFFIX 'OUS)
    // act109 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'N)) E...
    ":s-block", false, true, false),
  r("o u s # -> 19,35,106,122",
  // s-block-60, conditional phase-one
    // act19 = (KILL 3)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act106 = (SETQ SUFFIX 'OUS)
    // act122 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(N V ...
    ":s-block", false, true, false),
  r("o u s # -> 50,35,106,123",
  // s-block-61, conditional phase-one
    // act50 = (KILL 2)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act106 = (SETQ SUFFIX 'OUS)
    // act123 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(PREF...
    ":s-block", false, true, false),
  r("o u s # -> 19,124,68,106,125",
  // s-block-62, conditional phase-one
    // act19 = (KILL 3)
    // act124 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (PA...
    // act68 = (ADD E)
    // act106 = (SETQ SUFFIX 'OUS)
    // act125 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(NN V...
    ":s-block", false, true, false),
  r("consonant u o u s # -> 61,35,106,104",
  // s-block-63, conditional phase-one
    // act61 = (KILL 4)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act106 = (SETQ SUFFIX 'OUS)
    // act104 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(N V)...
    ":s-block", false, true, false),
  r("consonant r o u s # -> 61,72,35,106,109",
  // s-block-64, conditional phase-one
    // act61 = (KILL 4)
    // act72 = (ADD E R)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act106 = (SETQ SUFFIX 'OUS)
    // act109 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'N)) E...
    ":s-block", false, true, false),
  r("a n e o u s # -> 102,32,126,109",
  // s-block-65, conditional phase-one
    // act102 = (KILL 6)
    // act32 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-KNOW...
    // act126 = (SETQ SUFFIX 'ANEOUS)
    // act109 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'N)) E...
    ":s-block", false, true, false),
  r("a n e o u s # -> 57,32,126,109",
  // s-block-66, conditional phase-one
    // act57 = (KILL 5)
    // act32 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-KNOW...
    // act126 = (SETQ SUFFIX 'ANEOUS)
    // act109 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'N)) E...
    ":s-block", false, true, false),
  r("consonant a c e o u s # -> 102,117,114,127,128",
  // s-block-67, conditional phase-one
    // act102 = (KILL 6)
    // act117 = (ADD A)
    // act114 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (POLYSYLLABIC ROOT) (MORPH-...
    // act127 = (SETQ SUFFIX 'ACEOUS)
    // act128 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(NN A...
    ":s-block", false, true, false),
  r("a c e o u s # -> 102,35,129",
  // s-block-68, conditional phase-one
    // act102 = (KILL 6)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act129 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(N AD...
    ":s-block", false, true, false),
  r("a c e o u s # -> 102,124,68,127,128",
  // s-block-69, conditional phase-one
    // act102 = (KILL 6)
    // act124 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (PA...
    // act68 = (ADD E)
    // act127 = (SETQ SUFFIX 'ACEOUS)
    // act128 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(NN A...
    ":s-block", false, true, false),
  r("consonant a c e o u s # -> 102,37,35,130",
  // s-block-70, conditional phase-one
    // act102 = (KILL 6)
    // act37 = (ADD O)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act130 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(PREF...
    ":s-block", false, true, false),
  r("consonant e o u s # -> 61,35,106,109",
  // s-block-71, conditional phase-one
    // act61 = (KILL 4)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act106 = (SETQ SUFFIX 'OUS)
    // act109 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'N)) E...
    ":s-block", false, true, false),
  r("consonant e o u s # -> 61,117,131,106,115",
  // s-block-72, conditional phase-one
    // act61 = (KILL 4)
    // act117 = (ADD A)
    // act131 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (POLYSYLLABIC ROOT)))
    // act106 = (SETQ SUFFIX 'OUS)
    // act115 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'NN)) ...
    ":s-block", false, true, false),
  r("consonant e o u s # -> 61,132,131,106,115",
  // s-block-73, conditional phase-one
    // act61 = (KILL 4)
    // act132 = (ADD O N)
    // act131 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (POLYSYLLABIC ROOT)))
    // act106 = (SETQ SUFFIX 'OUS)
    // act115 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'NN)) ...
    ":s-block", false, true, false),
  r("consonant e o u s # -> 61,31,131,106,115",
  // s-block-74, conditional phase-one
    // act61 = (KILL 4)
    // act31 = (ADD Y)
    // act131 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (POLYSYLLABIC ROOT)))
    // act106 = (SETQ SUFFIX 'OUS)
    // act115 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'NN)) ...
    ":s-block", false, true, false),
  r("i t o u s # -> 19,31,131,106,115",
  // s-block-75, conditional phase-one
    // act19 = (KILL 3)
    // act31 = (ADD Y)
    // act131 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (POLYSYLLABIC ROOT)))
    // act106 = (SETQ SUFFIX 'OUS)
    // act115 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'NN)) ...
    ":s-block", false, true, false),
  r("consonant i n o u s # -> 57,68,105,106,125",
  // s-block-76, conditional phase-one
    // act57 = (KILL 5)
    // act68 = (ADD E)
    // act105 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (NEED-FINAL-E ROOT)))
    // act106 = (SETQ SUFFIX 'OUS)
    // act125 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(NN V...
    ":s-block", false, true, false),
  r("o s i s # -> 19,133",
  // s-block-77, conditional phase-one
    // act19 = (KILL 3)
    // act133 = (CAT NM (AND (POLYSYLLABIC ROOT) (MORPH-ROOT STATE) (IS-FORM...
    ":s-block", false, true, false),
  r("o s i s # -> 61,134",
  // s-block-78, conditional phase-one
    // act61 = (KILL 4)
    // act134 = (CAT NM (AND (SYLLABIC ROOT) (MORPH-ROOT STATE) (IS-FORM-OF-...
    ":s-block", false, true, false),
  r("i o s i s # -> 61,117,135",
  // s-block-79, conditional phase-one
    // act61 = (KILL 4)
    // act117 = (ADD A)
    // act135 = (CAT NM (AND (POLYSYLLABIC ROOT) (MORPH-ROOT STATE) (IS-FORM...
    ":s-block", false, true, false),
  r("i t i s # -> 136",
  // s-block-80, phase-one
    // act136 = (TRY ITIS-BLOCK)
    ":s-block", true, false, false),
  r("w a r d s # -> 57,137,138,139,140",
  // s-block-81, conditional phase-one
    // act57 = (KILL 5)
    // act137 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-ROOT...
    // act138 = (SETQ SUFFIX 'WARDS)
    // act139 = (CAT ADV T EVAL (CONS LEX (LIST (LIST 'ROOT ROOT) (LIST 'SUF...
    // act140 = (CAT ADJ T EVAL (CONS LEX (LIST (LIST 'ROOT ROOT) (LIST 'SUF...
    ":s-block", false, true, false),
  r("i n g s # -> 24,87",
  // s-block-82, phase-one
    // act24 = (KILL 1)
    // act87 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'N)) EVA...
    ":s-block", true, false, false),
  r("e r s # -> 24,87",
  // s-block-83, phase-one
    // act24 = (KILL 1)
    // act87 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'N)) EVA...
    ":s-block", true, false, false),
  r("c o l o r s # -> 24,87,141",
  // s-block-84, phase-one
    // act24 = (KILL 1)
    // act87 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'N)) EVA...
    // act141 = (CAT V (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'V)) EVA...
    ":s-block", true, false, false),
  r("o r s # -> 24,87",
  // s-block-85, phase-one
    // act24 = (KILL 1)
    // act87 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'N)) EVA...
    ":s-block", true, false, false),
  r("o p s # -> 142,143",
  // s-block-86, 
    // act142 = (TEST (POLYSYLLABIC ROOT))
    // act143 = (CAT N T EVAL (PROGN (MARK-DICT LEX 'KINDOF 'ANIMAL T T) (MA...
    ":s-block"),
  r("s # -> 24,144,56",
  // s-block-87, 
    // act24 = (KILL 1)
    // act144 = (TEST (AND (MORPH-ROOT STATE) (NOT (PATTERN-CHECK ROOT '((S ...
    // act56 = (CAT N T EVAL (LIST ROOT '(NUMBER PL)))
    ":s-block"),
  r("i o n s # -> 24,145",
  // s-block-88, 
    // act24 = (KILL 1)
    // act145 = (CAT N (AND (MORPH-ROOT STATE) (MORPH-CHECK ROOT 'N)) EVAL (...
    ":s-block"),
  r("consonant i e s # -> 19,31,35,146,147",
  // s-block-89, 
    // act19 = (KILL 3)
    // act31 = (ADD Y)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act146 = (CAT N (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT 'N)) EVAL (L...
    // act147 = (CAT V (AND *GUESS-VERB-FLAG* (MORPH-ROOT STATE) (MAY-BE-CAT...
    ":s-block"),
  r("e e s # -> 24,146,147",
  // s-block-90, 
    // act24 = (KILL 1)
    // act146 = (CAT N (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT 'N)) EVAL (L...
    // act147 = (CAT V (AND *GUESS-VERB-FLAG* (MORPH-ROOT STATE) (MAY-BE-CAT...
    ":s-block"),
  r("e s # -> 24,148,146,147",
  // s-block-91, 
    // act24 = (KILL 1)
    // act148 = (TEST (NEED-FINAL-E ROOT))
    // act146 = (CAT N (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT 'N)) EVAL (L...
    // act147 = (CAT V (AND *GUESS-VERB-FLAG* (MORPH-ROOT STATE) (MAY-BE-CAT...
    ":s-block"),
  r("c|g e s # -> 24,146,147",
  // s-block-92, 
    // act24 = (KILL 1)
    // act146 = (CAT N (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT 'N)) EVAL (L...
    // act147 = (CAT V (AND *GUESS-VERB-FLAG* (MORPH-ROOT STATE) (MAY-BE-CAT...
    ":s-block"),
  r("s|z & e s # -> 50,146,147",
  // s-block-93, 
    // act50 = (KILL 2)
    // act146 = (CAT N (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT 'N)) EVAL (L...
    // act147 = (CAT V (AND *GUESS-VERB-FLAG* (MORPH-ROOT STATE) (MAY-BE-CAT...
    ":s-block"),
  r("u s e s # -> 50,146,147",
  // s-block-94, 
    // act50 = (KILL 2)
    // act146 = (CAT N (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT 'N)) EVAL (L...
    // act147 = (CAT V (AND *GUESS-VERB-FLAG* (MORPH-ROOT STATE) (MAY-BE-CAT...
    ":s-block"),
  r("vowel s|z e s # -> 24,148,146,147",
  // s-block-95, 
    // act24 = (KILL 1)
    // act148 = (TEST (NEED-FINAL-E ROOT))
    // act146 = (CAT N (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT 'N)) EVAL (L...
    // act147 = (CAT V (AND *GUESS-VERB-FLAG* (MORPH-ROOT STATE) (MAY-BE-CAT...
    ":s-block"),
  r("s|z e s # -> 50,146,147",
  // s-block-96, 
    // act50 = (KILL 2)
    // act146 = (CAT N (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT 'N)) EVAL (L...
    // act147 = (CAT V (AND *GUESS-VERB-FLAG* (MORPH-ROOT STATE) (MAY-BE-CAT...
    ":s-block"),
  r("l e a v e s # -> 19,28,25,146,149,24,150,147",
  // s-block-97, phase-two
    // act19 = (KILL 3)
    // act28 = (ADD F)
    // act25 = (SETQ SUFFIX 'S)
    // act146 = (CAT N (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT 'N)) EVAL (L...
    // act149 = (CAT V (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT 'V)) EVAL (L...
    // act24 = (KILL 1)
    // act150 = (ADD)
    // act147 = (CAT V (AND *GUESS-VERB-FLAG* (MORPH-ROOT STATE) (MAY-BE-CAT...
    ":s-block", false, false, true),
  r("e l v e s # -> 19,28,25,146,149,24,150,147",
  // s-block-98, phase-two
    // act19 = (KILL 3)
    // act28 = (ADD F)
    // act25 = (SETQ SUFFIX 'S)
    // act146 = (CAT N (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT 'N)) EVAL (L...
    // act149 = (CAT V (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT 'V)) EVAL (L...
    // act24 = (KILL 1)
    // act150 = (ADD)
    // act147 = (CAT V (AND *GUESS-VERB-FLAG* (MORPH-ROOT STATE) (MAY-BE-CAT...
    ":s-block", false, false, true),
  r("consonant vowel b|d|g|k|l|m|n|p|r|s|t|v e s # -> 24,146,147",
  // s-block-99, 
    // act24 = (KILL 1)
    // act146 = (CAT N (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT 'N)) EVAL (L...
    // act147 = (CAT V (AND *GUESS-VERB-FLAG* (MORPH-ROOT STATE) (MAY-BE-CAT...
    ":s-block"),
  r("consonant vowel vowel b|c|d|f|g|k|l|m|n|p|q|r|t|v|w|y e s # -> 24,146,147",
  // s-block-100, 
    // act24 = (KILL 1)
    // act146 = (CAT N (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT 'N)) EVAL (L...
    // act147 = (CAT V (AND *GUESS-VERB-FLAG* (MORPH-ROOT STATE) (MAY-BE-CAT...
    ":s-block"),
  r("l e s # -> 24,146,147",
  // s-block-101, 
    // act24 = (KILL 1)
    // act146 = (CAT N (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT 'N)) EVAL (L...
    // act147 = (CAT V (AND *GUESS-VERB-FLAG* (MORPH-ROOT STATE) (MAY-BE-CAT...
    ":s-block"),
  r("y e s # -> 24,146,147",
  // s-block-102, 
    // act24 = (KILL 1)
    // act146 = (CAT N (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT 'N)) EVAL (L...
    // act147 = (CAT V (AND *GUESS-VERB-FLAG* (MORPH-ROOT STATE) (MAY-BE-CAT...
    ":s-block"),
  r("e s # -> 50,151,146,147",
  // s-block-103, conditional phase-one
    // act50 = (KILL 2)
    // act151 = (TEST (OR (PATTERN-CHECK ROOT '((C S) H)) (PATTERN-CHECK ROO...
    // act146 = (CAT N (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT 'N)) EVAL (L...
    // act147 = (CAT V (AND *GUESS-VERB-FLAG* (MORPH-ROOT STATE) (MAY-BE-CAT...
    ":s-block", false, true, false),
  r("h r e n s # -> 152",
  // s-block-104, 
    // act152 = (CAT LASTNAME (PLAUSIBLE-ROOT ROOT) EVAL '*)
    ":s-block"),
  r("u l o s # -> 152",
  // s-block-105, 
    // act152 = (CAT LASTNAME (PLAUSIBLE-ROOT ROOT) EVAL '*)
    ":s-block"),
  r("t t s # -> 152",
  // s-block-106, 
    // act152 = (CAT LASTNAME (PLAUSIBLE-ROOT ROOT) EVAL '*)
    ":s-block"),
  r("s t r a s s # -> 153",
  // s-block-107, 
    // act153 = (CAT LASTNAME (POLYSYLLABIC ROOT) EVAL '*)
    ":s-block"),
  r("e i s s # -> 154",
  // s-block-108, 
    // act154 = (CAT LASTNAME T EVAL '*)
    ":s-block"),
  r("n e s s # -> 155",
  // s-block-109, 
    // act155 = (CAT NM (POLYSYLLABIC ROOT) EVAL (PROGN (MARK-DICT LEX 'KIND...
    ":s-block"),
  r("l e s s # -> 156,157",
  // s-block-110, 
    // act156 = (CAT ADJ (PLAUSIBLE-ROOT ROOT) EVAL '*)
    // act157 = (CAT ADV (PLAUSIBLE-ROOT ROOT) EVAL '*)
    ":s-block"),
  r("s s # -> 158",
  // s-block-111, phase-one
    // act158 = (DO DEFAULT-RULE)
    ":s-block", true, false, false),
  r("s # -> 24,159,26,160",
  // s-block-112, conditional phase-one
    // act24 = (KILL 1)
    // act159 = (TEST (AND (MORPH-ROOT STATE) (NOT (PATTERN-CHECK ROOT '((S ...
    // act26 = (CAT V (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'V)) EVA...
    // act160 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'N) (NOT...
    ":s-block", false, true, false),
  r("i c s # -> 161",
  // s-block-113, 
    // act161 = (CAT N (POLYSYLLABIC ROOT) EVAL 'MASS/PL)
    ":s-block"),
  r("o u s # -> 162",
  // s-block-114, 
    // act162 = (CAT ADJ T EVAL '*)
    ":s-block"),
  r("consonant u s # -> 163",
  // s-block-115, 
    // act163 = (CAT N (POLYSYLLABIC ROOT) EVAL '-ES)
    ":s-block"),
  r("u s # -> 163,164",
  // s-block-116, 
    // act163 = (CAT N (POLYSYLLABIC ROOT) EVAL '-ES)
    // act164 = (CAT ADJ (POLYSYLLABIC ROOT) EVAL '*)
    ":s-block"),
  r("i t i s # -> 165",
  // s-block-117, 
    // act165 = (CAT NM (POLYSYLLABIC ROOT) EVAL '-DES)
    ":s-block"),
  r("l y s i s # -> 166",
  // s-block-118, 
    // act166 = (CAT NM (POLYSYLLABIC ROOT) EVAL 'IS-ES)
    ":s-block"),
  r("s|x i s # -> 166",
  // s-block-119, 
    // act166 = (CAT NM (POLYSYLLABIC ROOT) EVAL 'IS-ES)
    ":s-block"),
  r("i s # -> 167",
  // s-block-120, 
    // act167 = (CAT N T EVAL (PROGN (MARK-DICT LEX 'GUESSED 'T) '-ES))
    ":s-block"),
  r("consonant y s # -> 158",
  // s-block-121, phase-one
    // act158 = (DO DEFAULT-RULE)
    ":s-block", true, false, false),
  r("i e s # -> 19,31,35,168,169",
  // s-block-122, 
    // act19 = (KILL 3)
    // act31 = (ADD Y)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act168 = (CAT N (AND (MORPH-ROOT STATE) (MORPH-CHECK ROOT 'N 'KNOWN))...
    // act169 = (CAT V (AND (MORPH-ROOT STATE) (MORPH-CHECK ROOT 'V 'KNOWN))...
    ":s-block"),
  r("s # -> 24,170,56,171,45",
  // s-block-123, 
    // act24 = (KILL 1)
    // act170 = (TEST (AND (MORPH-ROOT STATE) (NOT (PATTERN-CHECK ROOT '((S ...
    // act56 = (CAT N T EVAL (LIST ROOT '(NUMBER PL)))
    // act171 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (MORPH-C...
    // act45 = (CAT V T EVAL (LIST ROOT '(TNS PRESENT) '(AGR 3SG)))
    ":s-block"),
  r("e e s # -> 24,35,172,173",
  // s-block-124, 
    // act24 = (KILL 1)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act172 = (CAT N T EVAL (PROGN (MARK-DICT LEX 'GUESSED 'T) (WHEN *GUES...
    // act173 = (CAT V *GUESS-VERB-FLAG* EVAL (LIST ROOT '(TNS PRESENT) '(AG...
    ":s-block"),
  r("i e s # -> 19,31,35,172,173",
  // s-block-125, 
    // act19 = (KILL 3)
    // act31 = (ADD Y)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act172 = (CAT N T EVAL (PROGN (MARK-DICT LEX 'GUESSED 'T) (WHEN *GUES...
    // act173 = (CAT V *GUESS-VERB-FLAG* EVAL (LIST ROOT '(TNS PRESENT) '(AG...
    ":s-block"),
  r("e s # -> 24,174,172,173",
  // s-block-126, 
    // act24 = (KILL 1)
    // act174 = (TEST (AND (NEED-FINAL-E ROOT) (PLAUSIBLE-ROOT ROOT)))
    // act172 = (CAT N T EVAL (PROGN (MARK-DICT LEX 'GUESSED 'T) (WHEN *GUES...
    // act173 = (CAT V *GUESS-VERB-FLAG* EVAL (LIST ROOT '(TNS PRESENT) '(AG...
    ":s-block"),
  r("c|s h e s # -> 50,35,172,173",
  // s-block-127, 
    // act50 = (KILL 2)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act172 = (CAT N T EVAL (PROGN (MARK-DICT LEX 'GUESSED 'T) (WHEN *GUES...
    // act173 = (CAT V *GUESS-VERB-FLAG* EVAL (LIST ROOT '(TNS PRESENT) '(AG...
    ":s-block"),
  r("c|g e s # -> 24,35,172,173",
  // s-block-128, 
    // act24 = (KILL 1)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act172 = (CAT N T EVAL (PROGN (MARK-DICT LEX 'GUESSED 'T) (WHEN *GUES...
    // act173 = (CAT V *GUESS-VERB-FLAG* EVAL (LIST ROOT '(TNS PRESENT) '(AG...
    ":s-block"),
  r("consonant o s # -> 175",
  // s-block-129, 
    // act175 = (CAT NPR (AND (MORPH-ROOT STATE) (NOT (POLYSYLLABIC ROOT))) ...
    ":s-block"),
  r("s # -> 24,159,176",
  // s-block-130, conditional phase-one
    // act24 = (KILL 1)
    // act159 = (TEST (AND (MORPH-ROOT STATE) (NOT (PATTERN-CHECK ROOT '((S ...
    // act176 = (CAT N (AND (MORPH-ROOT STATE) (OR (TEST-ICODE ROOT 'N '-APO...
    ":s-block", false, true, false),
  r("s # -> 24,159,177,173",
  // s-block-131, 
    // act24 = (KILL 1)
    // act159 = (TEST (AND (MORPH-ROOT STATE) (NOT (PATTERN-CHECK ROOT '((S ...
    // act177 = (CAT N (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT 'N) (NOT (TE...
    // act173 = (CAT V *GUESS-VERB-FLAG* EVAL (LIST ROOT '(TNS PRESENT) '(AG...
    ":s-block"),
  r("s # -> 24,178,179",
  // s-block-132, 
    // act24 = (KILL 1)
    // act178 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (PA...
    // act179 = (CAT N (AND (MORPH-ROOT STATE) (NOT (GET-INFLECTION-ROOTS RO...
    ":s-block"),
  r("j|s|x|z e s # -> 50,56",
  // s-block-133, 
    // act50 = (KILL 2)
    // act56 = (CAT N T EVAL (LIST ROOT '(NUMBER PL)))
    ":s-block"),
  r(" -> 180,158",
  // s-block-134, 
    // act180 = (TEST T)
    // act158 = (DO DEFAULT-RULE)
    ":s-block"),
 };

 protected static MorphRule[] dBlock = {//":d-block"
  r("' e d # -> 19,162,181",
  // d-block-1, phase-one
    // act19 = (KILL 3)
    // act162 = (CAT ADJ T EVAL '*)
    // act181 = (CAT V T EVAL (LIST ROOT '(TNS PAST) '(PASTPART)))
    ":d-block", true, false, false),
  r("' d # -> 50,162,181",
  // d-block-2, phase-one
    // act50 = (KILL 2)
    // act162 = (CAT ADJ T EVAL '*)
    // act181 = (CAT V T EVAL (LIST ROOT '(TNS PAST) '(PASTPART)))
    ":d-block", true, false, false),
  r("- f e d # -> 61,182,162,183",
  // d-block-3, conditional phase-one
    // act61 = (KILL 4)
    // act182 = (TEST (AND (MORPH-ROOT STATE) (IS-FORM-OF-CAT ROOT '(PREFIX ...
    // act162 = (CAT ADJ T EVAL '*)
    // act183 = (CAT V T EVAL (PROGN (MARK-DICT LEX 'FALSE-ROOT ROOT T T) (M...
    ":d-block", false, true, false),
  r("- f e e d # -> 57,182,184",
  // d-block-4, conditional phase-one
    // act57 = (KILL 5)
    // act182 = (TEST (AND (MORPH-ROOT STATE) (IS-FORM-OF-CAT ROOT '(PREFIX ...
    // act184 = (CAT V T EVAL (PROGN (MARK-DICT LEX 'FALSE-ROOT ROOT T T) (M...
    ":d-block", false, true, false),
  r("i e d # -> 19,31,185,162,186",
  // d-block-5, conditional phase-one
    // act19 = (KILL 3)
    // act31 = (ADD Y)
    // act185 = (TEST (AND (MORPH-ROOT STATE) (TEST-ICODE ROOT 'V '(ES-ED IE...
    // act162 = (CAT ADJ T EVAL '*)
    // act186 = (CAT V (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'V)) EVA...
    ":d-block", false, true, false),
  r("e d # -> 50,187,188,189,186,24,44,189,186",
  // d-block-6, conditional phase-one
    // act50 = (KILL 2)
    // act187 = (SETQ SUFFIX 'ED)
    // act188 = (TEST (AND (MORPH-ROOT STATE) (TEST-ICODE ROOT 'V '(S-ED ES-...
    // act189 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'V)) E...
    // act186 = (CAT V (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'V)) EVA...
    // act24 = (KILL 1)
    // act44 = (TEST (AND (MORPH-ROOT STATE) (TEST-ICODE ROOT 'V 'S-D)))
    // act189 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'V)) E...
    // act186 = (CAT V (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'V)) EVA...
    ":d-block", false, true, true),
  r("o i d # -> 19,68,190,191,192",
  // d-block-7, conditional phase-one
    // act19 = (KILL 3)
    // act68 = (ADD E)
    // act190 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (NEED-FINAL-E ROOT) (MORPH-...
    // act191 = (CAT ADJ T EVAL (PROGN (MARK-DICT LEX 'ROOT ROOT T T) (MARK-...
    // act192 = (CAT N T EVAL '-S)
    ":d-block", false, true, false),
  r("o i d # -> 19,137,191,192",
  // d-block-8, conditional phase-one
    // act19 = (KILL 3)
    // act137 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-ROOT...
    // act191 = (CAT ADJ T EVAL (PROGN (MARK-DICT LEX 'ROOT ROOT T T) (MARK-...
    // act192 = (CAT N T EVAL '-S)
    ":d-block", false, true, false),
  r("o i d # -> 19,68,193,191,192",
  // d-block-9, conditional phase-one
    // act19 = (KILL 3)
    // act68 = (ADD E)
    // act193 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-ROOT...
    // act191 = (CAT ADJ T EVAL (PROGN (MARK-DICT LEX 'ROOT ROOT T T) (MARK-...
    // act192 = (CAT N T EVAL '-S)
    ":d-block", false, true, false),
  r("o i d # -> 19,194,195,191,192",
  // d-block-10, conditional phase-one
    // act19 = (KILL 3)
    // act194 = (ADD U S)
    // act195 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (POLYSYLLABIC ROOT) (MORPH-...
    // act191 = (CAT ADJ T EVAL (PROGN (MARK-DICT LEX 'ROOT ROOT T T) (MARK-...
    // act192 = (CAT N T EVAL '-S)
    ":d-block", false, true, false),
  r("o i d # -> 19,116,195,191,192",
  // d-block-11, conditional phase-one
    // act19 = (KILL 3)
    // act116 = (ADD U M)
    // act195 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (POLYSYLLABIC ROOT) (MORPH-...
    // act191 = (CAT ADJ T EVAL (PROGN (MARK-DICT LEX 'ROOT ROOT T T) (MARK-...
    // act192 = (CAT N T EVAL '-S)
    ":d-block", false, true, false),
  r("o i d # -> 19,117,195,191,192",
  // d-block-12, conditional phase-one
    // act19 = (KILL 3)
    // act117 = (ADD A)
    // act195 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (POLYSYLLABIC ROOT) (MORPH-...
    // act191 = (CAT ADJ T EVAL (PROGN (MARK-DICT LEX 'ROOT ROOT T T) (MARK-...
    // act192 = (CAT N T EVAL '-S)
    ":d-block", false, true, false),
  r("o i d # -> 50,137,191,192",
  // d-block-13, conditional phase-one
    // act50 = (KILL 2)
    // act137 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-ROOT...
    // act191 = (CAT ADJ T EVAL (PROGN (MARK-DICT LEX 'ROOT ROOT T T) (MARK-...
    // act192 = (CAT N T EVAL '-S)
    ":d-block", false, true, false),
  r("o i d # -> 50,196,197,192",
  // d-block-14, conditional phase-one
    // act50 = (KILL 2)
    // act196 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-ROOT...
    // act197 = (CAT ADJ T EVAL (PROGN (MARK-DICT LEX 'FALSE-ROOT ROOT T T) ...
    // act192 = (CAT N T EVAL '-S)
    ":d-block", false, true, false),
  r("consonant i d # -> 50,117,198,199,200,192",
  // d-block-15, conditional phase-one
    // act50 = (KILL 2)
    // act117 = (ADD A)
    // act198 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-ROOT...
    // act199 = (SETQ SUFFIX 'ID)
    // act200 = (CAT ADJ T EVAL (LIST LEX (LIST 'ROOT ROOT) (LIST 'SUFFIX SU...
    // act192 = (CAT N T EVAL '-S)
    ":d-block", false, true, false),
  r("d # -> 24,44,162,181",
  // d-block-16, conditional phase-one
    // act24 = (KILL 1)
    // act44 = (TEST (AND (MORPH-ROOT STATE) (TEST-ICODE ROOT 'V 'S-D)))
    // act162 = (CAT ADJ T EVAL '*)
    // act181 = (CAT V T EVAL (LIST ROOT '(TNS PAST) '(PASTPART)))
    ":d-block", false, true, false),
  r("consonant & e d # -> 19,201,162,181",
  // d-block-17, conditional phase-one
    // act19 = (KILL 3)
    // act201 = (TEST (AND (MORPH-ROOT STATE) (TEST-ICODE ROOT 'V '(S-*ED ES...
    // act162 = (CAT ADJ T EVAL '*)
    // act181 = (CAT V T EVAL (LIST ROOT '(TNS PAST) '(PASTPART)))
    ":d-block", false, true, false),
  r("c k e d # -> 19,202,162,181",
  // d-block-18, conditional phase-one
    // act19 = (KILL 3)
    // act202 = (TEST (AND (MORPH-ROOT STATE) (TEST-ICODE ROOT 'V '(S-ED S-K...
    // act162 = (CAT ADJ T EVAL '*)
    // act181 = (CAT V T EVAL (LIST ROOT '(TNS PAST) '(PASTPART)))
    ":d-block", false, true, false),
  r("c k e d # -> 19,203,162,181",
  // d-block-19, conditional phase-one
    // act19 = (KILL 3)
    // act203 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-ROOT...
    // act162 = (CAT ADJ T EVAL '*)
    // act181 = (CAT V T EVAL (LIST ROOT '(TNS PAST) '(PASTPART)))
    ":d-block", false, true, false),
  r("c k e d # -> 19,171,162,181",
  // d-block-20, phase-one
    // act19 = (KILL 3)
    // act171 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (MORPH-C...
    // act162 = (CAT ADJ T EVAL '*)
    // act181 = (CAT V T EVAL (LIST ROOT '(TNS PAST) '(PASTPART)))
    ":d-block", true, false, false),
  r("consonant i e d # -> 19,31,171,162,181",
  // d-block-21, phase-one
    // act19 = (KILL 3)
    // act31 = (ADD Y)
    // act171 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (MORPH-C...
    // act162 = (CAT ADJ T EVAL '*)
    // act181 = (CAT V T EVAL (LIST ROOT '(TNS PAST) '(PASTPART)))
    ":d-block", true, false, false),
  r("consonant i e d # -> 19,31,204,205",
  // d-block-22, conditional phase-one
    // act19 = (KILL 3)
    // act31 = (ADD Y)
    // act204 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-ROOT...
    // act205 = (CAT ADJ T EVAL (PROGN (MARK-DICT LEX 'KINDOF (MAKE-STRUCTUR...
    ":d-block", false, true, false),
  r("e n e d # -> 50,203,162,206",
  // d-block-23, conditional phase-one
    // act50 = (KILL 2)
    // act203 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-ROOT...
    // act162 = (CAT ADJ T EVAL '*)
    // act206 = (CAT V T EVAL (LIST LEX (LIST 'ROOT ROOT) '(TNS PAST) '(PAST...
    ":d-block", false, true, false),
  r("b r e e d # -> 57,207,208",
  // d-block-24, conditional phase-one
    // act57 = (KILL 5)
    // act207 = (TEST (AND (MORPH-ROOT STATE) (MEMB ROOT *ADJ-PREFIXES*)))
    // act208 = (CAT ADJ T EVAL (PROGN (MARK-DICT LEX 'FALSE-ROOT ROOT T T) ...
    ":d-block", false, true, false),
  r("b r e e d # -> 57,209,210",
  // d-block-25, conditional phase-one
    // act57 = (KILL 5)
    // act209 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-KNOW...
    // act210 = (CAT VTI T EVAL (PROGN (MARK-DICT LEX 'FALSE-ROOT ROOT T T) ...
    ":d-block", false, true, false),
  r("b r e e d # -> 57,211,212",
  // d-block-26, conditional phase-one
    // act57 = (KILL 5)
    // act211 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-KNOW...
    // act212 = (CAT N T EVAL (PROGN (MARK-DICT LEX 'FALSE-ROOT ROOT T T) (M...
    ":d-block", false, true, false),
  r("s e e d # -> 61,207,213",
  // d-block-27, conditional phase-one
    // act61 = (KILL 4)
    // act207 = (TEST (AND (MORPH-ROOT STATE) (MEMB ROOT *ADJ-PREFIXES*)))
    // act213 = (CAT ADJ T EVAL (PROGN (MARK-DICT LEX 'FALSE-ROOT ROOT T T) ...
    ":d-block", false, true, false),
  r("s e e d # -> 61,209,214",
  // d-block-28, conditional phase-one
    // act61 = (KILL 4)
    // act209 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-KNOW...
    // act214 = (CAT VT T EVAL (PROGN (MARK-DICT LEX 'FALSE-ROOT ROOT T T) (...
    ":d-block", false, true, false),
  r("s e e d # -> 61,211,215",
  // d-block-29, conditional phase-one
    // act61 = (KILL 4)
    // act211 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-KNOW...
    // act215 = (CAT N T EVAL (PROGN (MARK-DICT LEX 'FALSE-ROOT ROOT T T) (M...
    ":d-block", false, true, false),
  r("s p e e d # -> 57,207,216",
  // d-block-30, conditional phase-one
    // act57 = (KILL 5)
    // act207 = (TEST (AND (MORPH-ROOT STATE) (MEMB ROOT *ADJ-PREFIXES*)))
    // act216 = (CAT ADJ T EVAL (PROGN (MARK-DICT LEX 'FALSE-ROOT ROOT T T) ...
    ":d-block", false, true, false),
  r("s p e e d # -> 57,209,217",
  // d-block-31, conditional phase-one
    // act57 = (KILL 5)
    // act209 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-KNOW...
    // act217 = (CAT VIT T EVAL (PROGN (MARK-DICT LEX 'FALSE-ROOT ROOT T T) ...
    ":d-block", false, true, false),
  r("s p e e d # -> 57,211,218",
  // d-block-32, conditional phase-one
    // act57 = (KILL 5)
    // act211 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-KNOW...
    // act218 = (CAT N T EVAL (PROGN (MARK-DICT LEX 'FALSE-ROOT ROOT T T) (M...
    ":d-block", false, true, false),
  r("w e e d # -> 61,209,219",
  // d-block-33, conditional phase-one
    // act61 = (KILL 4)
    // act209 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-KNOW...
    // act219 = (CAT VTI T EVAL (PROGN (MARK-DICT LEX 'FALSE-ROOT ROOT T T) ...
    ":d-block", false, true, false),
  r("w e e d # -> 61,211,220",
  // d-block-34, conditional phase-one
    // act61 = (KILL 4)
    // act211 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-KNOW...
    // act220 = (CAT N T EVAL (PROGN (MARK-DICT LEX 'FALSE-ROOT ROOT T T) (M...
    ":d-block", false, true, false),
  r("e d # -> 24,221,162,206",
  // d-block-35, conditional phase-one
    // act24 = (KILL 1)
    // act221 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (NEED-FINAL-E ROOT) (MORPH-...
    // act162 = (CAT ADJ T EVAL '*)
    // act206 = (CAT V T EVAL (LIST LEX (LIST 'ROOT ROOT) '(TNS PAST) '(PAST...
    ":d-block", false, true, false),
  r("e d # -> 50,222,162,206",
  // d-block-36, conditional phase-one
    // act50 = (KILL 2)
    // act222 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-ROOT...
    // act162 = (CAT ADJ T EVAL '*)
    // act206 = (CAT V T EVAL (LIST LEX (LIST 'ROOT ROOT) '(TNS PAST) '(PAST...
    ":d-block", false, true, false),
  r("vowel b|d|g|k|l|m|n|p|r|s|t|z & e d # -> 19,223,162,206",
  // d-block-37, conditional phase-one
    // act19 = (KILL 3)
    // act223 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-ROOT...
    // act162 = (CAT ADJ T EVAL '*)
    // act206 = (CAT V T EVAL (LIST LEX (LIST 'ROOT ROOT) '(TNS PAST) '(PAST...
    ":d-block", false, true, false),
  r("e d # -> 24,223,162,206",
  // d-block-38, conditional phase-one
    // act24 = (KILL 1)
    // act223 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-ROOT...
    // act162 = (CAT ADJ T EVAL '*)
    // act206 = (CAT V T EVAL (LIST LEX (LIST 'ROOT ROOT) '(TNS PAST) '(PAST...
    ":d-block", false, true, false),
  r("' d # -> 50,223,162,206",
  // d-block-39, conditional phase-one
    // act50 = (KILL 2)
    // act223 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-ROOT...
    // act162 = (CAT ADJ T EVAL '*)
    // act206 = (CAT V T EVAL (LIST LEX (LIST 'ROOT ROOT) '(TNS PAST) '(PAST...
    ":d-block", false, true, false),
  r("vowel b|d|g|k|l|m|n|p|r|s|t|z & ' d # -> 19,223,162,206",
  // d-block-40, conditional phase-one
    // act19 = (KILL 3)
    // act223 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-ROOT...
    // act162 = (CAT ADJ T EVAL '*)
    // act206 = (CAT V T EVAL (LIST LEX (LIST 'ROOT ROOT) '(TNS PAST) '(PAST...
    ":d-block", false, true, false),
  r("' d # -> 50,68,221,162,206",
  // d-block-41, conditional phase-one
    // act50 = (KILL 2)
    // act68 = (ADD E)
    // act221 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (NEED-FINAL-E ROOT) (MORPH-...
    // act162 = (CAT ADJ T EVAL '*)
    // act206 = (CAT V T EVAL (LIST LEX (LIST 'ROOT ROOT) '(TNS PAST) '(PAST...
    ":d-block", false, true, false),
  r("e n e d # -> 61,224,225,162,206",
  // d-block-42, conditional phase-one
    // act61 = (KILL 4)
    // act224 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-ROOT...
    // act225 = (ADD E N)
    // act162 = (CAT ADJ T EVAL '*)
    // act206 = (CAT V T EVAL (LIST LEX (LIST 'ROOT ROOT) '(TNS PAST) '(PAST...
    ":d-block", false, true, false),
  r("f o l d # -> 61,226,227,228,229",
  // d-block-43, 
    // act61 = (KILL 4)
    // act226 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (OR (IS-...
    // act227 = (SETQ SUFFIX 'FOLD)
    // act228 = (CAT ADJ T EVAL (LIST LEX (LIST 'SUFFIX SUFFIX) (LIST 'KINDO...
    // act229 = (CAT ADV T EVAL (LIST LEX (LIST 'SUFFIX SUFFIX) (LIST 'KINDO...
    ":d-block"),
  r("b r e d # -> 61,35,230",
  // d-block-44, conditional phase-one
    // act61 = (KILL 4)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act230 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(N AD...
    ":d-block", false, true, false),
  r("consonant i e d # -> 19,31,231,232",
  // d-block-45, 
    // act19 = (KILL 3)
    // act31 = (ADD Y)
    // act231 = (TEST (AND (MORPH-ROOT STATE) (IS-ADV+PASTPART ROOT NIL 'IED...
    // act232 = (CAT ADJ T EVAL (COMPOUND-WITH-SUFFIX LEX 'ADJ ROOT 0 'IED '...
    ":d-block"),
  r("e d # -> 24,233,234",
  // d-block-46, 
    // act24 = (KILL 1)
    // act233 = (TEST (AND (MORPH-ROOT STATE) (IS-ADV+PASTPART ROOT NIL 'D))...
    // act234 = (CAT ADJ T EVAL (COMPOUND-WITH-SUFFIX LEX 'ADJ ROOT 0 'D 'MO...
    ":d-block"),
  r("e d # -> 50,235,236",
  // d-block-47, 
    // act50 = (KILL 2)
    // act235 = (TEST (AND (MORPH-ROOT STATE) (IS-ADV+PASTPART ROOT NIL 'ED)...
    // act236 = (CAT ADJ T EVAL (COMPOUND-WITH-SUFFIX LEX 'ADJ ROOT 0 'ED 'M...
    ":d-block"),
  r("consonant vowel b|d|g|k|l|m|n|p|r|s|t|z & e d # -> 19,237,238",
  // d-block-48, 
    // act19 = (KILL 3)
    // act237 = (TEST (AND (MORPH-ROOT STATE) (IS-ADV+PASTPART ROOT T 'ED)))
    // act238 = (CAT ADJ T EVAL (COMPOUND-WITH-SUFFIX LEX 'ADJ ROOT -1 'ED '...
    ":d-block"),
  r("consonant i e d # -> 19,31,239,240",
  // d-block-49, 
    // act19 = (KILL 3)
    // act31 = (ADD Y)
    // act239 = (TEST (AND (MORPH-ROOT STATE) (IS-N+PASTPART ROOT NIL 'D)))
    // act240 = (CAT ADJ T EVAL (COMPOUND-WITH-SUFFIX LEX 'ADJ ROOT 0 'D 'BY...
    ":d-block"),
  r("e d # -> 24,239,240",
  // d-block-50, 
    // act24 = (KILL 1)
    // act239 = (TEST (AND (MORPH-ROOT STATE) (IS-N+PASTPART ROOT NIL 'D)))
    // act240 = (CAT ADJ T EVAL (COMPOUND-WITH-SUFFIX LEX 'ADJ ROOT 0 'D 'BY...
    ":d-block"),
  r("e d # -> 50,241,242",
  // d-block-51, 
    // act50 = (KILL 2)
    // act241 = (TEST (AND (MORPH-ROOT STATE) (IS-N+PASTPART ROOT NIL 'ED)))
    // act242 = (CAT ADJ T EVAL (COMPOUND-WITH-SUFFIX LEX 'ADJ ROOT 0 'ED 'B...
    ":d-block"),
  r("consonant vowel b|d|g|k|l|m|n|p|r|s|t|z & e d # -> 19,243,244",
  // d-block-52, 
    // act19 = (KILL 3)
    // act243 = (TEST (AND (MORPH-ROOT STATE) (IS-N+PASTPART ROOT T 'ED)))
    // act244 = (CAT ADJ T EVAL (COMPOUND-WITH-SUFFIX LEX 'ADJ ROOT -1 'ED '...
    ":d-block"),
  r("consonant i e d # -> 19,31,245,246",
  // d-block-53, 
    // act19 = (KILL 3)
    // act31 = (ADD Y)
    // act245 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-COMP...
    // act246 = (CAT ADJ T EVAL (PROGN (MARK-DICT LEX 'FALSE-ROOT ROOT T T) ...
    ":d-block"),
  r("e d # -> 50,247,246",
  // d-block-54, 
    // act50 = (KILL 2)
    // act247 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (PA...
    // act246 = (CAT ADJ T EVAL (PROGN (MARK-DICT LEX 'FALSE-ROOT ROOT T T) ...
    ":d-block"),
  r("consonant vowel b|d|g|k|l|m|n|p|r|s|t|z & e d # -> 19,245,246",
  // d-block-55, 
    // act19 = (KILL 3)
    // act245 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-COMP...
    // act246 = (CAT ADJ T EVAL (PROGN (MARK-DICT LEX 'FALSE-ROOT ROOT T T) ...
    ":d-block"),
  r("e d # -> 24,245,246",
  // d-block-56, 
    // act24 = (KILL 1)
    // act245 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-COMP...
    // act246 = (CAT ADJ T EVAL (PROGN (MARK-DICT LEX 'FALSE-ROOT ROOT T T) ...
    ":d-block"),
  r("consonant i e d # -> 19,31,248,249",
  // d-block-57, 
    // act19 = (KILL 3)
    // act31 = (ADD Y)
    // act248 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-ROOT...
    // act249 = (CAT ADJ T EVAL (PROGN (MARK-DICT LEX 'FALSE-ROOT ROOT T T) ...
    ":d-block"),
  r("e d # -> 50,250,249",
  // d-block-58, 
    // act50 = (KILL 2)
    // act250 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (PA...
    // act249 = (CAT ADJ T EVAL (PROGN (MARK-DICT LEX 'FALSE-ROOT ROOT T T) ...
    ":d-block"),
  r("consonant vowel b|d|g|k|l|m|n|p|r|s|t|z & e d # -> 19,248,249",
  // d-block-59, 
    // act19 = (KILL 3)
    // act248 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-ROOT...
    // act249 = (CAT ADJ T EVAL (PROGN (MARK-DICT LEX 'FALSE-ROOT ROOT T T) ...
    ":d-block"),
  r("e d # -> 24,248,251",
  // d-block-60, 
    // act24 = (KILL 1)
    // act248 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-ROOT...
    // act251 = (CAT ADJ T EVAL (PROGN (MARK-DICT LEX 'FALSE-ROOT ROOT T T) ...
    ":d-block"),
  r("consonant i e d # -> 19,31,252,253",
  // d-block-61, conditional phase-one
    // act19 = (KILL 3)
    // act31 = (ADD Y)
    // act252 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-KNOW...
    // act253 = (CAT ADJ T EVAL (PROGN (MARK-DICT LEX 'KINDOF (MAKE-STRUCTUR...
    ":d-block", false, true, false),
  r("e d # -> 50,254,253",
  // d-block-62, conditional phase-one
    // act50 = (KILL 2)
    // act254 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (PA...
    // act253 = (CAT ADJ T EVAL (PROGN (MARK-DICT LEX 'KINDOF (MAKE-STRUCTUR...
    ":d-block", false, true, false),
  r("consonant vowel b|d|g|k|l|m|n|p|r|s|t|z & e d # -> 19,252,253",
  // d-block-63, conditional phase-one
    // act19 = (KILL 3)
    // act252 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-KNOW...
    // act253 = (CAT ADJ T EVAL (PROGN (MARK-DICT LEX 'KINDOF (MAKE-STRUCTUR...
    ":d-block", false, true, false),
  r("e d # -> 24,252,253",
  // d-block-64, conditional phase-one
    // act24 = (KILL 1)
    // act252 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-KNOW...
    // act253 = (CAT ADJ T EVAL (PROGN (MARK-DICT LEX 'KINDOF (MAKE-STRUCTUR...
    ":d-block", false, true, false),
  r("consonant r e d # -> 19,72,252,253",
  // d-block-65, conditional phase-one
    // act19 = (KILL 3)
    // act72 = (ADD E R)
    // act252 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-KNOW...
    // act253 = (CAT ADJ T EVAL (PROGN (MARK-DICT LEX 'KINDOF (MAKE-STRUCTUR...
    ":d-block", false, true, false),
  r("consonant i e d # -> 19,31,255,253",
  // d-block-66, 
    // act19 = (KILL 3)
    // act31 = (ADD Y)
    // act255 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-ROOT...
    // act253 = (CAT ADJ T EVAL (PROGN (MARK-DICT LEX 'KINDOF (MAKE-STRUCTUR...
    ":d-block"),
  r("e d # -> 50,256,253",
  // d-block-67, 
    // act50 = (KILL 2)
    // act256 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (PA...
    // act253 = (CAT ADJ T EVAL (PROGN (MARK-DICT LEX 'KINDOF (MAKE-STRUCTUR...
    ":d-block"),
  r("consonant vowel b|d|g|k|l|m|n|p|r|s|t|z & e d # -> 19,255,253",
  // d-block-68, 
    // act19 = (KILL 3)
    // act255 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-ROOT...
    // act253 = (CAT ADJ T EVAL (PROGN (MARK-DICT LEX 'KINDOF (MAKE-STRUCTUR...
    ":d-block"),
  r("e d # -> 24,255,253",
  // d-block-69, 
    // act24 = (KILL 1)
    // act255 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-ROOT...
    // act253 = (CAT ADJ T EVAL (PROGN (MARK-DICT LEX 'KINDOF (MAKE-STRUCTUR...
    ":d-block"),
  r("consonant r e d # -> 19,72,255,253",
  // d-block-70, 
    // act19 = (KILL 3)
    // act72 = (ADD E R)
    // act255 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-ROOT...
    // act253 = (CAT ADJ T EVAL (PROGN (MARK-DICT LEX 'KINDOF (MAKE-STRUCTUR...
    ":d-block"),
  r("consonant i e d # -> 19,31,257,162,181",
  // d-block-71, 
    // act19 = (KILL 3)
    // act31 = (ADD Y)
    // act257 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (MAY-BE-...
    // act162 = (CAT ADJ T EVAL '*)
    // act181 = (CAT V T EVAL (LIST ROOT '(TNS PAST) '(PASTPART)))
    ":d-block"),
  r("r e e d # -> 24,258,162,181",
  // d-block-72, 
    // act24 = (KILL 1)
    // act258 = (TEST (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT '(N V))))
    // act162 = (CAT ADJ T EVAL '*)
    // act181 = (CAT V T EVAL (LIST ROOT '(TNS PAST) '(PASTPART)))
    ":d-block"),
  r("e e d # -> 35,259,260,261",
  // d-block-73, 
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act259 = (CAT N T EVAL (PROGN (MARK-DICT LEX 'GUESSED 'T) '-S))
    // act260 = (CAT ADJ *GUESS-VERB-FLAG* EVAL '*)
    // act261 = (CAT V *GUESS-VERB-FLAG* EVAL (PROGN (MARK-DICT LEX 'PENALTI...
    ":d-block"),
  r("w a r d # -> 61,262,263,140,139",
  // d-block-74, conditional phase-one
    // act61 = (KILL 4)
    // act262 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-ROOT...
    // act263 = (SETQ SUFFIX 'WARD)
    // act140 = (CAT ADJ T EVAL (CONS LEX (LIST (LIST 'ROOT ROOT) (LIST 'SUF...
    // act139 = (CAT ADV T EVAL (CONS LEX (LIST (LIST 'ROOT ROOT) (LIST 'SUF...
    ":d-block", false, true, false),
  r("f o r d # -> 35,264,154",
  // d-block-75, 
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act264 = (CAT CITY T EVAL '*)
    // act154 = (CAT LASTNAME T EVAL '*)
    ":d-block"),
  r("consonant vowel l|s|z & e d # -> 50,258,162,181",
  // d-block-76, 
    // act50 = (KILL 2)
    // act258 = (TEST (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT '(N V))))
    // act162 = (CAT ADJ T EVAL '*)
    // act181 = (CAT V T EVAL (LIST ROOT '(TNS PAST) '(PASTPART)))
    ":d-block"),
  r("consonant vowel b|d|g|k|l|m|n|p|r|t & e d # -> 19,258,162,181",
  // d-block-77, 
    // act19 = (KILL 3)
    // act258 = (TEST (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT '(N V))))
    // act162 = (CAT ADJ T EVAL '*)
    // act181 = (CAT V T EVAL (LIST ROOT '(TNS PAST) '(PASTPART)))
    ":d-block"),
  r("q u vowel b|d|g|k|l|m|n|p|r|t & e d # -> 19,258,162,181",
  // d-block-78, 
    // act19 = (KILL 3)
    // act258 = (TEST (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT '(N V))))
    // act162 = (CAT ADJ T EVAL '*)
    // act181 = (CAT V T EVAL (LIST ROOT '(TNS PAST) '(PASTPART)))
    ":d-block"),
  r("e d # -> 24,265,162,181",
  // d-block-79, 
    // act24 = (KILL 1)
    // act265 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (NEED-FINAL-E ROOT) (MORPH-...
    // act162 = (CAT ADJ T EVAL '*)
    // act181 = (CAT V T EVAL (LIST ROOT '(TNS PAST) '(PASTPART)))
    ":d-block"),
  r("consonant r e d # -> 19,72,257,162,181",
  // d-block-80, 
    // act19 = (KILL 3)
    // act72 = (ADD E R)
    // act257 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (MAY-BE-...
    // act162 = (CAT ADJ T EVAL '*)
    // act181 = (CAT V T EVAL (LIST ROOT '(TNS PAST) '(PASTPART)))
    ":d-block"),
  r("e y e d # -> 50,266,162,181",
  // d-block-81, conditional phase-one
    // act50 = (KILL 2)
    // act266 = (TEST (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(N V))))
    // act162 = (CAT ADJ T EVAL '*)
    // act181 = (CAT V T EVAL (LIST ROOT '(TNS PAST) '(PASTPART)))
    ":d-block", false, true, false),
  r("e y e d # -> 61,267,268",
  // d-block-82, 
    // act61 = (KILL 4)
    // act267 = (CAT ADJ T EVAL (PROGN (MARK-DICT LEX 'FALSE-ROOT ROOT T T) ...
    // act268 = (CAT V T EVAL (LIST (BUTLAST-CHAR LEX) '(TNS PAST) '(PASTPAR...
    ":d-block"),
  r("y e d # -> 50,162,181",
  // d-block-83, 
    // act50 = (KILL 2)
    // act162 = (CAT ADJ T EVAL '*)
    // act181 = (CAT V T EVAL (LIST ROOT '(TNS PAST) '(PASTPART)))
    ":d-block"),
  r("e d # -> 24,174,162,181",
  // d-block-84, 
    // act24 = (KILL 1)
    // act174 = (TEST (AND (NEED-FINAL-E ROOT) (PLAUSIBLE-ROOT ROOT)))
    // act162 = (CAT ADJ T EVAL '*)
    // act181 = (CAT V T EVAL (LIST ROOT '(TNS PAST) '(PASTPART)))
    ":d-block"),
  r("consonant vowel b|c|d|f|g|k|l|m|n|p|q|r|t|v|w|y e d # -> 24,35,162,181",
  // d-block-85, 
    // act24 = (KILL 1)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act162 = (CAT ADJ T EVAL '*)
    // act181 = (CAT V T EVAL (LIST ROOT '(TNS PAST) '(PASTPART)))
    ":d-block"),
  r("vowel c|g e d # -> 24,35,162,181",
  // d-block-86, 
    // act24 = (KILL 1)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act162 = (CAT ADJ T EVAL '*)
    // act181 = (CAT V T EVAL (LIST ROOT '(TNS PAST) '(PASTPART)))
    ":d-block"),
  r("l|n|r c|g e d # -> 24,35,162,181",
  // d-block-87, 
    // act24 = (KILL 1)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act162 = (CAT ADJ T EVAL '*)
    // act181 = (CAT V T EVAL (LIST ROOT '(TNS PAST) '(PASTPART)))
    ":d-block"),
  r("e d # -> 50,269,162,181",
  // d-block-88, 
    // act50 = (KILL 2)
    // act269 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (NE...
    // act162 = (CAT ADJ T EVAL '*)
    // act181 = (CAT V T EVAL (LIST ROOT '(TNS PAST) '(PASTPART)))
    ":d-block"),
  r("o i d # -> 164,270",
  // d-block-89, 
    // act164 = (CAT ADJ (POLYSYLLABIC ROOT) EVAL '*)
    // act270 = (CAT N (POLYSYLLABIC ROOT) EVAL '-S)
    ":d-block"),
  r("o o d # -> 271",
  // d-block-90, 
    // act271 = (CAT N (POLYSYLLABIC ROOT) EVAL (PROGN (MARK-DICT LEX 'GUESS...
    ":d-block"),
  r("p o d # -> 271",
  // d-block-91, 
    // act271 = (CAT N (POLYSYLLABIC ROOT) EVAL (PROGN (MARK-DICT LEX 'GUESS...
    ":d-block"),
  r(" -> 180,158",
  // d-block-92, 
    // act180 = (TEST T)
    // act158 = (DO DEFAULT-RULE)
    ":d-block"),
 };

 protected static MorphRule[] eBlock = {//":e-block"
  r("a e # -> 24,272,56",
  // e-block-1, conditional phase-one
    // act24 = (KILL 1)
    // act272 = (TEST (AND (MORPH-ROOT STATE) (TEST-ICODE ROOT 'N '-AE)))
    // act56 = (CAT N T EVAL (LIST ROOT '(NUMBER PL)))
    ":e-block", false, true, false),
  r("consonant i w i s e # -> 57,31,137,273,200,274",
  // e-block-2, conditional phase-one
    // act57 = (KILL 5)
    // act31 = (ADD Y)
    // act137 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-ROOT...
    // act273 = (SETQ SUFFIX 'WISE)
    // act200 = (CAT ADJ T EVAL (LIST LEX (LIST 'ROOT ROOT) (LIST 'SUFFIX SU...
    // act274 = (CAT ADV T EVAL (LIST LEX (LIST 'ROOT ROOT) (LIST 'SUFFIX SU...
    ":e-block", false, true, false),
  r("w i s e # -> 61,137,273,200,274",
  // e-block-3, conditional phase-one
    // act61 = (KILL 4)
    // act137 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-ROOT...
    // act273 = (SETQ SUFFIX 'WISE)
    // act200 = (CAT ADJ T EVAL (LIST LEX (LIST 'ROOT ROOT) (LIST 'SUFFIX SU...
    // act274 = (CAT ADV T EVAL (LIST LEX (LIST 'ROOT ROOT) (LIST 'SUFFIX SU...
    ":e-block", false, true, false),
  r("e s e # -> 19,275,162,276,277",
  // e-block-4, conditional phase-one
    // act19 = (KILL 3)
    // act275 = (TEST (AND (POLYSYLLABIC ROOT) (MORPH-ROOT STATE) (IS-FORM-O...
    // act162 = (CAT ADJ T EVAL '*)
    // act276 = (CAT NMSP T EVAL (PROGN (MARK-DICT LEX 'INSTANCEOF (MORPH-PA...
    // act277 = (CAT NPR T EVAL '*)
    ":e-block", false, true, false),
  r("e s e # -> 19,117,275,162,276,277",
  // e-block-5, conditional phase-one
    // act19 = (KILL 3)
    // act117 = (ADD A)
    // act275 = (TEST (AND (POLYSYLLABIC ROOT) (MORPH-ROOT STATE) (IS-FORM-O...
    // act162 = (CAT ADJ T EVAL '*)
    // act276 = (CAT NMSP T EVAL (PROGN (MARK-DICT LEX 'INSTANCEOF (MORPH-PA...
    // act277 = (CAT NPR T EVAL '*)
    ":e-block", false, true, false),
  r("e s e # -> 19,278,279",
  // e-block-6, conditional phase-one
    // act19 = (KILL 3)
    // act278 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-FORM...
    // act279 = (CAT NM T EVAL (PROGN (MARK-DICT LEX 'INSTANCEOF (MORPH-PACK...
    ":e-block", false, true, false),
  r("consonant vowel consonant & i|y s|z e # -> 61,35,280",
  // e-block-7, conditional phase-one
    // act61 = (KILL 4)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act280 = (CAT V (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(ADJ N)...
    ":e-block", false, true, false),
  r("a t i|y s|z e # -> 57,35,280",
  // e-block-8, conditional phase-one
    // act57 = (KILL 5)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act280 = (CAT V (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(ADJ N)...
    ":e-block", false, true, false),
  r("a|o t i|y s|z e # -> 61,35,281",
  // e-block-9, conditional phase-one
    // act61 = (KILL 4)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act281 = (CAT V (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(N ADJ ...
    ":e-block", false, true, false),
  r("i|y s|z e # -> 19,35,280",
  // e-block-10, conditional phase-one
    // act19 = (KILL 3)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act280 = (CAT V (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(ADJ N)...
    ":e-block", false, true, false),
  r("s i t i s|z e # -> 19,282,283,280",
  // e-block-11, conditional phase-one
    // act19 = (KILL 3)
    // act282 = (ADD I V E)
    // act283 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (> (NCHARS ROOT) 6)))
    // act280 = (CAT V (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(ADJ N)...
    ":e-block", false, true, false),
  r("i|y s|z e # -> 19,68,35,280",
  // e-block-12, conditional phase-one
    // act19 = (KILL 3)
    // act68 = (ADD E)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act280 = (CAT V (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(ADJ N)...
    ":e-block", false, true, false),
  r("consonant i|y s|z e # -> 19,31,131,284",
  // e-block-13, conditional phase-one
    // act19 = (KILL 3)
    // act31 = (ADD Y)
    // act131 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (POLYSYLLABIC ROOT)))
    // act284 = (CAT V (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(NN ADJ...
    ":e-block", false, true, false),
  r("i|y s|z e # -> 19,285,131,286",
  // e-block-14, conditional phase-one
    // act19 = (KILL 3)
    // act285 = (ADD I N)
    // act131 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (POLYSYLLABIC ROOT)))
    // act286 = (CAT V (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(NN ADJ...
    ":e-block", false, true, false),
  r("i|y s|z e # -> 19,54,131,286",
  // e-block-15, conditional phase-one
    // act19 = (KILL 3)
    // act54 = (ADD I S)
    // act131 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (POLYSYLLABIC ROOT)))
    // act286 = (CAT V (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(NN ADJ...
    ":e-block", false, true, false),
  r("i|y s|z e # -> 19,35,287,288",
  // e-block-16, conditional phase-one
    // act19 = (KILL 3)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act287 = (ADD I S M)
    // act288 = (CAT V (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'NN)) EV...
    ":e-block", false, true, false),
  r("i|y s|z e # -> 19,35,118,289",
  // e-block-17, conditional phase-one
    // act19 = (KILL 3)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act118 = (ADD I C)
    // act289 = (CAT V (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(ADJ NN...
    ":e-block", false, true, false),
  r("i|y s|z e # -> 19,35,116,289",
  // e-block-18, conditional phase-one
    // act19 = (KILL 3)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act116 = (ADD U M)
    // act289 = (CAT V (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(ADJ NN...
    ":e-block", false, true, false),
  r("i|y s|z e # -> 19,35,132,289",
  // e-block-19, conditional phase-one
    // act19 = (KILL 3)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act132 = (ADD O N)
    // act289 = (CAT V (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(ADJ NN...
    ":e-block", false, true, false),
  r("i|y s|z e # -> 19,35,290,289",
  // e-block-20, conditional phase-one
    // act19 = (KILL 3)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act290 = (ADD I)
    // act289 = (CAT V (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(ADJ NN...
    ":e-block", false, true, false),
  r("i|y s|z e # -> 19,35,291,289",
  // e-block-21, conditional phase-one
    // act19 = (KILL 3)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act291 = (ADD I A)
    // act289 = (CAT V (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(ADJ NN...
    ":e-block", false, true, false),
  r("i|y s|z e # -> 19,35,117,289",
  // e-block-22, conditional phase-one
    // act19 = (KILL 3)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act117 = (ADD A)
    // act289 = (CAT V (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(ADJ NN...
    ":e-block", false, true, false),
  r("l i|y s|z e # -> 50,35,292,293",
  // e-block-23, conditional phase-one
    // act50 = (KILL 2)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act292 = (ADD S I S)
    // act293 = (CAT V (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(ADJ NN...
    ":e-block", false, true, false),
  r("i s|z e # -> 19,35,108,293",
  // e-block-24, conditional phase-one
    // act19 = (KILL 3)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act108 = (ADD I T Y)
    // act293 = (CAT V (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(ADJ NN...
    ":e-block", false, true, false),
  r("consonant i n i|y s|z e # -> 57,35,68,289",
  // e-block-25, conditional phase-one
    // act57 = (KILL 5)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act68 = (ADD E)
    // act289 = (CAT V (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(ADJ NN...
    ":e-block", false, true, false),
  r("consonant i|y s|z e # -> 19,35,68,289",
  // e-block-26, conditional phase-one
    // act19 = (KILL 3)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act68 = (ADD E)
    // act289 = (CAT V (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(ADJ NN...
    ":e-block", false, true, false),
  r("a s e # -> 19,294,295,296",
  // e-block-27, conditional phase-one
    // act19 = (KILL 3)
    // act294 = (ADD Y Z E)
    // act295 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (POLYSYLLABIC ROOT) (MORPH-...
    // act296 = (CAT N T EVAL (PROGN (MARK-DICT LEX 'FALSE-ROOT ROOT T T) (M...
    ":e-block", false, true, false),
  r("a s e # -> 19,297,295,296",
  // e-block-28, conditional phase-one
    // act19 = (KILL 3)
    // act297 = (ADD I Z E)
    // act295 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (POLYSYLLABIC ROOT) (MORPH-...
    // act296 = (CAT N T EVAL (PROGN (MARK-DICT LEX 'FALSE-ROOT ROOT T T) (M...
    ":e-block", false, true, false),
  r("a s e # -> 19,298,296",
  // e-block-29, conditional phase-one
    // act19 = (KILL 3)
    // act298 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (POLYSYLLABIC ROOT) (MORPH-...
    // act296 = (CAT N T EVAL (PROGN (MARK-DICT LEX 'FALSE-ROOT ROOT T T) (M...
    ":e-block", false, true, false),
  r("s i d e # -> 61,299,300,301,302",
  // e-block-30, conditional phase-one
    // act61 = (KILL 4)
    // act299 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-ROOT...
    // act300 = (CAT ADJ T EVAL (LIST LEX (LIST 'ROOT ROOT) (LIST 'SUFFIX 'S...
    // act301 = (CAT ADV T EVAL '*)
    // act302 = (CAT N T EVAL (LIST LEX '(NUMBER SG) '(ROOT SIDE) (LIST 'PRE...
    ":e-block", false, true, false),
  r("w i d e # -> 61,299,303,304",
  // e-block-31, conditional phase-one
    // act61 = (KILL 4)
    // act299 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-ROOT...
    // act303 = (CAT ADJ T EVAL (LIST LEX (LIST 'ROOT ROOT) (LIST 'SUFFIX 'W...
    // act304 = (CAT ADV T EVAL (LIST LEX (LIST 'ROOT ROOT) (LIST 'SUFFIX 'W...
    ":e-block", false, true, false),
  r("s i z e # -> 61,35,305",
  // e-block-32, 
    // act61 = (KILL 4)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act305 = (CAT N T EVAL (LIST LEX (LIST 'PREFIX ROOT) '(KINDOF SIZE)))
    ":e-block"),
  r("consonant i w i s e # -> 57,31,35,273,200,274",
  // e-block-33, 
    // act57 = (KILL 5)
    // act31 = (ADD Y)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act273 = (SETQ SUFFIX 'WISE)
    // act200 = (CAT ADJ T EVAL (LIST LEX (LIST 'ROOT ROOT) (LIST 'SUFFIX SU...
    // act274 = (CAT ADV T EVAL (LIST LEX (LIST 'ROOT ROOT) (LIST 'SUFFIX SU...
    ":e-block"),
  r("w i s e # -> 61,35,273,200,274",
  // e-block-34, 
    // act61 = (KILL 4)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act273 = (SETQ SUFFIX 'WISE)
    // act200 = (CAT ADJ T EVAL (LIST LEX (LIST 'ROOT ROOT) (LIST 'SUFFIX SU...
    // act274 = (CAT ADV T EVAL (LIST LEX (LIST 'ROOT ROOT) (LIST 'SUFFIX SU...
    ":e-block"),
  r("i|y s|z e # -> 19,35,306",
  // e-block-35, 
    // act19 = (KILL 3)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act306 = (CAT V T EVAL (PROGN (WHEN (OR (PATTERN-CHECK LEX '(S E)) (P...
    ":e-block"),
  r("e s q u e # -> 57,307,204,200,61,204,200",
  // e-block-36, conditional phase-one
    // act57 = (KILL 5)
    // act307 = (SETQ SUFFIX 'ESQUE)
    // act204 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-ROOT...
    // act200 = (CAT ADJ T EVAL (LIST LEX (LIST 'ROOT ROOT) (LIST 'SUFFIX SU...
    // act61 = (KILL 4)
    // act204 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-ROOT...
    // act200 = (CAT ADJ T EVAL (LIST LEX (LIST 'ROOT ROOT) (LIST 'SUFFIX SU...
    ":e-block", false, true, true),
  r("o s o m e # -> 61,35,308",
  // e-block-37, conditional phase-one
    // act61 = (KILL 4)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act308 = (CAT N (AND (MORPH-ROOT STATE) (IS-FORM-OF-CAT ROOT 'PREFIX)...
    ":e-block", false, true, false),
  r("s o m e # -> 61,35,309,310",
  // e-block-38, conditional phase-one
    // act61 = (KILL 4)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act309 = (SETQ SUFFIX 'SOME)
    // act310 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'DIGITS)...
    ":e-block", false, true, false),
  r("s o m e # -> 61,35,309,311",
  // e-block-39, conditional phase-one
    // act61 = (KILL 4)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act309 = (SETQ SUFFIX 'SOME)
    // act311 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(N V ...
    ":e-block", false, true, false),
  r("a t i v e # -> 19,68,35,312,311",
  // e-block-40, conditional phase-one
    // act19 = (KILL 3)
    // act68 = (ADD E)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act312 = (SETQ SUFFIX 'IVE)
    // act311 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(N V ...
    ":e-block", false, true, false),
  r("a t i v e # -> 57,35,313,311,68,311",
  // e-block-41, conditional phase-one
    // act57 = (KILL 5)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act313 = (SETQ SUFFIX 'ATIVE)
    // act311 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(N V ...
    // act68 = (ADD E)
    // act311 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(N V ...
    ":e-block", false, true, true),
  r("c e p t i v e # -> 102,314,131,315,311",
  // e-block-42, conditional phase-one
    // act102 = (KILL 6)
    // act314 = (ADD E I V E)
    // act131 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (POLYSYLLABIC ROOT)))
    // act315 = (SETQ SUFFIX 'TIVE)
    // act311 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(N V ...
    ":e-block", false, true, false),
  r("p t i v e # -> 57,316,131,315,311",
  // e-block-43, conditional phase-one
    // act57 = (KILL 5)
    // act316 = (ADD B)
    // act131 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (POLYSYLLABIC ROOT)))
    // act315 = (SETQ SUFFIX 'TIVE)
    // act311 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(N V ...
    ":e-block", false, true, false),
  r("p t i v e # -> 57,317,131,315,311",
  // e-block-44, conditional phase-one
    // act57 = (KILL 5)
    // act317 = (ADD B E)
    // act131 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (POLYSYLLABIC ROOT)))
    // act315 = (SETQ SUFFIX 'TIVE)
    // act311 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(N V ...
    ":e-block", false, true, false),
  r("vowel s i v e # -> 61,318,131,312,311",
  // e-block-45, conditional phase-one
    // act61 = (KILL 4)
    // act318 = (ADD D E)
    // act131 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (POLYSYLLABIC ROOT)))
    // act312 = (SETQ SUFFIX 'IVE)
    // act311 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(N V ...
    ":e-block", false, true, false),
  r("d r i v e # -> 57,319,320,321",
  // e-block-46, conditional phase-one
    // act57 = (KILL 5)
    // act319 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-FORM...
    // act320 = (CAT VTI T EVAL (PROGN (MARK-DICT LEX 'PASTPART (MORPH-PACK-...
    // act321 = (CAT NMC T EVAL (PROGN (MARK-DICT LEX 'FALSE-ROOT ROOT T T) ...
    ":e-block", false, true, false),
  r("d r i v e # -> 57,322,323",
  // e-block-47, conditional phase-one
    // act57 = (KILL 5)
    // act322 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-FORM...
    // act323 = (CAT NM T EVAL (PROGN (MARK-DICT LEX 'FALSE-ROOT ROOT T T) (...
    ":e-block", false, true, false),
  r("d r i v e # -> 57,35,320,324",
  // e-block-48, 
    // act57 = (KILL 5)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act320 = (CAT VTI T EVAL (PROGN (MARK-DICT LEX 'PASTPART (MORPH-PACK-...
    // act324 = (CAT NM T EVAL (PROGN (MARK-DICT LEX 'FALSE-ROOT ROOT T T) (...
    ":e-block"),
  r("i v e # -> 19,68,325,312,311",
  // e-block-49, conditional phase-one
    // act19 = (KILL 3)
    // act68 = (ADD E)
    // act325 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (POLYSYLLABIC ROOT) (NEED-F...
    // act312 = (SETQ SUFFIX 'IVE)
    // act311 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(N V ...
    ":e-block", false, true, false),
  r("i v e # -> 19,131,312,311",
  // e-block-50, conditional phase-one
    // act19 = (KILL 3)
    // act131 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (POLYSYLLABIC ROOT)))
    // act312 = (SETQ SUFFIX 'IVE)
    // act311 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(N V ...
    ":e-block", false, true, false),
  r("i v e # -> 19,68,131,312,311",
  // e-block-51, conditional phase-one
    // act19 = (KILL 3)
    // act68 = (ADD E)
    // act131 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (POLYSYLLABIC ROOT)))
    // act312 = (SETQ SUFFIX 'IVE)
    // act311 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(N V ...
    ":e-block", false, true, false),
  r("i v e # -> 326,327,328,329,330",
  // e-block-52, phase-one
    // act326 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (MORPH-P...
    // act327 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-KNOWN-FORM-OF-CAT ROOT ...
    // act328 = (CAT ADV (AND (MORPH-ROOT STATE) (IS-KNOWN-FORM-OF-CAT ROOT ...
    // act329 = (CAT N (AND (MORPH-ROOT STATE) (IS-KNOWN-FORM-OF-CAT ROOT 'N...
    // act330 = (CAT V (AND (MORPH-ROOT STATE) (IS-KNOWN-FORM-OF-CAT ROOT 'V...
    ":e-block", true, false, false),
  r("s|t i v e # -> 19,331,131,312,311",
  // e-block-53, conditional phase-one
    // act19 = (KILL 3)
    // act331 = (ADD I O N)
    // act131 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (POLYSYLLABIC ROOT)))
    // act312 = (SETQ SUFFIX 'IVE)
    // act311 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(N V ...
    ":e-block", false, true, false),
  r("i v e # -> 19,332,131,312,311",
  // e-block-54, conditional phase-one
    // act19 = (KILL 3)
    // act332 = (ADD A N C E)
    // act131 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (POLYSYLLABIC ROOT)))
    // act312 = (SETQ SUFFIX 'IVE)
    // act311 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(N V ...
    ":e-block", false, true, false),
  r("i v e # -> 19,31,131,312,311",
  // e-block-55, conditional phase-one
    // act19 = (KILL 3)
    // act31 = (ADD Y)
    // act131 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (POLYSYLLABIC ROOT)))
    // act312 = (SETQ SUFFIX 'IVE)
    // act311 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(N V ...
    ":e-block", false, true, false),
  r("i v e # -> 19,69,131,312,311",
  // e-block-56, conditional phase-one
    // act19 = (KILL 3)
    // act69 = (ADD O R)
    // act131 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (POLYSYLLABIC ROOT)))
    // act312 = (SETQ SUFFIX 'IVE)
    // act311 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(N V ...
    ":e-block", false, true, false),
  r("consonant vowel consonant & u l e # -> 61,35,333,334",
  // e-block-57, conditional phase-one
    // act61 = (KILL 4)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act333 = (SETQ SUFFIX 'ULE)
    // act334 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'N)) EVA...
    ":e-block", false, true, false),
  r("consonant vowel consonant u l e # -> 19,68,105,333,334",
  // e-block-58, conditional phase-one
    // act19 = (KILL 3)
    // act68 = (ADD E)
    // act105 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (NEED-FINAL-E ROOT)))
    // act333 = (SETQ SUFFIX 'ULE)
    // act334 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'N)) EVA...
    ":e-block", false, true, false),
  r("u l e # -> 19,35,333,334",
  // e-block-59, conditional phase-one
    // act19 = (KILL 3)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act333 = (SETQ SUFFIX 'ULE)
    // act334 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'N)) EVA...
    ":e-block", false, true, false),
  r("p h i l e # -> 57,35,335",
  // e-block-60, conditional phase-one
    // act57 = (KILL 5)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act335 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(N ADJ ...
    ":e-block", false, true, false),
  r("p h i l e # -> 57,68,105,335",
  // e-block-61, conditional phase-one
    // act57 = (KILL 5)
    // act68 = (ADD E)
    // act105 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (NEED-FINAL-E ROOT)))
    // act335 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(N ADJ ...
    ":e-block", false, true, false),
  r("o p h i l e # -> 102,35,335",
  // e-block-62, conditional phase-one
    // act102 = (KILL 6)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act335 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(N ADJ ...
    ":e-block", false, true, false),
  r("a|i b l e # -> 61,68,336,337,338",
  // e-block-63, conditional phase-one
    // act61 = (KILL 4)
    // act68 = (ADD E)
    // act336 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-KNOW...
    // act337 = (SETQ SUFFIX 'ABLE)
    // act338 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'V)) E...
    ":e-block", false, true, false),
  r("a|i b l e # -> 61,68,105,337,338",
  // e-block-64, conditional phase-one
    // act61 = (KILL 4)
    // act68 = (ADD E)
    // act105 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (NEED-FINAL-E ROOT)))
    // act337 = (SETQ SUFFIX 'ABLE)
    // act338 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'V)) E...
    ":e-block", false, true, false),
  r("a|i b l e # -> 61,35,337,338",
  // e-block-65, conditional phase-one
    // act61 = (KILL 4)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act337 = (SETQ SUFFIX 'ABLE)
    // act338 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'V)) E...
    ":e-block", false, true, false),
  r("a|i b l e # -> 61,68,35,337,338",
  // e-block-66, conditional phase-one
    // act61 = (KILL 4)
    // act68 = (ADD E)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act337 = (SETQ SUFFIX 'ABLE)
    // act338 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'V)) E...
    ":e-block", false, true, false),
  r("consonant vowel b|d|f|g|k|l|m|n|p|r|s|t|v|z & a|i b l e # -> 57,35,337,338",
  // e-block-67, conditional phase-one
    // act57 = (KILL 5)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act337 = (SETQ SUFFIX 'ABLE)
    // act338 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'V)) E...
    ":e-block", false, true, false),
  r("vowel l|s|z & a|i b l e # -> 61,35,337,338",
  // e-block-68, conditional phase-one
    // act61 = (KILL 4)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act337 = (SETQ SUFFIX 'ABLE)
    // act338 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'V)) E...
    ":e-block", false, true, false),
  r("consonant i a b l e # -> 57,31,35,337,338",
  // e-block-69, conditional phase-one
    // act57 = (KILL 5)
    // act31 = (ADD Y)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act337 = (SETQ SUFFIX 'ABLE)
    // act338 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'V)) E...
    ":e-block", false, true, false),
  r("a b l e # -> 61,35,337,339",
  // e-block-70, conditional phase-one
    // act61 = (KILL 4)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act337 = (SETQ SUFFIX 'ABLE)
    // act339 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(NN A...
    ":e-block", false, true, false),
  r("a b l e # -> 61,31,32,337,340",
  // e-block-71, conditional phase-one
    // act61 = (KILL 4)
    // act31 = (ADD Y)
    // act32 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-KNOW...
    // act337 = (SETQ SUFFIX 'ABLE)
    // act340 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(NN V...
    ":e-block", false, true, false),
  r("a b l e # -> 61,35,341,337,338",
  // e-block-72, conditional phase-one
    // act61 = (KILL 4)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act341 = (ADD A T E)
    // act337 = (SETQ SUFFIX 'ABLE)
    // act338 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'V)) E...
    ":e-block", false, true, false),
  r("i s s i b l e # -> 102,342,35,337,338",
  // e-block-73, conditional phase-one
    // act102 = (KILL 6)
    // act342 = (ADD T)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act337 = (SETQ SUFFIX 'ABLE)
    // act338 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'V)) E...
    ":e-block", false, true, false),
  r("i s s a b l e # -> 102,342,35,337,343",
  // e-block-74, conditional phase-one
    // act102 = (KILL 6)
    // act342 = (ADD T)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act337 = (SETQ SUFFIX 'ABLE)
    // act343 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'V)) E...
    ":e-block", false, true, false),
  r("s i b l e # -> 57,344,35,337,338",
  // e-block-75, conditional phase-one
    // act57 = (KILL 5)
    // act344 = (ADD D)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act337 = (SETQ SUFFIX 'ABLE)
    // act338 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'V)) E...
    ":e-block", false, true, false),
  r("s i b l e # -> 57,318,35,337,338",
  // e-block-76, conditional phase-one
    // act57 = (KILL 5)
    // act318 = (ADD D E)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act337 = (SETQ SUFFIX 'ABLE)
    // act338 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'V)) E...
    ":e-block", false, true, false),
  r("i t e # -> 19,345,162,346",
  // e-block-77, conditional phase-one
    // act19 = (KILL 3)
    // act345 = (TEST (AND (> (NCHARS ROOT) 2) (PLAUSIBLE-ROOT ROOT) (MORPH-...
    // act162 = (CAT ADJ T EVAL '*)
    // act346 = (CAT N T EVAL (PROGN (MARK-DICT LEX 'ROOT ROOT T T) (MARK-DI...
    ":e-block", false, true, false),
  r("consonant i t e # -> 19,68,347,162,346",
  // e-block-78, conditional phase-one
    // act19 = (KILL 3)
    // act68 = (ADD E)
    // act347 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (NEED-FINAL-E ROOT) (MORPH-...
    // act162 = (CAT ADJ T EVAL '*)
    // act346 = (CAT N T EVAL (PROGN (MARK-DICT LEX 'ROOT ROOT T T) (MARK-DI...
    ":e-block", false, true, false),
  r("i t e # -> 19,348,162,349",
  // e-block-79, conditional phase-one
    // act19 = (KILL 3)
    // act348 = (TEST (AND (> (NCHARS ROOT) 2) (PLAUSIBLE-ROOT ROOT) (MORPH-...
    // act162 = (CAT ADJ T EVAL '*)
    // act349 = (CAT N T EVAL (PROGN (MARK-DICT LEX 'ROOT ROOT T T) (MARK-DI...
    ":e-block", false, true, false),
  r("consonant i t e # -> 19,68,350,162,349",
  // e-block-80, conditional phase-one
    // act19 = (KILL 3)
    // act68 = (ADD E)
    // act350 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (NEED-FINAL-E ROOT) (MORPH-...
    // act162 = (CAT ADJ T EVAL '*)
    // act349 = (CAT N T EVAL (PROGN (MARK-DICT LEX 'ROOT ROOT T T) (MARK-DI...
    ":e-block", false, true, false),
  r("i t e # -> 19,351,162,352",
  // e-block-81, conditional phase-one
    // act19 = (KILL 3)
    // act351 = (TEST (AND (> (NCHARS ROOT) 2) (PLAUSIBLE-ROOT ROOT) (MORPH-...
    // act162 = (CAT ADJ T EVAL '*)
    // act352 = (CAT N T EVAL (PROGN (MARK-DICT LEX 'ROOT ROOT T T) (MARK-DI...
    ":e-block", false, true, false),
  r("consonant i t e # -> 19,68,353,162,352",
  // e-block-82, conditional phase-one
    // act19 = (KILL 3)
    // act68 = (ADD E)
    // act353 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (> (NCHARS ROOT) 3) (NEED-F...
    // act162 = (CAT ADJ T EVAL '*)
    // act352 = (CAT N T EVAL (PROGN (MARK-DICT LEX 'ROOT ROOT T T) (MARK-DI...
    ":e-block", false, true, false),
  r("consonant i t e # -> 19,117,354,162,352",
  // e-block-83, conditional phase-one
    // act19 = (KILL 3)
    // act117 = (ADD A)
    // act354 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (> (NCHARS ROOT) 3) (MORPH-...
    // act162 = (CAT ADJ T EVAL '*)
    // act352 = (CAT N T EVAL (PROGN (MARK-DICT LEX 'ROOT ROOT T T) (MARK-DI...
    ":e-block", false, true, false),
  r("consonant i t e # -> 355,162,356",
  // e-block-84, conditional phase-one
    // act355 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (POLYSYLLABIC ROOT) (MORPH-...
    // act162 = (CAT ADJ T EVAL '*)
    // act356 = (CAT NM T EVAL (PROGN (MARK-DICT LEX 'KINDOF 'SUBSTANCE T T)...
    ":e-block", false, true, false),
  r("a t e # -> 19,357,358,359",
  // e-block-85, phase-one
    // act19 = (KILL 3)
    // act357 = (TEST (AND (MORPH-ROOT STATE) (CHEMICAL-NAME-TEST ROOT) (MAK...
    // act358 = (CAT NM T EVAL (PROGN (MARK-DICT LEX 'DOMAIN 'CHEMISTRY T T)...
    // act359 = (CAT V T EVAL (PROGN (MARK-DICT LEX 'FEATURES '(TRANS PASSIV...
    ":e-block", true, false, false),
  r("consonant vowel b|d|f|g|k|l|m|n|p|r|s|t|v|z & a t e # -> 61,68,360,361,362,363",
  // e-block-86, conditional phase-one
    // act61 = (KILL 4)
    // act68 = (ADD E)
    // act360 = (TEST (AND (> (NCHARS ROOT) 2) (PLAUSIBLE-ROOT ROOT)))
    // act361 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(NN))...
    // act362 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(V ADJ ...
    // act363 = (CAT V (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(NN ADJ...
    ":e-block", false, true, false),
  r("consonant a t e # -> 19,364,361,362,363",
  // e-block-87, conditional phase-one
    // act19 = (KILL 3)
    // act364 = (TEST (AND (> (NCHARS ROOT) 2) (PLAUSIBLE-ROOT ROOT) (POLYSY...
    // act361 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(NN))...
    // act362 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(V ADJ ...
    // act363 = (CAT V (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(NN ADJ...
    ":e-block", false, true, false),
  r("consonant a t e # -> 19,35,68,361,365,366",
  // e-block-88, conditional phase-one
    // act19 = (KILL 3)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act68 = (ADD E)
    // act361 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(NN))...
    // act365 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(V ADJ ...
    // act366 = (CAT V (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(NN ADJ...
    ":e-block", false, true, false),
  r("consonant a t e # -> 50,364,361,362,363",
  // e-block-89, conditional phase-one
    // act50 = (KILL 2)
    // act364 = (TEST (AND (> (NCHARS ROOT) 2) (PLAUSIBLE-ROOT ROOT) (POLYSY...
    // act361 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(NN))...
    // act362 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(V ADJ ...
    // act363 = (CAT V (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(NN ADJ...
    ":e-block", false, true, false),
  r("consonant a t e # -> 19,194,364,361,362,363",
  // e-block-90, conditional phase-one
    // act19 = (KILL 3)
    // act194 = (ADD U S)
    // act364 = (TEST (AND (> (NCHARS ROOT) 2) (PLAUSIBLE-ROOT ROOT) (POLYSY...
    // act361 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(NN))...
    // act362 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(V ADJ ...
    // act363 = (CAT V (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(NN ADJ...
    ":e-block", false, true, false),
  r("a t e # -> 19,364,367,368,369",
  // e-block-91, conditional phase-one
    // act19 = (KILL 3)
    // act364 = (TEST (AND (> (NCHARS ROOT) 2) (PLAUSIBLE-ROOT ROOT) (POLYSY...
    // act367 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(PREF...
    // act368 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(PREFIX...
    // act369 = (CAT V (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(PREFIX...
    ":e-block", false, true, false),
  r("l a t e # -> 19,118,370,371,372",
  // e-block-92, conditional phase-one
    // act19 = (KILL 3)
    // act118 = (ADD I C)
    // act370 = (TEST (AND (> (NCHARS ROOT) 2) (PLAUSIBLE-ROOT ROOT) (POLYSY...
    // act371 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(ADJ)))...
    // act372 = (CAT V (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(NN ADJ...
    ":e-block", false, true, false),
  r("i a t e # -> 50,373,370,374",
  // e-block-93, conditional phase-one
    // act50 = (KILL 2)
    // act373 = (ADD L)
    // act370 = (TEST (AND (> (NCHARS ROOT) 2) (PLAUSIBLE-ROOT ROOT) (POLYSY...
    // act374 = (CAT V (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(ADJ)))...
    ":e-block", false, true, false),
  r("w a r e # -> 61,35,375",
  // e-block-94, conditional phase-one
    // act61 = (KILL 4)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act375 = (CAT NM (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(ADJ N...
    ":e-block", false, true, false),
  r("p h a g e # -> 57,35,376",
  // e-block-95, conditional phase-one
    // act57 = (KILL 5)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act376 = (CAT NC (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(PREFI...
    ":e-block", false, true, false),
  r("i c i d e # -> 57,35,377",
  // e-block-96, conditional phase-one
    // act57 = (KILL 5)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act377 = (CAT NMC (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(NN))...
    ":e-block", false, true, false),
  r("i c i d e # -> 57,68,35,377",
  // e-block-97, conditional phase-one
    // act57 = (KILL 5)
    // act68 = (ADD E)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act377 = (CAT NMC (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(NN))...
    ":e-block", false, true, false),
  r("u r e # -> 19,378,379,378,380,68,380",
  // e-block-98, conditional phase-one
    // act19 = (KILL 3)
    // act378 = (SETQ SUFFIX 'URE)
    // act379 = (TEST (AND (MORPH-ROOT STATE) (OR (PATTERN-CHECK-LEFT ROOT '...
    // act378 = (SETQ SUFFIX 'URE)
    // act380 = (CAT N (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-ROO...
    // act68 = (ADD E)
    // act380 = (CAT N (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-ROO...
    ":e-block", false, true, true),
  r("vowel b|d|f|g|k|l|m|n|p|r|s|t|v|z & u r e # -> 61,381,378,382",
  // e-block-99, conditional phase-one
    // act61 = (KILL 4)
    // act381 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (PA...
    // act378 = (SETQ SUFFIX 'URE)
    // act382 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(ADJ V ...
    ":e-block", false, true, false),
  r("consonant r e # -> 50,72,32,383,384",
  // e-block-100, conditional phase-one
    // act50 = (KILL 2)
    // act72 = (ADD E R)
    // act32 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-KNOW...
    // act383 = (SETQ SUFFIX 'RE)
    // act384 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(NN))) ...
    ":e-block", false, true, false),
  r("a g e # -> 19,68,385,386,382",
  // e-block-101, conditional phase-one
    // act19 = (KILL 3)
    // act68 = (ADD E)
    // act385 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (NEED-FINAL-E ROOT) (MORPH-...
    // act386 = (SETQ SUFFIX 'AGE)
    // act382 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(ADJ V ...
    ":e-block", false, true, false),
  r("a g e # -> 19,35,386,382",
  // e-block-102, conditional phase-one
    // act19 = (KILL 3)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act386 = (SETQ SUFFIX 'AGE)
    // act382 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(ADJ V ...
    ":e-block", false, true, false),
  r("a g e # -> 19,68,387,386,382",
  // e-block-103, conditional phase-one
    // act19 = (KILL 3)
    // act68 = (ADD E)
    // act387 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (PA...
    // act386 = (SETQ SUFFIX 'AGE)
    // act382 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(ADJ V ...
    ":e-block", false, true, false),
  r("consonant vowel b|d|f|g|k|l|m|n|p|r|s|t|v|z & a g e # -> 61,360,386,382",
  // e-block-104, conditional phase-one
    // act61 = (KILL 4)
    // act360 = (TEST (AND (> (NCHARS ROOT) 2) (PLAUSIBLE-ROOT ROOT)))
    // act386 = (SETQ SUFFIX 'AGE)
    // act382 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(ADJ V ...
    ":e-block", false, true, false),
  r("e n c e # -> 50,342,35,388,389",
  // e-block-105, conditional phase-one
    // act50 = (KILL 2)
    // act342 = (ADD T)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act388 = (SETQ SUFFIX 'ENCE)
    // act389 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(ADJ)))...
    ":e-block", false, true, false),
  r("a n c e # -> 50,342,35,390,389",
  // e-block-106, conditional phase-one
    // act50 = (KILL 2)
    // act342 = (ADD T)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act390 = (SETQ SUFFIX 'ANCE)
    // act389 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(ADJ)))...
    ":e-block", false, true, false),
  r("i a n c e # -> 57,31,35,390,391",
  // e-block-107, conditional phase-one
    // act57 = (KILL 5)
    // act31 = (ADD Y)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act390 = (SETQ SUFFIX 'ANCE)
    // act391 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(V))) E...
    ":e-block", false, true, false),
  r("a n c e # -> 61,68,105,390,391",
  // e-block-108, conditional phase-one
    // act61 = (KILL 4)
    // act68 = (ADD E)
    // act105 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (NEED-FINAL-E ROOT)))
    // act390 = (SETQ SUFFIX 'ANCE)
    // act391 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(V))) E...
    ":e-block", false, true, false),
  r("a n c e # -> 61,35,390,391",
  // e-block-109, conditional phase-one
    // act61 = (KILL 4)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act390 = (SETQ SUFFIX 'ANCE)
    // act391 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(V))) E...
    ":e-block", false, true, false),
  r("consonant & a n c e # -> 57,35,390,391",
  // e-block-110, conditional phase-one
    // act57 = (KILL 5)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act390 = (SETQ SUFFIX 'ANCE)
    // act391 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(V))) E...
    ":e-block", false, true, false),
  r("consonant & e n c e # -> 50,342,35,388,391",
  // e-block-111, conditional phase-one
    // act50 = (KILL 2)
    // act342 = (ADD T)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act388 = (SETQ SUFFIX 'ENCE)
    // act391 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(V))) E...
    ":e-block", false, true, false),
  r("consonant & a n c e # -> 50,342,35,390,391",
  // e-block-112, conditional phase-one
    // act50 = (KILL 2)
    // act342 = (ADD T)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act390 = (SETQ SUFFIX 'ANCE)
    // act391 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(V))) E...
    ":e-block", false, true, false),
  r("e n c e # -> 50,342,131,388,389",
  // e-block-113, conditional phase-one
    // act50 = (KILL 2)
    // act342 = (ADD T)
    // act131 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (POLYSYLLABIC ROOT)))
    // act388 = (SETQ SUFFIX 'ENCE)
    // act389 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(ADJ)))...
    ":e-block", false, true, false),
  r("a n c e # -> 50,342,131,390,389",
  // e-block-114, conditional phase-one
    // act50 = (KILL 2)
    // act342 = (ADD T)
    // act131 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (POLYSYLLABIC ROOT)))
    // act390 = (SETQ SUFFIX 'ANCE)
    // act389 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(ADJ)))...
    ":e-block", false, true, false),
  r("consonant & e n c e # -> 57,131,388,391",
  // e-block-115, conditional phase-one
    // act57 = (KILL 5)
    // act131 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (POLYSYLLABIC ROOT)))
    // act388 = (SETQ SUFFIX 'ENCE)
    // act391 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(V))) E...
    ":e-block", false, true, false),
  r("consonant & a n c e # -> 57,131,390,391",
  // e-block-116, conditional phase-one
    // act57 = (KILL 5)
    // act131 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (POLYSYLLABIC ROOT)))
    // act390 = (SETQ SUFFIX 'ANCE)
    // act391 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(V))) E...
    ":e-block", false, true, false),
  r("e n c e # -> 19,325,388,391",
  // e-block-117, conditional phase-one
    // act19 = (KILL 3)
    // act325 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (POLYSYLLABIC ROOT) (NEED-F...
    // act388 = (SETQ SUFFIX 'ENCE)
    // act391 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(V))) E...
    ":e-block", false, true, false),
  r("e n c e # -> 61,131,388,391",
  // e-block-118, conditional phase-one
    // act61 = (KILL 4)
    // act131 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (POLYSYLLABIC ROOT)))
    // act388 = (SETQ SUFFIX 'ENCE)
    // act391 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(V))) E...
    ":e-block", false, true, false),
  r("a c e a e # -> 24,107,35,392",
  // e-block-119, conditional phase-one
    // act24 = (KILL 1)
    // act107 = (ADD N)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act392 = (CAT NPR (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(ADJ ...
    ":e-block", false, true, false),
  r("i d a e # -> 50,35,393",
  // e-block-120, conditional phase-one
    // act50 = (KILL 2)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act393 = (CAT NPR (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(ADJ ...
    ":e-block", false, true, false),
  r("i d a e # -> 61,35,393",
  // e-block-121, conditional phase-one
    // act61 = (KILL 4)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act393 = (CAT NPR (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(ADJ ...
    ":e-block", false, true, false),
  r("i d a e # -> 61,117,131,394",
  // e-block-122, conditional phase-one
    // act61 = (KILL 4)
    // act117 = (ADD A)
    // act131 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (POLYSYLLABIC ROOT)))
    // act394 = (CAT NPR (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(NN))...
    ":e-block", false, true, false),
  r("i d a e # -> 61,194,131,394",
  // e-block-123, conditional phase-one
    // act61 = (KILL 4)
    // act194 = (ADD U S)
    // act131 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (POLYSYLLABIC ROOT)))
    // act394 = (CAT NPR (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(NN))...
    ":e-block", false, true, false),
  r("i d a e # -> 61,116,131,394",
  // e-block-124, conditional phase-one
    // act61 = (KILL 4)
    // act116 = (ADD U M)
    // act131 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (POLYSYLLABIC ROOT)))
    // act394 = (CAT NPR (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(NN))...
    ":e-block", false, true, false),
  r("i d a e # -> 50,35,395",
  // e-block-125, 
    // act50 = (KILL 2)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act395 = (CAT NPR (POLYSYLLABIC ROOT) EVAL (PROGN (MARK-DICT LEX 'KIN...
    ":e-block"),
  r("a e # -> 50,131,396",
  // e-block-126, conditional phase-one
    // act50 = (KILL 2)
    // act131 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (POLYSYLLABIC ROOT)))
    // act396 = (CAT NPR (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(ADJ ...
    ":e-block", false, true, false),
  r("a e # -> 24,131,397",
  // e-block-127, conditional phase-one
    // act24 = (KILL 1)
    // act131 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (POLYSYLLABIC ROOT)))
    // act397 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(N))) E...
    ":e-block", false, true, false),
  r("consonant vowel b|d|g|m|n|p|r|s|t & e e # -> 19,398,399",
  // e-block-128, conditional phase-one
    // act19 = (KILL 3)
    // act398 = (SETQ SUFFIX 'EE)
    // act399 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'V)) EVA...
    ":e-block", false, true, false),
  r("consonant e # -> 24,400,401",
  // e-block-129, conditional phase-one
    // act24 = (KILL 1)
    // act400 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (OR (NEED-FINAL-E ROOT) (PO...
    // act401 = (CAT FEMALEFIRSTNAME (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT...
    ":e-block", false, true, false),
  r("consonant i e # -> 50,31,35,402",
  // e-block-130, conditional phase-one
    // act50 = (KILL 2)
    // act31 = (ADD Y)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act402 = (CAT FEMALEFIRSTNAME (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT...
    ":e-block", false, true, false),
  r("consonant e e # -> 50,31,35,402",
  // e-block-131, conditional phase-one
    // act50 = (KILL 2)
    // act31 = (ADD Y)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act402 = (CAT FEMALEFIRSTNAME (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT...
    ":e-block", false, true, false),
  r("e e # -> 50,35,398,399",
  // e-block-132, conditional phase-one
    // act50 = (KILL 2)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act398 = (SETQ SUFFIX 'EE)
    // act399 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'V)) EVA...
    ":e-block", false, true, false),
  r("e e # -> 50,35,398,403",
  // e-block-133, conditional phase-one
    // act50 = (KILL 2)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act398 = (SETQ SUFFIX 'EE)
    // act403 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'NN)) EV...
    ":e-block", false, true, false),
  r("consonant e e # -> 50,68,35,398,404",
  // e-block-134, conditional phase-one
    // act50 = (KILL 2)
    // act68 = (ADD E)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act398 = (SETQ SUFFIX 'EE)
    // act404 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'V)) EVA...
    ":e-block", false, true, false),
  r("consonant vowel b|d|g|k|l|m|n|p|r|t & e e # -> 19,35,398,404",
  // e-block-135, conditional phase-one
    // act19 = (KILL 3)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act398 = (SETQ SUFFIX 'EE)
    // act404 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'V)) EVA...
    ":e-block", false, true, false),
  r("q u vowel b|d|g|k|l|m|n|p|r|t & e e # -> 19,35,398,404",
  // e-block-136, conditional phase-one
    // act19 = (KILL 3)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act398 = (SETQ SUFFIX 'EE)
    // act404 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'V)) EVA...
    ":e-block", false, true, false),
  r("vowel consonant e e # -> 50,68,105,398,404",
  // e-block-137, conditional phase-one
    // act50 = (KILL 2)
    // act68 = (ADD E)
    // act105 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (NEED-FINAL-E ROOT)))
    // act398 = (SETQ SUFFIX 'EE)
    // act404 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'V)) EVA...
    ":e-block", false, true, false),
  r("consonant vowel b|d|g|k|l|m|n|p|r|t & e e # -> 19,35,398,405",
  // e-block-138, 
    // act19 = (KILL 3)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act398 = (SETQ SUFFIX 'EE)
    // act405 = (CAT N (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT 'V)) EVAL (L...
    ":e-block"),
  r("q u vowel b|d|g|k|l|m|n|p|r|t & e e # -> 19,35,398,405",
  // e-block-139, 
    // act19 = (KILL 3)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act398 = (SETQ SUFFIX 'EE)
    // act405 = (CAT N (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT 'V)) EVAL (L...
    ":e-block"),
  r("vowel consonant e e # -> 50,68,105,398,405",
  // e-block-140, 
    // act50 = (KILL 2)
    // act68 = (ADD E)
    // act105 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (NEED-FINAL-E ROOT)))
    // act398 = (SETQ SUFFIX 'EE)
    // act405 = (CAT N (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT 'V)) EVAL (L...
    ":e-block"),
  r("vowel l|r c|g e e # -> 50,68,105,398,405",
  // e-block-141, 
    // act50 = (KILL 2)
    // act68 = (ADD E)
    // act105 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (NEED-FINAL-E ROOT)))
    // act398 = (SETQ SUFFIX 'EE)
    // act405 = (CAT N (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT 'V)) EVAL (L...
    ":e-block"),
  r("consonant e e # -> 50,68,105,398,405",
  // e-block-142, 
    // act50 = (KILL 2)
    // act68 = (ADD E)
    // act105 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (NEED-FINAL-E ROOT)))
    // act398 = (SETQ SUFFIX 'EE)
    // act405 = (CAT N (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT 'V)) EVAL (L...
    ":e-block"),
  r("consonant e e # -> 50,35,398,405",
  // e-block-143, 
    // act50 = (KILL 2)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act398 = (SETQ SUFFIX 'EE)
    // act405 = (CAT N (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT 'V)) EVAL (L...
    ":e-block"),
  r("i e # -> 50,35,406",
  // e-block-144, conditional phase-one
    // act50 = (KILL 2)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act406 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADJ)) E...
    ":e-block", false, true, false),
  r("vowel consonant i e # -> 50,68,35,406",
  // e-block-145, conditional phase-one
    // act50 = (KILL 2)
    // act68 = (ADD E)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act406 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADJ)) E...
    ":e-block", false, true, false),
  r("consonant vowel b|d|g|k|m|n|p|r|t & i e # -> 19,35,406",
  // e-block-146, conditional phase-one
    // act19 = (KILL 3)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act406 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADJ)) E...
    ":e-block", false, true, false),
  r("q u vowel b|d|g|k|m|n|p|r|t & i e # -> 19,35,406",
  // e-block-147, conditional phase-one
    // act19 = (KILL 3)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act406 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADJ)) E...
    ":e-block", false, true, false),
  r("i e # -> 50,35,407",
  // e-block-148, conditional phase-one
    // act50 = (KILL 2)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act407 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'NN)) EV...
    ":e-block", false, true, false),
  r("vowel consonant i e # -> 50,68,35,407",
  // e-block-149, conditional phase-one
    // act50 = (KILL 2)
    // act68 = (ADD E)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act407 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'NN)) EV...
    ":e-block", false, true, false),
  r("consonant vowel b|d|g|k|m|n|p|r|t & i e # -> 19,35,407",
  // e-block-150, conditional phase-one
    // act19 = (KILL 3)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act407 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'NN)) EV...
    ":e-block", false, true, false),
  r("q u vowel b|d|g|k|m|n|p|r|t & i e # -> 19,35,407",
  // e-block-151, conditional phase-one
    // act19 = (KILL 3)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act407 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'NN)) EV...
    ":e-block", false, true, false),
  r("o s e # -> 19,408,114,409,410",
  // e-block-152, conditional phase-one
    // act19 = (KILL 3)
    // act408 = (ADD O U S)
    // act114 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (POLYSYLLABIC ROOT) (MORPH-...
    // act409 = (SETQ SUFFIX 'OSE)
    // act410 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(ADJ)...
    ":e-block", false, true, false),
  r("o s e # -> 19,37,131,411",
  // e-block-153, conditional phase-one
    // act19 = (KILL 3)
    // act37 = (ADD O)
    // act131 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (POLYSYLLABIC ROOT)))
    // act411 = (CAT NM (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'PREFIX...
    ":e-block", false, true, false),
  r("t o s e # -> 19,118,35,409,412",
  // e-block-154, conditional phase-one
    // act19 = (KILL 3)
    // act118 = (ADD I C)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act409 = (SETQ SUFFIX 'OSE)
    // act412 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(ADJ)...
    ":e-block", false, true, false),
  r("o s e # -> 19,68,105,409,115",
  // e-block-155, conditional phase-one
    // act19 = (KILL 3)
    // act68 = (ADD E)
    // act105 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (NEED-FINAL-E ROOT)))
    // act409 = (SETQ SUFFIX 'OSE)
    // act115 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'NN)) ...
    ":e-block", false, true, false),
  r("consonant o s e # -> 19,35,409,115",
  // e-block-156, conditional phase-one
    // act19 = (KILL 3)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act409 = (SETQ SUFFIX 'OSE)
    // act115 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'NN)) ...
    ":e-block", false, true, false),
  r("o s e # -> 19,117,131,409,115",
  // e-block-157, conditional phase-one
    // act19 = (KILL 3)
    // act117 = (ADD A)
    // act131 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (POLYSYLLABIC ROOT)))
    // act409 = (SETQ SUFFIX 'OSE)
    // act115 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'NN)) ...
    ":e-block", false, true, false),
  r("o s e # -> 19,194,131,409,115",
  // e-block-158, conditional phase-one
    // act19 = (KILL 3)
    // act194 = (ADD U S)
    // act131 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (POLYSYLLABIC ROOT)))
    // act409 = (SETQ SUFFIX 'OSE)
    // act115 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'NN)) ...
    ":e-block", false, true, false),
  r("o s e # -> 19,116,131,409,115",
  // e-block-159, conditional phase-one
    // act19 = (KILL 3)
    // act116 = (ADD U M)
    // act131 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (POLYSYLLABIC ROOT)))
    // act409 = (SETQ SUFFIX 'OSE)
    // act115 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'NN)) ...
    ":e-block", false, true, false),
  r("o s e # -> 19,68,409,413",
  // e-block-160, conditional phase-one
    // act19 = (KILL 3)
    // act68 = (ADD E)
    // act409 = (SETQ SUFFIX 'OSE)
    // act413 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'NN) (...
    ":e-block", false, true, false),
  r("y c|l|m|t o s e # -> 35,409,414",
  // e-block-161, 
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act409 = (SETQ SUFFIX 'OSE)
    // act414 = (CAT ADJ T EVAL (LIST LEX (LIST 'SUFFIX SUFFIX)))
    ":e-block"),
  r("consonant e|i|y o s e # -> 35,409,414",
  // e-block-162, 
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act409 = (SETQ SUFFIX 'OSE)
    // act414 = (CAT ADJ T EVAL (LIST LEX (LIST 'SUFFIX SUFFIX)))
    ":e-block"),
  r("u l o s e # -> 19,68,35,409,200",
  // e-block-163, 
    // act19 = (KILL 3)
    // act68 = (ADD E)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act409 = (SETQ SUFFIX 'OSE)
    // act200 = (CAT ADJ T EVAL (LIST LEX (LIST 'ROOT ROOT) (LIST 'SUFFIX SU...
    ":e-block"),
  r("consonant o s e # -> 131,409,414",
  // e-block-164, 
    // act131 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (POLYSYLLABIC ROOT)))
    // act409 = (SETQ SUFFIX 'OSE)
    // act414 = (CAT ADJ T EVAL (LIST LEX (LIST 'SUFFIX SUFFIX)))
    ":e-block"),
  r("consonant i t e # -> 131,162,356",
  // e-block-165, 
    // act131 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (POLYSYLLABIC ROOT)))
    // act162 = (CAT ADJ T EVAL '*)
    // act356 = (CAT NM T EVAL (PROGN (MARK-DICT LEX 'KINDOF 'SUBSTANCE T T)...
    ":e-block"),
  r("a c e a e # -> 35,415",
  // e-block-166, 
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act415 = (CAT NPR T EVAL (PROGN (MARK-DICT LEX 'KINDOF '!N/PLANT/VEGE...
    ":e-block"),
  r("p h y c e a e # -> 35,416",
  // e-block-167, 
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act416 = (CAT NPR T EVAL (PROGN (MARK-DICT LEX 'KINDOF '!N/PLANT/VEGE...
    ":e-block"),
  r("i d a e # -> 35,417",
  // e-block-168, 
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act417 = (CAT NPR T EVAL (PROGN (MARK-DICT LEX 'KINDOF 'ANIMAL T T) (...
    ":e-block"),
  r("i n a e # -> 35,418",
  // e-block-169, 
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act418 = (CAT NPR T EVAL (PROGN (MARK-DICT LEX 'KINDOF 'ANIMAL T T) (...
    ":e-block"),
  r("a e # -> 50,419,117,420",
  // e-block-170, 
    // act50 = (KILL 2)
    // act419 = (TEST (SYLLABIC ROOT))
    // act117 = (ADD A)
    // act420 = (CAT N T EVAL (LIST LEX (LIST 'ROOT ROOT) '(NUMBER PL)))
    ":e-block"),
  r("b o u r n e # -> 35,264,154",
  // e-block-171, 
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act264 = (CAT CITY T EVAL '*)
    // act154 = (CAT LASTNAME T EVAL '*)
    ":e-block"),
  r("d a l e # -> 35,264,154",
  // e-block-172, 
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act264 = (CAT CITY T EVAL '*)
    // act154 = (CAT LASTNAME T EVAL '*)
    ":e-block"),
  r("d i k e # -> 35,264,154",
  // e-block-173, 
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act264 = (CAT CITY T EVAL '*)
    // act154 = (CAT LASTNAME T EVAL '*)
    ":e-block"),
  r("s h i r e # -> 35,421,277,154",
  // e-block-174, 
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act421 = (MARK-DICT LEX 'INSTANCEOF '(DISTRICT LOCATION) T T)
    // act277 = (CAT NPR T EVAL '*)
    // act154 = (CAT LASTNAME T EVAL '*)
    ":e-block"),
  r("s b r i d g e # -> 35,264,154",
  // e-block-175, 
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act264 = (CAT CITY T EVAL '*)
    // act154 = (CAT LASTNAME T EVAL '*)
    ":e-block"),
  r("s s i v e # -> 19,35,312,422",
  // e-block-176, 
    // act19 = (KILL 3)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act312 = (SETQ SUFFIX 'IVE)
    // act422 = (CAT ADJ (POLYSYLLABIC ROOT) EVAL (LIST LEX (LIST 'ROOT ROOT...
    ":e-block"),
  r("c|s i v e # -> 19,68,35,312,422",
  // e-block-177, 
    // act19 = (KILL 3)
    // act68 = (ADD E)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act312 = (SETQ SUFFIX 'IVE)
    // act422 = (CAT ADJ (POLYSYLLABIC ROOT) EVAL (LIST LEX (LIST 'ROOT ROOT...
    ":e-block"),
  r("consonant vowel t i v e # -> 19,68,35,312,422",
  // e-block-178, 
    // act19 = (KILL 3)
    // act68 = (ADD E)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act312 = (SETQ SUFFIX 'IVE)
    // act422 = (CAT ADJ (POLYSYLLABIC ROOT) EVAL (LIST LEX (LIST 'ROOT ROOT...
    ":e-block"),
  r("t|x i v e # -> 19,35,312,422",
  // e-block-179, 
    // act19 = (KILL 3)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act312 = (SETQ SUFFIX 'IVE)
    // act422 = (CAT ADJ (POLYSYLLABIC ROOT) EVAL (LIST LEX (LIST 'ROOT ROOT...
    ":e-block"),
  r("i v e # -> 35,312,423",
  // e-block-180, 
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act312 = (SETQ SUFFIX 'IVE)
    // act423 = (CAT ADJ (POLYSYLLABIC ROOT) EVAL (LIST LEX (LIST 'SUFFIX SU...
    ":e-block"),
  r("consonant vowel b|d|g|k|m|n|p|r|t & a b l e # -> 57,337,424",
  // e-block-181, 
    // act57 = (KILL 5)
    // act337 = (SETQ SUFFIX 'ABLE)
    // act424 = (CAT ADJ (PLAUSIBLE-ROOT ROOT) EVAL (LIST LEX (LIST 'ROOT RO...
    ":e-block"),
  r("consonant vowel b|d|g|k|m|n|p|r|t a b l e # -> 61,68,337,424",
  // e-block-182, 
    // act61 = (KILL 4)
    // act68 = (ADD E)
    // act337 = (SETQ SUFFIX 'ABLE)
    // act424 = (CAT ADJ (PLAUSIBLE-ROOT ROOT) EVAL (LIST LEX (LIST 'ROOT RO...
    ":e-block"),
  r("consonant i a b l e # -> 337,424",
  // e-block-183, 
    // act337 = (SETQ SUFFIX 'ABLE)
    // act424 = (CAT ADJ (PLAUSIBLE-ROOT ROOT) EVAL (LIST LEX (LIST 'ROOT RO...
    ":e-block"),
  r("a b l e # -> 61,68,148,337,156",
  // e-block-184, 
    // act61 = (KILL 4)
    // act68 = (ADD E)
    // act148 = (TEST (NEED-FINAL-E ROOT))
    // act337 = (SETQ SUFFIX 'ABLE)
    // act156 = (CAT ADJ (PLAUSIBLE-ROOT ROOT) EVAL '*)
    ":e-block"),
  r("a b l e # -> 61,337,156",
  // e-block-185, 
    // act61 = (KILL 4)
    // act337 = (SETQ SUFFIX 'ABLE)
    // act156 = (CAT ADJ (PLAUSIBLE-ROOT ROOT) EVAL '*)
    ":e-block"),
  r("a|i b l e # -> 35,164",
  // e-block-186, 
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act164 = (CAT ADJ (POLYSYLLABIC ROOT) EVAL '*)
    ":e-block"),
  r("consonant vowel b|d|g|k|l|m|n|p|r|t & i|y s|z e # -> 61,425",
  // e-block-187, 
    // act61 = (KILL 4)
    // act425 = (CAT V (PLAUSIBLE-ROOT ROOT) EVAL (PROGN (WHEN (OR (PATTERN-...
    ":e-block"),
  r("consonant vowel b|d|g|k|l|m|n|p|r|t|v i|y s|z e # -> 19,68,425",
  // e-block-188, 
    // act19 = (KILL 3)
    // act68 = (ADD E)
    // act425 = (CAT V (PLAUSIBLE-ROOT ROOT) EVAL (PROGN (WHEN (OR (PATTERN-...
    ":e-block"),
  r("i|y s|z e # -> 19,425",
  // e-block-189, 
    // act19 = (KILL 3)
    // act425 = (CAT V (PLAUSIBLE-ROOT ROOT) EVAL (PROGN (WHEN (OR (PATTERN-...
    ":e-block"),
  r("b o r n e # -> 57,35,426",
  // e-block-190, conditional phase-one
    // act57 = (KILL 5)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act426 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(N V)...
    ":e-block", false, true, false),
  r("b o r n e # -> 57,427",
  // e-block-191, 
    // act57 = (KILL 5)
    // act427 = (CAT ADJ (PLAUSIBLE-ROOT ROOT) EVAL (PROGN (MARK-DICT LEX 'G...
    ":e-block"),
  r("l i k e # -> 61,35,428,109",
  // e-block-192, conditional phase-one
    // act61 = (KILL 4)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act428 = (SETQ SUFFIX 'LIKE)
    // act109 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'N)) E...
    ":e-block", false, true, false),
  r("l i k e # -> 61,428,429",
  // e-block-193, 
    // act61 = (KILL 4)
    // act428 = (SETQ SUFFIX 'LIKE)
    // act429 = (CAT ADJ (PLAUSIBLE-ROOT ROOT) EVAL (PROGN (MARK-DICT LEX 'G...
    ":e-block"),
  r("e s q u e # -> 57,35,307,200",
  // e-block-194, 
    // act57 = (KILL 5)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act307 = (SETQ SUFFIX 'ESQUE)
    // act200 = (CAT ADJ T EVAL (LIST LEX (LIST 'ROOT ROOT) (LIST 'SUFFIX SU...
    ":e-block"),
  r("e s q u e # -> 61,35,307,200",
  // e-block-195, 
    // act61 = (KILL 4)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act307 = (SETQ SUFFIX 'ESQUE)
    // act200 = (CAT ADJ T EVAL (LIST LEX (LIST 'ROOT ROOT) (LIST 'SUFFIX SU...
    ":e-block"),
  r("e s q u e # -> 35,307,414",
  // e-block-196, 
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act307 = (SETQ SUFFIX 'ESQUE)
    // act414 = (CAT ADJ T EVAL (LIST LEX (LIST 'SUFFIX SUFFIX)))
    ":e-block"),
  r("o s o m e # -> 61,430",
  // e-block-197, 
    // act61 = (KILL 4)
    // act430 = (CAT N (PLAUSIBLE-ROOT ROOT) EVAL (PROGN (MARK-DICT LEX 'GUE...
    ":e-block"),
  r("s o m e # -> 61,309,429",
  // e-block-198, 
    // act61 = (KILL 4)
    // act309 = (SETQ SUFFIX 'SOME)
    // act429 = (CAT ADJ (PLAUSIBLE-ROOT ROOT) EVAL (PROGN (MARK-DICT LEX 'G...
    ":e-block"),
  r("p h i l e # -> 57,431",
  // e-block-199, 
    // act57 = (KILL 5)
    // act431 = (CAT N (PLAUSIBLE-ROOT ROOT) EVAL (PROGN (MARK-DICT LEX 'HAS...
    ":e-block"),
  r("c i d e # -> 35,432",
  // e-block-200, 
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act432 = (CAT NMC (POLYSYLLABIC ROOT) EVAL (PROGN (MARK-DICT LEX 'HAS...
    ":e-block"),
  r("i d e # -> 35,433",
  // e-block-201, 
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act433 = (CAT NM (POLYSYLLABIC ROOT) EVAL '-S)
    ":e-block"),
  r("y d e # -> 35,433",
  // e-block-202, 
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act433 = (CAT NM (POLYSYLLABIC ROOT) EVAL '-S)
    ":e-block"),
  r("a n c e # -> 35,433",
  // e-block-203, 
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act433 = (CAT NM (POLYSYLLABIC ROOT) EVAL '-S)
    ":e-block"),
  r("e n c e # -> 35,433",
  // e-block-204, 
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act433 = (CAT NM (POLYSYLLABIC ROOT) EVAL '-S)
    ":e-block"),
  r("e e # -> 35,270",
  // e-block-205, 
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act270 = (CAT N (POLYSYLLABIC ROOT) EVAL '-S)
    ":e-block"),
  r("a g e # -> 35,433",
  // e-block-206, 
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act433 = (CAT NM (POLYSYLLABIC ROOT) EVAL '-S)
    ":e-block"),
  r("d g e # -> 35,270",
  // e-block-207, 
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act270 = (CAT N (POLYSYLLABIC ROOT) EVAL '-S)
    ":e-block"),
  r("d g e # -> 434,435",
  // e-block-208, 
    // act434 = (CAT V (PLAUSIBLE-ROOT ROOT) EVAL 'S-D)
    // act435 = (CAT N (PLAUSIBLE-ROOT ROOT) EVAL '-S)
    ":e-block"),
  r("e m e # -> 35,270",
  // e-block-209, 
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act270 = (CAT N (POLYSYLLABIC ROOT) EVAL '-S)
    ":e-block"),
  r("w a r e # -> 35,436",
  // e-block-210, 
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act436 = (CAT NM (POLYSYLLABIC ROOT) EVAL (PROGN (MARK-DICT LEX 'KIND...
    ":e-block"),
  r("p h o r e # -> 35,270",
  // e-block-211, 
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act270 = (CAT N (POLYSYLLABIC ROOT) EVAL '-S)
    ":e-block"),
  r("e t e # -> 35,270",
  // e-block-212, 
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act270 = (CAT N (POLYSYLLABIC ROOT) EVAL '-S)
    ":e-block"),
  r("consonant a t e # -> 131,259,162,359",
  // e-block-213, 
    // act131 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (POLYSYLLABIC ROOT)))
    // act259 = (CAT N T EVAL (PROGN (MARK-DICT LEX 'GUESSED 'T) '-S))
    // act162 = (CAT ADJ T EVAL '*)
    // act359 = (CAT V T EVAL (PROGN (MARK-DICT LEX 'FEATURES '(TRANS PASSIV...
    ":e-block"),
  r("y t e # -> 35,270",
  // e-block-214, 
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act270 = (CAT N (POLYSYLLABIC ROOT) EVAL '-S)
    ":e-block"),
  r("i n e # -> 19,437,438",
  // e-block-215, conditional phase-one
    // act19 = (KILL 3)
    // act437 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-KNOW...
    // act438 = (CAT NC T EVAL (PROGN (MARK-DICT LEX 'HAS-SUFFIX 'INE T T) (...
    ":e-block", false, true, false),
  r("i n e # -> 326,327,328,439,329,330",
  // e-block-216, phase-one
    // act326 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (MORPH-P...
    // act327 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-KNOWN-FORM-OF-CAT ROOT ...
    // act328 = (CAT ADV (AND (MORPH-ROOT STATE) (IS-KNOWN-FORM-OF-CAT ROOT ...
    // act439 = (CAT NM (AND (MORPH-ROOT STATE) (IS-KNOWN-FORM-OF-CAT ROOT '...
    // act329 = (CAT N (AND (MORPH-ROOT STATE) (IS-KNOWN-FORM-OF-CAT ROOT 'N...
    // act330 = (CAT V (AND (MORPH-ROOT STATE) (IS-KNOWN-FORM-OF-CAT ROOT 'V...
    ":e-block", true, false, false),
  r("i n e # -> 19,291,440,441,162",
  // e-block-217, conditional phase-one
    // act19 = (KILL 3)
    // act291 = (ADD I A)
    // act440 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-KNOW...
    // act441 = (CAT NMC T EVAL (PROGN (MARK-DICT LEX 'HAS-SUFFIX 'INE T T) ...
    // act162 = (CAT ADJ T EVAL '*)
    ":e-block", false, true, false),
  r("i n e # -> 19,194,442,441,162",
  // e-block-218, conditional phase-one
    // act19 = (KILL 3)
    // act194 = (ADD U S)
    // act442 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-KNOW...
    // act441 = (CAT NMC T EVAL (PROGN (MARK-DICT LEX 'HAS-SUFFIX 'INE T T) ...
    // act162 = (CAT ADJ T EVAL '*)
    ":e-block", false, true, false),
  r("i n e # -> 19,117,442,441,162",
  // e-block-219, conditional phase-one
    // act19 = (KILL 3)
    // act117 = (ADD A)
    // act442 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-KNOW...
    // act441 = (CAT NMC T EVAL (PROGN (MARK-DICT LEX 'HAS-SUFFIX 'INE T T) ...
    // act162 = (CAT ADJ T EVAL '*)
    ":e-block", false, true, false),
  r("consonant r i n e # -> 61,72,440,441,162",
  // e-block-220, conditional phase-one
    // act61 = (KILL 4)
    // act72 = (ADD E R)
    // act440 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-KNOW...
    // act441 = (CAT NMC T EVAL (PROGN (MARK-DICT LEX 'HAS-SUFFIX 'INE T T) ...
    // act162 = (CAT ADJ T EVAL '*)
    ":e-block", false, true, false),
  r("i n e # -> 19,443,441,162",
  // e-block-221, conditional phase-one
    // act19 = (KILL 3)
    // act443 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-FORM...
    // act441 = (CAT NMC T EVAL (PROGN (MARK-DICT LEX 'HAS-SUFFIX 'INE T T) ...
    // act162 = (CAT ADJ T EVAL '*)
    ":e-block", false, true, false),
  r("i n e # -> 19,68,444,441,162",
  // e-block-222, conditional phase-one
    // act19 = (KILL 3)
    // act68 = (ADD E)
    // act444 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (NEED-FINAL-E ROOT) (MORPH-...
    // act441 = (CAT NMC T EVAL (PROGN (MARK-DICT LEX 'HAS-SUFFIX 'INE T T) ...
    // act162 = (CAT ADJ T EVAL '*)
    ":e-block", false, true, false),
  r("t h i n e # -> 35,164",
  // e-block-223, 
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act164 = (CAT ADJ (POLYSYLLABIC ROOT) EVAL '*)
    ":e-block"),
  r("i n e # -> 131,445,162",
  // e-block-224, 
    // act131 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (POLYSYLLABIC ROOT)))
    // act445 = (CAT NMC T EVAL '-S)
    // act162 = (CAT ADJ T EVAL '*)
    ":e-block"),
  r("n o n e # -> 131,446,162",
  // e-block-225, 
    // act131 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (POLYSYLLABIC ROOT)))
    // act446 = (CAT NMC T EVAL (PROGN (MARK-DICT LEX 'HAS-SUFFIX 'ONE T T) ...
    // act162 = (CAT ADJ T EVAL '*)
    ":e-block"),
  r(" -> 180,158",
  // e-block-226, 
    // act180 = (TEST T)
    // act158 = (DO DEFAULT-RULE)
    ":e-block"),
 };

 protected static MorphRule[] gBlock = {//":g-block"
  r("- i n g # -> 61,180,447,162,448",
  // g-block-1, phase-one
    // act61 = (KILL 4)
    // act180 = (TEST T)
    // act447 = (CAT NMC *MAKE-GERUND-FLAG* EVAL '-S)
    // act162 = (CAT ADJ T EVAL '*)
    // act448 = (CAT V T EVAL (LIST ROOT '(PRESPART)))
    ":g-block", true, false, false),
  r("' i n g # -> 61,180,447,162,448",
  // g-block-2, phase-one
    // act61 = (KILL 4)
    // act180 = (TEST T)
    // act447 = (CAT NMC *MAKE-GERUND-FLAG* EVAL '-S)
    // act162 = (CAT ADJ T EVAL '*)
    // act448 = (CAT V T EVAL (LIST ROOT '(PRESPART)))
    ":g-block", true, false, false),
  r("consonant vowel b|d|g|k|l|m|n|p|r|s|t|z i n g # -> 19,68,449,447,162,448",
  // g-block-3, conditional phase-one
    // act19 = (KILL 3)
    // act68 = (ADD E)
    // act449 = (TEST (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'V) (TEST...
    // act447 = (CAT NMC *MAKE-GERUND-FLAG* EVAL '-S)
    // act162 = (CAT ADJ T EVAL '*)
    // act448 = (CAT V T EVAL (LIST ROOT '(PRESPART)))
    ":g-block", false, true, false),
  r("q u vowel b|d|g|k|l|m|n|p|r|s|t|z i n g # -> 19,68,449,447,162,448",
  // g-block-4, conditional phase-one
    // act19 = (KILL 3)
    // act68 = (ADD E)
    // act449 = (TEST (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'V) (TEST...
    // act447 = (CAT NMC *MAKE-GERUND-FLAG* EVAL '-S)
    // act162 = (CAT ADJ T EVAL '*)
    // act448 = (CAT V T EVAL (LIST ROOT '(PRESPART)))
    ":g-block", false, true, false),
  r("consonant y i n g # -> 61,450,449,447,162,448",
  // g-block-5, conditional phase-one
    // act61 = (KILL 4)
    // act450 = (ADD I E)
    // act449 = (TEST (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'V) (TEST...
    // act447 = (CAT NMC *MAKE-GERUND-FLAG* EVAL '-S)
    // act162 = (CAT ADJ T EVAL '*)
    // act448 = (CAT V T EVAL (LIST ROOT '(PRESPART)))
    ":g-block", false, true, false),
  r("i n g # -> 19,451,452,447,162,448,68,453,447,162,448",
  // g-block-6, conditional phase-one
    // act19 = (KILL 3)
    // act451 = (SETQ SUFFIX 'ING)
    // act452 = (TEST (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'V) (TEST...
    // act447 = (CAT NMC *MAKE-GERUND-FLAG* EVAL '-S)
    // act162 = (CAT ADJ T EVAL '*)
    // act448 = (CAT V T EVAL (LIST ROOT '(PRESPART)))
    // act68 = (ADD E)
    // act453 = (TEST (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'V) (TEST...
    // act447 = (CAT NMC *MAKE-GERUND-FLAG* EVAL '-S)
    // act162 = (CAT ADJ T EVAL '*)
    // act448 = (CAT V T EVAL (LIST ROOT '(PRESPART)))
    ":g-block", false, true, true),
  r("any & i n g # -> 61,454,447,455,448",
  // g-block-7, conditional phase-one
    // act61 = (KILL 4)
    // act454 = (TEST (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'V) (TEST...
    // act447 = (CAT NMC *MAKE-GERUND-FLAG* EVAL '-S)
    // act455 = (CAT ADJ T EVAL (PROGN (IF (TEST-ICODE ROOT 'V '(S-ED-*ED ES...
    // act448 = (CAT V T EVAL (LIST ROOT '(PRESPART)))
    ":g-block", false, true, false),
  r("i n g # -> 19,68,449,447,162,448",
  // g-block-8, conditional phase-one
    // act19 = (KILL 3)
    // act68 = (ADD E)
    // act449 = (TEST (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'V) (TEST...
    // act447 = (CAT NMC *MAKE-GERUND-FLAG* EVAL '-S)
    // act162 = (CAT ADJ T EVAL '*)
    // act448 = (CAT V T EVAL (LIST ROOT '(PRESPART)))
    ":g-block", false, true, false),
  r("c k i n g # -> 61,456,447,162,448",
  // g-block-9, conditional phase-one
    // act61 = (KILL 4)
    // act456 = (TEST (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'V) (TEST...
    // act447 = (CAT NMC *MAKE-GERUND-FLAG* EVAL '-S)
    // act162 = (CAT ADJ T EVAL '*)
    // act448 = (CAT V T EVAL (LIST ROOT '(PRESPART)))
    ":g-block", false, true, false),
  r("i s|z i n g # -> 19,68,203,447,162,448",
  // g-block-10, phase-one
    // act19 = (KILL 3)
    // act68 = (ADD E)
    // act203 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-ROOT...
    // act447 = (CAT NMC *MAKE-GERUND-FLAG* EVAL '-S)
    // act162 = (CAT ADJ T EVAL '*)
    // act448 = (CAT V T EVAL (LIST ROOT '(PRESPART)))
    ":g-block", true, false, false),
  r("o w n i n g # -> 102,204,457,162",
  // g-block-11, conditional phase-one
    // act102 = (KILL 6)
    // act204 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-ROOT...
    // act457 = (CAT NM T EVAL (PROGN (MARK-DICT LEX 'FALSE-ROOT ROOT T T) (...
    // act162 = (CAT ADJ T EVAL '*)
    ":g-block", false, true, false),
  r("i n g # -> 19,68,458,459,162",
  // g-block-12, conditional phase-one
    // act19 = (KILL 3)
    // act68 = (ADD E)
    // act458 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (IS...
    // act459 = (CAT NM T EVAL (COMPOUND-WITH-SUFFIX LEX 'N ROOT 1 'ING (IF ...
    // act162 = (CAT ADJ T EVAL '*)
    ":g-block", false, true, false),
  r("i n g # -> 19,458,460,162",
  // g-block-13, conditional phase-one
    // act19 = (KILL 3)
    // act458 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (IS...
    // act460 = (CAT NM T EVAL (COMPOUND-WITH-SUFFIX LEX 'N ROOT 0 'ING (IF ...
    // act162 = (CAT ADJ T EVAL '*)
    ":g-block", false, true, false),
  r("consonant vowel b|d|g|k|l|m|n|p|r|s|t|z & i n g # -> 61,458,461,162",
  // g-block-14, conditional phase-one
    // act61 = (KILL 4)
    // act458 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (IS...
    // act461 = (CAT NM T EVAL (COMPOUND-WITH-SUFFIX LEX 'N ROOT -1 'ING (IF...
    // act162 = (CAT ADJ T EVAL '*)
    ":g-block", false, true, false),
  r("i n g # -> 19,451,462,447,162,448,68,463,447,162,448",
  // g-block-15, conditional phase-one
    // act19 = (KILL 3)
    // act451 = (SETQ SUFFIX 'ING)
    // act462 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-ROOT...
    // act447 = (CAT NMC *MAKE-GERUND-FLAG* EVAL '-S)
    // act162 = (CAT ADJ T EVAL '*)
    // act448 = (CAT V T EVAL (LIST ROOT '(PRESPART)))
    // act68 = (ADD E)
    // act463 = (TEST (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'V) (NEED...
    // act447 = (CAT NMC *MAKE-GERUND-FLAG* EVAL '-S)
    // act162 = (CAT ADJ T EVAL '*)
    // act448 = (CAT V T EVAL (LIST ROOT '(PRESPART)))
    ":g-block", false, true, true),
  r("i n g # -> 19,68,464,447,162,448",
  // g-block-16, conditional phase-one
    // act19 = (KILL 3)
    // act68 = (ADD E)
    // act464 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (NEED-FINAL-E ROOT) (MORPH-...
    // act447 = (CAT NMC *MAKE-GERUND-FLAG* EVAL '-S)
    // act162 = (CAT ADJ T EVAL '*)
    // act448 = (CAT V T EVAL (LIST ROOT '(PRESPART)))
    ":g-block", false, true, false),
  r("c k i n g # -> 61,203,447,162,448",
  // g-block-17, conditional phase-one
    // act61 = (KILL 4)
    // act203 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-ROOT...
    // act447 = (CAT NMC *MAKE-GERUND-FLAG* EVAL '-S)
    // act162 = (CAT ADJ T EVAL '*)
    // act448 = (CAT V T EVAL (LIST ROOT '(PRESPART)))
    ":g-block", false, true, false),
  r("b|d|g|k|l|m|n|p|r|s|t|z & i n g # -> 61,203,447,162,448",
  // g-block-18, conditional phase-one
    // act61 = (KILL 4)
    // act203 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-ROOT...
    // act447 = (CAT NMC *MAKE-GERUND-FLAG* EVAL '-S)
    // act162 = (CAT ADJ T EVAL '*)
    // act448 = (CAT V T EVAL (LIST ROOT '(PRESPART)))
    ":g-block", false, true, false),
  r("consonant vowel l l i n g # -> 19,465,447,162,448",
  // g-block-19, 
    // act19 = (KILL 3)
    // act465 = (TEST (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'NN)))
    // act447 = (CAT NMC *MAKE-GERUND-FLAG* EVAL '-S)
    // act162 = (CAT ADJ T EVAL '*)
    // act448 = (CAT V T EVAL (LIST ROOT '(PRESPART)))
    ":g-block"),
  r("consonant vowel l l i n g # -> 61,465,447,162,448",
  // g-block-20, 
    // act61 = (KILL 4)
    // act465 = (TEST (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'NN)))
    // act447 = (CAT NMC *MAKE-GERUND-FLAG* EVAL '-S)
    // act162 = (CAT ADJ T EVAL '*)
    // act448 = (CAT V T EVAL (LIST ROOT '(PRESPART)))
    ":g-block"),
  r("l i n g # -> 19,68,466,447,162,448",
  // g-block-21, 
    // act19 = (KILL 3)
    // act68 = (ADD E)
    // act466 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (NEED-FINAL-E ROOT) (MORPH-...
    // act447 = (CAT NMC *MAKE-GERUND-FLAG* EVAL '-S)
    // act162 = (CAT ADJ T EVAL '*)
    // act448 = (CAT V T EVAL (LIST ROOT '(PRESPART)))
    ":g-block"),
  r("l i n g # -> 19,467,447,162,448",
  // g-block-22, 
    // act19 = (KILL 3)
    // act467 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-ROOT...
    // act447 = (CAT NMC *MAKE-GERUND-FLAG* EVAL '-S)
    // act162 = (CAT ADJ T EVAL '*)
    // act448 = (CAT V T EVAL (LIST ROOT '(PRESPART)))
    ":g-block"),
  r("l i n g # -> 61,35,468,469",
  // g-block-23, conditional phase-one
    // act61 = (KILL 4)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act468 = (SETQ SUFFIX 'LING)
    // act469 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'NN)) EV...
    ":g-block", false, true, false),
  r("l i n g # -> 61,35,468,470",
  // g-block-24, conditional phase-one
    // act61 = (KILL 4)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act468 = (SETQ SUFFIX 'LING)
    // act470 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(ADJ)))...
    ":g-block", false, true, false),
  r("t|d|l y i n g # -> 61,450,471,447,162,448",
  // g-block-25, 
    // act61 = (KILL 4)
    // act450 = (ADD I E)
    // act471 = (TEST (AND (MORPH-ROOT STATE) (MEMB ROOT '(TIE DIE LIE UNTIE...
    // act447 = (CAT NMC *MAKE-GERUND-FLAG* EVAL '-S)
    // act162 = (CAT ADJ T EVAL '*)
    // act448 = (CAT V T EVAL (LIST ROOT '(PRESPART)))
    ":g-block"),
  r("e n i n g # -> 19,203,447,162,472",
  // g-block-26, conditional phase-one
    // act19 = (KILL 3)
    // act203 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-ROOT...
    // act447 = (CAT NMC *MAKE-GERUND-FLAG* EVAL '-S)
    // act162 = (CAT ADJ T EVAL '*)
    // act472 = (CAT V T EVAL (LIST LEX (LIST 'ROOT ROOT) '(PRESPART)))
    ":g-block", false, true, false),
  r("e n i n g # -> 61,224,107,447,162,472",
  // g-block-27, conditional phase-one
    // act61 = (KILL 4)
    // act224 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-ROOT...
    // act107 = (ADD N)
    // act447 = (CAT NMC *MAKE-GERUND-FLAG* EVAL '-S)
    // act162 = (CAT ADJ T EVAL '*)
    // act472 = (CAT V T EVAL (LIST LEX (LIST 'ROOT ROOT) '(PRESPART)))
    ":g-block", false, true, false),
  r("e n i n g # -> 57,224,225,447,162,472",
  // g-block-28, conditional phase-one
    // act57 = (KILL 5)
    // act224 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-ROOT...
    // act225 = (ADD E N)
    // act447 = (CAT NMC *MAKE-GERUND-FLAG* EVAL '-S)
    // act162 = (CAT ADJ T EVAL '*)
    // act472 = (CAT V T EVAL (LIST LEX (LIST 'ROOT ROOT) '(PRESPART)))
    ":g-block", false, true, false),
  r("i n g # -> 19,467,447,162,472",
  // g-block-29, conditional phase-one
    // act19 = (KILL 3)
    // act467 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-ROOT...
    // act447 = (CAT NMC *MAKE-GERUND-FLAG* EVAL '-S)
    // act162 = (CAT ADJ T EVAL '*)
    // act472 = (CAT V T EVAL (LIST LEX (LIST 'ROOT ROOT) '(PRESPART)))
    ":g-block", false, true, false),
  r("i n g # -> 19,68,467,447,162,472",
  // g-block-30, conditional phase-one
    // act19 = (KILL 3)
    // act68 = (ADD E)
    // act467 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-ROOT...
    // act447 = (CAT NMC *MAKE-GERUND-FLAG* EVAL '-S)
    // act162 = (CAT ADJ T EVAL '*)
    // act472 = (CAT V T EVAL (LIST LEX (LIST 'ROOT ROOT) '(PRESPART)))
    ":g-block", false, true, false),
  r("y i n g # -> 19,473,447,474,448",
  // g-block-31, 
    // act19 = (KILL 3)
    // act473 = (TEST (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT '(V N))))
    // act447 = (CAT NMC *MAKE-GERUND-FLAG* EVAL '-S)
    // act474 = (CAT ADJ T EVAL (PROGN (MARK-DICT LEX 'GUESSED T) '*))
    // act448 = (CAT V T EVAL (LIST ROOT '(PRESPART)))
    ":g-block"),
  r("consonant vowel b|d|g|k|m|n|p|r|t & i n g # -> 61,473,447,474,448",
  // g-block-32, 
    // act61 = (KILL 4)
    // act473 = (TEST (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT '(V N))))
    // act447 = (CAT NMC *MAKE-GERUND-FLAG* EVAL '-S)
    // act474 = (CAT ADJ T EVAL (PROGN (MARK-DICT LEX 'GUESSED T) '*))
    // act448 = (CAT V T EVAL (LIST ROOT '(PRESPART)))
    ":g-block"),
  r("q u vowel b|d|g|k|m|n|p|r|t & i n g # -> 61,473,447,474,448",
  // g-block-33, 
    // act61 = (KILL 4)
    // act473 = (TEST (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT '(V N))))
    // act447 = (CAT NMC *MAKE-GERUND-FLAG* EVAL '-S)
    // act474 = (CAT ADJ T EVAL (PROGN (MARK-DICT LEX 'GUESSED T) '*))
    // act448 = (CAT V T EVAL (LIST ROOT '(PRESPART)))
    ":g-block"),
  r("consonant vowel l|s|z & i n g # -> 61,475,447,474,448",
  // g-block-34, 
    // act61 = (KILL 4)
    // act475 = (TEST (AND (POLYSYLLABIC ROOT) (MORPH-ROOT STATE) (OR (MORPH...
    // act447 = (CAT NMC *MAKE-GERUND-FLAG* EVAL '-S)
    // act474 = (CAT ADJ T EVAL (PROGN (MARK-DICT LEX 'GUESSED T) '*))
    // act448 = (CAT V T EVAL (LIST ROOT '(PRESPART)))
    ":g-block"),
  r("consonant vowel l|s|z & i n g # -> 19,475,447,474,448",
  // g-block-35, 
    // act19 = (KILL 3)
    // act475 = (TEST (AND (POLYSYLLABIC ROOT) (MORPH-ROOT STATE) (OR (MORPH...
    // act447 = (CAT NMC *MAKE-GERUND-FLAG* EVAL '-S)
    // act474 = (CAT ADJ T EVAL (PROGN (MARK-DICT LEX 'GUESSED T) '*))
    // act448 = (CAT V T EVAL (LIST ROOT '(PRESPART)))
    ":g-block"),
  r("consonant a|e|o l|s|z & i n g # -> 61,476,447,474,448",
  // g-block-36, 
    // act61 = (KILL 4)
    // act476 = (TEST (AND (POLYSYLLABIC ROOT) (MORPH-ROOT STATE) (MAY-BE-CA...
    // act447 = (CAT NMC *MAKE-GERUND-FLAG* EVAL '-S)
    // act474 = (CAT ADJ T EVAL (PROGN (MARK-DICT LEX 'GUESSED T) '*))
    // act448 = (CAT V T EVAL (LIST ROOT '(PRESPART)))
    ":g-block"),
  r("consonant vowel l|s|z & i n g # -> 19,473,447,474,448",
  // g-block-37, 
    // act19 = (KILL 3)
    // act473 = (TEST (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT '(V N))))
    // act447 = (CAT NMC *MAKE-GERUND-FLAG* EVAL '-S)
    // act474 = (CAT ADJ T EVAL (PROGN (MARK-DICT LEX 'GUESSED T) '*))
    // act448 = (CAT V T EVAL (LIST ROOT '(PRESPART)))
    ":g-block"),
  r("consonant vowel b|d|g|k|m|n|p|r|t|l|s|z i n g # -> 19,68,473,447,474,448",
  // g-block-38, 
    // act19 = (KILL 3)
    // act68 = (ADD E)
    // act473 = (TEST (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT '(V N))))
    // act447 = (CAT NMC *MAKE-GERUND-FLAG* EVAL '-S)
    // act474 = (CAT ADJ T EVAL (PROGN (MARK-DICT LEX 'GUESSED T) '*))
    // act448 = (CAT V T EVAL (LIST ROOT '(PRESPART)))
    ":g-block"),
  r("q u vowel b|d|g|k|m|n|p|r|t i n g # -> 19,68,473,447,474,448",
  // g-block-39, 
    // act19 = (KILL 3)
    // act68 = (ADD E)
    // act473 = (TEST (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT '(V N))))
    // act447 = (CAT NMC *MAKE-GERUND-FLAG* EVAL '-S)
    // act474 = (CAT ADJ T EVAL (PROGN (MARK-DICT LEX 'GUESSED T) '*))
    // act448 = (CAT V T EVAL (LIST ROOT '(PRESPART)))
    ":g-block"),
  r("vowel consonant i n g # -> 19,68,477,447,474,448",
  // g-block-40, 
    // act19 = (KILL 3)
    // act68 = (ADD E)
    // act477 = (TEST (AND (NEED-FINAL-E ROOT) (MORPH-ROOT STATE) (MAY-BE-CA...
    // act447 = (CAT NMC *MAKE-GERUND-FLAG* EVAL '-S)
    // act474 = (CAT ADJ T EVAL (PROGN (MARK-DICT LEX 'GUESSED T) '*))
    // act448 = (CAT V T EVAL (LIST ROOT '(PRESPART)))
    ":g-block"),
  r("q u i t i n g # -> 19,68,473,447,474,448",
  // g-block-41, 
    // act19 = (KILL 3)
    // act68 = (ADD E)
    // act473 = (TEST (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT '(V N))))
    // act447 = (CAT NMC *MAKE-GERUND-FLAG* EVAL '-S)
    // act474 = (CAT ADJ T EVAL (PROGN (MARK-DICT LEX 'GUESSED T) '*))
    // act448 = (CAT V T EVAL (LIST ROOT '(PRESPART)))
    ":g-block"),
  r("f i t i n g # -> 19,473,447,474,448",
  // g-block-42, 
    // act19 = (KILL 3)
    // act473 = (TEST (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT '(V N))))
    // act447 = (CAT NMC *MAKE-GERUND-FLAG* EVAL '-S)
    // act474 = (CAT ADJ T EVAL (PROGN (MARK-DICT LEX 'GUESSED T) '*))
    // act448 = (CAT V T EVAL (LIST ROOT '(PRESPART)))
    ":g-block"),
  r("vowel s|x i t i n g # -> 19,473,447,474,448",
  // g-block-43, 
    // act19 = (KILL 3)
    // act473 = (TEST (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT '(V N))))
    // act447 = (CAT NMC *MAKE-GERUND-FLAG* EVAL '-S)
    // act474 = (CAT ADJ T EVAL (PROGN (MARK-DICT LEX 'GUESSED T) '*))
    // act448 = (CAT V T EVAL (LIST ROOT '(PRESPART)))
    ":g-block"),
  r("i c|r i t i n g # -> 19,473,447,474,448",
  // g-block-44, 
    // act19 = (KILL 3)
    // act473 = (TEST (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT '(V N))))
    // act447 = (CAT NMC *MAKE-GERUND-FLAG* EVAL '-S)
    // act474 = (CAT ADJ T EVAL (PROGN (MARK-DICT LEX 'GUESSED T) '*))
    // act448 = (CAT V T EVAL (LIST ROOT '(PRESPART)))
    ":g-block"),
  r("c r e d i t i n g # -> 19,473,447,474,448",
  // g-block-45, 
    // act19 = (KILL 3)
    // act473 = (TEST (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT '(V N))))
    // act447 = (CAT NMC *MAKE-GERUND-FLAG* EVAL '-S)
    // act474 = (CAT ADJ T EVAL (PROGN (MARK-DICT LEX 'GUESSED T) '*))
    // act448 = (CAT V T EVAL (LIST ROOT '(PRESPART)))
    ":g-block"),
  r("h a|i b i t i n g # -> 19,473,447,474,448",
  // g-block-46, 
    // act19 = (KILL 3)
    // act473 = (TEST (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT '(V N))))
    // act447 = (CAT NMC *MAKE-GERUND-FLAG* EVAL '-S)
    // act474 = (CAT ADJ T EVAL (PROGN (MARK-DICT LEX 'GUESSED T) '*))
    // act448 = (CAT V T EVAL (LIST ROOT '(PRESPART)))
    ":g-block"),
  r("consonant & i t i n g # -> 19,473,447,474,448",
  // g-block-47, 
    // act19 = (KILL 3)
    // act473 = (TEST (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT '(V N))))
    // act447 = (CAT NMC *MAKE-GERUND-FLAG* EVAL '-S)
    // act474 = (CAT ADJ T EVAL (PROGN (MARK-DICT LEX 'GUESSED T) '*))
    // act448 = (CAT V T EVAL (LIST ROOT '(PRESPART)))
    ":g-block"),
  r("consonant i t i n g # -> 19,68,478,447,474,448",
  // g-block-48, 
    // act19 = (KILL 3)
    // act68 = (ADD E)
    // act478 = (TEST (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT '(V N)) (NOT ...
    // act447 = (CAT NMC *MAKE-GERUND-FLAG* EVAL '-S)
    // act474 = (CAT ADJ T EVAL (PROGN (MARK-DICT LEX 'GUESSED T) '*))
    // act448 = (CAT V T EVAL (LIST ROOT '(PRESPART)))
    ":g-block"),
  r("t h e r i n g # -> 19,473,447,474,448",
  // g-block-49, 
    // act19 = (KILL 3)
    // act473 = (TEST (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT '(V N))))
    // act447 = (CAT NMC *MAKE-GERUND-FLAG* EVAL '-S)
    // act474 = (CAT ADJ T EVAL (PROGN (MARK-DICT LEX 'GUESSED T) '*))
    // act448 = (CAT V T EVAL (LIST ROOT '(PRESPART)))
    ":g-block"),
  r("h e r i n g # -> 19,68,473,447,474,448",
  // g-block-50, 
    // act19 = (KILL 3)
    // act68 = (ADD E)
    // act473 = (TEST (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT '(V N))))
    // act447 = (CAT NMC *MAKE-GERUND-FLAG* EVAL '-S)
    // act474 = (CAT ADJ T EVAL (PROGN (MARK-DICT LEX 'GUESSED T) '*))
    // act448 = (CAT V T EVAL (LIST ROOT '(PRESPART)))
    ":g-block"),
  r("e n|r i n g # -> 19,473,447,474,448",
  // g-block-51, 
    // act19 = (KILL 3)
    // act473 = (TEST (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT '(V N))))
    // act447 = (CAT NMC *MAKE-GERUND-FLAG* EVAL '-S)
    // act474 = (CAT ADJ T EVAL (PROGN (MARK-DICT LEX 'GUESSED T) '*))
    // act448 = (CAT V T EVAL (LIST ROOT '(PRESPART)))
    ":g-block"),
  r("consonant a|e|i|o|u|y b|d|g|k|l|m|n|p|r|s|t i n g # -> 19,68,473,447,474,448",
  // g-block-52, 
    // act19 = (KILL 3)
    // act68 = (ADD E)
    // act473 = (TEST (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT '(V N))))
    // act447 = (CAT NMC *MAKE-GERUND-FLAG* EVAL '-S)
    // act474 = (CAT ADJ T EVAL (PROGN (MARK-DICT LEX 'GUESSED T) '*))
    // act448 = (CAT V T EVAL (LIST ROOT '(PRESPART)))
    ":g-block"),
  r("consonant a|e|i|o|u|y c|g|s|v|z i n g # -> 19,68,473,447,474,448",
  // g-block-53, 
    // act19 = (KILL 3)
    // act68 = (ADD E)
    // act473 = (TEST (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT '(V N))))
    // act447 = (CAT NMC *MAKE-GERUND-FLAG* EVAL '-S)
    // act474 = (CAT ADJ T EVAL (PROGN (MARK-DICT LEX 'GUESSED T) '*))
    // act448 = (CAT V T EVAL (LIST ROOT '(PRESPART)))
    ":g-block"),
  r("consonant vowel b|d|f|g|k|l|m|n|p|r|s|t|v|z & i n g # -> 61,479,447,474,448",
  // g-block-54, 
    // act61 = (KILL 4)
    // act479 = (TEST (AND (NEED-FINAL-E (PACK-LEX ROOT 'E)) (MORPH-ROOT STA...
    // act447 = (CAT NMC *MAKE-GERUND-FLAG* EVAL '-S)
    // act474 = (CAT ADJ T EVAL (PROGN (MARK-DICT LEX 'GUESSED T) '*))
    // act448 = (CAT V T EVAL (LIST ROOT '(PRESPART)))
    ":g-block"),
  r("l|s|z & i n g # -> 19,473,447,474,448",
  // g-block-55, 
    // act19 = (KILL 3)
    // act473 = (TEST (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT '(V N))))
    // act447 = (CAT NMC *MAKE-GERUND-FLAG* EVAL '-S)
    // act474 = (CAT ADJ T EVAL (PROGN (MARK-DICT LEX 'GUESSED T) '*))
    // act448 = (CAT V T EVAL (LIST ROOT '(PRESPART)))
    ":g-block"),
  r("consonant c|l|s|u|v i n g # -> 19,68,473,447,474,448",
  // g-block-56, 
    // act19 = (KILL 3)
    // act68 = (ADD E)
    // act473 = (TEST (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT '(V N))))
    // act447 = (CAT NMC *MAKE-GERUND-FLAG* EVAL '-S)
    // act474 = (CAT ADJ T EVAL (PROGN (MARK-DICT LEX 'GUESSED T) '*))
    // act448 = (CAT V T EVAL (LIST ROOT '(PRESPART)))
    ":g-block"),
  r("consonant vowel & b|d|f|g|k|l|m|n|p|r|s|t|v|z i n g # -> 19,473,447,162,448",
  // g-block-57, 
    // act19 = (KILL 3)
    // act473 = (TEST (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT '(V N))))
    // act447 = (CAT NMC *MAKE-GERUND-FLAG* EVAL '-S)
    // act162 = (CAT ADJ T EVAL '*)
    // act448 = (CAT V T EVAL (LIST ROOT '(PRESPART)))
    ":g-block"),
  r("c i n g # -> 19,68,473,447,474,448",
  // g-block-58, 
    // act19 = (KILL 3)
    // act68 = (ADD E)
    // act473 = (TEST (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT '(V N))))
    // act447 = (CAT NMC *MAKE-GERUND-FLAG* EVAL '-S)
    // act474 = (CAT ADJ T EVAL (PROGN (MARK-DICT LEX 'GUESSED T) '*))
    // act448 = (CAT V T EVAL (LIST ROOT '(PRESPART)))
    ":g-block"),
  r("consonant w i n g # -> 192,162,480",
  // g-block-59, 
    // act192 = (CAT N T EVAL '-S)
    // act162 = (CAT ADJ T EVAL '*)
    // act480 = (CAT V T EVAL 'S-ED)
    ":g-block"),
  r("vowel f|l|s|z & i n g # -> 19,473,447,474,448",
  // g-block-60, 
    // act19 = (KILL 3)
    // act473 = (TEST (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT '(V N))))
    // act447 = (CAT NMC *MAKE-GERUND-FLAG* EVAL '-S)
    // act474 = (CAT ADJ T EVAL (PROGN (MARK-DICT LEX 'GUESSED T) '*))
    // act448 = (CAT V T EVAL (LIST ROOT '(PRESPART)))
    ":g-block"),
  r("vowel consonant & i n g # -> 61,447,474,448",
  // g-block-61, 
    // act61 = (KILL 4)
    // act447 = (CAT NMC *MAKE-GERUND-FLAG* EVAL '-S)
    // act474 = (CAT ADJ T EVAL (PROGN (MARK-DICT LEX 'GUESSED T) '*))
    // act448 = (CAT V T EVAL (LIST ROOT '(PRESPART)))
    ":g-block"),
  r("vowel s|z i n g # -> 19,68,473,447,474,448",
  // g-block-62, 
    // act19 = (KILL 3)
    // act68 = (ADD E)
    // act473 = (TEST (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT '(V N))))
    // act447 = (CAT NMC *MAKE-GERUND-FLAG* EVAL '-S)
    // act474 = (CAT ADJ T EVAL (PROGN (MARK-DICT LEX 'GUESSED T) '*))
    // act448 = (CAT V T EVAL (LIST ROOT '(PRESPART)))
    ":g-block"),
  r("i n g # -> 19,481,447,474,448",
  // g-block-63, 
    // act19 = (KILL 3)
    // act481 = (TEST (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT '(V N)) (NOT ...
    // act447 = (CAT NMC *MAKE-GERUND-FLAG* EVAL '-S)
    // act474 = (CAT ADJ T EVAL (PROGN (MARK-DICT LEX 'GUESSED T) '*))
    // act448 = (CAT V T EVAL (LIST ROOT '(PRESPART)))
    ":g-block"),
  r("i n g # -> 19,68,105,447,474,448",
  // g-block-64, 
    // act19 = (KILL 3)
    // act68 = (ADD E)
    // act105 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (NEED-FINAL-E ROOT)))
    // act447 = (CAT NMC *MAKE-GERUND-FLAG* EVAL '-S)
    // act474 = (CAT ADJ T EVAL (PROGN (MARK-DICT LEX 'GUESSED T) '*))
    // act448 = (CAT V T EVAL (LIST ROOT '(PRESPART)))
    ":g-block"),
  r("i n g # -> 19,269,447,474,448",
  // g-block-65, 
    // act19 = (KILL 3)
    // act269 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (NE...
    // act447 = (CAT NMC *MAKE-GERUND-FLAG* EVAL '-S)
    // act474 = (CAT ADJ T EVAL (PROGN (MARK-DICT LEX 'GUESSED T) '*))
    // act448 = (CAT V T EVAL (LIST ROOT '(PRESPART)))
    ":g-block"),
  r("i n g # -> 19,68,35,447,474,448",
  // g-block-66, 
    // act19 = (KILL 3)
    // act68 = (ADD E)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act447 = (CAT NMC *MAKE-GERUND-FLAG* EVAL '-S)
    // act474 = (CAT ADJ T EVAL (PROGN (MARK-DICT LEX 'GUESSED T) '*))
    // act448 = (CAT V T EVAL (LIST ROOT '(PRESPART)))
    ":g-block"),
  r("b e r g # -> 152",
  // g-block-67, 
    // act152 = (CAT LASTNAME (PLAUSIBLE-ROOT ROOT) EVAL '*)
    ":g-block"),
  r(" -> 180,158",
  // g-block-68, 
    // act180 = (TEST T)
    // act158 = (DO DEFAULT-RULE)
    ":g-block"),
 };

 protected static MorphRule[] lBlock = {//":l-block"
  r("c i a l # -> 19,68,105,482",
  // l-block-1, conditional phase-one
    // act19 = (KILL 3)
    // act68 = (ADD E)
    // act105 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (NEED-FINAL-E ROOT)))
    // act482 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(NN A...
    ":l-block", false, true, false),
  r("o d i a l # -> 61,35,483",
  // l-block-2, conditional phase-one
    // act61 = (KILL 4)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act483 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'PREFI...
    ":l-block", false, true, false),
  r("a|e n t i a l # -> 61,484,35,482",
  // l-block-3, conditional phase-one
    // act61 = (KILL 4)
    // act484 = (ADD C E)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act482 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(NN A...
    ":l-block", false, true, false),
  r("i a l # -> 19,485,482",
  // l-block-4, conditional phase-one
    // act19 = (KILL 3)
    // act485 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-KNOW...
    // act482 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(NN A...
    ":l-block", false, true, false),
  r("i a l # -> 19,68,485,482",
  // l-block-5, conditional phase-one
    // act19 = (KILL 3)
    // act68 = (ADD E)
    // act485 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-KNOW...
    // act482 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(NN A...
    ":l-block", false, true, false),
  r("i a l # -> 19,31,485,482",
  // l-block-6, conditional phase-one
    // act19 = (KILL 3)
    // act31 = (ADD Y)
    // act485 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-KNOW...
    // act482 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(NN A...
    ":l-block", false, true, false),
  r("consonant e a l # -> 50,485,486",
  // l-block-7, conditional phase-one
    // act50 = (KILL 2)
    // act485 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-KNOW...
    // act486 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(NN A...
    ":l-block", false, true, false),
  r("consonant e a l # -> 19,485,486",
  // l-block-8, conditional phase-one
    // act19 = (KILL 3)
    // act485 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-KNOW...
    // act486 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(NN A...
    ":l-block", false, true, false),
  r("t u a l # -> 19,485,487",
  // l-block-9, conditional phase-one
    // act19 = (KILL 3)
    // act485 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-KNOW...
    // act487 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(NN A...
    ":l-block", false, true, false),
  r("s u a l # -> 19,68,485,487",
  // l-block-10, conditional phase-one
    // act19 = (KILL 3)
    // act68 = (ADD E)
    // act485 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-KNOW...
    // act487 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(NN A...
    ":l-block", false, true, false),
  r("o l o g i c a l # -> 61,31,35,488",
  // l-block-11, phase-one
    // act61 = (KILL 4)
    // act31 = (ADD Y)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act488 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'N)) E...
    ":l-block", true, false, false),
  r("p e t a l # -> 57,35,489",
  // l-block-12, conditional phase-one
    // act57 = (KILL 5)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act489 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(PREF...
    ":l-block", false, true, false),
  r("vowel b|d|g|l|m|n|p|r|s|t & a l # -> 19,131,490",
  // l-block-13, conditional phase-one
    // act19 = (KILL 3)
    // act131 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (POLYSYLLABIC ROOT)))
    // act490 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(NN A...
    ":l-block", false, true, false),
  r("vowel b|d|g|l|m|n|p|r|s|t & a l # -> 19,131,491",
  // l-block-14, conditional phase-one
    // act19 = (KILL 3)
    // act131 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (POLYSYLLABIC ROOT)))
    // act491 = (CAT NMC (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(V)))...
    ":l-block", false, true, false),
  r("vowel t h a l # -> 50,131,491",
  // l-block-15, conditional phase-one
    // act50 = (KILL 2)
    // act131 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (POLYSYLLABIC ROOT)))
    // act491 = (CAT NMC (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(V)))...
    ":l-block", false, true, false),
  r("vowel s s a l # -> 50,131,491",
  // l-block-16, conditional phase-one
    // act50 = (KILL 2)
    // act131 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (POLYSYLLABIC ROOT)))
    // act491 = (CAT NMC (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(V)))...
    ":l-block", false, true, false),
  r("vowel l|m|n|r a l # -> 50,131,491",
  // l-block-17, conditional phase-one
    // act50 = (KILL 2)
    // act131 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (POLYSYLLABIC ROOT)))
    // act491 = (CAT NMC (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(V)))...
    ":l-block", false, true, false),
  r("s|v|z a l # -> 50,68,325,491",
  // l-block-18, conditional phase-one
    // act50 = (KILL 2)
    // act68 = (ADD E)
    // act325 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (POLYSYLLABIC ROOT) (NEED-F...
    // act491 = (CAT NMC (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(V)))...
    ":l-block", false, true, false),
  r("i|u t a l # -> 50,68,325,491",
  // l-block-19, conditional phase-one
    // act50 = (KILL 2)
    // act68 = (ADD E)
    // act325 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (POLYSYLLABIC ROOT) (NEED-F...
    // act491 = (CAT NMC (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(V)))...
    ":l-block", false, true, false),
  r("n|p|r i a l # -> 19,31,131,491",
  // l-block-20, conditional phase-one
    // act19 = (KILL 3)
    // act31 = (ADD Y)
    // act131 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (POLYSYLLABIC ROOT)))
    // act491 = (CAT NMC (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(V)))...
    ":l-block", false, true, false),
  r("n t a l # -> 50,492,491",
  // l-block-21, conditional phase-one
    // act50 = (KILL 2)
    // act492 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (HAS-PRE...
    // act491 = (CAT NMC (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(V)))...
    ":l-block", false, true, false),
  r("a|e|o w|y a l # -> 50,131,491",
  // l-block-22, conditional phase-one
    // act50 = (KILL 2)
    // act131 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (POLYSYLLABIC ROOT)))
    // act491 = (CAT NMC (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(V)))...
    ":l-block", false, true, false),
  r("consonant u a l # -> 50,68,131,491",
  // l-block-23, conditional phase-one
    // act50 = (KILL 2)
    // act68 = (ADD E)
    // act131 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (POLYSYLLABIC ROOT)))
    // act491 = (CAT NMC (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(V)))...
    ":l-block", false, true, false),
  r("consonant a l # -> 50,68,105,490",
  // l-block-24, conditional phase-one
    // act50 = (KILL 2)
    // act68 = (ADD E)
    // act105 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (NEED-FINAL-E ROOT)))
    // act490 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(NN A...
    ":l-block", false, true, false),
  r("e a d a l # -> 50,493,491",
  // l-block-25, conditional phase-one
    // act50 = (KILL 2)
    // act493 = (TEST (AND (PLAUSIBLE-ROOT ROOT)))
    // act491 = (CAT NMC (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(V)))...
    ":l-block", false, true, false),
  r("consonant a l # -> 50,35,490",
  // l-block-26, conditional phase-one
    // act50 = (KILL 2)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act490 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(NN A...
    ":l-block", false, true, false),
  r("consonant u a l # -> 50,68,131,490",
  // l-block-27, conditional phase-one
    // act50 = (KILL 2)
    // act68 = (ADD E)
    // act131 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (POLYSYLLABIC ROOT)))
    // act490 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(NN A...
    ":l-block", false, true, false),
  r("a l # -> 24,131,490",
  // l-block-28, conditional phase-one
    // act24 = (KILL 1)
    // act131 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (POLYSYLLABIC ROOT)))
    // act490 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(NN A...
    ":l-block", false, true, false),
  r("a l # -> 50,408,494,495",
  // l-block-29, conditional phase-one
    // act50 = (KILL 2)
    // act408 = (ADD O U S)
    // act494 = (TEST (AND (POLYSYLLABIC ROOT) (MORPH-ROOT STATE) (IS-KNOWN-...
    // act495 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADJ))...
    ":l-block", false, true, false),
  r("a l # -> 50,194,496,497",
  // l-block-30, conditional phase-one
    // act50 = (KILL 2)
    // act194 = (ADD U S)
    // act496 = (TEST (AND (POLYSYLLABIC ROOT) (MORPH-ROOT STATE) (NOT (PATT...
    // act497 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'NN)) ...
    ":l-block", false, true, false),
  r("a l # -> 50,142,116,497",
  // l-block-31, conditional phase-one
    // act50 = (KILL 2)
    // act142 = (TEST (POLYSYLLABIC ROOT))
    // act116 = (ADD U M)
    // act497 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'NN)) ...
    ":l-block", false, true, false),
  r("a l # -> 50,132,498,497",
  // l-block-32, conditional phase-one
    // act50 = (KILL 2)
    // act132 = (ADD O N)
    // act498 = (TEST (AND (POLYSYLLABIC ROOT) (> (NCHARS ROOT) 3) (MORPH-RO...
    // act497 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'NN)) ...
    ":l-block", false, true, false),
  r("consonant a l # -> 50,37,131,499",
  // l-block-33, conditional phase-one
    // act50 = (KILL 2)
    // act37 = (ADD O)
    // act131 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (POLYSYLLABIC ROOT)))
    // act499 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-KNOWN-WORD ROOT) (IS-RO...
    ":l-block", false, true, false),
  r("n s u a l # -> 19,68,35,490",
  // l-block-34, conditional phase-one
    // act19 = (KILL 3)
    // act68 = (ADD E)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act490 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(NN A...
    ":l-block", false, true, false),
  r("i c a l # -> 61,68,500",
  // l-block-35, conditional phase-one
    // act61 = (KILL 4)
    // act68 = (ADD E)
    // act500 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-KNOWN-WORD ROOT) (IS-RO...
    ":l-block", false, true, false),
  r("i c a l # -> 61,31,500",
  // l-block-36, conditional phase-one
    // act61 = (KILL 4)
    // act31 = (ADD Y)
    // act500 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-KNOWN-WORD ROOT) (IS-RO...
    ":l-block", false, true, false),
  r("i c a l # -> 61,500",
  // l-block-37, conditional phase-one
    // act61 = (KILL 4)
    // act500 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-KNOWN-WORD ROOT) (IS-RO...
    ":l-block", false, true, false),
  r("i c a l # -> 61,68,501",
  // l-block-38, conditional phase-one
    // act61 = (KILL 4)
    // act68 = (ADD E)
    // act501 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(NN A...
    ":l-block", false, true, false),
  r("i c a l # -> 61,501",
  // l-block-39, conditional phase-one
    // act61 = (KILL 4)
    // act501 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(NN A...
    ":l-block", false, true, false),
  r("consonant r i c a l # -> 57,72,501",
  // l-block-40, conditional phase-one
    // act57 = (KILL 5)
    // act72 = (ADD E R)
    // act501 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(NN A...
    ":l-block", false, true, false),
  r("consonant r i c a l # -> 61,31,501",
  // l-block-41, conditional phase-one
    // act61 = (KILL 4)
    // act31 = (ADD Y)
    // act501 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(NN A...
    ":l-block", false, true, false),
  r("i c a l # -> 50,22,501",
  // l-block-42, conditional phase-one
    // act50 = (KILL 2)
    // act22 = (ADD S)
    // act501 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(NN A...
    ":l-block", false, true, false),
  r("i c a l # -> 50,487",
  // l-block-43, conditional phase-one
    // act50 = (KILL 2)
    // act487 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(NN A...
    ":l-block", false, true, false),
  r("n|t|c a l # -> 164",
  // l-block-44, 
    // act164 = (CAT ADJ (POLYSYLLABIC ROOT) EVAL '*)
    ":l-block"),
  r("i a l # -> 502,164",
  // l-block-45, 
    // act502 = (TEST (> (NCHARS ROOT) 4))
    // act164 = (CAT ADJ (POLYSYLLABIC ROOT) EVAL '*)
    ":l-block"),
  r("a l # -> 503,162,504",
  // l-block-46, 
    // act503 = (TEST (AND (POLYSYLLABIC ROOT) (> (NCHARS ROOT) 3)))
    // act162 = (CAT ADJ T EVAL '*)
    // act504 = (CAT N T EVAL (PROGN (MARK-DICT LEX 'GUESSED 'T) (LIST LEX '...
    ":l-block"),
  r("consonant i f u l # -> 61,31,35,505",
  // l-block-47, conditional phase-one
    // act61 = (KILL 4)
    // act31 = (ADD Y)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act505 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(N V ...
    ":l-block", false, true, false),
  r("consonant i e s f u l l # -> 113,31,506",
  // l-block-48, conditional phase-one
    // act113 = (KILL 7)
    // act31 = (ADD Y)
    // act506 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'N) (NOT...
    ":l-block", false, true, false),
  r("consonant i e s f u l l # -> 57,35,507",
  // l-block-49, conditional phase-one
    // act57 = (KILL 5)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act507 = (CAT N (AND (MORPH-ROOT STATE) (IS-KNOWN-WORD ROOT)) EVAL (L...
    ":l-block", false, true, false),
  r("e s f u l l # -> 57,508",
  // l-block-50, 
    // act57 = (KILL 5)
    // act508 = (CAT N (AND (NEED-FINAL-E ROOT) (MORPH-ROOT STATE) (MAY-BE-C...
    ":l-block"),
  r("c|g e s f u l l # -> 57,509",
  // l-block-51, 
    // act57 = (KILL 5)
    // act509 = (CAT N (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT 'N)) EVAL (L...
    ":l-block"),
  r("s|z & e s f u l l # -> 102,509",
  // l-block-52, 
    // act102 = (KILL 6)
    // act509 = (CAT N (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT 'N)) EVAL (L...
    ":l-block"),
  r("u s e s f u l l # -> 102,509",
  // l-block-53, 
    // act102 = (KILL 6)
    // act509 = (CAT N (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT 'N)) EVAL (L...
    ":l-block"),
  r("vowel s|z e s f u l l # -> 57,148,509",
  // l-block-54, 
    // act57 = (KILL 5)
    // act148 = (TEST (NEED-FINAL-E ROOT))
    // act509 = (CAT N (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT 'N)) EVAL (L...
    ":l-block"),
  r("s|z e s f u l l # -> 102,509",
  // l-block-55, 
    // act102 = (KILL 6)
    // act509 = (CAT N (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT 'N)) EVAL (L...
    ":l-block"),
  r("consonant vowel b|d|g|k|l|m|n|p|r|s|t|v e s f u l l # -> 57,509",
  // l-block-56, 
    // act57 = (KILL 5)
    // act509 = (CAT N (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT 'N)) EVAL (L...
    ":l-block"),
  r("consonant vowel & b|d|g|k|l|m|n|p|r|s|t|v e s f u l l # -> 102,509",
  // l-block-57, 
    // act102 = (KILL 6)
    // act509 = (CAT N (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT 'N)) EVAL (L...
    ":l-block"),
  r("consonant vowel vowel b|c|d|f|g|k|l|m|n|p|q|r|t|v|w|y e s f u l l # -> 57,509",
  // l-block-58, 
    // act57 = (KILL 5)
    // act509 = (CAT N (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT 'N)) EVAL (L...
    ":l-block"),
  r("l e s f u l l # -> 57,509",
  // l-block-59, 
    // act57 = (KILL 5)
    // act509 = (CAT N (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT 'N)) EVAL (L...
    ":l-block"),
  r("y e s f u l l # -> 57,509",
  // l-block-60, 
    // act57 = (KILL 5)
    // act509 = (CAT N (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT 'N)) EVAL (L...
    ":l-block"),
  r("e s f u l l # -> 102,509",
  // l-block-61, 
    // act102 = (KILL 6)
    // act509 = (CAT N (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT 'N)) EVAL (L...
    ":l-block"),
  r("s f u l l # -> 57,35,510",
  // l-block-62, conditional phase-one
    // act57 = (KILL 5)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act510 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'N)) EVA...
    ":l-block", false, true, false),
  r("e s f u l l # -> 57,174,511",
  // l-block-63, 
    // act57 = (KILL 5)
    // act174 = (TEST (AND (NEED-FINAL-E ROOT) (PLAUSIBLE-ROOT ROOT)))
    // act511 = (CAT N T EVAL (PROGN (MARK-DICT LEX 'GUESSED 'T) (LIST (MORP...
    ":l-block"),
  r("c|s h e s f u l l # -> 102,35,511",
  // l-block-64, 
    // act102 = (KILL 6)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act511 = (CAT N T EVAL (PROGN (MARK-DICT LEX 'GUESSED 'T) (LIST (MORP...
    ":l-block"),
  r("c|g e s f u l l # -> 57,35,511",
  // l-block-65, 
    // act57 = (KILL 5)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act511 = (CAT N T EVAL (PROGN (MARK-DICT LEX 'GUESSED 'T) (LIST (MORP...
    ":l-block"),
  r("consonant o s f u l l # -> 57,512",
  // l-block-66, 
    // act57 = (KILL 5)
    // act512 = (CAT N (AND (MORPH-ROOT STATE) (NOT (POLYSYLLABIC ROOT))) EV...
    ":l-block"),
  r("s f u l l # -> 57,35,511",
  // l-block-67, 
    // act57 = (KILL 5)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act511 = (CAT N T EVAL (PROGN (MARK-DICT LEX 'GUESSED 'T) (LIST (MORP...
    ":l-block"),
  r("f u l l # -> 61,35,513",
  // l-block-68, conditional phase-one
    // act61 = (KILL 4)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act513 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'N)) EVA...
    ":l-block", false, true, false),
  r("f u l # -> 19,514,515",
  // l-block-69, conditional phase-one
    // act19 = (KILL 3)
    // act514 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-ROOT...
    // act515 = (CAT N T EVAL (PROGN (MARK-DICT LEX 'INSTANCEOF 'UNIT_OF_MEA...
    ":l-block", false, true, false),
  r("f u l # -> 19,516,515",
  // l-block-70, conditional phase-one
    // act19 = (KILL 3)
    // act516 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-ROOT...
    // act515 = (CAT N T EVAL (PROGN (MARK-DICT LEX 'INSTANCEOF 'UNIT_OF_MEA...
    ":l-block", false, true, false),
  r("f u l # -> 19,517,518",
  // l-block-71, conditional phase-one
    // act19 = (KILL 3)
    // act517 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-ROOT...
    // act518 = (CAT ADJ T EVAL (PROGN (MARK-DICT LEX 'ROOT ROOT T T) (MARK-...
    ":l-block", false, true, false),
  r("f u l # -> 19,519,518",
  // l-block-72, conditional phase-one
    // act19 = (KILL 3)
    // act519 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-ROOT...
    // act518 = (CAT ADJ T EVAL (PROGN (MARK-DICT LEX 'ROOT ROOT T T) (MARK-...
    ":l-block", false, true, false),
  r("f u l # -> 19,520,518",
  // l-block-73, conditional phase-one
    // act19 = (KILL 3)
    // act520 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-ROOT...
    // act518 = (CAT ADJ T EVAL (PROGN (MARK-DICT LEX 'ROOT ROOT T T) (MARK-...
    ":l-block", false, true, false),
  r("f u l # -> 19,223,518",
  // l-block-74, conditional phase-one
    // act19 = (KILL 3)
    // act223 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-ROOT...
    // act518 = (CAT ADJ T EVAL (PROGN (MARK-DICT LEX 'ROOT ROOT T T) (MARK-...
    ":l-block", false, true, false),
  r("f u l # -> 19,35,521,522",
  // l-block-75, conditional phase-one
    // act19 = (KILL 3)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act521 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'NM)) ...
    // act522 = (CAT N (AND (MORPH-ROOT STATE) (IS-NONNAME-ROOT-OF-CAT ROOT ...
    ":l-block", false, true, false),
  r("f u l # -> 19,35,523",
  // l-block-76, conditional phase-one
    // act19 = (KILL 3)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act523 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(N V ...
    ":l-block", false, true, false),
  r("d a c t y l # -> 102,524,162,525",
  // l-block-77, conditional phase-one
    // act102 = (KILL 6)
    // act524 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-ROOT...
    // act162 = (CAT ADJ T EVAL '*)
    // act525 = (CAT NM T EVAL (LIST LEX (LIST 'ROOT ROOT) '(SUFFIX DACTYL) ...
    ":l-block", false, true, false),
  r("y l # -> 50,194,35,526",
  // l-block-78, conditional phase-one
    // act50 = (KILL 2)
    // act194 = (ADD U S)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act526 = (CAT NM (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(NM AD...
    ":l-block", false, true, false),
  r("y l # -> 50,527,35,526",
  // l-block-79, conditional phase-one
    // act50 = (KILL 2)
    // act527 = (ADD A N E)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act526 = (CAT NM (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(NM AD...
    ":l-block", false, true, false),
  r("y l # -> 50,68,35,526",
  // l-block-80, conditional phase-one
    // act50 = (KILL 2)
    // act68 = (ADD E)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act526 = (CAT NM (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(NM AD...
    ":l-block", false, true, false),
  r("y l # -> 50,35,526",
  // l-block-81, conditional phase-one
    // act50 = (KILL 2)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act526 = (CAT NM (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(NM AD...
    ":l-block", false, true, false),
  r("p h i l # -> 61,528,529,192",
  // l-block-82, conditional phase-one
    // act61 = (KILL 4)
    // act528 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (POLYSYLLABIC ROOT) (MORPH-...
    // act529 = (CAT ADJ T EVAL (PROGN (MARK-DICT LEX 'FALSE-ROOT ROOT T T) ...
    // act192 = (CAT N T EVAL '-S)
    ":l-block", false, true, false),
  r("f u l # -> 156",
  // l-block-83, 
    // act156 = (CAT ADJ (PLAUSIBLE-ROOT ROOT) EVAL '*)
    ":l-block"),
  r("i o l # -> 530",
  // l-block-84, 
    // act530 = (CAT N (POLYSYLLABIC ROOT) EVAL 'MASS)
    ":l-block"),
  r("s o l # -> 530",
  // l-block-85, 
    // act530 = (CAT N (POLYSYLLABIC ROOT) EVAL 'MASS)
    ":l-block"),
  r("p h i l # -> 131,162,192",
  // l-block-86, 
    // act131 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (POLYSYLLABIC ROOT)))
    // act162 = (CAT ADJ T EVAL '*)
    // act192 = (CAT N T EVAL '-S)
    ":l-block"),
  r("d a c t y l # -> 131,162,531",
  // l-block-87, 
    // act131 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (POLYSYLLABIC ROOT)))
    // act162 = (CAT ADJ T EVAL '*)
    // act531 = (CAT NM T EVAL (LIST LEX '(SUFFIX DACTYL) '(KINDOF ANIMAL)))
    ":l-block"),
  r("y l # -> 131,532",
  // l-block-88, 
    // act131 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (POLYSYLLABIC ROOT)))
    // act532 = (CAT NM T EVAL (LIST LEX '(DOMAIN CHEMISTRY)))
    ":l-block"),
  r(" -> 180,158",
  // l-block-89, 
    // act180 = (TEST T)
    // act158 = (DO DEFAULT-RULE)
    ":l-block"),
 };

 protected static MorphRule[] mBlock = {//":m-block"
  r("d o m # -> 19,35,533",
  // m-block-1, conditional phase-one
    // act19 = (KILL 3)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act533 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(N))) E...
    ":m-block", false, true, false),
  r("vowel b|d|g|k|l|m|n|p|r|s|t|z & i s m # -> 61,35,534",
  // m-block-2, conditional phase-one
    // act61 = (KILL 4)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act534 = (CAT NM (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(NN V ...
    ":m-block", false, true, false),
  r("i s m # -> 19,68,535,536",
  // m-block-3, conditional phase-one
    // act19 = (KILL 3)
    // act68 = (ADD E)
    // act535 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (NEED-FINAL-E ROOT) (MORPH-...
    // act536 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(NN V A...
    ":m-block", false, true, false),
  r("i s m # -> 19,35,537",
  // m-block-4, conditional phase-one
    // act19 = (KILL 3)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act537 = (CAT NM (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(N V A...
    ":m-block", false, true, false),
  r("i s m # -> 19,108,131,536",
  // m-block-5, conditional phase-one
    // act19 = (KILL 3)
    // act108 = (ADD I T Y)
    // act131 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (POLYSYLLABIC ROOT)))
    // act536 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(NN V A...
    ":m-block", false, true, false),
  r("i s m # -> 19,68,538,536",
  // m-block-6, conditional phase-one
    // act19 = (KILL 3)
    // act68 = (ADD E)
    // act538 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (PA...
    // act536 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(NN V A...
    ":m-block", false, true, false),
  r("b i l i s m # -> 57,539,131,536",
  // m-block-7, conditional phase-one
    // act57 = (KILL 5)
    // act539 = (ADD L E)
    // act131 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (POLYSYLLABIC ROOT)))
    // act536 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(NN V A...
    ":m-block", false, true, false),
  r("i s m # -> 19,37,131,540",
  // m-block-8, conditional phase-one
    // act19 = (KILL 3)
    // act37 = (ADD O)
    // act131 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (POLYSYLLABIC ROOT)))
    // act540 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'PREFIX)...
    ":m-block", false, true, false),
  r("i s m # -> 19,117,131,541",
  // m-block-9, conditional phase-one
    // act19 = (KILL 3)
    // act117 = (ADD A)
    // act131 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (POLYSYLLABIC ROOT)))
    // act541 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(NN PRE...
    ":m-block", false, true, false),
  r("i s m # -> 50,542,131,543",
  // m-block-10, conditional phase-one
    // act50 = (KILL 2)
    // act542 = (ADD Z E)
    // act131 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (POLYSYLLABIC ROOT)))
    // act543 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(V))) E...
    ":m-block", false, true, false),
  r("i s m # -> 24,68,131,543",
  // m-block-11, conditional phase-one
    // act24 = (KILL 1)
    // act68 = (ADD E)
    // act131 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (POLYSYLLABIC ROOT)))
    // act543 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(V))) E...
    ":m-block", false, true, false),
  r("i s m # -> 19,31,131,544",
  // m-block-12, conditional phase-one
    // act19 = (KILL 3)
    // act31 = (ADD Y)
    // act131 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (POLYSYLLABIC ROOT)))
    // act544 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(NN V A...
    ":m-block", false, true, false),
  r("i s m # -> 24,342,131,545",
  // m-block-13, conditional phase-one
    // act24 = (KILL 1)
    // act342 = (ADD T)
    // act131 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (POLYSYLLABIC ROOT)))
    // act545 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(ADJ NN...
    ":m-block", false, true, false),
  r("t i s m # -> 50,546,142,547",
  // m-block-14, conditional phase-one
    // act50 = (KILL 2)
    // act546 = (ADD C)
    // act142 = (TEST (POLYSYLLABIC ROOT))
    // act547 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(ADJ)))...
    ":m-block", false, true, false),
  r("t i s m # -> 61,35,544",
  // m-block-15, conditional phase-one
    // act61 = (KILL 4)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act544 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(NN V A...
    ":m-block", false, true, false),
  r("a t i s m # -> 57,35,548",
  // m-block-16, conditional phase-one
    // act57 = (KILL 5)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act548 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(N V AD...
    ":m-block", false, true, false),
  r("a t i s m # -> 57,68,35,549",
  // m-block-17, conditional phase-one
    // act57 = (KILL 5)
    // act68 = (ADD E)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act549 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(NN V A...
    ":m-block", false, true, false),
  r("v a t i s m # -> 57,68,550",
  // m-block-18, 
    // act57 = (KILL 5)
    // act68 = (ADD E)
    // act550 = (CAT N (PLAUSIBLE-ROOT ROOT) EVAL (LIST LEX '(NUMBER SG) '(M...
    ":m-block"),
  r("consonant vowel m|n|t|u|v a t i s m # -> 57,68,550",
  // m-block-19, 
    // act57 = (KILL 5)
    // act68 = (ADD E)
    // act550 = (CAT N (PLAUSIBLE-ROOT ROOT) EVAL (LIST LEX '(NUMBER SG) '(M...
    ":m-block"),
  r("a|e|o n i s m # -> 19,551",
  // m-block-20, 
    // act19 = (KILL 3)
    // act551 = (CAT N (PLAUSIBLE-ROOT ROOT) EVAL (LIST LEX '(NUMBER SG) '(M...
    ":m-block"),
  r("consonant vowel r v i s m # -> 19,68,551",
  // m-block-21, 
    // act19 = (KILL 3)
    // act68 = (ADD E)
    // act551 = (CAT N (PLAUSIBLE-ROOT ROOT) EVAL (LIST LEX '(NUMBER SG) '(M...
    ":m-block"),
  r("consonant vowel m|n|t|u|v i s m # -> 19,68,551",
  // m-block-22, 
    // act19 = (KILL 3)
    // act68 = (ADD E)
    // act551 = (CAT N (PLAUSIBLE-ROOT ROOT) EVAL (LIST LEX '(NUMBER SG) '(M...
    ":m-block"),
  r("i s m # -> 19,551",
  // m-block-23, 
    // act19 = (KILL 3)
    // act551 = (CAT N (PLAUSIBLE-ROOT ROOT) EVAL (LIST LEX '(NUMBER SG) '(M...
    ":m-block"),
  r("s h a m # -> 35,264,154",
  // m-block-24, 
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act264 = (CAT CITY T EVAL '*)
    // act154 = (CAT LASTNAME T EVAL '*)
    ":m-block"),
  r("i f o r m # -> 57,552,553,554",
  // m-block-25, phase-one
    // act57 = (KILL 5)
    // act552 = (TEST (AND (> (NCHARS ROOT) 2) (SYLLABIC ROOT)))
    // act553 = (KILL 0)
    // act554 = (TRY IFORM-BLOCK)
    ":m-block", true, false, false),
  r("a s m # -> 433",
  // m-block-26, 
    // act433 = (CAT NM (POLYSYLLABIC ROOT) EVAL '-S)
    ":m-block"),
  r("u m # -> 270",
  // m-block-27, 
    // act270 = (CAT N (POLYSYLLABIC ROOT) EVAL '-S)
    ":m-block"),
  r("y m # -> 270",
  // m-block-28, 
    // act270 = (CAT N (POLYSYLLABIC ROOT) EVAL '-S)
    ":m-block"),
  r("d o m # -> 270",
  // m-block-29, 
    // act270 = (CAT N (POLYSYLLABIC ROOT) EVAL '-S)
    ":m-block"),
  r("- m m # -> 19,555,162,556",
  // m-block-30, 
    // act19 = (KILL 3)
    // act555 = (TEST (NUMBERP ROOT))
    // act162 = (CAT ADJ T EVAL '*)
    // act556 = (CAT N T EVAL '-APOSTROPHE-S)
    ":m-block"),
  r("m m # -> 50,555,162,556",
  // m-block-31, 
    // act50 = (KILL 2)
    // act555 = (TEST (NUMBERP ROOT))
    // act162 = (CAT ADJ T EVAL '*)
    // act556 = (CAT N T EVAL '-APOSTROPHE-S)
    ":m-block"),
  r(" -> 180,158",
  // m-block-32, 
    // act180 = (TEST T)
    // act158 = (DO DEFAULT-RULE)
    ":m-block"),
 };

 protected static MorphRule[] nBlock = {//":n-block"
  r("e n # -> 50,557",
  // n-block-1, conditional phase-one
    // act50 = (KILL 2)
    // act557 = (CAT N (AND (MORPH-ROOT STATE) (TEST-ICODE ROOT 'N '-EN)) EV...
    ":n-block", false, true, false),
  r("m e n # -> 50,558,559",
  // n-block-2, conditional phase-one
    // act50 = (KILL 2)
    // act558 = (ADD A N)
    // act559 = (CAT N (AND (MORPH-ROOT STATE) (TEST-ICODE ROOT 'N '-MEN)) E...
    ":n-block", false, true, false),
  r("h u m a n # -> 57,35,560",
  // n-block-3, phase-one
    // act57 = (KILL 5)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act560 = (CAT N (AND (MORPH-ROOT STATE) (MORPH-CHECK ROOT '(N V ADJ D...
    ":n-block", true, false, false),
  r("s w o m a n # -> 102,35,561",
  // n-block-4, phase-one
    // act102 = (KILL 6)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act561 = (CAT N (AND (MORPH-ROOT STATE) (MORPH-CHECK ROOT '(N V ADJ D...
    ":n-block", true, false, false),
  r("s m a n # -> 61,35,562",
  // n-block-5, 
    // act61 = (KILL 4)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act562 = (CAT N (AND (MORPH-ROOT STATE) (MORPH-CHECK ROOT '(N V ADJ D...
    ":n-block"),
  r("w o m a n # -> 57,35,563",
  // n-block-6, phase-one
    // act57 = (KILL 5)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act563 = (CAT N (AND (MORPH-ROOT STATE) (MORPH-CHECK ROOT '(N V ADJ D...
    ":n-block", true, false, false),
  r("m a n # -> 19,35,564",
  // n-block-7, conditional phase-one
    // act19 = (KILL 3)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act564 = (CAT N (AND (MORPH-ROOT STATE) (MORPH-CHECK ROOT '(N V ADJ D...
    ":n-block", false, true, false),
  r("s w o m e n # -> 102,35,565",
  // n-block-8, phase-one
    // act102 = (KILL 6)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act565 = (CAT N (AND (MORPH-ROOT STATE) (MORPH-CHECK ROOT '(N V ADJ D...
    ":n-block", true, false, false),
  r("w o m e n # -> 57,35,566",
  // n-block-9, phase-one
    // act57 = (KILL 5)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act566 = (CAT N (AND (MORPH-ROOT STATE) (MORPH-CHECK ROOT '(N V ADJ D...
    ":n-block", true, false, false),
  r("s m e n # -> 61,35,567",
  // n-block-10, phase-one
    // act61 = (KILL 4)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act567 = (CAT N (AND (MORPH-ROOT STATE) (MORPH-CHECK ROOT '(N V ADJ D...
    ":n-block", true, false, false),
  r("m e n # -> 19,35,568",
  // n-block-11, conditional phase-one
    // act19 = (KILL 3)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act568 = (CAT N (AND (MORPH-ROOT STATE) (MORPH-CHECK ROOT '(N V ADJ D...
    ":n-block", false, true, false),
  r("m e n # -> 50,569,558,87",
  // n-block-12, conditional phase-one
    // act50 = (KILL 2)
    // act569 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (IS...
    // act558 = (ADD A N)
    // act87 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'N)) EVA...
    ":n-block", false, true, false),
  r("g e n # -> 19,298,570",
  // n-block-13, conditional phase-one
    // act19 = (KILL 3)
    // act298 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (POLYSYLLABIC ROOT) (MORPH-...
    // act570 = (CAT N T EVAL (PROGN (MARK-DICT LEX 'FALSE-ROOT ROOT T T) (M...
    ":n-block", false, true, false),
  r("t i o n # -> 19,571,553,572",
  // n-block-14, phase-one
    // act19 = (KILL 3)
    // act571 = (TEST (AND (MORPH-ROOT STATE) (NOT (IS-HYPHENATED LEX)) (OR ...
    // act553 = (KILL 0)
    // act572 = (TRY TION-BLOCK)
    ":n-block", true, false, false),
  r("t i o n # -> 180,572",
  // n-block-15, 
    // act180 = (TEST T)
    // act572 = (TRY TION-BLOCK)
    ":n-block"),
  r("s s i o n # -> 19,35,573",
  // n-block-16, conditional phase-one
    // act19 = (KILL 3)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act573 = (CAT NMC (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'V)) E...
    ":n-block", false, true, false),
  r("s i o n # -> 19,68,35,573",
  // n-block-17, conditional phase-one
    // act19 = (KILL 3)
    // act68 = (ADD E)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act573 = (CAT NMC (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'V)) E...
    ":n-block", false, true, false),
  r("s i o n # -> 61,318,35,573",
  // n-block-18, conditional phase-one
    // act61 = (KILL 4)
    // act318 = (ADD D E)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act573 = (CAT NMC (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'V)) E...
    ":n-block", false, true, false),
  r("e n # -> 24,574,575",
  // n-block-19, conditional phase-one
    // act24 = (KILL 1)
    // act574 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT-PRE...
    // act575 = (CAT V (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(ADJ)))...
    ":n-block", false, true, false),
  r("e n # -> 50,576,575",
  // n-block-20, conditional phase-one
    // act50 = (KILL 2)
    // act576 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT-PRE...
    // act575 = (CAT V (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(ADJ)))...
    ":n-block", false, true, false),
  r("i d d e n # -> 19,68,203,577,162",
  // n-block-21, conditional phase-one
    // act19 = (KILL 3)
    // act68 = (ADD E)
    // act203 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-ROOT...
    // act577 = (CAT V T EVAL (LIST ROOT '(PASTPART)))
    // act162 = (CAT ADJ T EVAL '*)
    ":n-block", false, true, false),
  r("i c i a n # -> 57,31,578,579",
  // n-block-22, conditional phase-one
    // act57 = (KILL 5)
    // act31 = (ADD Y)
    // act578 = (TEST (AND (POLYSYLLABIC ROOT) (MORPH-ROOT STATE) (IS-KNOWN-...
    // act579 = (CAT N T EVAL (PROGN (MARK-DICT LEX 'KINDOF 'PERSON T T) (MA...
    ":n-block", false, true, false),
  r("i c i a n # -> 19,580,581",
  // n-block-23, conditional phase-one
    // act19 = (KILL 3)
    // act580 = (TEST (AND (POLYSYLLABIC ROOT) (MORPH-ROOT STATE) (IS-KNOWN-...
    // act581 = (CAT N T EVAL (PROGN (MARK-DICT LEX 'KINDOF 'PERSON T T) (MA...
    ":n-block", false, true, false),
  r("i c i a n # -> 19,68,580,581",
  // n-block-24, conditional phase-one
    // act19 = (KILL 3)
    // act68 = (ADD E)
    // act580 = (TEST (AND (POLYSYLLABIC ROOT) (MORPH-ROOT STATE) (IS-KNOWN-...
    // act581 = (CAT N T EVAL (PROGN (MARK-DICT LEX 'KINDOF 'PERSON T T) (MA...
    ":n-block", false, true, false),
  r("i c i a n # -> 19,22,580,581",
  // n-block-25, conditional phase-one
    // act19 = (KILL 3)
    // act22 = (ADD S)
    // act580 = (TEST (AND (POLYSYLLABIC ROOT) (MORPH-ROOT STATE) (IS-KNOWN-...
    // act581 = (CAT N T EVAL (PROGN (MARK-DICT LEX 'KINDOF 'PERSON T T) (MA...
    ":n-block", false, true, false),
  r("consonant i c i a n # -> 57,68,578,579",
  // n-block-26, conditional phase-one
    // act57 = (KILL 5)
    // act68 = (ADD E)
    // act578 = (TEST (AND (POLYSYLLABIC ROOT) (MORPH-ROOT STATE) (IS-KNOWN-...
    // act579 = (CAT N T EVAL (PROGN (MARK-DICT LEX 'KINDOF 'PERSON T T) (MA...
    ":n-block", false, true, false),
  r("i c i a n # -> 57,578,579",
  // n-block-27, conditional phase-one
    // act57 = (KILL 5)
    // act578 = (TEST (AND (POLYSYLLABIC ROOT) (MORPH-ROOT STATE) (IS-KNOWN-...
    // act579 = (CAT N T EVAL (PROGN (MARK-DICT LEX 'KINDOF 'PERSON T T) (MA...
    ":n-block", false, true, false),
  r("i c i a n # -> 19,22,580,581",
  // n-block-28, conditional phase-one
    // act19 = (KILL 3)
    // act22 = (ADD S)
    // act580 = (TEST (AND (POLYSYLLABIC ROOT) (MORPH-ROOT STATE) (IS-KNOWN-...
    // act581 = (CAT N T EVAL (PROGN (MARK-DICT LEX 'KINDOF 'PERSON T T) (MA...
    ":n-block", false, true, false),
  r("consonant i a n # -> 19,31,582,162,581",
  // n-block-29, conditional phase-one
    // act19 = (KILL 3)
    // act31 = (ADD Y)
    // act582 = (TEST (AND (POLYSYLLABIC ROOT) (MORPH-ROOT STATE) (IS-KNOWN-...
    // act162 = (CAT ADJ T EVAL '*)
    // act581 = (CAT N T EVAL (PROGN (MARK-DICT LEX 'KINDOF 'PERSON T T) (MA...
    ":n-block", false, true, false),
  r("a r i a n # -> 61,583,162,584",
  // n-block-30, conditional phase-one
    // act61 = (KILL 4)
    // act583 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (POLYSYLLABIC ROOT) (MORPH-...
    // act162 = (CAT ADJ T EVAL '*)
    // act584 = (CAT N T EVAL (PROGN (MARK-DICT LEX 'KINDOF 'PERSON T T) (MA...
    ":n-block", false, true, false),
  r("i a n # -> 19,580,162,581",
  // n-block-31, conditional phase-one
    // act19 = (KILL 3)
    // act580 = (TEST (AND (POLYSYLLABIC ROOT) (MORPH-ROOT STATE) (IS-KNOWN-...
    // act162 = (CAT ADJ T EVAL '*)
    // act581 = (CAT N T EVAL (PROGN (MARK-DICT LEX 'KINDOF 'PERSON T T) (MA...
    ":n-block", false, true, false),
  r("consonant i a n # -> 24,583,162,585",
  // n-block-32, conditional phase-one
    // act24 = (KILL 1)
    // act583 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (POLYSYLLABIC ROOT) (MORPH-...
    // act162 = (CAT ADJ T EVAL '*)
    // act585 = (CAT N T EVAL (PROGN (MARK-DICT LEX 'KINDOF 'PERSON T T) (MA...
    ":n-block", false, true, false),
  r("consonant i a n # -> 19,117,580,162,581",
  // n-block-33, conditional phase-one
    // act19 = (KILL 3)
    // act117 = (ADD A)
    // act580 = (TEST (AND (POLYSYLLABIC ROOT) (MORPH-ROOT STATE) (IS-KNOWN-...
    // act162 = (CAT ADJ T EVAL '*)
    // act581 = (CAT N T EVAL (PROGN (MARK-DICT LEX 'KINDOF 'PERSON T T) (MA...
    ":n-block", false, true, false),
  r("consonant i a n # -> 19,68,580,162,581",
  // n-block-34, conditional phase-one
    // act19 = (KILL 3)
    // act68 = (ADD E)
    // act580 = (TEST (AND (POLYSYLLABIC ROOT) (MORPH-ROOT STATE) (IS-KNOWN-...
    // act162 = (CAT ADJ T EVAL '*)
    // act581 = (CAT N T EVAL (PROGN (MARK-DICT LEX 'KINDOF 'PERSON T T) (MA...
    ":n-block", false, true, false),
  r("i a n # -> 19,31,580,162,581",
  // n-block-35, conditional phase-one
    // act19 = (KILL 3)
    // act31 = (ADD Y)
    // act580 = (TEST (AND (POLYSYLLABIC ROOT) (MORPH-ROOT STATE) (IS-KNOWN-...
    // act162 = (CAT ADJ T EVAL '*)
    // act581 = (CAT N T EVAL (PROGN (MARK-DICT LEX 'KINDOF 'PERSON T T) (MA...
    ":n-block", false, true, false),
  r("g e n a r i a n # -> 111,586,162,587",
  // n-block-36, conditional phase-one
    // act111 = (KILL 8)
    // act586 = (TEST (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(PREFIX)...
    // act162 = (CAT ADJ T EVAL '*)
    // act587 = (CAT N T EVAL (PROGN (MARK-DICT LEX 'KINDOF (MAKE-STRUCTURED...
    ":n-block", false, true, false),
  r("a g e n a r i a n # -> 588,290,586,162,587",
  // n-block-37, conditional phase-one
    // act588 = (KILL 9)
    // act290 = (ADD I)
    // act586 = (TEST (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(PREFIX)...
    // act162 = (CAT ADJ T EVAL '*)
    // act587 = (CAT N T EVAL (PROGN (MARK-DICT LEX 'KINDOF (MAKE-STRUCTURED...
    ":n-block", false, true, false),
  r("a g e n a r i a n # -> 588,68,586,162,587",
  // n-block-38, conditional phase-one
    // act588 = (KILL 9)
    // act68 = (ADD E)
    // act586 = (TEST (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(PREFIX)...
    // act162 = (CAT ADJ T EVAL '*)
    // act587 = (CAT N T EVAL (PROGN (MARK-DICT LEX 'KINDOF (MAKE-STRUCTURED...
    ":n-block", false, true, false),
  r("g e n a r i a n # -> 111,589,162,590",
  // n-block-39, conditional phase-one
    // act111 = (KILL 8)
    // act589 = (TEST (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(PREFIX)...
    // act162 = (CAT ADJ T EVAL '*)
    // act590 = (CAT N T EVAL (PROGN (MARK-DICT LEX 'KINDOF 'PERSON T T) (MA...
    ":n-block", false, true, false),
  r("consonant a r i a n # -> 57,31,583,162,584",
  // n-block-40, conditional phase-one
    // act57 = (KILL 5)
    // act31 = (ADD Y)
    // act583 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (POLYSYLLABIC ROOT) (MORPH-...
    // act162 = (CAT ADJ T EVAL '*)
    // act584 = (CAT N T EVAL (PROGN (MARK-DICT LEX 'KINDOF 'PERSON T T) (MA...
    ":n-block", false, true, false),
  r("a r i a n # -> 50,194,591,162,584",
  // n-block-41, conditional phase-one
    // act50 = (KILL 2)
    // act194 = (ADD U S)
    // act591 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (POLYSYLLABIC ROOT) (MORPH-...
    // act162 = (CAT ADJ T EVAL '*)
    // act584 = (CAT N T EVAL (PROGN (MARK-DICT LEX 'KINDOF 'PERSON T T) (MA...
    ":n-block", false, true, false),
  r("a r i a n # -> 50,117,591,162,584",
  // n-block-42, conditional phase-one
    // act50 = (KILL 2)
    // act117 = (ADD A)
    // act591 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (POLYSYLLABIC ROOT) (MORPH-...
    // act162 = (CAT ADJ T EVAL '*)
    // act584 = (CAT N T EVAL (PROGN (MARK-DICT LEX 'KINDOF 'PERSON T T) (MA...
    ":n-block", false, true, false),
  r("a r i a n # -> 50,116,591,162,584",
  // n-block-43, conditional phase-one
    // act50 = (KILL 2)
    // act116 = (ADD U M)
    // act591 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (POLYSYLLABIC ROOT) (MORPH-...
    // act162 = (CAT ADJ T EVAL '*)
    // act584 = (CAT N T EVAL (PROGN (MARK-DICT LEX 'KINDOF 'PERSON T T) (MA...
    ":n-block", false, true, false),
  r("consonant a r i a n # -> 57,68,592,162,584",
  // n-block-44, conditional phase-one
    // act57 = (KILL 5)
    // act68 = (ADD E)
    // act592 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (NEED-FINAL-E ROOT) (MORPH-...
    // act162 = (CAT ADJ T EVAL '*)
    // act584 = (CAT N T EVAL (PROGN (MARK-DICT LEX 'KINDOF 'PERSON T T) (MA...
    ":n-block", false, true, false),
  r("o l a r i a n # -> 102,593,162,594",
  // n-block-45, conditional phase-one
    // act102 = (KILL 6)
    // act593 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-KNOW...
    // act162 = (CAT ADJ T EVAL '*)
    // act594 = (CAT N T EVAL (PROGN (MARK-DICT LEX 'KINDOF 'ANIMAL T T) (MA...
    ":n-block", false, true, false),
  r("consonant i n a r i a n # -> 113,68,592,162,584",
  // n-block-46, conditional phase-one
    // act113 = (KILL 7)
    // act68 = (ADD E)
    // act592 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (NEED-FINAL-E ROOT) (MORPH-...
    // act162 = (CAT ADJ T EVAL '*)
    // act584 = (CAT N T EVAL (PROGN (MARK-DICT LEX 'KINDOF 'PERSON T T) (MA...
    ":n-block", false, true, false),
  r("a r i a n # -> 57,595,162,584",
  // n-block-47, conditional phase-one
    // act57 = (KILL 5)
    // act595 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (SYLLABIC ROOT) (MORPH-ROOT...
    // act162 = (CAT ADJ T EVAL '*)
    // act584 = (CAT N T EVAL (PROGN (MARK-DICT LEX 'KINDOF 'PERSON T T) (MA...
    ":n-block", false, true, false),
  r("a r i a n # -> 57,117,583,162,584",
  // n-block-48, conditional phase-one
    // act57 = (KILL 5)
    // act117 = (ADD A)
    // act583 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (POLYSYLLABIC ROOT) (MORPH-...
    // act162 = (CAT ADJ T EVAL '*)
    // act584 = (CAT N T EVAL (PROGN (MARK-DICT LEX 'KINDOF 'PERSON T T) (MA...
    ":n-block", false, true, false),
  r("a r i a n # -> 57,194,583,162,584",
  // n-block-49, conditional phase-one
    // act57 = (KILL 5)
    // act194 = (ADD U S)
    // act583 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (POLYSYLLABIC ROOT) (MORPH-...
    // act162 = (CAT ADJ T EVAL '*)
    // act584 = (CAT N T EVAL (PROGN (MARK-DICT LEX 'KINDOF 'PERSON T T) (MA...
    ":n-block", false, true, false),
  r("a r i a n # -> 57,116,583,162,584",
  // n-block-50, conditional phase-one
    // act57 = (KILL 5)
    // act116 = (ADD U M)
    // act583 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (POLYSYLLABIC ROOT) (MORPH-...
    // act162 = (CAT ADJ T EVAL '*)
    // act584 = (CAT N T EVAL (PROGN (MARK-DICT LEX 'KINDOF 'PERSON T T) (MA...
    ":n-block", false, true, false),
  r("consonant a r i a n # -> 57,68,583,162,584",
  // n-block-51, conditional phase-one
    // act57 = (KILL 5)
    // act68 = (ADD E)
    // act583 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (POLYSYLLABIC ROOT) (MORPH-...
    // act162 = (CAT ADJ T EVAL '*)
    // act584 = (CAT N T EVAL (PROGN (MARK-DICT LEX 'KINDOF 'PERSON T T) (MA...
    ":n-block", false, true, false),
  r("consonant a r i a n # -> 57,596,583,162,584",
  // n-block-52, conditional phase-one
    // act57 = (KILL 5)
    // act596 = (ADD ATION)
    // act583 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (POLYSYLLABIC ROOT) (MORPH-...
    // act162 = (CAT ADJ T EVAL '*)
    // act584 = (CAT N T EVAL (PROGN (MARK-DICT LEX 'KINDOF 'PERSON T T) (MA...
    ":n-block", false, true, false),
  r("consonant a r i a n # -> 57,68,597,162,584",
  // n-block-53, conditional phase-one
    // act57 = (KILL 5)
    // act68 = (ADD E)
    // act597 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (POLYSYLLABIC ROOT) (MORPH-...
    // act162 = (CAT ADJ T EVAL '*)
    // act584 = (CAT N T EVAL (PROGN (MARK-DICT LEX 'KINDOF 'PERSON T T) (MA...
    ":n-block", false, true, false),
  r("a r i a n # -> 57,598,162,584",
  // n-block-54, conditional phase-one
    // act57 = (KILL 5)
    // act598 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (SYLLABIC ROOT) (MORPH-ROOT...
    // act162 = (CAT ADJ T EVAL '*)
    // act584 = (CAT N T EVAL (PROGN (MARK-DICT LEX 'KINDOF 'PERSON T T) (MA...
    ":n-block", false, true, false),
  r("consonant r i a n # -> 61,72,597,162,581",
  // n-block-55, conditional phase-one
    // act61 = (KILL 4)
    // act72 = (ADD E R)
    // act597 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (POLYSYLLABIC ROOT) (MORPH-...
    // act162 = (CAT ADJ T EVAL '*)
    // act581 = (CAT N T EVAL (PROGN (MARK-DICT LEX 'KINDOF 'PERSON T T) (MA...
    ":n-block", false, true, false),
  r("e|i a n # -> 24,597,162,585",
  // n-block-56, conditional phase-one
    // act24 = (KILL 1)
    // act597 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (POLYSYLLABIC ROOT) (MORPH-...
    // act162 = (CAT ADJ T EVAL '*)
    // act585 = (CAT N T EVAL (PROGN (MARK-DICT LEX 'KINDOF 'PERSON T T) (MA...
    ":n-block", false, true, false),
  r("consonant e|i a n # -> 19,68,599,162,581",
  // n-block-57, conditional phase-one
    // act19 = (KILL 3)
    // act68 = (ADD E)
    // act599 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (POLYSYLLABIC ROOT) (MORPH-...
    // act162 = (CAT ADJ T EVAL '*)
    // act581 = (CAT N T EVAL (PROGN (MARK-DICT LEX 'KINDOF 'PERSON T T) (MA...
    ":n-block", false, true, false),
  r("e|i a n # -> 19,597,162,581",
  // n-block-58, conditional phase-one
    // act19 = (KILL 3)
    // act597 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (POLYSYLLABIC ROOT) (MORPH-...
    // act162 = (CAT ADJ T EVAL '*)
    // act581 = (CAT N T EVAL (PROGN (MARK-DICT LEX 'KINDOF 'PERSON T T) (MA...
    ":n-block", false, true, false),
  r("consonant e|i a n # -> 19,68,597,162,581",
  // n-block-59, conditional phase-one
    // act19 = (KILL 3)
    // act68 = (ADD E)
    // act597 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (POLYSYLLABIC ROOT) (MORPH-...
    // act162 = (CAT ADJ T EVAL '*)
    // act581 = (CAT N T EVAL (PROGN (MARK-DICT LEX 'KINDOF 'PERSON T T) (MA...
    ":n-block", false, true, false),
  r("consonant e|i a n # -> 19,117,600,162,581",
  // n-block-60, conditional phase-one
    // act19 = (KILL 3)
    // act117 = (ADD A)
    // act600 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (POLYSYLLABIC ROOT) (MORPH-...
    // act162 = (CAT ADJ T EVAL '*)
    // act581 = (CAT N T EVAL (PROGN (MARK-DICT LEX 'KINDOF 'PERSON T T) (MA...
    ":n-block", false, true, false),
  r("n i a n # -> 19,117,597,162,581",
  // n-block-61, conditional phase-one
    // act19 = (KILL 3)
    // act117 = (ADD A)
    // act597 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (POLYSYLLABIC ROOT) (MORPH-...
    // act162 = (CAT ADJ T EVAL '*)
    // act581 = (CAT N T EVAL (PROGN (MARK-DICT LEX 'KINDOF 'PERSON T T) (MA...
    ":n-block", false, true, false),
  r("e|i a n # -> 19,118,601,162,581",
  // n-block-62, conditional phase-one
    // act19 = (KILL 3)
    // act118 = (ADD I C)
    // act601 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (POLYSYLLABIC ROOT) (MORPH-...
    // act162 = (CAT ADJ T EVAL '*)
    // act581 = (CAT N T EVAL (PROGN (MARK-DICT LEX 'KINDOF 'PERSON T T) (MA...
    ":n-block", false, true, false),
  r("i a n # -> 19,602,162,581",
  // n-block-63, conditional phase-one
    // act19 = (KILL 3)
    // act602 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (IS...
    // act162 = (CAT ADJ T EVAL '*)
    // act581 = (CAT N T EVAL (PROGN (MARK-DICT LEX 'KINDOF 'PERSON T T) (MA...
    ":n-block", false, true, false),
  r("o v i a n # -> 61,603,604,605,162,581,606,605,162,581",
  // n-block-64, conditional phase-one
    // act61 = (KILL 4)
    // act603 = (ADD W)
    // act604 = (SETQ SUFFIX 'IAN)
    // act605 = (TEST (AND (POLYSYLLABIC ROOT) (MORPH-ROOT STATE) (IS-ROOT-O...
    // act162 = (CAT ADJ T EVAL '*)
    // act581 = (CAT N T EVAL (PROGN (MARK-DICT LEX 'KINDOF 'PERSON T T) (MA...
    // act606 = (ADD W E)
    // act605 = (TEST (AND (POLYSYLLABIC ROOT) (MORPH-ROOT STATE) (IS-ROOT-O...
    // act162 = (CAT ADJ T EVAL '*)
    // act581 = (CAT N T EVAL (PROGN (MARK-DICT LEX 'KINDOF 'PERSON T T) (MA...
    ":n-block", false, true, true),
  r("vowel v i a n # -> 61,597,162,581",
  // n-block-65, conditional phase-one
    // act61 = (KILL 4)
    // act597 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (POLYSYLLABIC ROOT) (MORPH-...
    // act162 = (CAT ADJ T EVAL '*)
    // act581 = (CAT N T EVAL (PROGN (MARK-DICT LEX 'KINDOF 'PERSON T T) (MA...
    ":n-block", false, true, false),
  r("a n # -> 50,607,608,609",
  // n-block-66, conditional phase-one
    // act50 = (KILL 2)
    // act607 = (TEST (AND (POLYSYLLABIC ROOT) (MORPH-ROOT STATE) (NOT (IS-H...
    // act608 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(N)))...
    // act609 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(N))) E...
    ":n-block", false, true, false),
  r("a n # -> 24,610,611,612",
  // n-block-67, conditional phase-one
    // act24 = (KILL 1)
    // act610 = (TEST (AND (POLYSYLLABIC ROOT) (MORPH-ROOT STATE) (NOT (IS-H...
    // act611 = (CAT ADJ T EVAL (LIST LEX (LIST 'ROOT ROOT) '(SUFFIX AN)))
    // act612 = (CAT N T EVAL (LIST LEX '(NUMBER SG) (LIST 'ROOT ROOT) '(SUF...
    ":n-block", false, true, false),
  r("s o n # -> 19,35,613",
  // n-block-68, conditional phase-one
    // act19 = (KILL 3)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act613 = (CAT LASTNAME (AND (MORPH-ROOT STATE) (IS-FORM-OF-CAT ROOT '...
    ":n-block", false, true, false),
  r("s e n # -> 19,35,614",
  // n-block-69, conditional phase-one
    // act19 = (KILL 3)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act614 = (CAT LASTNAME (AND (MORPH-ROOT STATE) (IS-FORM-OF-CAT ROOT '...
    ":n-block", false, true, false),
  r("d o n # -> 19,615,616",
  // n-block-70, conditional phase-one
    // act19 = (KILL 3)
    // act615 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (POLYSYLLABIC ROOT) (MORPH-...
    // act616 = (CAT NC T EVAL (PROGN (MARK-DICT LEX 'FALSE-ROOT ROOT T T) (...
    ":n-block", false, true, false),
  r("i n # -> 50,37,617,618",
  // n-block-71, conditional phase-one
    // act50 = (KILL 2)
    // act37 = (ADD O)
    // act617 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (POLYSYLLABIC ROOT) (MORPH-...
    // act618 = (CAT NM T EVAL (PROGN (MARK-DICT LEX 'FALSE-ROOT ROOT T T) (...
    ":n-block", false, true, false),
  r("i n # -> 50,290,617,618",
  // n-block-72, conditional phase-one
    // act50 = (KILL 2)
    // act290 = (ADD I)
    // act617 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (POLYSYLLABIC ROOT) (MORPH-...
    // act618 = (CAT NM T EVAL (PROGN (MARK-DICT LEX 'FALSE-ROOT ROOT T T) (...
    ":n-block", false, true, false),
  r("i l l i o n # -> 102,619,620,621",
  // n-block-73, conditional phase-one
    // act102 = (KILL 6)
    // act619 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (PA...
    // act620 = (CAT UNIT T EVAL '-S)
    // act621 = (CAT N T EVAL (PROGN (IF (GETDICT ROOT 'VALUE) (MARK-DICT LE...
    ":n-block", false, true, false),
  r("i l l i o n # -> 102,622,620,621",
  // n-block-74, 
    // act102 = (KILL 6)
    // act622 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (PA...
    // act620 = (CAT UNIT T EVAL '-S)
    // act621 = (CAT N T EVAL (PROGN (IF (GETDICT ROOT 'VALUE) (MARK-DICT LE...
    ":n-block"),
  r("o n # -> 270",
  // n-block-75, 
    // act270 = (CAT N (POLYSYLLABIC ROOT) EVAL '-S)
    ":n-block"),
  r("i c i a n # -> 19,623",
  // n-block-76, 
    // act19 = (KILL 3)
    // act623 = (CAT N (POLYSYLLABIC ROOT) EVAL (PROGN (MARK-DICT LEX 'KINDO...
    ":n-block"),
  r("h n a n # -> 152",
  // n-block-77, 
    // act152 = (CAT LASTNAME (PLAUSIBLE-ROOT ROOT) EVAL '*)
    ":n-block"),
  r("a n # -> 164,270",
  // n-block-78, 
    // act164 = (CAT ADJ (POLYSYLLABIC ROOT) EVAL '*)
    // act270 = (CAT N (POLYSYLLABIC ROOT) EVAL '-S)
    ":n-block"),
  r("s t e i n # -> 152",
  // n-block-79, 
    // act152 = (CAT LASTNAME (PLAUSIBLE-ROOT ROOT) EVAL '*)
    ":n-block"),
  r("m a n n # -> 152",
  // n-block-80, 
    // act152 = (CAT LASTNAME (PLAUSIBLE-ROOT ROOT) EVAL '*)
    ":n-block"),
  r("t s o n # -> 152",
  // n-block-81, 
    // act152 = (CAT LASTNAME (PLAUSIBLE-ROOT ROOT) EVAL '*)
    ":n-block"),
  r("s e n # -> 152",
  // n-block-82, 
    // act152 = (CAT LASTNAME (PLAUSIBLE-ROOT ROOT) EVAL '*)
    ":n-block"),
  r("a n s o n # -> 152",
  // n-block-83, 
    // act152 = (CAT LASTNAME (PLAUSIBLE-ROOT ROOT) EVAL '*)
    ":n-block"),
  r(" -> 180,158",
  // n-block-84, 
    // act180 = (TEST T)
    // act158 = (DO DEFAULT-RULE)
    ":n-block"),
 };

 protected static MorphRule[] rBlock = {//":r-block"
  r("y i e r # -> 19,624,625,35,626,627,628",
  // r-block-1, conditional phase-one
    // act19 = (KILL 3)
    // act624 = (ADD E Y)
    // act625 = (SETQ SUFFIX 'ER)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act626 = (CAT ADJ (AND (MORPH-ROOT STATE) (OR (TEST-ICODE ROOT 'ADJ '...
    // act627 = (CAT ADV (AND (MORPH-ROOT STATE) (OR (TEST-ICODE ROOT 'ADV '...
    // act628 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'V)) EVA...
    ":r-block", false, true, false),
  r("i e r # -> 19,31,625,35,629,630,628",
  // r-block-2, conditional phase-one
    // act19 = (KILL 3)
    // act31 = (ADD Y)
    // act625 = (SETQ SUFFIX 'ER)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act629 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADJ))...
    // act630 = (CAT ADV (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADV))...
    // act628 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'V)) EVA...
    ":r-block", false, true, false),
  r("i e r # -> 19,31,631,629,630,632",
  // r-block-3, conditional phase-one
    // act19 = (KILL 3)
    // act31 = (ADD Y)
    // act631 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-KNOW...
    // act629 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADJ))...
    // act630 = (CAT ADV (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADV))...
    // act632 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(NN))) ...
    ":r-block", false, true, false),
  r("consonant i e r # -> 19,633,634,635,31,636",
  // r-block-4, phase-one
    // act19 = (KILL 3)
    // act633 = (SETQ SUFFIX 'IER)
    // act634 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (POLYSYLLABIC ROOT) (MORPH-...
    // act635 = (CAT N T EVAL (LIST LEX '(NUMBER SG) '(KINDOF PERSON) '(PROB...
    // act31 = (ADD Y)
    // act636 = (CAT ADJ (AND (MORPH-ROOT STATE) (PLAUSIBLE-COMPARATIVE-ROOT...
    ":r-block", true, false, true),
  r("o p t e r # -> 57,35,637",
  // r-block-5, conditional phase-one
    // act57 = (KILL 5)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act637 = (CAT NCM (AND (MORPH-ROOT STATE) (IS-FORM-OF-CAT ROOT '(ADJ ...
    ":r-block", false, true, false),
  r("b a c t e r # -> 102,180,638",
  // r-block-6, phase-one
    // act102 = (KILL 6)
    // act180 = (TEST T)
    // act638 = (CAT NCM T EVAL (PROGN (MARK-DICT LEX 'HAS-SUFFIX 'BACTER T ...
    ":r-block", true, false, false),
  r("m e r # -> 19,35,639",
  // r-block-7, conditional phase-one
    // act19 = (KILL 3)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act639 = (CAT NCM (AND (MORPH-ROOT STATE) (IS-FORM-OF-CAT ROOT 'PREFI...
    ":r-block", false, true, false),
  r("o w n e r # -> 57,467,640",
  // r-block-8, conditional phase-one
    // act57 = (KILL 5)
    // act467 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-ROOT...
    // act640 = (CAT N T EVAL (PROGN (MARK-DICT LEX 'FALSE-ROOT ROOT T T) (M...
    ":r-block", false, true, false),
  r("s e t t e r # -> 102,467,641",
  // r-block-9, conditional phase-one
    // act102 = (KILL 6)
    // act467 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-ROOT...
    // act641 = (CAT N T EVAL (PROGN (MARK-DICT LEX 'FALSE-ROOT ROOT T T) (M...
    ":r-block", false, true, false),
  r("a t e r # -> 50,642,643,644",
  // r-block-10, conditional phase-one
    // act50 = (KILL 2)
    // act642 = (ADD R Y)
    // act643 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-KNOW...
    // act644 = (CAT N T EVAL (PROGN (MARK-DICT LEX 'HAS-SUFFIX 'ER T T) '-S...
    ":r-block", false, true, false),
  r("m e t e r # -> 57,196,645",
  // r-block-11, conditional phase-one
    // act57 = (KILL 5)
    // act196 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-ROOT...
    // act645 = (CAT N T EVAL (PROGN (MARK-DICT LEX 'FALSE-ROOT ROOT T T) (M...
    ":r-block", false, true, false),
  r("i|o m e t e r # -> 102,193,645",
  // r-block-12, conditional phase-one
    // act102 = (KILL 6)
    // act193 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-ROOT...
    // act645 = (CAT N T EVAL (PROGN (MARK-DICT LEX 'FALSE-ROOT ROOT T T) (M...
    ":r-block", false, true, false),
  r("m e t e r # -> 57,193,645",
  // r-block-13, conditional phase-one
    // act57 = (KILL 5)
    // act193 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-ROOT...
    // act645 = (CAT N T EVAL (PROGN (MARK-DICT LEX 'FALSE-ROOT ROOT T T) (M...
    ":r-block", false, true, false),
  r("d o t t e r # -> 102,35,646",
  // r-block-14, conditional phase-one
    // act102 = (KILL 6)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act646 = (CAT LASTNAME (AND (MORPH-ROOT STATE) (IS-FORM-OF-CAT ROOT '...
    ":r-block", false, true, false),
  r("h e i m e r # -> 102,35,647",
  // r-block-15, conditional phase-one
    // act102 = (KILL 6)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act647 = (CAT LASTNAME (AND (MORPH-ROOT STATE) (IS-FORM-OF-CAT ROOT '...
    ":r-block", false, true, false),
  r("h e i m e r # -> 648",
  // r-block-16, 
    // act648 = (CAT LASTNAME T EVAL (PROGN (MARK-DICT LEX 'HAS-SUFFIX 'HEIM...
    ":r-block"),
  r("m a c h e r # -> 649",
  // r-block-17, 
    // act649 = (CAT LASTNAME T EVAL (PROGN (MARK-DICT LEX 'HAS-SUFFIX 'MACH...
    ":r-block"),
  r("e|o r # -> 650,327,328,651,330",
  // r-block-18, phase-one
    // act650 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (PA...
    // act327 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-KNOWN-FORM-OF-CAT ROOT ...
    // act328 = (CAT ADV (AND (MORPH-ROOT STATE) (IS-KNOWN-FORM-OF-CAT ROOT ...
    // act651 = (CAT N (AND (MORPH-ROOT STATE) (IS-KNOWN-FORM-OF-CAT ROOT 'N...
    // act330 = (CAT V (AND (MORPH-ROOT STATE) (IS-KNOWN-FORM-OF-CAT ROOT 'V...
    ":r-block", true, false, false),
  r("consonant i e r # -> 19,31,652,653",
  // r-block-19, conditional phase-one
    // act19 = (KILL 3)
    // act31 = (ADD Y)
    // act652 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (IS...
    // act653 = (CAT N T EVAL (COMPOUND-WITH-SUFFIX LEX 'N ROOT 1 'IER 'MOD)...
    ":r-block", false, true, false),
  r("e r # -> 24,652,654",
  // r-block-20, conditional phase-one
    // act24 = (KILL 1)
    // act652 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (IS...
    // act654 = (CAT N T EVAL (COMPOUND-WITH-SUFFIX LEX 'N ROOT 0 'R 'MOD))
    ":r-block", false, true, false),
  r("e r # -> 50,655,656",
  // r-block-21, conditional phase-one
    // act50 = (KILL 2)
    // act655 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (IS...
    // act656 = (CAT N T EVAL (COMPOUND-WITH-SUFFIX LEX 'N ROOT 0 'ER 'MOD))
    ":r-block", false, true, false),
  r("consonant vowel b|d|g|k|l|m|n|p|r|s|t|z & e r # -> 19,652,657",
  // r-block-22, conditional phase-one
    // act19 = (KILL 3)
    // act652 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (IS...
    // act657 = (CAT N T EVAL (COMPOUND-WITH-SUFFIX LEX 'N ROOT -1 'ER 'MOD)...
    ":r-block", false, true, false),
  r("consonant i e r # -> 19,31,658,659",
  // r-block-23, conditional phase-one
    // act19 = (KILL 3)
    // act31 = (ADD Y)
    // act658 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (IS...
    // act659 = (CAT N T EVAL (COMPOUND-WITH-SUFFIX LEX 'N ROOT 1 'IER 'OF))
    ":r-block", false, true, false),
  r("e r # -> 24,658,660",
  // r-block-24, conditional phase-one
    // act24 = (KILL 1)
    // act658 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (IS...
    // act660 = (CAT N T EVAL (COMPOUND-WITH-SUFFIX LEX 'N ROOT 0 'R 'OF))
    ":r-block", false, true, false),
  r("e r # -> 50,661,662",
  // r-block-25, conditional phase-one
    // act50 = (KILL 2)
    // act661 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (IS...
    // act662 = (CAT N T EVAL (COMPOUND-WITH-SUFFIX LEX 'N ROOT 0 'ER 'OF))
    ":r-block", false, true, false),
  r("consonant vowel b|d|g|k|l|m|n|p|r|s|t|z & e r # -> 19,658,663",
  // r-block-26, conditional phase-one
    // act19 = (KILL 3)
    // act658 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (IS...
    // act663 = (CAT N T EVAL (COMPOUND-WITH-SUFFIX LEX 'N ROOT -1 'ER 'OF))
    ":r-block", false, true, false),
  r("s t e r # -> 61,35,664",
  // r-block-27, conditional phase-one
    // act61 = (KILL 4)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act664 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(N V)))...
    ":r-block", false, true, false),
  r("consonant s t e r # -> 61,68,35,664",
  // r-block-28, conditional phase-one
    // act61 = (KILL 4)
    // act68 = (ADD E)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act664 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(N V)))...
    ":r-block", false, true, false),
  r("i e r # -> 19,31,35,626,627,665",
  // r-block-29, conditional phase-one
    // act19 = (KILL 3)
    // act31 = (ADD Y)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act626 = (CAT ADJ (AND (MORPH-ROOT STATE) (OR (TEST-ICODE ROOT 'ADJ '...
    // act627 = (CAT ADV (AND (MORPH-ROOT STATE) (OR (TEST-ICODE ROOT 'ADV '...
    // act665 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(V NN))...
    ":r-block", false, true, false),
  r("vowel consonant & e r # -> 19,35,666,667,668",
  // r-block-30, conditional phase-one
    // act19 = (KILL 3)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act666 = (CAT ADJ (AND (MORPH-ROOT STATE) (OR (TEST-ICODE ROOT 'ADJ '...
    // act667 = (CAT ADV (AND (MORPH-ROOT STATE) (OR (TEST-ICODE ROOT 'ADV '...
    // act668 = (CAT N (AND (MORPH-ROOT STATE) (OR (TEST-ICODE ROOT 'V '(S-*...
    ":r-block", false, true, false),
  r("e e r # -> 19,35,669",
  // r-block-31, conditional phase-one
    // act19 = (KILL 3)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act669 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'N)) EVA...
    ":r-block", false, true, false),
  r("i n e e r # -> 19,31,131,670",
  // r-block-32, conditional phase-one
    // act19 = (KILL 3)
    // act31 = (ADD Y)
    // act131 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (POLYSYLLABIC ROOT)))
    // act670 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'NN)) EV...
    ":r-block", false, true, false),
  r("i e r # -> 19,31,35,671,672,673",
  // r-block-33, conditional phase-one
    // act19 = (KILL 3)
    // act31 = (ADD Y)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act671 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADJ) ...
    // act672 = (CAT ADV (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADV) ...
    // act673 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(V NN))...
    ":r-block", false, true, false),
  r("i e r # -> 19,35,624,671,672,673",
  // r-block-34, conditional phase-one
    // act19 = (KILL 3)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act624 = (ADD E Y)
    // act671 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADJ) ...
    // act672 = (CAT ADV (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADV) ...
    // act673 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(V NN))...
    ":r-block", false, true, false),
  r("i e r # -> 19,68,674,31,636,675,676,677",
  // r-block-35, phase-one
    // act19 = (KILL 3)
    // act68 = (ADD E)
    // act674 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (NEED-FINAL-E ROOT) (MORPH-...
    // act31 = (ADD Y)
    // act636 = (CAT ADJ (AND (MORPH-ROOT STATE) (PLAUSIBLE-COMPARATIVE-ROOT...
    // act675 = (CAT ADV (AND (MORPH-ROOT STATE) (PLAUSIBLE-COMPARATIVE-ROOT...
    // act676 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-ROOT...
    // act677 = (CAT N T EVAL (LIST LEX (LIST 'ROOT ROOT) '(NUMBER SG) '(SUF...
    ":r-block", true, false, false),
  r("i e r # -> 19,676,31,636,675,676,677",
  // r-block-36, phase-one
    // act19 = (KILL 3)
    // act676 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-ROOT...
    // act31 = (ADD Y)
    // act636 = (CAT ADJ (AND (MORPH-ROOT STATE) (PLAUSIBLE-COMPARATIVE-ROOT...
    // act675 = (CAT ADV (AND (MORPH-ROOT STATE) (PLAUSIBLE-COMPARATIVE-ROOT...
    // act676 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-ROOT...
    // act677 = (CAT N T EVAL (LIST LEX (LIST 'ROOT ROOT) '(NUMBER SG) '(SUF...
    ":r-block", true, false, false),
  r("e r # -> 24,678,671,672,673",
  // r-block-37, conditional phase-one
    // act24 = (KILL 1)
    // act678 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (PO...
    // act671 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADJ) ...
    // act672 = (CAT ADV (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADV) ...
    // act673 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(V NN))...
    ":r-block", false, true, false),
  r("e r # -> 50,625,35,679,680,681,24,682,683,684,685",
  // r-block-38, conditional phase-one
    // act50 = (KILL 2)
    // act625 = (SETQ SUFFIX 'ER)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act679 = (CAT ADJ (AND (MORPH-ROOT STATE) (OR (TEST-ICODE ROOT 'ADJ '...
    // act680 = (CAT ADV (AND (MORPH-ROOT STATE) (OR (TEST-ICODE ROOT 'ADV '...
    // act681 = (CAT N (AND (MORPH-ROOT STATE) (OR (AND (IS-ROOT-OF-CAT ROOT...
    // act24 = (KILL 1)
    // act682 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (NEED-FINAL-E ROOT) (MORPH-...
    // act683 = (CAT ADJ (AND (MORPH-ROOT STATE) (OR (TEST-ICODE ROOT 'ADJ '...
    // act684 = (CAT ADV (AND (MORPH-ROOT STATE) (OR (TEST-ICODE ROOT 'ADV '...
    // act685 = (CAT N (AND (MORPH-ROOT STATE) (OR (IS-ROOT-OF-CAT ROOT '(V ...
    ":r-block", false, true, true),
  r("c k e r # -> 19,35,686,687,685",
  // r-block-39, conditional phase-one
    // act19 = (KILL 3)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act686 = (CAT ADJ (AND (MORPH-ROOT STATE) (OR (TEST-ICODE ROOT 'ADJ '...
    // act687 = (CAT ADV (AND (MORPH-ROOT STATE) (OR (TEST-ICODE ROOT 'ADV '...
    // act685 = (CAT N (AND (MORPH-ROOT STATE) (OR (IS-ROOT-OF-CAT ROOT '(V ...
    ":r-block", false, true, false),
  r("consonant vowel b|d|g|k|l|m|n|p|r|t & e r # -> 19,35,671,672,685",
  // r-block-40, conditional phase-one
    // act19 = (KILL 3)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act671 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADJ) ...
    // act672 = (CAT ADV (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADV) ...
    // act685 = (CAT N (AND (MORPH-ROOT STATE) (OR (IS-ROOT-OF-CAT ROOT '(V ...
    ":r-block", false, true, false),
  r("consonant vowel b|d|g|k|l|m|n|p|r|t & i e r # -> 61,676,19,31,636,675,688,677",
  // r-block-41, phase-one
    // act61 = (KILL 4)
    // act676 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-ROOT...
    // act19 = (KILL 3)
    // act31 = (ADD Y)
    // act636 = (CAT ADJ (AND (MORPH-ROOT STATE) (PLAUSIBLE-COMPARATIVE-ROOT...
    // act675 = (CAT ADV (AND (MORPH-ROOT STATE) (PLAUSIBLE-COMPARATIVE-ROOT...
    // act688 = (TEST (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(V NN)))...
    // act677 = (CAT N T EVAL (LIST LEX (LIST 'ROOT ROOT) '(NUMBER SG) '(SUF...
    ":r-block", true, false, false),
  r("q u vowel b|d|g|k|m|n|p|r|t & i e r # -> 61,676,19,31,636,675,676,677",
  // r-block-42, phase-one
    // act61 = (KILL 4)
    // act676 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-ROOT...
    // act19 = (KILL 3)
    // act31 = (ADD Y)
    // act636 = (CAT ADJ (AND (MORPH-ROOT STATE) (PLAUSIBLE-COMPARATIVE-ROOT...
    // act675 = (CAT ADV (AND (MORPH-ROOT STATE) (PLAUSIBLE-COMPARATIVE-ROOT...
    // act676 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-ROOT...
    // act677 = (CAT N T EVAL (LIST LEX (LIST 'ROOT ROOT) '(NUMBER SG) '(SUF...
    ":r-block", true, false, false),
  r("i e r # -> 19,633,689,690,676,31,625,636,675",
  // r-block-43, phase-one
    // act19 = (KILL 3)
    // act633 = (SETQ SUFFIX 'IER)
    // act689 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (POLYSYLLABIC ROOT) (MORPH-...
    // act690 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'NN)) EV...
    // act676 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-ROOT...
    // act31 = (ADD Y)
    // act625 = (SETQ SUFFIX 'ER)
    // act636 = (CAT ADJ (AND (MORPH-ROOT STATE) (PLAUSIBLE-COMPARATIVE-ROOT...
    // act675 = (CAT ADV (AND (MORPH-ROOT STATE) (PLAUSIBLE-COMPARATIVE-ROOT...
    ":r-block", true, false, true),
  r("consonant vowel b|d|g|k|m|n|p|r|t & e r # -> 19,35,671,672,673",
  // r-block-44, conditional phase-one
    // act19 = (KILL 3)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act671 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADJ) ...
    // act672 = (CAT ADV (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADV) ...
    // act673 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(V NN))...
    ":r-block", false, true, false),
  r("q u vowel b|d|g|k|m|n|p|r|t & e r # -> 19,671,672,673",
  // r-block-45, conditional phase-one
    // act19 = (KILL 3)
    // act671 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADJ) ...
    // act672 = (CAT ADV (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADV) ...
    // act673 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(V NN))...
    ":r-block", false, true, false),
  r("consonant vowel l l e r # -> 50,32,671,672,673",
  // r-block-46, conditional phase-one
    // act50 = (KILL 2)
    // act32 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-KNOW...
    // act671 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADJ) ...
    // act672 = (CAT ADV (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADV) ...
    // act673 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(V NN))...
    ":r-block", false, true, false),
  r("consonant vowel l l e r # -> 19,35,671,672,673",
  // r-block-47, conditional phase-one
    // act19 = (KILL 3)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act671 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADJ) ...
    // act672 = (CAT ADV (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADV) ...
    // act673 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(V NN))...
    ":r-block", false, true, false),
  r("consonant vowel s|z & e r # -> 50,35,671,672,673",
  // r-block-48, conditional phase-one
    // act50 = (KILL 2)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act671 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADJ) ...
    // act672 = (CAT ADV (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADV) ...
    // act673 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(V NN))...
    ":r-block", false, true, false),
  r("consonant vowel s|z & e r # -> 19,35,671,672,673",
  // r-block-49, conditional phase-one
    // act19 = (KILL 3)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act671 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADJ) ...
    // act672 = (CAT ADV (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADV) ...
    // act673 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(V NN))...
    ":r-block", false, true, false),
  r("e r # -> 24,682,671,672,673",
  // r-block-50, conditional phase-one
    // act24 = (KILL 1)
    // act682 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (NEED-FINAL-E ROOT) (MORPH-...
    // act671 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADJ) ...
    // act672 = (CAT ADV (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADV) ...
    // act673 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(V NN))...
    ":r-block", false, true, false),
  r("e r # -> 50,31,691,692",
  // r-block-51, conditional phase-one
    // act50 = (KILL 2)
    // act31 = (ADD Y)
    // act691 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (POLYSYLLABIC ROOT) (MORPH-...
    // act692 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'NM)) EV...
    ":r-block", false, true, false),
  r("consonant vowel b|d|f|g|k|l|m|n|p|r|s|t|v|z e r # -> 24,35,693,671,672",
  // r-block-52, conditional phase-one
    // act24 = (KILL 1)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act693 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'V)) EVA...
    // act671 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADJ) ...
    // act672 = (CAT ADV (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADV) ...
    ":r-block", false, true, false),
  r("q u a|i|o|u b|d|f|g|k|l|m|n|p|r|s|t|v|z e r # -> 24,35,693,671,672",
  // r-block-53, conditional phase-one
    // act24 = (KILL 1)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act693 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'V)) EVA...
    // act671 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADJ) ...
    // act672 = (CAT ADV (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADV) ...
    ":r-block", false, true, false),
  r("r v e r # -> 24,35,693,671,672",
  // r-block-54, conditional phase-one
    // act24 = (KILL 1)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act693 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'V)) EVA...
    // act671 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADJ) ...
    // act672 = (CAT ADV (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADV) ...
    ":r-block", false, true, false),
  r("u e r # -> 24,35,693,671,672",
  // r-block-55, conditional phase-one
    // act24 = (KILL 1)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act693 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'V)) EVA...
    // act671 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADJ) ...
    // act672 = (CAT ADV (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADV) ...
    ":r-block", false, true, false),
  r("consonant vowel & b|d|f|g|k|l|m|n|p|r|s|t|v|z e r # -> 50,35,693,671,672",
  // r-block-56, conditional phase-one
    // act50 = (KILL 2)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act693 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'V)) EVA...
    // act671 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADJ) ...
    // act672 = (CAT ADV (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADV) ...
    ":r-block", false, true, false),
  r("consonant vowel b|c|d|f|g|k|l|m|n|p|q|r|t|v|w|y e r # -> 24,35,693,671,672",
  // r-block-57, conditional phase-one
    // act24 = (KILL 1)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act693 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'V)) EVA...
    // act671 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADJ) ...
    // act672 = (CAT ADV (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADV) ...
    ":r-block", false, true, false),
  r("i n g e r # -> 50,625,35,693,671,672,24,693,671,672",
  // r-block-58, conditional phase-one
    // act50 = (KILL 2)
    // act625 = (SETQ SUFFIX 'ER)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act693 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'V)) EVA...
    // act671 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADJ) ...
    // act672 = (CAT ADV (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADV) ...
    // act24 = (KILL 1)
    // act693 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'V)) EVA...
    // act671 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADJ) ...
    // act672 = (CAT ADV (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADV) ...
    ":r-block", false, true, true),
  r("c|g e r # -> 24,35,693,671,672",
  // r-block-59, conditional phase-one
    // act24 = (KILL 1)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act693 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'V)) EVA...
    // act671 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADJ) ...
    // act672 = (CAT ADV (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADV) ...
    ":r-block", false, true, false),
  r("l|n|r c|g e r # -> 24,35,693,671,672",
  // r-block-60, conditional phase-one
    // act24 = (KILL 1)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act693 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'V)) EVA...
    // act671 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADJ) ...
    // act672 = (CAT ADV (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADV) ...
    ":r-block", false, true, false),
  r("l|r s|v e r # -> 24,35,693,671,672",
  // r-block-61, conditional phase-one
    // act24 = (KILL 1)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act693 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'V)) EVA...
    // act671 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADJ) ...
    // act672 = (CAT ADV (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADV) ...
    ":r-block", false, true, false),
  r("e r # -> 24,35,693,671,672",
  // r-block-62, conditional phase-one
    // act24 = (KILL 1)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act693 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'V)) EVA...
    // act671 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADJ) ...
    // act672 = (CAT ADV (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADV) ...
    ":r-block", false, true, false),
  r("e r # -> 50,269,693,671,672",
  // r-block-63, conditional phase-one
    // act50 = (KILL 2)
    // act269 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (NE...
    // act693 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'V)) EVA...
    // act671 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADJ) ...
    // act672 = (CAT ADV (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADV) ...
    ":r-block", false, true, false),
  r("c k e r # -> 19,35,693",
  // r-block-64, conditional phase-one
    // act19 = (KILL 3)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act693 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'V)) EVA...
    ":r-block", false, true, false),
  r("y e r # -> 24,35,693,629",
  // r-block-65, conditional phase-one
    // act24 = (KILL 1)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act693 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'V)) EVA...
    // act629 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADJ))...
    ":r-block", false, true, false),
  r("l e r # -> 24,35,693,671,672",
  // r-block-66, conditional phase-one
    // act24 = (KILL 1)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act693 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'V)) EVA...
    // act671 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADJ) ...
    // act672 = (CAT ADV (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADV) ...
    ":r-block", false, true, false),
  r("consonant vowel b|d|f|g|l|m|n|p|r|s|t|k|v|z e r # -> 24,35,693,671,672",
  // r-block-67, conditional phase-one
    // act24 = (KILL 1)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act693 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'V)) EVA...
    // act671 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADJ) ...
    // act672 = (CAT ADV (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADV) ...
    ":r-block", false, true, false),
  r("o u r # -> 50,694,35,695,696,697,698",
  // r-block-68, conditional phase-one
    // act50 = (KILL 2)
    // act694 = (ADD R)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act695 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(N))) E...
    // act696 = (CAT V (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(V))) E...
    // act697 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(ADJ)...
    // act698 = (CAT ADV (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(ADV)...
    ":r-block", false, true, false),
  r("c o l o r # -> 57,699,700,701",
  // r-block-69, 
    // act57 = (KILL 5)
    // act699 = (CAT N T EVAL (PROGN (MARK-DICT LEX 'FALSE-ROOT ROOT T T) (M...
    // act700 = (CAT V T EVAL (PROGN (MARK-DICT LEX 'FALSE-ROOT ROOT T T) (M...
    // act701 = (CAT ADJ (PLAUSIBLE-ROOT ROOT) EVAL (PROGN (MARK-DICT LEX 'F...
    ":r-block"),
  r("b|l|n a r # -> 50,68,702,703",
  // r-block-70, conditional phase-one
    // act50 = (KILL 2)
    // act68 = (ADD E)
    // act702 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (NEED-FINAL-E ROOT) (MORPH-...
    // act703 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'NN)) ...
    ":r-block", false, true, false),
  r("b|l|m|n|e a r # -> 50,704,703",
  // r-block-71, conditional phase-one
    // act50 = (KILL 2)
    // act704 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NO-SUFF...
    // act703 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'NN)) ...
    ":r-block", false, true, false),
  r("a r # -> 50,117,705,703",
  // r-block-72, conditional phase-one
    // act50 = (KILL 2)
    // act117 = (ADD A)
    // act705 = (TEST (AND (POLYSYLLABIC ROOT) (PLAUSIBLE-ROOT ROOT)))
    // act703 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'NN)) ...
    ":r-block", false, true, false),
  r("a r # -> 50,194,705,703",
  // r-block-73, conditional phase-one
    // act50 = (KILL 2)
    // act194 = (ADD U S)
    // act705 = (TEST (AND (POLYSYLLABIC ROOT) (PLAUSIBLE-ROOT ROOT)))
    // act703 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'NN)) ...
    ":r-block", false, true, false),
  r("a r # -> 50,116,705,703",
  // r-block-74, conditional phase-one
    // act50 = (KILL 2)
    // act116 = (ADD U M)
    // act705 = (TEST (AND (POLYSYLLABIC ROOT) (PLAUSIBLE-ROOT ROOT)))
    // act703 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'NN)) ...
    ":r-block", false, true, false),
  r("vowel b|l|n a r # -> 50,68,706",
  // r-block-75, conditional phase-one
    // act50 = (KILL 2)
    // act68 = (ADD E)
    // act706 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'N) (P...
    ":r-block", false, true, false),
  r("y l a r # -> 50,68,707",
  // r-block-76, conditional phase-one
    // act50 = (KILL 2)
    // act68 = (ADD E)
    // act707 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'NN) (...
    ":r-block", false, true, false),
  r("consonant i|o|u a r # -> 50,68,707",
  // r-block-77, conditional phase-one
    // act50 = (KILL 2)
    // act68 = (ADD E)
    // act707 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'NN) (...
    ":r-block", false, true, false),
  r("u|y l a r # -> 50,68,35,708",
  // r-block-78, 
    // act50 = (KILL 2)
    // act68 = (ADD E)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act708 = (CAT ADJ T EVAL (LIST LEX (LIST 'ROOT ROOT) '(SUFFIX AR)))
    ":r-block"),
  r("e u r # -> 19,35,69,709",
  // r-block-79, conditional phase-one
    // act19 = (KILL 3)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act69 = (ADD O R)
    // act709 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(NN))) ...
    ":r-block", false, true, false),
  r("e u r # -> 19,35,710",
  // r-block-80, conditional phase-one
    // act19 = (KILL 3)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act710 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(V NN))...
    ":r-block", false, true, false),
  r("e u r # -> 50,35,69,709",
  // r-block-81, conditional phase-one
    // act50 = (KILL 2)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act69 = (ADD O R)
    // act709 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(NN))) ...
    ":r-block", false, true, false),
  r("e u r # -> 50,35,710",
  // r-block-82, conditional phase-one
    // act50 = (KILL 2)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act710 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(V NN))...
    ":r-block", false, true, false),
  r("o r # -> 50,711,35,712,68,105,713",
  // r-block-83, conditional phase-one
    // act50 = (KILL 2)
    // act711 = (SETQ SUFFIX 'OR)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act712 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'V)) EVA...
    // act68 = (ADD E)
    // act105 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (NEED-FINAL-E ROOT)))
    // act713 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(V))) E...
    ":r-block", false, true, true),
  r("vowel consonant o r # -> 50,35,68,714",
  // r-block-84, conditional phase-one
    // act50 = (KILL 2)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act68 = (ADD E)
    // act714 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'V)) EVA...
    ":r-block", false, true, false),
  r("consonant vowel b|d|g|k|m|n|p|r|t & o r # -> 19,35,714",
  // r-block-85, conditional phase-one
    // act19 = (KILL 3)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act714 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'V)) EVA...
    ":r-block", false, true, false),
  r("q u vowel b|d|g|k|m|n|p|r|t & o r # -> 19,35,714",
  // r-block-86, conditional phase-one
    // act19 = (KILL 3)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act714 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'V)) EVA...
    ":r-block", false, true, false),
  r("p t o r # -> 61,316,493,715",
  // r-block-87, conditional phase-one
    // act61 = (KILL 4)
    // act316 = (ADD B)
    // act493 = (TEST (AND (PLAUSIBLE-ROOT ROOT)))
    // act715 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'V)) EVA...
    ":r-block", false, true, false),
  r("p t o r # -> 61,317,35,715",
  // r-block-88, conditional phase-one
    // act61 = (KILL 4)
    // act317 = (ADD B E)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act715 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'V)) EVA...
    ":r-block", false, true, false),
  r("c e p t o r # -> 61,282,35,716",
  // r-block-89, conditional phase-one
    // act61 = (KILL 4)
    // act282 = (ADD I V E)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act716 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADJ)) E...
    ":r-block", false, true, false),
  r("e r r o r # -> 57,717",
  // r-block-90, 
    // act57 = (KILL 5)
    // act717 = (CAT N T EVAL (LIST LEX '(NUMBER SG) (LIST 'PREFIX ROOT) '(R...
    ":r-block"),
  r("m a n a g e r # -> 113,718",
  // r-block-91, 
    // act113 = (KILL 7)
    // act718 = (CAT N (PLAUSIBLE-ROOT ROOT) EVAL (PROGN (MARK-DICT LEX 'FAL...
    ":r-block"),
  r("m e t e r # -> 435",
  // r-block-92, 
    // act435 = (CAT N (PLAUSIBLE-ROOT ROOT) EVAL '-S)
    ":r-block"),
  r("c h e s t e r # -> 35,264,154",
  // r-block-93, 
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act264 = (CAT CITY T EVAL '*)
    // act154 = (CAT LASTNAME T EVAL '*)
    ":r-block"),
  r("consonant vowel b|d|g|k|m|n|p|r|t & o r # -> 19,719",
  // r-block-94, 
    // act19 = (KILL 3)
    // act719 = (CAT N (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT 'V)) EVAL (L...
    ":r-block"),
  r("q u vowel b|d|g|k|m|n|p|r|t & o r # -> 19,719",
  // r-block-95, 
    // act19 = (KILL 3)
    // act719 = (CAT N (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT 'V)) EVAL (L...
    ":r-block"),
  r("vowel consonant o r # -> 50,68,105,719",
  // r-block-96, 
    // act50 = (KILL 2)
    // act68 = (ADD E)
    // act105 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (NEED-FINAL-E ROOT)))
    // act719 = (CAT N (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT 'V)) EVAL (L...
    ":r-block"),
  r("consonant o r # -> 50,719",
  // r-block-97, 
    // act50 = (KILL 2)
    // act719 = (CAT N (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT 'V)) EVAL (L...
    ":r-block"),
  r("consonant i e r # -> 19,31,720,721,722",
  // r-block-98, 
    // act19 = (KILL 3)
    // act31 = (ADD Y)
    // act720 = (CAT N (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT '(V NN))) EV...
    // act721 = (CAT ADJ (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT 'ADJ) (PLA...
    // act722 = (CAT ADV (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT 'ADV) (PLA...
    ":r-block"),
  r("e e r # -> 24,625,723,721,722,19,724,725",
  // r-block-99, phase-two
    // act24 = (KILL 1)
    // act625 = (SETQ SUFFIX 'ER)
    // act723 = (CAT N (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT 'V)) EVAL (L...
    // act721 = (CAT ADJ (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT 'ADJ) (PLA...
    // act722 = (CAT ADV (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT 'ADV) (PLA...
    // act19 = (KILL 3)
    // act724 = (SETQ SUFFIX 'EER)
    // act725 = (CAT N (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT 'N)) EVAL (P...
    ":r-block", false, false, true),
  r("consonant vowel b|d|g|k|m|n|p|r|t & e r # -> 19,726,723,721,722",
  // r-block-100, 
    // act19 = (KILL 3)
    // act726 = (TEST (AND (MORPH-ROOT STATE) (NOT (IS-HYPHENATED ROOT))))
    // act723 = (CAT N (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT 'V)) EVAL (L...
    // act721 = (CAT ADJ (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT 'ADJ) (PLA...
    // act722 = (CAT ADV (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT 'ADV) (PLA...
    ":r-block"),
  r("consonant vowel b|d|g|k|m|n|p|r|t & e r # -> 19,726,727",
  // r-block-101, 
    // act19 = (KILL 3)
    // act726 = (TEST (AND (MORPH-ROOT STATE) (NOT (IS-HYPHENATED ROOT))))
    // act727 = (CAT N (POLYSYLLABIC ROOT) EVAL (LIST LEX (LIST 'ROOT ROOT) ...
    ":r-block"),
  r("consonant vowel l|s|z & e r # -> 50,726,723,721,722",
  // r-block-102, 
    // act50 = (KILL 2)
    // act726 = (TEST (AND (MORPH-ROOT STATE) (NOT (IS-HYPHENATED ROOT))))
    // act723 = (CAT N (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT 'V)) EVAL (L...
    // act721 = (CAT ADJ (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT 'ADJ) (PLA...
    // act722 = (CAT ADV (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT 'ADV) (PLA...
    ":r-block"),
  r("consonant e r e r # -> 50,726,727,728,729",
  // r-block-103, 
    // act50 = (KILL 2)
    // act726 = (TEST (AND (MORPH-ROOT STATE) (NOT (IS-HYPHENATED ROOT))))
    // act727 = (CAT N (POLYSYLLABIC ROOT) EVAL (LIST LEX (LIST 'ROOT ROOT) ...
    // act728 = (CAT ADJ (AND (POLYSYLLABIC ROOT) (MORPH-ROOT STATE) (PLAUSI...
    // act729 = (CAT ADV (AND (POLYSYLLABIC ROOT) (MORPH-ROOT STATE) (PLAUSI...
    ":r-block"),
  r("b e r g e r # -> 152",
  // r-block-104, 
    // act152 = (CAT LASTNAME (PLAUSIBLE-ROOT ROOT) EVAL '*)
    ":r-block"),
  r("consonant o v e r # -> 158",
  // r-block-105, phase-one
    // act158 = (DO DEFAULT-RULE)
    ":r-block", true, false, false),
  r("consonant vowel b|d|f|g|l|m|n|p|r|s|t|k|v|z e r # -> 24,726,723,721,722",
  // r-block-106, 
    // act24 = (KILL 1)
    // act726 = (TEST (AND (MORPH-ROOT STATE) (NOT (IS-HYPHENATED ROOT))))
    // act723 = (CAT N (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT 'V)) EVAL (L...
    // act721 = (CAT ADJ (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT 'ADJ) (PLA...
    // act722 = (CAT ADV (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT 'ADV) (PLA...
    ":r-block"),
  r("consonant vowel & b|d|f|g|l|m|n|p|r|s|t|k|v|z e r # -> 50,726,723,721,722",
  // r-block-107, 
    // act50 = (KILL 2)
    // act726 = (TEST (AND (MORPH-ROOT STATE) (NOT (IS-HYPHENATED ROOT))))
    // act723 = (CAT N (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT 'V)) EVAL (L...
    // act721 = (CAT ADJ (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT 'ADJ) (PLA...
    // act722 = (CAT ADV (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT 'ADV) (PLA...
    ":r-block"),
  r("c|g e r # -> 24,726,723,721,722",
  // r-block-108, 
    // act24 = (KILL 1)
    // act726 = (TEST (AND (MORPH-ROOT STATE) (NOT (IS-HYPHENATED ROOT))))
    // act723 = (CAT N (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT 'V)) EVAL (L...
    // act721 = (CAT ADJ (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT 'ADJ) (PLA...
    // act722 = (CAT ADV (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT 'ADV) (PLA...
    ":r-block"),
  r("l|n|r c|g e r # -> 24,726,723,721,722",
  // r-block-109, 
    // act24 = (KILL 1)
    // act726 = (TEST (AND (MORPH-ROOT STATE) (NOT (IS-HYPHENATED ROOT))))
    // act723 = (CAT N (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT 'V)) EVAL (L...
    // act721 = (CAT ADJ (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT 'ADJ) (PLA...
    // act722 = (CAT ADV (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT 'ADV) (PLA...
    ":r-block"),
  r("c|s h e r # -> 50,726,723,721,722",
  // r-block-110, 
    // act50 = (KILL 2)
    // act726 = (TEST (AND (MORPH-ROOT STATE) (NOT (IS-HYPHENATED ROOT))))
    // act723 = (CAT N (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT 'V)) EVAL (L...
    // act721 = (CAT ADJ (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT 'ADJ) (PLA...
    // act722 = (CAT ADV (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT 'ADV) (PLA...
    ":r-block"),
  r("s|z & e r # -> 50,726,723,721,722",
  // r-block-111, 
    // act50 = (KILL 2)
    // act726 = (TEST (AND (MORPH-ROOT STATE) (NOT (IS-HYPHENATED ROOT))))
    // act723 = (CAT N (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT 'V)) EVAL (L...
    // act721 = (CAT ADJ (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT 'ADJ) (PLA...
    // act722 = (CAT ADV (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT 'ADV) (PLA...
    ":r-block"),
  r("s|z e r # -> 24,726,723,721,722",
  // r-block-112, 
    // act24 = (KILL 1)
    // act726 = (TEST (AND (MORPH-ROOT STATE) (NOT (IS-HYPHENATED ROOT))))
    // act723 = (CAT N (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT 'V)) EVAL (L...
    // act721 = (CAT ADJ (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT 'ADJ) (PLA...
    // act722 = (CAT ADV (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT 'ADV) (PLA...
    ":r-block"),
  r("vowel f|l|s|z & e r # -> 50,726,730,721,722",
  // r-block-113, 
    // act50 = (KILL 2)
    // act726 = (TEST (AND (MORPH-ROOT STATE) (NOT (IS-HYPHENATED ROOT))))
    // act730 = (CAT N (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT '(V N))) EVA...
    // act721 = (CAT ADJ (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT 'ADJ) (PLA...
    // act722 = (CAT ADV (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT 'ADV) (PLA...
    ":r-block"),
  r("vowel consonant & e r # -> 19,726,677,721,722",
  // r-block-114, 
    // act19 = (KILL 3)
    // act726 = (TEST (AND (MORPH-ROOT STATE) (NOT (IS-HYPHENATED ROOT))))
    // act677 = (CAT N T EVAL (LIST LEX (LIST 'ROOT ROOT) '(NUMBER SG) '(SUF...
    // act721 = (CAT ADJ (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT 'ADJ) (PLA...
    // act722 = (CAT ADV (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT 'ADV) (PLA...
    ":r-block"),
  r("e r # -> 24,731,732,721,722",
  // r-block-115, 
    // act24 = (KILL 1)
    // act731 = (TEST (AND (MORPH-ROOT STATE) (NOT (IS-HYPHENATED ROOT)) (NE...
    // act732 = (CAT N (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT '(NN))) EVAL...
    // act721 = (CAT ADJ (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT 'ADJ) (PLA...
    // act722 = (CAT ADV (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT 'ADV) (PLA...
    ":r-block"),
  r("e r # -> 50,726,733",
  // r-block-116, 
    // act50 = (KILL 2)
    // act726 = (TEST (AND (MORPH-ROOT STATE) (NOT (IS-HYPHENATED ROOT))))
    // act733 = (CAT N (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT '(NN)) (NOT ...
    ":r-block"),
  r("e r # -> 24,731,732",
  // r-block-117, 
    // act24 = (KILL 1)
    // act731 = (TEST (AND (MORPH-ROOT STATE) (NOT (IS-HYPHENATED ROOT)) (NE...
    // act732 = (CAT N (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT '(NN))) EVAL...
    ":r-block"),
  r("p h e r # -> 270",
  // r-block-118, 
    // act270 = (CAT N (POLYSYLLABIC ROOT) EVAL '-S)
    ":r-block"),
  r("s e r # -> 270",
  // r-block-119, 
    // act270 = (CAT N (POLYSYLLABIC ROOT) EVAL '-S)
    ":r-block"),
  r("y e r # -> 270",
  // r-block-120, 
    // act270 = (CAT N (POLYSYLLABIC ROOT) EVAL '-S)
    ":r-block"),
  r("z e r # -> 270",
  // r-block-121, 
    // act270 = (CAT N (POLYSYLLABIC ROOT) EVAL '-S)
    ":r-block"),
  r("p h o r # -> 270",
  // r-block-122, 
    // act270 = (CAT N (POLYSYLLABIC ROOT) EVAL '-S)
    ":r-block"),
  r("t o r # -> 270",
  // r-block-123, 
    // act270 = (CAT N (POLYSYLLABIC ROOT) EVAL '-S)
    ":r-block"),
  r("e r # -> 24,731,734",
  // r-block-124, 
    // act24 = (KILL 1)
    // act731 = (TEST (AND (MORPH-ROOT STATE) (NOT (IS-HYPHENATED ROOT)) (NE...
    // act734 = (CAT N (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (I...
    ":r-block"),
  r(" -> 180,158",
  // r-block-125, 
    // act180 = (TEST T)
    // act158 = (DO DEFAULT-RULE)
    ":r-block"),
 };

 protected static MorphRule[] tBlock = {//":t-block"
  r("e s t # -> 735,736",
  // t-block-1, phase-one
    // act735 = (TEST (AND (MORPH-ROOT STATE) (MAY-BE-SUPERLATIVE-ETC LEX)))
    // act736 = (TRY EST-BLOCK)
    ":t-block", true, false, false),
  r("e d s t # -> 50,737,738",
  // t-block-2, conditional phase-one
    // act50 = (KILL 2)
    // act737 = (CAT V (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'V)) EVA...
    // act738 = (CAT V (AND (MORPH-ROOT STATE) (IS-FORM-OF-CAT ROOT 'PAST)) ...
    ":t-block", false, true, false),
  r("consonant i m e n t # -> 57,31,35,739",
  // t-block-3, conditional phase-one
    // act57 = (KILL 5)
    // act31 = (ADD Y)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act739 = (CAT NMC (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'V)) E...
    ":t-block", false, true, false),
  r("m e n t # -> 61,740,35,741,68,538,741",
  // t-block-4, conditional phase-one
    // act61 = (KILL 4)
    // act740 = (SETQ SUFFIX 'MENT)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act741 = (CAT NMC (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'V)) E...
    // act68 = (ADD E)
    // act538 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (PA...
    // act741 = (CAT NMC (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'V)) E...
    ":t-block", false, true, true),
  r("m o s t # -> 61,35,742",
  // t-block-5, conditional phase-one
    // act61 = (KILL 4)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act742 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(ADJ)...
    ":t-block", false, true, false),
  r("l l a n t # -> 61,743,744,745",
  // t-block-6, conditional phase-one
    // act61 = (KILL 4)
    // act743 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (POLYSYLLABIC ROOT) (MORPH-...
    // act744 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(NN V...
    // act745 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(V)) (>...
    ":t-block", false, true, false),
  r("a n t # -> 19,743,744,745",
  // t-block-7, conditional phase-one
    // act19 = (KILL 3)
    // act743 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (POLYSYLLABIC ROOT) (MORPH-...
    // act744 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(NN V...
    // act745 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(V)) (>...
    ":t-block", false, true, false),
  r("a n t # -> 19,68,746,747,748",
  // t-block-8, conditional phase-one
    // act19 = (KILL 3)
    // act68 = (ADD E)
    // act746 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (POLYSYLLABIC ROOT) (> (NCH...
    // act747 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(NN V...
    // act748 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(V)) (>...
    ":t-block", false, true, false),
  r("a n t # -> 19,341,743,744,749",
  // t-block-9, conditional phase-one
    // act19 = (KILL 3)
    // act341 = (ADD A T E)
    // act743 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (POLYSYLLABIC ROOT) (MORPH-...
    // act744 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(NN V...
    // act749 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(V ADJ)...
    ":t-block", false, true, false),
  r("a n t # -> 50,750,751,752,753",
  // t-block-10, conditional phase-one
    // act50 = (KILL 2)
    // act750 = (ADD T I O N)
    // act751 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (POLYSYLLABIC ROOT) (> (NCH...
    // act752 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(NN))...
    // act753 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(NN)) (...
    ":t-block", false, true, false),
  r("a n t # -> 24,484,743,752,753",
  // t-block-11, conditional phase-one
    // act24 = (KILL 1)
    // act484 = (ADD C E)
    // act743 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (POLYSYLLABIC ROOT) (MORPH-...
    // act752 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(NN))...
    // act753 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(NN)) (...
    ":t-block", false, true, false),
  r("consonant vowel b|d|g|k|l|m|n|p|r|t & e n t # -> 61,35,754,755",
  // t-block-12, conditional phase-one
    // act61 = (KILL 4)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act754 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(V)) ...
    // act755 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(V)) (>...
    ":t-block", false, true, false),
  r("e n t # -> 19,756,754,755",
  // t-block-13, conditional phase-one
    // act19 = (KILL 3)
    // act756 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (PA...
    // act754 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(V)) ...
    // act755 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(V)) (>...
    ":t-block", false, true, false),
  r("e n t # -> 19,756,68,754,755",
  // t-block-14, conditional phase-one
    // act19 = (KILL 3)
    // act756 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (PA...
    // act68 = (ADD E)
    // act754 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(V)) ...
    // act755 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(V)) (>...
    ":t-block", false, true, false),
  r("vowel l i e n t # -> 61,35,68,754,757",
  // t-block-15, conditional phase-one
    // act61 = (KILL 4)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act68 = (ADD E)
    // act754 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(V)) ...
    // act757 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(V)) (>...
    ":t-block", false, true, false),
  r("l e f t # -> 61,758,759,760",
  // t-block-16, conditional phase-one
    // act61 = (KILL 4)
    // act758 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (> (NCHARS ROOT) 2)))
    // act759 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(N AD...
    // act760 = (CAT V (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'V)) EVA...
    ":t-block", false, true, false),
  r("n a u t # -> 761,758,762",
  // t-block-17, conditional phase-one
    // act761 = (ADD I C S)
    // act758 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (> (NCHARS ROOT) 2)))
    // act762 = (CAT N (AND (MORPH-ROOT STATE) (IS-KNOWN-WORD ROOT) (IS-ROOT...
    ":t-block", false, true, false),
  r("n a u t # -> 61,758,763",
  // t-block-18, conditional phase-one
    // act61 = (KILL 4)
    // act758 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (> (NCHARS ROOT) 2)))
    // act763 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(PREFIX...
    ":t-block", false, true, false),
  r("s t a t # -> 61,758,764",
  // t-block-19, conditional phase-one
    // act61 = (KILL 4)
    // act758 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (> (NCHARS ROOT) 2)))
    // act764 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(PREFIX...
    ":t-block", false, true, false),
  r("i s t # -> 19,68,765,766,767",
  // t-block-20, conditional phase-one
    // act19 = (KILL 3)
    // act68 = (ADD E)
    // act765 = (TEST (AND (MORPH-ROOT STATE) (IS-KNOWN-WORD ROOT) (PLAUSIBL...
    // act766 = (CAT ADJ T EVAL (LIST LEX (LIST 'ROOT ROOT) '(SUFFIX IST)))
    // act767 = (CAT NC T EVAL (LIST LEX '(NUMBER SG) (LIST 'ROOT ROOT) '(SU...
    ":t-block", false, true, false),
  r("i s t # -> 19,768,766,767",
  // t-block-21, conditional phase-one
    // act19 = (KILL 3)
    // act768 = (TEST (AND (MORPH-ROOT STATE) (IS-KNOWN-WORD ROOT) (PLAUSIBL...
    // act766 = (CAT ADJ T EVAL (LIST LEX (LIST 'ROOT ROOT) '(SUFFIX IST)))
    // act767 = (CAT NC T EVAL (LIST LEX '(NUMBER SG) (LIST 'ROOT ROOT) '(SU...
    ":t-block", false, true, false),
  r("i s t # -> 19,68,769,766,767",
  // t-block-22, conditional phase-one
    // act19 = (KILL 3)
    // act68 = (ADD E)
    // act769 = (TEST (AND (MORPH-ROOT STATE) (IS-KNOWN-WORD ROOT) (PLAUSIBL...
    // act766 = (CAT ADJ T EVAL (LIST LEX (LIST 'ROOT ROOT) '(SUFFIX IST)))
    // act767 = (CAT NC T EVAL (LIST LEX '(NUMBER SG) (LIST 'ROOT ROOT) '(SU...
    ":t-block", false, true, false),
  r("i s t # -> 19,761,770,766,767",
  // t-block-23, conditional phase-one
    // act19 = (KILL 3)
    // act761 = (ADD I C S)
    // act770 = (TEST (AND (MORPH-ROOT STATE) (IS-KNOWN-WORD ROOT) (PLAUSIBL...
    // act766 = (CAT ADJ T EVAL (LIST LEX (LIST 'ROOT ROOT) '(SUFFIX IST)))
    // act767 = (CAT NC T EVAL (LIST LEX '(NUMBER SG) (LIST 'ROOT ROOT) '(SU...
    ":t-block", false, true, false),
  r("i s t # -> 19,287,771,766,767",
  // t-block-24, conditional phase-one
    // act19 = (KILL 3)
    // act287 = (ADD I S M)
    // act771 = (TEST (AND (MORPH-ROOT STATE) (IS-KNOWN-WORD ROOT) (PLAUSIBL...
    // act766 = (CAT ADJ T EVAL (LIST LEX (LIST 'ROOT ROOT) '(SUFFIX IST)))
    // act767 = (CAT NC T EVAL (LIST LEX '(NUMBER SG) (LIST 'ROOT ROOT) '(SU...
    ":t-block", false, true, false),
  r("i s t # -> 19,31,771,766,767",
  // t-block-25, conditional phase-one
    // act19 = (KILL 3)
    // act31 = (ADD Y)
    // act771 = (TEST (AND (MORPH-ROOT STATE) (IS-KNOWN-WORD ROOT) (PLAUSIBL...
    // act766 = (CAT ADJ T EVAL (LIST LEX (LIST 'ROOT ROOT) '(SUFFIX IST)))
    // act767 = (CAT NC T EVAL (LIST LEX '(NUMBER SG) (LIST 'ROOT ROOT) '(SU...
    ":t-block", false, true, false),
  r("i s t # -> 19,118,771,766,767",
  // t-block-26, conditional phase-one
    // act19 = (KILL 3)
    // act118 = (ADD I C)
    // act771 = (TEST (AND (MORPH-ROOT STATE) (IS-KNOWN-WORD ROOT) (PLAUSIBL...
    // act766 = (CAT ADJ T EVAL (LIST LEX (LIST 'ROOT ROOT) '(SUFFIX IST)))
    // act767 = (CAT NC T EVAL (LIST LEX '(NUMBER SG) (LIST 'ROOT ROOT) '(SU...
    ":t-block", false, true, false),
  r("i s t # -> 24,772,773,766,767",
  // t-block-27, conditional phase-one
    // act24 = (KILL 1)
    // act772 = (ADD M)
    // act773 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (POLYSYLLABIC ROOT) (MORPH-...
    // act766 = (CAT ADJ T EVAL (LIST LEX (LIST 'ROOT ROOT) '(SUFFIX IST)))
    // act767 = (CAT NC T EVAL (LIST LEX '(NUMBER SG) (LIST 'ROOT ROOT) '(SU...
    ":t-block", false, true, false),
  r("i s t # -> 19,37,774,766,767",
  // t-block-28, conditional phase-one
    // act19 = (KILL 3)
    // act37 = (ADD O)
    // act774 = (TEST (AND (MORPH-ROOT STATE) (IS-KNOWN-WORD ROOT) (PLAUSIBL...
    // act766 = (CAT ADJ T EVAL (LIST LEX (LIST 'ROOT ROOT) '(SUFFIX IST)))
    // act767 = (CAT NC T EVAL (LIST LEX '(NUMBER SG) (LIST 'ROOT ROOT) '(SU...
    ":t-block", false, true, false),
  r("vowel b|d|g|k|l|m|n|p|r|t & i s t # -> 61,770,766,767",
  // t-block-29, conditional phase-one
    // act61 = (KILL 4)
    // act770 = (TEST (AND (MORPH-ROOT STATE) (IS-KNOWN-WORD ROOT) (PLAUSIBL...
    // act766 = (CAT ADJ T EVAL (LIST LEX (LIST 'ROOT ROOT) '(SUFFIX IST)))
    // act767 = (CAT NC T EVAL (LIST LEX '(NUMBER SG) (LIST 'ROOT ROOT) '(SU...
    ":t-block", false, true, false),
  r("i s t # -> 50,542,775,766,767",
  // t-block-30, conditional phase-one
    // act50 = (KILL 2)
    // act542 = (ADD Z E)
    // act775 = (TEST (AND (MORPH-ROOT STATE) (IS-KNOWN-WORD ROOT) (PLAUSIBL...
    // act766 = (CAT ADJ T EVAL (LIST LEX (LIST 'ROOT ROOT) '(SUFFIX IST)))
    // act767 = (CAT NC T EVAL (LIST LEX '(NUMBER SG) (LIST 'ROOT ROOT) '(SU...
    ":t-block", false, true, false),
  r("i s t # -> 24,68,775,766,767",
  // t-block-31, conditional phase-one
    // act24 = (KILL 1)
    // act68 = (ADD E)
    // act775 = (TEST (AND (MORPH-ROOT STATE) (IS-KNOWN-WORD ROOT) (PLAUSIBL...
    // act766 = (CAT ADJ T EVAL (LIST LEX (LIST 'ROOT ROOT) '(SUFFIX IST)))
    // act767 = (CAT NC T EVAL (LIST LEX '(NUMBER SG) (LIST 'ROOT ROOT) '(SU...
    ":t-block", false, true, false),
  r("i s t # -> 19,776,766,767",
  // t-block-32, conditional phase-one
    // act19 = (KILL 3)
    // act776 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (> (NCHARS ROOT) 2) (MORPH-...
    // act766 = (CAT ADJ T EVAL (LIST LEX (LIST 'ROOT ROOT) '(SUFFIX IST)))
    // act767 = (CAT NC T EVAL (LIST LEX '(NUMBER SG) (LIST 'ROOT ROOT) '(SU...
    ":t-block", false, true, false),
  r("i s t # -> 19,68,777,766,767",
  // t-block-33, conditional phase-one
    // act19 = (KILL 3)
    // act68 = (ADD E)
    // act777 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (> (NCHARS ROOT) 2) (MORPH-...
    // act766 = (CAT ADJ T EVAL (LIST LEX (LIST 'ROOT ROOT) '(SUFFIX IST)))
    // act767 = (CAT NC T EVAL (LIST LEX '(NUMBER SG) (LIST 'ROOT ROOT) '(SU...
    ":t-block", false, true, false),
  r("i s t # -> 19,778,766,767",
  // t-block-34, conditional phase-one
    // act19 = (KILL 3)
    // act778 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (> (NCHARS ROOT) 2) (MORPH-...
    // act766 = (CAT ADJ T EVAL (LIST LEX (LIST 'ROOT ROOT) '(SUFFIX IST)))
    // act767 = (CAT NC T EVAL (LIST LEX '(NUMBER SG) (LIST 'ROOT ROOT) '(SU...
    ":t-block", false, true, false),
  r("i s t # -> 19,68,779,766,767",
  // t-block-35, conditional phase-one
    // act19 = (KILL 3)
    // act68 = (ADD E)
    // act779 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (> (NCHARS ROOT) 2) (MORPH-...
    // act766 = (CAT ADJ T EVAL (LIST LEX (LIST 'ROOT ROOT) '(SUFFIX IST)))
    // act767 = (CAT NC T EVAL (LIST LEX '(NUMBER SG) (LIST 'ROOT ROOT) '(SU...
    ":t-block", false, true, false),
  r("vowel consonant i s t # -> 19,31,780,766,767",
  // t-block-36, conditional phase-one
    // act19 = (KILL 3)
    // act31 = (ADD Y)
    // act780 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-KNOW...
    // act766 = (CAT ADJ T EVAL (LIST LEX (LIST 'ROOT ROOT) '(SUFFIX IST)))
    // act767 = (CAT NC T EVAL (LIST LEX '(NUMBER SG) (LIST 'ROOT ROOT) '(SU...
    ":t-block", false, true, false),
  r("vowel consonant i s t # -> 19,31,781,766,767",
  // t-block-37, conditional phase-one
    // act19 = (KILL 3)
    // act31 = (ADD Y)
    // act781 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-KNOW...
    // act766 = (CAT ADJ T EVAL (LIST LEX (LIST 'ROOT ROOT) '(SUFFIX IST)))
    // act767 = (CAT NC T EVAL (LIST LEX '(NUMBER SG) (LIST 'ROOT ROOT) '(SU...
    ":t-block", false, true, false),
  r("i c i s t # -> 19,22,773,782,767",
  // t-block-38, conditional phase-one
    // act19 = (KILL 3)
    // act22 = (ADD S)
    // act773 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (POLYSYLLABIC ROOT) (MORPH-...
    // act782 = (CAT ADJ T EVAL (LIST LEX (LIST 'ROOT ROOT) '(SUFFIX IST) '(...
    // act767 = (CAT NC T EVAL (LIST LEX '(NUMBER SG) (LIST 'ROOT ROOT) '(SU...
    ":t-block", false, true, false),
  r("b|c|d|f|g|k|l|m|n|p|r|s|t|v|z i s t # -> 19,783,766,767",
  // t-block-39, conditional phase-one
    // act19 = (KILL 3)
    // act783 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (> (NCHARS ROOT) 2) (MORPH-...
    // act766 = (CAT ADJ T EVAL (LIST LEX (LIST 'ROOT ROOT) '(SUFFIX IST)))
    // act767 = (CAT NC T EVAL (LIST LEX '(NUMBER SG) (LIST 'ROOT ROOT) '(SU...
    ":t-block", false, true, false),
  r("b|c|d|f|g|k|l|m|n|p|r|s|t|v|z i s t # -> 19,68,783,766,767",
  // t-block-40, conditional phase-one
    // act19 = (KILL 3)
    // act68 = (ADD E)
    // act783 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (> (NCHARS ROOT) 2) (MORPH-...
    // act766 = (CAT ADJ T EVAL (LIST LEX (LIST 'ROOT ROOT) '(SUFFIX IST)))
    // act767 = (CAT NC T EVAL (LIST LEX '(NUMBER SG) (LIST 'ROOT ROOT) '(SU...
    ":t-block", false, true, false),
  r("i s t # -> 19,117,784,766,767",
  // t-block-41, conditional phase-one
    // act19 = (KILL 3)
    // act117 = (ADD A)
    // act784 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (POLYSYLLABIC ROOT) (MORPH-...
    // act766 = (CAT ADJ T EVAL (LIST LEX (LIST 'ROOT ROOT) '(SUFFIX IST)))
    // act767 = (CAT NC T EVAL (LIST LEX '(NUMBER SG) (LIST 'ROOT ROOT) '(SU...
    ":t-block", false, true, false),
  r("vowel l l i s t # -> 61,783,766,767",
  // t-block-42, conditional phase-one
    // act61 = (KILL 4)
    // act783 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (> (NCHARS ROOT) 2) (MORPH-...
    // act766 = (CAT ADJ T EVAL (LIST LEX (LIST 'ROOT ROOT) '(SUFFIX IST)))
    // act767 = (CAT NC T EVAL (LIST LEX '(NUMBER SG) (LIST 'ROOT ROOT) '(SU...
    ":t-block", false, true, false),
  r("l i s t # -> 61,785,786",
  // t-block-43, conditional phase-one
    // act61 = (KILL 4)
    // act785 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-ROOT...
    // act786 = (CAT NC T EVAL (PROGN (MARK-DICT LEX 'FALSE-ROOT ROOT T T) (...
    ":t-block", false, true, false),
  r("l i s t # -> 61,787,786",
  // t-block-44, 
    // act61 = (KILL 4)
    // act787 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (MORPH-C...
    // act786 = (CAT NC T EVAL (PROGN (MARK-DICT LEX 'FALSE-ROOT ROOT T T) (...
    ":t-block"),
  r("l e t # -> 19,35,788",
  // t-block-45, conditional phase-one
    // act19 = (KILL 3)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act788 = (CAT NC (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(ADJ N...
    ":t-block", false, true, false),
  r("s t a t # -> 270",
  // t-block-46, 
    // act270 = (CAT N (POLYSYLLABIC ROOT) EVAL '-S)
    ":t-block"),
  r("e t # -> 270",
  // t-block-47, 
    // act270 = (CAT N (POLYSYLLABIC ROOT) EVAL '-S)
    ":t-block"),
  r("d e n t # -> 270,164",
  // t-block-48, 
    // act270 = (CAT N (POLYSYLLABIC ROOT) EVAL '-S)
    // act164 = (CAT ADJ (POLYSYLLABIC ROOT) EVAL '*)
    ":t-block"),
  r("a n t # -> 270,164",
  // t-block-49, 
    // act270 = (CAT N (POLYSYLLABIC ROOT) EVAL '-S)
    // act164 = (CAT ADJ (POLYSYLLABIC ROOT) EVAL '*)
    ":t-block"),
  r("m e n t # -> 789",
  // t-block-50, 
    // act789 = (CAT NMC (POLYSYLLABIC ROOT) EVAL '-S)
    ":t-block"),
  r("f a c i e n t # -> 192",
  // t-block-51, 
    // act192 = (CAT N T EVAL '-S)
    ":t-block"),
  r("c|l|n|r e n t # -> 164",
  // t-block-52, 
    // act164 = (CAT ADJ (POLYSYLLABIC ROOT) EVAL '*)
    ":t-block"),
  r("i e n t # -> 164",
  // t-block-53, 
    // act164 = (CAT ADJ (POLYSYLLABIC ROOT) EVAL '*)
    ":t-block"),
  r("e n t # -> 270,164",
  // t-block-54, 
    // act270 = (CAT N (POLYSYLLABIC ROOT) EVAL '-S)
    // act164 = (CAT ADJ (POLYSYLLABIC ROOT) EVAL '*)
    ":t-block"),
  r("o l o g i s t # -> 19,31,790,766,767",
  // t-block-55, 
    // act19 = (KILL 3)
    // act31 = (ADD Y)
    // act790 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (MAY-BE-...
    // act766 = (CAT ADJ T EVAL (LIST LEX (LIST 'ROOT ROOT) '(SUFFIX IST)))
    // act767 = (CAT NC T EVAL (LIST LEX '(NUMBER SG) (LIST 'ROOT ROOT) '(SU...
    ":t-block"),
  r("i a t r i s t # -> 19,31,790,767",
  // t-block-56, 
    // act19 = (KILL 3)
    // act31 = (ADD Y)
    // act790 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (MAY-BE-...
    // act767 = (CAT NC T EVAL (LIST LEX '(NUMBER SG) (LIST 'ROOT ROOT) '(SU...
    ":t-block"),
  r("consonant vowel b|c|d|f|g|k|l|m|n|p|r|s|t|v|z i s t # -> 19,68,791,766,792",
  // t-block-57, 
    // act19 = (KILL 3)
    // act68 = (ADD E)
    // act791 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (NEED-FINAL-E ROOT) (MORPH-...
    // act766 = (CAT ADJ T EVAL (LIST LEX (LIST 'ROOT ROOT) '(SUFFIX IST)))
    // act792 = (CAT NC T EVAL (LIST LEX '(NUMBER SG) (LIST 'ROOT ROOT) '(SU...
    ":t-block"),
  r("l i s t # -> 19,793,766,794",
  // t-block-58, 
    // act19 = (KILL 3)
    // act793 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (> (NCHARS ROOT) 2) (MORPH-...
    // act766 = (CAT ADJ T EVAL (LIST LEX (LIST 'ROOT ROOT) '(SUFFIX IST)))
    // act794 = (CAT NC T EVAL (LIST LEX '(NUMBER SG) (LIST 'PREFIX ROOT) '(...
    ":t-block"),
  r("l i s t # -> 61,793,794",
  // t-block-59, 
    // act61 = (KILL 4)
    // act793 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (> (NCHARS ROOT) 2) (MORPH-...
    // act794 = (CAT NC T EVAL (LIST LEX '(NUMBER SG) (LIST 'PREFIX ROOT) '(...
    ":t-block"),
  r("i s t # -> 19,795,766,792",
  // t-block-60, 
    // act19 = (KILL 3)
    // act795 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (> (NCHARS ROOT) 2) (MORPH-...
    // act766 = (CAT ADJ T EVAL (LIST LEX (LIST 'ROOT ROOT) '(SUFFIX IST)))
    // act792 = (CAT NC T EVAL (LIST LEX '(NUMBER SG) (LIST 'ROOT ROOT) '(SU...
    ":t-block"),
  r("i s t # -> 19,68,796,766,792",
  // t-block-61, 
    // act19 = (KILL 3)
    // act68 = (ADD E)
    // act796 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (> (NCHARS ROOT) 2) (MORPH-...
    // act766 = (CAT ADJ T EVAL (LIST LEX (LIST 'ROOT ROOT) '(SUFFIX IST)))
    // act792 = (CAT NC T EVAL (LIST LEX '(NUMBER SG) (LIST 'ROOT ROOT) '(SU...
    ":t-block"),
  r("vowel consonant i s t # -> 19,31,797,766,792",
  // t-block-62, 
    // act19 = (KILL 3)
    // act31 = (ADD Y)
    // act797 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (POLYSYLLABIC ROOT) (MORPH-...
    // act766 = (CAT ADJ T EVAL (LIST LEX (LIST 'ROOT ROOT) '(SUFFIX IST)))
    // act792 = (CAT NC T EVAL (LIST LEX '(NUMBER SG) (LIST 'ROOT ROOT) '(SU...
    ":t-block"),
  r("i s t # -> 19,22,798,766,792",
  // t-block-63, 
    // act19 = (KILL 3)
    // act22 = (ADD S)
    // act798 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (POLYSYLLABIC ROOT) (MORPH-...
    // act766 = (CAT ADJ T EVAL (LIST LEX (LIST 'ROOT ROOT) '(SUFFIX IST)))
    // act792 = (CAT NC T EVAL (LIST LEX '(NUMBER SG) (LIST 'ROOT ROOT) '(SU...
    ":t-block"),
  r("b|c|d|f|g|k|l|m|n|p|r|s|t|v|z i s t # -> 19,68,795,766,792",
  // t-block-64, 
    // act19 = (KILL 3)
    // act68 = (ADD E)
    // act795 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (> (NCHARS ROOT) 2) (MORPH-...
    // act766 = (CAT ADJ T EVAL (LIST LEX (LIST 'ROOT ROOT) '(SUFFIX IST)))
    // act792 = (CAT NC T EVAL (LIST LEX '(NUMBER SG) (LIST 'ROOT ROOT) '(SU...
    ":t-block"),
  r("a u t # -> 270",
  // t-block-65, 
    // act270 = (CAT N (POLYSYLLABIC ROOT) EVAL '-S)
    ":t-block"),
  r("n o s t # -> 799",
  // t-block-66, 
    // act799 = (CAT NM (POLYSYLLABIC ROOT) EVAL (PROGN (MARK-DICT LEX 'FEAT...
    ":t-block"),
  r(" -> 180,158",
  // t-block-67, 
    // act180 = (TEST T)
    // act158 = (DO DEFAULT-RULE)
    ":t-block"),
 };

 protected static MorphRule[] yBlock = {//":y-block"
  r("a|e n c y # -> 24,68,131,800",
  // y-block-1, conditional phase-one
    // act24 = (KILL 1)
    // act68 = (ADD E)
    // act131 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (POLYSYLLABIC ROOT)))
    // act800 = (CAT NM (AND (MORPH-ROOT STATE) (IS-KNOWN-WORD ROOT) (IS-ROO...
    ":y-block", false, true, false),
  r("m o r p h y # -> 102,35,801",
  // y-block-2, conditional phase-one
    // act102 = (KILL 6)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act801 = (CAT NM (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(PREFI...
    ":y-block", false, true, false),
  r("p a t h y # -> 57,35,802",
  // y-block-3, conditional phase-one
    // act57 = (KILL 5)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act802 = (CAT NM (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(PREFI...
    ":y-block", false, true, false),
  r("t r o p h y # -> 102,35,803",
  // y-block-4, conditional phase-one
    // act102 = (KILL 6)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act803 = (CAT NM (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(PREFI...
    ":y-block", false, true, false),
  r("t r o p y # -> 24,68,35,804",
  // y-block-5, conditional phase-one
    // act24 = (KILL 1)
    // act68 = (ADD E)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act804 = (CAT NM (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(N))) ...
    ":y-block", false, true, false),
  r("p h a g y # -> 57,35,805",
  // y-block-6, conditional phase-one
    // act57 = (KILL 5)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act805 = (CAT NM (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(PREFI...
    ":y-block", false, true, false),
  r("p h o n y # -> 24,68,35,804",
  // y-block-7, conditional phase-one
    // act24 = (KILL 1)
    // act68 = (ADD E)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act804 = (CAT NM (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(N))) ...
    ":y-block", false, true, false),
  r("p h o n y # -> 57,35,806",
  // y-block-8, conditional phase-one
    // act57 = (KILL 5)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act806 = (CAT NM (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(PREFI...
    ":y-block", false, true, false),
  r("m e g a l y # -> 102,35,807",
  // y-block-9, conditional phase-one
    // act102 = (KILL 6)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act807 = (CAT NM (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(PREFI...
    ":y-block", false, true, false),
  r("c e p h a l y # -> 113,35,808",
  // y-block-10, conditional phase-one
    // act113 = (KILL 7)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act808 = (CAT NM (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(PREFI...
    ":y-block", false, true, false),
  r("p a t h y # -> 809",
  // y-block-11, phase-one
    // act809 = (CAT NM (POLYSYLLABIC ROOT) EVAL '-IES)
    ":y-block", true, false, false),
  r("t r o p h y # -> 809",
  // y-block-12, phase-one
    // act809 = (CAT NM (POLYSYLLABIC ROOT) EVAL '-IES)
    ":y-block", true, false, false),
  r("m e g a l y # -> 810",
  // y-block-13, phase-one
    // act810 = (CAT N (POLYSYLLABIC ROOT) EVAL (LIST LEX '(NUMBER SG) '(MAS...
    ":y-block", true, false, false),
  r("c e p h a l y # -> 810",
  // y-block-14, phase-one
    // act810 = (CAT N (POLYSYLLABIC ROOT) EVAL (LIST LEX '(NUMBER SG) '(MAS...
    ":y-block", true, false, false),
  r("e r y # -> 24,32,811,812",
  // y-block-15, conditional phase-one
    // act24 = (KILL 1)
    // act32 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-KNOW...
    // act811 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(NM))...
    // act812 = (CAT NM (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(N V A...
    ":y-block", false, true, false),
  r("vowel b|d|g|k|l|m|n|p|r|t & e r y # -> 61,32,812",
  // y-block-16, conditional phase-one
    // act61 = (KILL 4)
    // act32 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-KNOW...
    // act812 = (CAT NM (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(N V A...
    ":y-block", false, true, false),
  r("e r y # -> 50,813,812",
  // y-block-17, conditional phase-one
    // act50 = (KILL 2)
    // act813 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-KNOW...
    // act812 = (CAT NM (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(N V A...
    ":y-block", false, true, false),
  r("e r y # -> 19,32,812",
  // y-block-18, conditional phase-one
    // act19 = (KILL 3)
    // act32 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-KNOW...
    // act812 = (CAT NM (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(N V A...
    ":y-block", false, true, false),
  r("e r y # -> 24,35,811,812",
  // y-block-19, conditional phase-one
    // act24 = (KILL 1)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act811 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(NM))...
    // act812 = (CAT NM (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(N V A...
    ":y-block", false, true, false),
  r("vowel b|d|g|k|l|m|n|p|r|t & e r y # -> 61,35,812",
  // y-block-20, conditional phase-one
    // act61 = (KILL 4)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act812 = (CAT NM (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(N V A...
    ":y-block", false, true, false),
  r("e r y # -> 50,105,812",
  // y-block-21, conditional phase-one
    // act50 = (KILL 2)
    // act105 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (NEED-FINAL-E ROOT)))
    // act812 = (CAT NM (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(N V A...
    ":y-block", false, true, false),
  r("e r y # -> 19,35,812",
  // y-block-22, conditional phase-one
    // act19 = (KILL 3)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act812 = (CAT NM (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(N V A...
    ":y-block", false, true, false),
  r("vowel l l o g r a p h y # -> 111,35,814",
  // y-block-23, conditional phase-one
    // act111 = (KILL 8)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act814 = (CAT NM (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(N V))...
    ":y-block", false, true, false),
  r("o g r a p h y # -> 102,35,815",
  // y-block-24, conditional phase-one
    // act102 = (KILL 6)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act815 = (CAT NM (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(PREFI...
    ":y-block", false, true, false),
  r("o g r a p h y # -> 113,35,814",
  // y-block-25, conditional phase-one
    // act113 = (KILL 7)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act814 = (CAT NM (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(N V))...
    ":y-block", false, true, false),
  r("vowel g r a p h y # -> 102,35,816",
  // y-block-26, conditional phase-one
    // act102 = (KILL 6)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act816 = (CAT NM (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(N V))...
    ":y-block", false, true, false),
  r("i o g r a p h y # -> 111,31,35,814",
  // y-block-27, conditional phase-one
    // act111 = (KILL 8)
    // act31 = (ADD Y)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act814 = (CAT NM (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(N V))...
    ":y-block", false, true, false),
  r("o g r a p h y # -> 113,35,817",
  // y-block-28, 
    // act113 = (KILL 7)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act817 = (CAT NM (POLYSYLLABIC ROOT) EVAL (PROGN (MARK-DICT LEX 'KIND...
    ":y-block"),
  r("i o g r a p h y # -> 111,31,35,818",
  // y-block-29, 
    // act111 = (KILL 8)
    // act31 = (ADD Y)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act818 = (CAT NM (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT 'N)) EVAL (...
    ":y-block"),
  r("vowel g r a p h y # -> 102,35,818",
  // y-block-30, 
    // act102 = (KILL 6)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act818 = (CAT NM (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT 'N)) EVAL (...
    ":y-block"),
  r("vowel l l o l o g y # -> 102,35,819",
  // y-block-31, conditional phase-one
    // act102 = (KILL 6)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act819 = (CAT NM (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(N V))...
    ":y-block", false, true, false),
  r("a t o l o g y # -> 113,35,820",
  // y-block-32, 
    // act113 = (KILL 7)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act820 = (CAT NM T EVAL (PROGN (MARK-DICT LEX 'KINDOF 'SCIENCE T T) (...
    ":y-block"),
  r("a t o l o g y # -> 102,35,819",
  // y-block-33, conditional phase-one
    // act102 = (KILL 6)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act819 = (CAT NM (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(N V))...
    ":y-block", false, true, false),
  r("o l o g y # -> 61,107,114,819",
  // y-block-34, conditional phase-one
    // act61 = (KILL 4)
    // act107 = (ADD N)
    // act114 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (POLYSYLLABIC ROOT) (MORPH-...
    // act819 = (CAT NM (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(N V))...
    ":y-block", false, true, false),
  r("o l o g y # -> 57,35,819",
  // y-block-35, conditional phase-one
    // act57 = (KILL 5)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act819 = (CAT NM (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(N V))...
    ":y-block", false, true, false),
  r("o l o g y # -> 57,117,114,821",
  // y-block-36, conditional phase-one
    // act57 = (KILL 5)
    // act117 = (ADD A)
    // act114 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (POLYSYLLABIC ROOT) (MORPH-...
    // act821 = (CAT NM (AND (MORPH-ROOT STATE) (IS-FORM-OF-CAT ROOT '(N V))...
    ":y-block", false, true, false),
  r("i o l o g y # -> 57,22,35,819",
  // y-block-37, conditional phase-one
    // act57 = (KILL 5)
    // act22 = (ADD S)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act819 = (CAT NM (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(N V))...
    ":y-block", false, true, false),
  r("i o l o g y # -> 57,546,35,819",
  // y-block-38, conditional phase-one
    // act57 = (KILL 5)
    // act546 = (ADD C)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act819 = (CAT NM (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(N V))...
    ":y-block", false, true, false),
  r("o l o g y # -> 61,22,35,822",
  // y-block-39, conditional phase-one
    // act61 = (KILL 4)
    // act22 = (ADD S)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act822 = (CAT NM (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(N)) (...
    ":y-block", false, true, false),
  r("consonant o l o g y # -> 57,68,32,823",
  // y-block-40, conditional phase-one
    // act57 = (KILL 5)
    // act68 = (ADD E)
    // act32 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-KNOW...
    // act823 = (CAT NM (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(N V))...
    ":y-block", false, true, false),
  r("o l o g y # -> 57,118,32,824",
  // y-block-41, conditional phase-one
    // act57 = (KILL 5)
    // act118 = (ADD I C)
    // act32 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-KNOW...
    // act824 = (CAT NM (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(ADJ))...
    ":y-block", false, true, false),
  r("o l o g y # -> 57,68,105,825",
  // y-block-42, 
    // act57 = (KILL 5)
    // act68 = (ADD E)
    // act105 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (NEED-FINAL-E ROOT)))
    // act825 = (CAT NM T EVAL (PROGN (MARK-DICT LEX 'FALSE-ROOT ROOT T T) (...
    ":y-block"),
  r("o l o g y # -> 57,35,825",
  // y-block-43, 
    // act57 = (KILL 5)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act825 = (CAT NM T EVAL (PROGN (MARK-DICT LEX 'FALSE-ROOT ROOT T T) (...
    ":y-block"),
  r("o l o g y # -> 61,35,819",
  // y-block-44, conditional phase-one
    // act61 = (KILL 4)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act819 = (CAT NM (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(N V))...
    ":y-block", false, true, false),
  r("o l o g y # -> 61,35,826",
  // y-block-45, conditional phase-one
    // act61 = (KILL 4)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act826 = (CAT NM (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(PREFI...
    ":y-block", false, true, false),
  r("a l o g y # -> 19,35,827",
  // y-block-46, conditional phase-one
    // act19 = (KILL 3)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act827 = (CAT NM (AND (MORPH-ROOT STATE) (IS-KNOWN-WORD ROOT) (IS-ROO...
    ":y-block", false, true, false),
  r("a l o g y # -> 57,827",
  // y-block-47, conditional phase-one
    // act57 = (KILL 5)
    // act827 = (CAT NM (AND (MORPH-ROOT STATE) (IS-KNOWN-WORD ROOT) (IS-ROO...
    ":y-block", false, true, false),
  r("o g n o m y # -> 57,35,828",
  // y-block-48, conditional phase-one
    // act57 = (KILL 5)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act828 = (CAT NM (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(PREFI...
    ":y-block", false, true, false),
  r("n o m y # -> 61,35,829",
  // y-block-49, conditional phase-one
    // act61 = (KILL 4)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act829 = (CAT NM (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(PREFI...
    ":y-block", false, true, false),
  r("o g n o m y # -> 102,830",
  // y-block-50, 
    // act102 = (KILL 6)
    // act830 = (CAT NM (PLAUSIBLE-ROOT ROOT) EVAL (PROGN (MARK-DICT LEX 'FA...
    ":y-block"),
  r("o t o m y # -> 61,35,831",
  // y-block-51, conditional phase-one
    // act61 = (KILL 4)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act831 = (CAT NM (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(PREFI...
    ":y-block", false, true, false),
  r("o t o m y # -> 57,832",
  // y-block-52, 
    // act57 = (KILL 5)
    // act832 = (CAT NM (PLAUSIBLE-ROOT ROOT) EVAL (PROGN (MARK-DICT LEX 'FA...
    ":y-block"),
  r("o s t o m y # -> 57,35,833",
  // y-block-53, conditional phase-one
    // act57 = (KILL 5)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act833 = (CAT NM (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(PREFI...
    ":y-block", false, true, false),
  r("o s t o m y # -> 102,834",
  // y-block-54, 
    // act102 = (KILL 6)
    // act834 = (CAT NM (PLAUSIBLE-ROOT ROOT) EVAL (PROGN (MARK-DICT LEX 'FA...
    ":y-block"),
  r("e c t o m y # -> 102,204,835",
  // y-block-55, conditional phase-one
    // act102 = (KILL 6)
    // act204 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-ROOT...
    // act835 = (CAT NM T EVAL (PROGN (MARK-DICT LEX 'KINDOF 'OPERATION T T)...
    ":y-block", false, true, false),
  r("e c t o m y # -> 57,836,835",
  // y-block-56, conditional phase-one
    // act57 = (KILL 5)
    // act836 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-ROOT...
    // act835 = (CAT NM T EVAL (PROGN (MARK-DICT LEX 'KINDOF 'OPERATION T T)...
    ":y-block", false, true, false),
  r("e c t o m y # -> 837",
  // y-block-57, 
    // act837 = (CAT NM (PLAUSIBLE-ROOT ROOT) EVAL (PROGN (MARK-DICT LEX 'HA...
    ":y-block"),
  r("t r o p y # -> 838",
  // y-block-58, 
    // act838 = (CAT NM (PLAUSIBLE-ROOT ROOT) EVAL (PROGN (MARK-DICT LEX 'HA...
    ":y-block"),
  r("vowel l l o s c o p y # -> 113,35,839",
  // y-block-59, conditional phase-one
    // act113 = (KILL 7)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act839 = (CAT NM (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(N V))...
    ":y-block", false, true, false),
  r("o s c o p y # -> 57,35,840",
  // y-block-60, conditional phase-one
    // act57 = (KILL 5)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act840 = (CAT NM (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(PREFI...
    ":y-block", false, true, false),
  r("o s c o p y # -> 102,35,839",
  // y-block-61, conditional phase-one
    // act102 = (KILL 6)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act839 = (CAT NM (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(N V))...
    ":y-block", false, true, false),
  r("vowel s c o p y # -> 57,35,841",
  // y-block-62, conditional phase-one
    // act57 = (KILL 5)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act841 = (CAT NM (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(N V))...
    ":y-block", false, true, false),
  r("i o s c o p y # -> 113,31,35,839",
  // y-block-63, conditional phase-one
    // act113 = (KILL 7)
    // act31 = (ADD Y)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act839 = (CAT NM (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(N V))...
    ":y-block", false, true, false),
  r("o s c o p y # -> 102,35,842",
  // y-block-64, 
    // act102 = (KILL 6)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act842 = (CAT NM (POLYSYLLABIC ROOT) EVAL (PROGN (MARK-DICT LEX 'KIND...
    ":y-block"),
  r("i o s c o p y # -> 113,31,35,843",
  // y-block-65, 
    // act113 = (KILL 7)
    // act31 = (ADD Y)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act843 = (CAT NM (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT 'N)) EVAL (...
    ":y-block"),
  r("vowel s c o p y # -> 57,35,843",
  // y-block-66, 
    // act57 = (KILL 5)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act843 = (CAT NM (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT 'N)) EVAL (...
    ":y-block"),
  r("i o s c o p y # -> 102,31,35,844",
  // y-block-67, 
    // act102 = (KILL 6)
    // act31 = (ADD Y)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act844 = (CAT NM (SYLLABIC ROOT) EVAL (PROGN (MARK-DICT LEX 'KINDOF '...
    ":y-block"),
  r("o s c o p y # -> 102,35,844",
  // y-block-68, 
    // act102 = (KILL 6)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act844 = (CAT NM (SYLLABIC ROOT) EVAL (PROGN (MARK-DICT LEX 'KINDOF '...
    ":y-block"),
  r("g a m y # -> 61,35,845",
  // y-block-69, conditional phase-one
    // act61 = (KILL 4)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act845 = (CAT NM (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(NN V ...
    ":y-block", false, true, false),
  r("t a x y # -> 61,35,846",
  // y-block-70, conditional phase-one
    // act61 = (KILL 4)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act846 = (CAT NM (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(NN V ...
    ":y-block", false, true, false),
  r("g a m y # -> 61,847,848",
  // y-block-71, conditional phase-one
    // act61 = (KILL 4)
    // act847 = (TEST (AND (MORPH-ROOT STATE) (NOT (MEMB ROOT '(DE NON RE UN...
    // act848 = (CAT NM (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(NN V ...
    ":y-block", false, true, false),
  r("t a x y # -> 61,847,849",
  // y-block-72, conditional phase-one
    // act61 = (KILL 4)
    // act847 = (TEST (AND (MORPH-ROOT STATE) (NOT (MEMB ROOT '(DE NON RE UN...
    // act849 = (CAT NM (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(NN V ...
    ":y-block", false, true, false),
  r("o g o n y # -> 61,35,850",
  // y-block-73, conditional phase-one
    // act61 = (KILL 4)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act850 = (CAT NM (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(PREFI...
    ":y-block", false, true, false),
  r("o g r a p h y # -> 102,35,851",
  // y-block-74, conditional phase-one
    // act102 = (KILL 6)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act851 = (CAT NM (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(PREFI...
    ":y-block", false, true, false),
  r("g r a p h y # -> 102,35,852",
  // y-block-75, conditional phase-one
    // act102 = (KILL 6)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act852 = (CAT NM (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(PREFI...
    ":y-block", false, true, false),
  r("o g e n y # -> 61,35,853",
  // y-block-76, conditional phase-one
    // act61 = (KILL 4)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act853 = (CAT NM (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(PREFI...
    ":y-block", false, true, false),
  r("o g e n y # -> 57,35,854",
  // y-block-77, conditional phase-one
    // act57 = (KILL 5)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act854 = (CAT NM (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(N V))...
    ":y-block", false, true, false),
  r("o g e n y # -> 61,35,854",
  // y-block-78, conditional phase-one
    // act61 = (KILL 4)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act854 = (CAT NM (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(N V))...
    ":y-block", false, true, false),
  r("o g e n y # -> 61,107,32,854",
  // y-block-79, conditional phase-one
    // act61 = (KILL 4)
    // act107 = (ADD N)
    // act32 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-KNOW...
    // act854 = (CAT NM (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(N V))...
    ":y-block", false, true, false),
  r("o g e n y # -> 57,855",
  // y-block-80, 
    // act57 = (KILL 5)
    // act855 = (CAT NM (PLAUSIBLE-ROOT ROOT) EVAL (PROGN (MARK-DICT LEX 'FA...
    ":y-block"),
  r("o l a t r y # -> 57,35,856",
  // y-block-81, conditional phase-one
    // act57 = (KILL 5)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act856 = (CAT NM (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(PREFI...
    ":y-block", false, true, false),
  r("o l a t r y # -> 102,35,857",
  // y-block-82, conditional phase-one
    // act102 = (KILL 6)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act857 = (CAT NM (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(N V))...
    ":y-block", false, true, false),
  r("a n d r y # -> 57,35,858",
  // y-block-83, conditional phase-one
    // act57 = (KILL 5)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act858 = (CAT NM (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(ADJ P...
    ":y-block", false, true, false),
  r("a n d r y # -> 57,37,35,858",
  // y-block-84, conditional phase-one
    // act57 = (KILL 5)
    // act37 = (ADD O)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act858 = (CAT NM (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(ADJ P...
    ":y-block", false, true, false),
  r("s c o p y # -> 24,68,35,859",
  // y-block-85, conditional phase-one
    // act24 = (KILL 1)
    // act68 = (ADD E)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act859 = (CAT NM (AND (MORPH-ROOT STATE) (IS-FORM-OF-CAT ROOT '(NN)))...
    ":y-block", false, true, false),
  r("vowel l l o m e t r y # -> 113,35,860",
  // y-block-86, conditional phase-one
    // act113 = (KILL 7)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act860 = (CAT NM (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(N V))...
    ":y-block", false, true, false),
  r("m e t r y # -> 57,35,861",
  // y-block-87, conditional phase-one
    // act57 = (KILL 5)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act861 = (CAT NM (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(PREFI...
    ":y-block", false, true, false),
  r("o m e t r y # -> 102,35,860",
  // y-block-88, conditional phase-one
    // act102 = (KILL 6)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act860 = (CAT NM (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(N V))...
    ":y-block", false, true, false),
  r("vowel m e t r y # -> 57,35,860",
  // y-block-89, conditional phase-one
    // act57 = (KILL 5)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act860 = (CAT NM (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(N V))...
    ":y-block", false, true, false),
  r("i o m e t r y # -> 113,31,35,860",
  // y-block-90, conditional phase-one
    // act113 = (KILL 7)
    // act31 = (ADD Y)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act860 = (CAT NM (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(N V))...
    ":y-block", false, true, false),
  r("o m e t r y # -> 102,31,35,860",
  // y-block-91, conditional phase-one
    // act102 = (KILL 6)
    // act31 = (ADD Y)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act860 = (CAT NM (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(N V))...
    ":y-block", false, true, false),
  r("o m e t r y # -> 102,35,862",
  // y-block-92, 
    // act102 = (KILL 6)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act862 = (CAT NM (POLYSYLLABIC ROOT) EVAL (PROGN (MARK-DICT LEX 'KIND...
    ":y-block"),
  r("i o m e t r y # -> 113,31,35,863",
  // y-block-93, 
    // act113 = (KILL 7)
    // act31 = (ADD Y)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act863 = (CAT NM (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT 'N)) EVAL (...
    ":y-block"),
  r("vowel m e t r y # -> 57,35,863",
  // y-block-94, 
    // act57 = (KILL 5)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act863 = (CAT NM (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT 'N)) EVAL (...
    ":y-block"),
  r("i o m e t r y # -> 102,31,35,864",
  // y-block-95, 
    // act102 = (KILL 6)
    // act31 = (ADD Y)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act864 = (CAT NM (SYLLABIC ROOT) EVAL (PROGN (MARK-DICT LEX 'KINDOF '...
    ":y-block"),
  r("o m e t r y # -> 102,35,864",
  // y-block-96, 
    // act102 = (KILL 6)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act864 = (CAT NM (SYLLABIC ROOT) EVAL (PROGN (MARK-DICT LEX 'KINDOF '...
    ":y-block"),
  r("consonant l y # -> 24,68,105,865,866",
  // y-block-97, conditional phase-one
    // act24 = (KILL 1)
    // act68 = (ADD E)
    // act105 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (NEED-FINAL-E ROOT)))
    // act865 = (CAT ADV (AND (MORPH-ROOT STATE) (IS-KNOWN-WORD ROOT) (IS-RO...
    // act866 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-KNOWN-WORD ROOT) (IS-RO...
    ":y-block", false, true, false),
  r("e r y # -> 24,35,867",
  // y-block-98, conditional phase-one
    // act24 = (KILL 1)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act867 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(NN))...
    ":y-block", false, true, false),
  r("e r y # -> 50,105,868",
  // y-block-99, conditional phase-one
    // act50 = (KILL 2)
    // act105 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (NEED-FINAL-E ROOT)))
    // act868 = (CAT NM (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(NN)) ...
    ":y-block", false, true, false),
  r("e r y # -> 19,35,868",
  // y-block-100, conditional phase-one
    // act19 = (KILL 3)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act868 = (CAT NM (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(NN)) ...
    ":y-block", false, true, false),
  r("i f y # -> 19,869",
  // y-block-101, conditional phase-one
    // act19 = (KILL 3)
    // act869 = (CAT V (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-ROO...
    ":y-block", false, true, false),
  r("y f y # -> 50,869",
  // y-block-102, conditional phase-one
    // act50 = (KILL 2)
    // act869 = (CAT V (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-ROO...
    ":y-block", false, true, false),
  r("e f y # -> 50,869",
  // y-block-103, conditional phase-one
    // act50 = (KILL 2)
    // act869 = (CAT V (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-ROO...
    ":y-block", false, true, false),
  r("e f y # -> 19,870,869",
  // y-block-104, conditional phase-one
    // act19 = (KILL 3)
    // act870 = (ADD I D)
    // act869 = (CAT V (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-ROO...
    ":y-block", false, true, false),
  r("i f y # -> 19,68,871",
  // y-block-105, conditional phase-one
    // act19 = (KILL 3)
    // act68 = (ADD E)
    // act871 = (CAT V (AND (PLAUSIBLE-ROOT ROOT) (NEED-FINAL-E ROOT) (MORPH...
    ":y-block", false, true, false),
  r("i f y # -> 19,31,869",
  // y-block-106, conditional phase-one
    // act19 = (KILL 3)
    // act31 = (ADD Y)
    // act869 = (CAT V (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-ROO...
    ":y-block", false, true, false),
  r("i f y # -> 19,194,872",
  // y-block-107, conditional phase-one
    // act19 = (KILL 3)
    // act194 = (ADD U S)
    // act872 = (CAT V (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-KNO...
    ":y-block", false, true, false),
  r("i f y # -> 19,69,869",
  // y-block-108, conditional phase-one
    // act19 = (KILL 3)
    // act69 = (ADD O R)
    // act869 = (CAT V (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-ROO...
    ":y-block", false, true, false),
  r("i f y # -> 50,873",
  // y-block-109, conditional phase-one
    // act50 = (KILL 2)
    // act873 = (CAT V (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-ROO...
    ":y-block", false, true, false),
  r("i f y # -> 19,37,873",
  // y-block-110, conditional phase-one
    // act19 = (KILL 3)
    // act37 = (ADD O)
    // act873 = (CAT V (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-ROO...
    ":y-block", false, true, false),
  r("c k y # -> 50,35,874",
  // y-block-111, conditional phase-one
    // act50 = (KILL 2)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act874 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(NN V...
    ":y-block", false, true, false),
  r("i c a l l y # -> 50,35,875",
  // y-block-112, conditional phase-one
    // act50 = (KILL 2)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act875 = (CAT ADV (AND (MORPH-ROOT STATE) (IS-KNOWN-WORD ROOT) (IS-RO...
    ":y-block", false, true, false),
  r("i c a l l y # -> 61,35,876",
  // y-block-113, conditional phase-one
    // act61 = (KILL 4)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act876 = (CAT ADV (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADJ))...
    ":y-block", false, true, false),
  r("consonant i l y # -> 19,31,35,877,878",
  // y-block-114, conditional phase-one
    // act19 = (KILL 3)
    // act31 = (ADD Y)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act877 = (CAT ADV (AND (MORPH-ROOT STATE) (IS-KNOWN-WORD ROOT) (IS-RO...
    // act878 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-KNOWN-WORD ROOT) (IS-RO...
    ":y-block", false, true, false),
  r("consonant i l y # -> 19,31,35,876",
  // y-block-115, conditional phase-one
    // act19 = (KILL 3)
    // act31 = (ADD Y)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act876 = (CAT ADV (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADJ))...
    ":y-block", false, true, false),
  r("l y # -> 50,35,879,880",
  // y-block-116, conditional phase-one
    // act50 = (KILL 2)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act879 = (CAT ADV (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADJ) ...
    // act880 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(NN))...
    ":y-block", false, true, false),
  r("l y # -> 50,68,35,879,881",
  // y-block-117, conditional phase-one
    // act50 = (KILL 2)
    // act68 = (ADD E)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act879 = (CAT ADV (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADJ) ...
    // act881 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(NN))...
    ":y-block", false, true, false),
  r("l y # -> 50,35,882",
  // y-block-118, conditional phase-one
    // act50 = (KILL 2)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act882 = (CAT ADJ (AND (MORPH-ROOT STATE) (NOT (IS-ROOT-OF-CAT ROOT '...
    ":y-block", false, true, false),
  r("consonant l y # -> 24,68,35,882",
  // y-block-119, conditional phase-one
    // act24 = (KILL 1)
    // act68 = (ADD E)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act882 = (CAT ADJ (AND (MORPH-ROOT STATE) (NOT (IS-ROOT-OF-CAT ROOT '...
    ":y-block", false, true, false),
  r("l y # -> 50,35,883",
  // y-block-120, 
    // act50 = (KILL 2)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act883 = (CAT ADV (AND (MORPH-ROOT STATE) (MORPH-CHECK ROOT 'ADJ 'KNO...
    ":y-block"),
  r("l y # -> 50,35,884",
  // y-block-121, phase-one
    // act50 = (KILL 2)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act884 = (CAT ADV (AND (MORPH-ROOT STATE) (MORPH-CHECK ROOT 'ADJ 'KNO...
    ":y-block", true, false, false),
  r("consonant i l y # -> 19,35,31,876",
  // y-block-122, conditional phase-one
    // act19 = (KILL 3)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act31 = (ADD Y)
    // act876 = (CAT ADV (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADJ))...
    ":y-block", false, true, false),
  r("vowel l l y # -> 24,876",
  // y-block-123, conditional phase-one
    // act24 = (KILL 1)
    // act876 = (CAT ADV (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADJ))...
    ":y-block", false, true, false),
  r("l y # -> 50,885,876",
  // y-block-124, conditional phase-one
    // act50 = (KILL 2)
    // act885 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT-PRE...
    // act876 = (CAT ADV (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADJ))...
    ":y-block", false, true, false),
  r("l y # -> 50,68,885,876",
  // y-block-125, conditional phase-one
    // act50 = (KILL 2)
    // act68 = (ADD E)
    // act885 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT-PRE...
    // act876 = (CAT ADV (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADJ))...
    ":y-block", false, true, false),
  r("i c a l l y # -> 61,886,887",
  // y-block-126, conditional phase-one
    // act61 = (KILL 4)
    // act886 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-ROOT...
    // act887 = (CAT ADV T EVAL (LIST LEX (LIST 'ROOT ROOT) '(SUFFIX LY)))
    ":y-block", false, true, false),
  r("i c a l y # -> 19,886,887",
  // y-block-127, conditional phase-one
    // act19 = (KILL 3)
    // act886 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-ROOT...
    // act887 = (CAT ADV T EVAL (LIST LEX (LIST 'ROOT ROOT) '(SUFFIX LY)))
    ":y-block", false, true, false),
  r("a l y # -> 19,299,120,887",
  // y-block-128, conditional phase-one
    // act19 = (KILL 3)
    // act299 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-ROOT...
    // act120 = (ADD A L)
    // act887 = (CAT ADV T EVAL (LIST LEX (LIST 'ROOT ROOT) '(SUFFIX LY)))
    ":y-block", false, true, false),
  r("b l y # -> 24,68,35,876",
  // y-block-129, conditional phase-one
    // act24 = (KILL 1)
    // act68 = (ADD E)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act876 = (CAT ADV (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADJ))...
    ":y-block", false, true, false),
  r("a b l y # -> 61,35,888",
  // y-block-130, conditional phase-one
    // act61 = (KILL 4)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act888 = (CAT ADV (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(N V)...
    ":y-block", false, true, false),
  r("a b l y # -> 61,68,35,888",
  // y-block-131, conditional phase-one
    // act61 = (KILL 4)
    // act68 = (ADD E)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act888 = (CAT ADV (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(N V)...
    ":y-block", false, true, false),
  r("i t y # -> 19,68,535,889",
  // y-block-132, conditional phase-one
    // act19 = (KILL 3)
    // act68 = (ADD E)
    // act535 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (NEED-FINAL-E ROOT) (MORPH-...
    // act889 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(ADJ)))...
    ":y-block", false, true, false),
  r("i t y # -> 19,32,889",
  // y-block-133, conditional phase-one
    // act19 = (KILL 3)
    // act32 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-KNOW...
    // act889 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(ADJ)))...
    ":y-block", false, true, false),
  r("a|i b i l i t y # -> 57,539,35,889",
  // y-block-134, conditional phase-one
    // act57 = (KILL 5)
    // act539 = (ADD L E)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act889 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(ADJ)))...
    ":y-block", false, true, false),
  r("a b i l i t y # -> 113,35,890",
  // y-block-135, conditional phase-one
    // act113 = (KILL 7)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act890 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(V))) E...
    ":y-block", false, true, false),
  r("a b i l i t y # -> 113,35,68,890",
  // y-block-136, conditional phase-one
    // act113 = (KILL 7)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act68 = (ADD E)
    // act890 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(V))) E...
    ":y-block", false, true, false),
  r("b i l i t y # -> 57,35,539,891",
  // y-block-137, conditional phase-one
    // act57 = (KILL 5)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act539 = (ADD L E)
    // act891 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(ADJ N)...
    ":y-block", false, true, false),
  r("p l i c i t y # -> 57,35,68,892",
  // y-block-138, conditional phase-one
    // act57 = (KILL 5)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act68 = (ADD E)
    // act892 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(ADJ N)...
    ":y-block", false, true, false),
  r("a l i t y # -> 57,68,538,893",
  // y-block-139, conditional phase-one
    // act57 = (KILL 5)
    // act68 = (ADD E)
    // act538 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (PA...
    // act893 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(ADJ)))...
    ":y-block", false, true, false),
  r("a l i t y # -> 57,35,893",
  // y-block-140, conditional phase-one
    // act57 = (KILL 5)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act893 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(ADJ)))...
    ":y-block", false, true, false),
  r("o s i t y # -> 57,408,35,889",
  // y-block-141, conditional phase-one
    // act57 = (KILL 5)
    // act408 = (ADD O U S)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act889 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(ADJ)))...
    ":y-block", false, true, false),
  r("i t y # -> 19,68,538,889",
  // y-block-142, conditional phase-one
    // act19 = (KILL 3)
    // act68 = (ADD E)
    // act538 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (PA...
    // act889 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(ADJ)))...
    ":y-block", false, true, false),
  r("i t y # -> 19,35,889",
  // y-block-143, conditional phase-one
    // act19 = (KILL 3)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act889 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(ADJ)))...
    ":y-block", false, true, false),
  r("i t y # -> 19,68,538,894",
  // y-block-144, conditional phase-one
    // act19 = (KILL 3)
    // act68 = (ADD E)
    // act538 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (PA...
    // act894 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(N V)))...
    ":y-block", false, true, false),
  r("i t y # -> 19,35,894",
  // y-block-145, conditional phase-one
    // act19 = (KILL 3)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act894 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(N V)))...
    ":y-block", false, true, false),
  r("i l i t y # -> 57,895,896,889",
  // y-block-146, conditional phase-one
    // act57 = (KILL 5)
    // act895 = (ADD AL)
    // act896 = (TEST (AND (MORPH-ROOT STATE) (IS-KNOWN-WORD ROOT) (PLAUSIBL...
    // act889 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(ADJ)))...
    ":y-block", false, true, false),
  r("i l i t y # -> 57,896,897",
  // y-block-147, conditional phase-one
    // act57 = (KILL 5)
    // act896 = (TEST (AND (MORPH-ROOT STATE) (IS-KNOWN-WORD ROOT) (PLAUSIBL...
    // act897 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(N V AD...
    ":y-block", false, true, false),
  r("i l i t y # -> 57,895,35,898",
  // y-block-148, conditional phase-one
    // act57 = (KILL 5)
    // act895 = (ADD AL)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act898 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(N V AD...
    ":y-block", false, true, false),
  r("consonant y # -> 24,68,105,899",
  // y-block-149, conditional phase-one
    // act24 = (KILL 1)
    // act68 = (ADD E)
    // act105 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (NEED-FINAL-E ROOT)))
    // act899 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-KNOWN-WORD ROOT) (IS-RO...
    ":y-block", false, true, false),
  r("consonant y # -> 24,900,899",
  // y-block-150, conditional phase-one
    // act24 = (KILL 1)
    // act900 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (PA...
    // act899 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-KNOWN-WORD ROOT) (IS-RO...
    ":y-block", false, true, false),
  r("consonant y # -> 24,68,901,899",
  // y-block-151, conditional phase-one
    // act24 = (KILL 1)
    // act68 = (ADD E)
    // act901 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT-PRE...
    // act899 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-KNOWN-WORD ROOT) (IS-RO...
    ":y-block", false, true, false),
  r("consonant e y # -> 24,901,899",
  // y-block-152, conditional phase-one
    // act24 = (KILL 1)
    // act901 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT-PRE...
    // act899 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-KNOWN-WORD ROOT) (IS-RO...
    ":y-block", false, true, false),
  r("m e t r y # -> 902",
  // y-block-153, 
    // act902 = (CAT NM T EVAL '-IES)
    ":y-block"),
  r("a t r y # -> 902",
  // y-block-154, 
    // act902 = (CAT NM T EVAL '-IES)
    ":y-block"),
  r("b e r r y # -> 57,35,903",
  // y-block-155, phase-one
    // act57 = (KILL 5)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act903 = (CAT NM (PLAUSIBLE-ROOT ROOT) EVAL (PROGN (MARK-DICT LEX 'FA...
    ":y-block", true, false, false),
  r("consonant vowel b|d|g|m|n|p|r|s|t & y # -> 50,904,905",
  // y-block-156, conditional phase-one
    // act50 = (KILL 2)
    // act904 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-KNOWN-WORD ROOT) (IS-RO...
    // act905 = (CAT FIRSTNAME (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT ...
    ":y-block", false, true, false),
  r("consonant y # -> 24,68,105,906",
  // y-block-157, conditional phase-one
    // act24 = (KILL 1)
    // act68 = (ADD E)
    // act105 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (NEED-FINAL-E ROOT)))
    // act906 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-KNOWN-WORD ROOT) (IS-RO...
    ":y-block", false, true, false),
  r("consonant y # -> 24,900,906",
  // y-block-158, conditional phase-one
    // act24 = (KILL 1)
    // act900 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (PA...
    // act906 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-KNOWN-WORD ROOT) (IS-RO...
    ":y-block", false, true, false),
  r("consonant y # -> 24,68,901,906",
  // y-block-159, conditional phase-one
    // act24 = (KILL 1)
    // act68 = (ADD E)
    // act901 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT-PRE...
    // act906 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-KNOWN-WORD ROOT) (IS-RO...
    ":y-block", false, true, false),
  r("consonant e y # -> 24,901,899",
  // y-block-160, conditional phase-one
    // act24 = (KILL 1)
    // act901 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT-PRE...
    // act899 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-KNOWN-WORD ROOT) (IS-RO...
    ":y-block", false, true, false),
  r("consonant a|i|o|u|y consonant y # -> 24,68,907",
  // y-block-161, conditional phase-one
    // act24 = (KILL 1)
    // act68 = (ADD E)
    // act907 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-KNOWN-WORD ROOT) (IS-RO...
    ":y-block", false, true, false),
  r("a|e n c y # -> 24,68,35,908",
  // y-block-162, conditional phase-one
    // act24 = (KILL 1)
    // act68 = (ADD E)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act908 = (CAT NM (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(N))) ...
    ":y-block", false, true, false),
  r("a|e n c y # -> 50,342,35,909",
  // y-block-163, conditional phase-one
    // act50 = (KILL 2)
    // act342 = (ADD T)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act909 = (CAT NM (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(ADJ N...
    ":y-block", false, true, false),
  r("a|e n c y # -> 19,35,910",
  // y-block-164, conditional phase-one
    // act19 = (KILL 3)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act910 = (CAT NM (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(V))) ...
    ":y-block", false, true, false),
  r("a|e n c y # -> 61,35,910",
  // y-block-165, conditional phase-one
    // act61 = (KILL 4)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act910 = (CAT NM (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(V))) ...
    ":y-block", false, true, false),
  r("a|e c y # -> 50,342,131,911",
  // y-block-166, conditional phase-one
    // act50 = (KILL 2)
    // act342 = (ADD T)
    // act131 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (POLYSYLLABIC ROOT)))
    // act911 = (CAT NM (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(ADJ V...
    ":y-block", false, true, false),
  r("a|e c y # -> 50,912,131,913",
  // y-block-167, conditional phase-one
    // act50 = (KILL 2)
    // act912 = (ADD T E)
    // act131 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (POLYSYLLABIC ROOT)))
    // act913 = (CAT NM (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(ADJ V...
    ":y-block", false, true, false),
  r("e r y # -> 50,105,914",
  // y-block-168, conditional phase-one
    // act50 = (KILL 2)
    // act105 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (NEED-FINAL-E ROOT)))
    // act914 = (CAT NM (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(NN V)...
    ":y-block", false, true, false),
  r("e r y # -> 19,35,914",
  // y-block-169, conditional phase-one
    // act19 = (KILL 3)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act914 = (CAT NM (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(NN V)...
    ":y-block", false, true, false),
  r("e r y # -> 50,35,914",
  // y-block-170, conditional phase-one
    // act50 = (KILL 2)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act914 = (CAT NM (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(NN V)...
    ":y-block", false, true, false),
  r("vowel b|d|g|k|l|m|n|p|r|s|t|z & e r y # -> 61,35,914",
  // y-block-171, conditional phase-one
    // act61 = (KILL 4)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act914 = (CAT NM (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(NN V)...
    ":y-block", false, true, false),
  r("b u r y # -> 35,264,154",
  // y-block-172, 
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act264 = (CAT CITY T EVAL '*)
    // act154 = (CAT LASTNAME T EVAL '*)
    ":y-block"),
  r("vowel consonant a r y # -> 19,68,915,916",
  // y-block-173, conditional phase-one
    // act19 = (KILL 3)
    // act68 = (ADD E)
    // act915 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NO-PREF...
    // act916 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(ADJ ...
    ":y-block", false, true, false),
  r("a r y # -> 19,917,916",
  // y-block-174, conditional phase-one
    // act19 = (KILL 3)
    // act917 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NO-PREF...
    // act916 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(ADJ ...
    ":y-block", false, true, false),
  r("vowel consonant a r y # -> 19,68,917,916",
  // y-block-175, conditional phase-one
    // act19 = (KILL 3)
    // act68 = (ADD E)
    // act917 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NO-PREF...
    // act916 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(ADJ ...
    ":y-block", false, true, false),
  r("a r y # -> 19,68,917,918",
  // y-block-176, conditional phase-one
    // act19 = (KILL 3)
    // act68 = (ADD E)
    // act917 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NO-PREF...
    // act918 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'N)) E...
    ":y-block", false, true, false),
  r("a r y # -> 19,917,918",
  // y-block-177, conditional phase-one
    // act19 = (KILL 3)
    // act917 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NO-PREF...
    // act918 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'N)) E...
    ":y-block", false, true, false),
  r("vowel l l a r y # -> 61,917,918",
  // y-block-178, conditional phase-one
    // act61 = (KILL 4)
    // act917 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NO-PREF...
    // act918 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'N)) E...
    ":y-block", false, true, false),
  r("a r y # -> 19,117,917,918",
  // y-block-179, conditional phase-one
    // act19 = (KILL 3)
    // act117 = (ADD A)
    // act917 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NO-PREF...
    // act918 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'N)) E...
    ":y-block", false, true, false),
  r("a r y # -> 19,194,917,918",
  // y-block-180, conditional phase-one
    // act19 = (KILL 3)
    // act194 = (ADD U S)
    // act917 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NO-PREF...
    // act918 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'N)) E...
    ":y-block", false, true, false),
  r("a r y # -> 19,116,917,918",
  // y-block-181, conditional phase-one
    // act19 = (KILL 3)
    // act116 = (ADD U M)
    // act917 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NO-PREF...
    // act918 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'N)) E...
    ":y-block", false, true, false),
  r("i a r y # -> 61,917,918",
  // y-block-182, conditional phase-one
    // act61 = (KILL 4)
    // act917 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NO-PREF...
    // act918 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'N)) E...
    ":y-block", false, true, false),
  r("i a r y # -> 61,68,917,918",
  // y-block-183, conditional phase-one
    // act61 = (KILL 4)
    // act68 = (ADD E)
    // act917 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NO-PREF...
    // act918 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'N)) E...
    ":y-block", false, true, false),
  r("vowel consonant i n a r y # -> 57,68,915,916",
  // y-block-184, conditional phase-one
    // act57 = (KILL 5)
    // act68 = (ADD E)
    // act915 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NO-PREF...
    // act916 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(ADJ ...
    ":y-block", false, true, false),
  r("r y # -> 50,919,920",
  // y-block-185, conditional phase-one
    // act50 = (KILL 2)
    // act919 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NO-PREF...
    // act920 = (CAT NM (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(NN V)...
    ":y-block", false, true, false),
  r("m e t r y # -> 50,72,35,921",
  // y-block-186, conditional phase-one
    // act50 = (KILL 2)
    // act72 = (ADD E R)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act921 = (CAT NM (AND (MORPH-ROOT STATE) (IS-KNOWN-WORD ROOT) (IS-ROO...
    ":y-block", false, true, false),
  r("consonant r y # -> 50,72,35,904",
  // y-block-187, conditional phase-one
    // act50 = (KILL 2)
    // act72 = (ADD E R)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act904 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-KNOWN-WORD ROOT) (IS-RO...
    ":y-block", false, true, false),
  r("s c o p y # -> 24,68,35,922",
  // y-block-188, conditional phase-one
    // act24 = (KILL 1)
    // act68 = (ADD E)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act922 = (CAT NM (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(NN)))...
    ":y-block", false, true, false),
  r("m e t r y # -> 50,72,35,923",
  // y-block-189, conditional phase-one
    // act50 = (KILL 2)
    // act72 = (ADD E R)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act923 = (CAT NM (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(NN)))...
    ":y-block", false, true, false),
  r("consonant r y # -> 50,72,35,924",
  // y-block-190, conditional phase-one
    // act50 = (KILL 2)
    // act72 = (ADD E R)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act924 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(NN))...
    ":y-block", false, true, false),
  r("r y # -> 50,72,925,920",
  // y-block-191, conditional phase-one
    // act50 = (KILL 2)
    // act72 = (ADD E R)
    // act925 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (PA...
    // act920 = (CAT NM (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(NN V)...
    ":y-block", false, true, false),
  r("r y # -> 24,35,920",
  // y-block-192, conditional phase-one
    // act24 = (KILL 1)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act920 = (CAT NM (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(NN V)...
    ":y-block", false, true, false),
  r("s y # -> 50,926,927",
  // y-block-193, conditional phase-one
    // act50 = (KILL 2)
    // act926 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (PO...
    // act927 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(ADJ ...
    ":y-block", false, true, false),
  r("consonant y # -> 24,68,105,928,929,930",
  // y-block-194, conditional phase-one
    // act24 = (KILL 1)
    // act68 = (ADD E)
    // act105 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (NEED-FINAL-E ROOT)))
    // act928 = (CAT FIRSTNAME (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT ...
    // act929 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-KNOWN-WORD ROOT) (IS-RO...
    // act930 = (CAT NM (AND (MORPH-ROOT STATE) (IS-KNOWN-WORD ROOT) (IS-ROO...
    ":y-block", false, true, false),
  r("consonant y # -> 24,931,928,929,932",
  // y-block-195, conditional phase-one
    // act24 = (KILL 1)
    // act931 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (PA...
    // act928 = (CAT FIRSTNAME (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT ...
    // act929 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-KNOWN-WORD ROOT) (IS-RO...
    // act932 = (CAT NC (AND (MORPH-ROOT STATE) (IS-KNOWN-WORD ROOT) (IS-ROO...
    ":y-block", false, true, false),
  r("vowel consonant y # -> 24,68,35,928,929,930",
  // y-block-196, conditional phase-one
    // act24 = (KILL 1)
    // act68 = (ADD E)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act928 = (CAT FIRSTNAME (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT ...
    // act929 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-KNOWN-WORD ROOT) (IS-RO...
    // act930 = (CAT NM (AND (MORPH-ROOT STATE) (IS-KNOWN-WORD ROOT) (IS-ROO...
    ":y-block", false, true, false),
  r("consonant e y # -> 24,35,928,933,932",
  // y-block-197, conditional phase-one
    // act24 = (KILL 1)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act928 = (CAT FIRSTNAME (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT ...
    // act933 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-KNOWN-WORD ROOT) (IS-RO...
    // act932 = (CAT NC (AND (MORPH-ROOT STATE) (IS-KNOWN-WORD ROOT) (IS-ROO...
    ":y-block", false, true, false),
  r("o r y # -> 19,35,934",
  // y-block-198, conditional phase-one
    // act19 = (KILL 3)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act934 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'V)) E...
    ":y-block", false, true, false),
  r("vowel consonant o r y # -> 19,68,35,934",
  // y-block-199, conditional phase-one
    // act19 = (KILL 3)
    // act68 = (ADD E)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act934 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'V)) E...
    ":y-block", false, true, false),
  r("a t o r y # -> 57,35,935",
  // y-block-200, conditional phase-one
    // act57 = (KILL 5)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act935 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'V)) E...
    ":y-block", false, true, false),
  r("vowel consonant a t o r y # -> 57,68,35,935",
  // y-block-201, conditional phase-one
    // act57 = (KILL 5)
    // act68 = (ADD E)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act935 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'V)) E...
    ":y-block", false, true, false),
  r("r y # -> 24,35,920",
  // y-block-202, conditional phase-one
    // act24 = (KILL 1)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act920 = (CAT NM (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(NN V)...
    ":y-block", false, true, false),
  r("consonant y # -> 24,900,936",
  // y-block-203, conditional phase-one
    // act24 = (KILL 1)
    // act900 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (PA...
    // act936 = (CAT NM (AND (MORPH-ROOT STATE) (IS-KNOWN-WORD ROOT) (IS-ROO...
    ":y-block", false, true, false),
  r("vowel m|n|r y # -> 24,68,35,937",
  // y-block-204, conditional phase-one
    // act24 = (KILL 1)
    // act68 = (ADD E)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act937 = (CAT NM (AND (MORPH-ROOT STATE) (IS-KNOWN-WORD ROOT) (IS-ROO...
    ":y-block", false, true, false),
  r("consonant e y # -> 24,35,937",
  // y-block-205, conditional phase-one
    // act24 = (KILL 1)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act937 = (CAT NM (AND (MORPH-ROOT STATE) (IS-KNOWN-WORD ROOT) (IS-ROO...
    ":y-block", false, true, false),
  r("i f y # -> 938",
  // y-block-206, 
    // act938 = (CAT V (PLAUSIBLE-ROOT ROOT) EVAL (PROGN (MARK-DICT LEX 'HAS...
    ":y-block"),
  r("- p l y # -> 61,939",
  // y-block-207, 
    // act61 = (KILL 4)
    // act939 = (CAT ADJ (PLAUSIBLE-ROOT ROOT) EVAL (PROGN (MARK-DICT LEX 'R...
    ":y-block"),
  r("m e g a l y # -> 940",
  // y-block-208, 
    // act940 = (CAT N T EVAL (LIST LEX '(NUMBER SG) '(MASS)))
    ":y-block"),
  r("c e p h a l y # -> 940",
  // y-block-209, 
    // act940 = (CAT N T EVAL (LIST LEX '(NUMBER SG) '(MASS)))
    ":y-block"),
  r("p o l y # -> 940",
  // y-block-210, 
    // act940 = (CAT N T EVAL (LIST LEX '(NUMBER SG) '(MASS)))
    ":y-block"),
  r("vowel f f l y # -> 50,941",
  // y-block-211, 
    // act50 = (KILL 2)
    // act941 = (CAT ADV (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT 'ADJ)) EVA...
    ":y-block"),
  r("f l y # -> 50,942",
  // y-block-212, 
    // act50 = (KILL 2)
    // act942 = (CAT ADV (AND (MORPH-ROOT STATE) (MORPH-CHECK ROOT 'ADJ)) EV...
    ":y-block"),
  r("f l y # -> 19,943",
  // y-block-213, 
    // act19 = (KILL 3)
    // act943 = (CAT N (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT '(V ADJ N)))...
    ":y-block"),
  r("f a m i l y # -> 102,944",
  // y-block-214, 
    // act102 = (KILL 6)
    // act944 = (CAT N T EVAL (PROGN (MARK-DICT LEX 'FALSE-ROOT ROOT T T) (M...
    ":y-block"),
  r("b l y # -> 24,68,941",
  // y-block-215, 
    // act24 = (KILL 1)
    // act68 = (ADD E)
    // act941 = (CAT ADV (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT 'ADJ)) EVA...
    ":y-block"),
  r("i l y # -> 945",
  // y-block-216, 
    // act945 = (CAT ADV (PLAUSIBLE-ROOT ROOT) EVAL (LIST LEX (LIST 'ROOT RO...
    ":y-block"),
  r("f u l l y # -> 50,941",
  // y-block-217, 
    // act50 = (KILL 2)
    // act941 = (CAT ADV (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT 'ADJ)) EVA...
    ":y-block"),
  r("vowel l l y # -> 50,941",
  // y-block-218, 
    // act50 = (KILL 2)
    // act941 = (CAT ADV (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT 'ADJ)) EVA...
    ":y-block"),
  r("l y # -> 50,941",
  // y-block-219, 
    // act50 = (KILL 2)
    // act941 = (CAT ADV (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT 'ADJ)) EVA...
    ":y-block"),
  r("b l y # -> 24,68,35,887",
  // y-block-220, 
    // act24 = (KILL 1)
    // act68 = (ADD E)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act887 = (CAT ADV T EVAL (LIST LEX (LIST 'ROOT ROOT) '(SUFFIX LY)))
    ":y-block"),
  r("i l y # -> 19,35,31,887",
  // y-block-221, 
    // act19 = (KILL 3)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act31 = (ADD Y)
    // act887 = (CAT ADV T EVAL (LIST LEX (LIST 'ROOT ROOT) '(SUFFIX LY)))
    ":y-block"),
  r("f u l l y # -> 50,946",
  // y-block-222, 
    // act50 = (KILL 2)
    // act946 = (CAT ADV (POLYSYLLABIC ROOT) EVAL (LIST LEX (LIST 'ROOT ROOT...
    ":y-block"),
  r("vowel l l y # -> 50,946",
  // y-block-223, 
    // act50 = (KILL 2)
    // act946 = (CAT ADV (POLYSYLLABIC ROOT) EVAL (LIST LEX (LIST 'ROOT ROOT...
    ":y-block"),
  r("l y # -> 157,947",
  // y-block-224, 
    // act157 = (CAT ADV (PLAUSIBLE-ROOT ROOT) EVAL '*)
    // act947 = (CAT ADJ (PLAUSIBLE-ROOT ROOT) EVAL (PROGN (MARK-DICT LEX 'P...
    ":y-block"),
  r("b|d|g|k|l|m|n|p|r|s|t & i t y # -> 19,948",
  // y-block-225, 
    // act19 = (KILL 3)
    // act948 = (CAT N (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT 'ADJ)) EVAL ...
    ":y-block"),
  r("o s i t y # -> 57,408,948",
  // y-block-226, 
    // act57 = (KILL 5)
    // act408 = (ADD O U S)
    // act948 = (CAT N (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT 'ADJ)) EVAL ...
    ":y-block"),
  r("c|s|u|v i t y # -> 19,68,948",
  // y-block-227, 
    // act19 = (KILL 3)
    // act68 = (ADD E)
    // act948 = (CAT N (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT 'ADJ)) EVAL ...
    ":y-block"),
  r("i t y # -> 19,68,105,948",
  // y-block-228, 
    // act19 = (KILL 3)
    // act68 = (ADD E)
    // act105 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (NEED-FINAL-E ROOT)))
    // act948 = (CAT N (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT 'ADJ)) EVAL ...
    ":y-block"),
  r("i t y # -> 19,269,948",
  // y-block-229, 
    // act19 = (KILL 3)
    // act269 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (NE...
    // act948 = (CAT N (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT 'ADJ)) EVAL ...
    ":y-block"),
  r("i t y # -> 19,68,948",
  // y-block-230, 
    // act19 = (KILL 3)
    // act68 = (ADD E)
    // act948 = (CAT N (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT 'ADJ)) EVAL ...
    ":y-block"),
  r("g a m y # -> 61,949",
  // y-block-231, 
    // act61 = (KILL 4)
    // act949 = (CAT NM (PLAUSIBLE-ROOT ROOT) EVAL '-IES)
    ":y-block"),
  r("t a x y # -> 61,949",
  // y-block-232, 
    // act61 = (KILL 4)
    // act949 = (CAT NM (PLAUSIBLE-ROOT ROOT) EVAL '-IES)
    ":y-block"),
  r("a r y # -> 19,35,950",
  // y-block-233, 
    // act19 = (KILL 3)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act950 = (CAT ADJ (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT 'N)) EVAL ...
    ":y-block"),
  r("a|e n c y # -> 50,342,131,951",
  // y-block-234, conditional phase-one
    // act50 = (KILL 2)
    // act342 = (ADD T)
    // act131 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (POLYSYLLABIC ROOT)))
    // act951 = (CAT NM (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADJ)) ...
    ":y-block", false, true, false),
  r("e n c y # -> 61,35,952",
  // y-block-235, 
    // act61 = (KILL 4)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act952 = (CAT NM (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT 'V)) EVAL (...
    ":y-block"),
  r("a n c y # -> 61,35,953",
  // y-block-236, 
    // act61 = (KILL 4)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act953 = (CAT NM (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT 'V)) EVAL (...
    ":y-block"),
  r("a c y # -> 19,142,954,902",
  // y-block-237, 
    // act19 = (KILL 3)
    // act142 = (TEST (POLYSYLLABIC ROOT))
    // act954 = (ADD A C Y)
    // act902 = (CAT NM T EVAL '-IES)
    ":y-block"),
  r("a l c y # -> 809",
  // y-block-238, 
    // act809 = (CAT NM (POLYSYLLABIC ROOT) EVAL '-IES)
    ":y-block"),
  r("a n c y # -> 809",
  // y-block-239, 
    // act809 = (CAT NM (POLYSYLLABIC ROOT) EVAL '-IES)
    ":y-block"),
  r("e n c y # -> 809",
  // y-block-240, 
    // act809 = (CAT NM (POLYSYLLABIC ROOT) EVAL '-IES)
    ":y-block"),
  r("a|o l o g y # -> 955",
  // y-block-241, 
    // act955 = (CAT NM (POLYSYLLABIC ROOT) EVAL (PROGN (MARK-DICT LEX 'KIND...
    ":y-block"),
  r("o g r a p h y # -> 817",
  // y-block-242, 
    // act817 = (CAT NM (POLYSYLLABIC ROOT) EVAL (PROGN (MARK-DICT LEX 'KIND...
    ":y-block"),
  r("g r a p h y # -> 956",
  // y-block-243, 
    // act956 = (CAT NM (POLYSYLLABIC ROOT) EVAL (PROGN (MARK-DICT LEX 'KIND...
    ":y-block"),
  r("o s c o p y # -> 957",
  // y-block-244, 
    // act957 = (CAT NM (SYLLABIC ROOT) EVAL (PROGN (MARK-DICT LEX 'KINDOF '...
    ":y-block"),
  r("l o g y # -> 809",
  // y-block-245, 
    // act809 = (CAT NM (POLYSYLLABIC ROOT) EVAL '-IES)
    ":y-block"),
  r("p h y # -> 949",
  // y-block-246, 
    // act949 = (CAT NM (PLAUSIBLE-ROOT ROOT) EVAL '-IES)
    ":y-block"),
  r("t h y # -> 958",
  // y-block-247, 
    // act958 = (CAT ADJ (POLYSYLLABIC ROOT) EVAL 'IER-IEST)
    ":y-block"),
  r("a m y # -> 809",
  // y-block-248, 
    // act809 = (CAT NM (POLYSYLLABIC ROOT) EVAL '-IES)
    ":y-block"),
  r("e m y # -> 809",
  // y-block-249, 
    // act809 = (CAT NM (POLYSYLLABIC ROOT) EVAL '-IES)
    ":y-block"),
  r("o n y # -> 809",
  // y-block-250, 
    // act809 = (CAT NM (POLYSYLLABIC ROOT) EVAL '-IES)
    ":y-block"),
  r("a p y # -> 809",
  // y-block-251, 
    // act809 = (CAT NM (POLYSYLLABIC ROOT) EVAL '-IES)
    ":y-block"),
  r("e r y # -> 959",
  // y-block-252, 
    // act959 = (CAT NM (AND (POLYSYLLABIC ROOT) (MORPH-ROOT STATE) (NOT (PA...
    ":y-block"),
  r("e s y # -> 809",
  // y-block-253, 
    // act809 = (CAT NM (POLYSYLLABIC ROOT) EVAL '-IES)
    ":y-block"),
  r("a r y # -> 164",
  // y-block-254, 
    // act164 = (CAT ADJ (POLYSYLLABIC ROOT) EVAL '*)
    ":y-block"),
  r("m e t r y # -> 902",
  // y-block-255, 
    // act902 = (CAT NM T EVAL '-IES)
    ":y-block"),
  r("s c o p y # -> 902",
  // y-block-256, 
    // act902 = (CAT NM T EVAL '-IES)
    ":y-block"),
  r("i a t r y # -> 902",
  // y-block-257, 
    // act902 = (CAT NM T EVAL '-IES)
    ":y-block"),
  r("i t y # -> 960",
  // y-block-258, 
    // act960 = (CAT NM (POLYSYLLABIC ROOT) EVAL (PROGN (MARK-DICT LEX 'HAS-...
    ":y-block"),
  r("consonant vowel b|d|g|l|m|n|p|r|s|t & y # -> 50,961,962",
  // y-block-259, 
    // act50 = (KILL 2)
    // act961 = (CAT N (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT 'N)) EVAL (L...
    // act962 = (CAT ADJ (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT 'ADJ)) EVA...
    ":y-block"),
  r("consonant vowel b|d|g|l|m|n|p|r|s|t & y # -> 963,162",
  // y-block-260, 
    // act963 = (CAT N T EVAL '-IES)
    // act162 = (CAT ADJ T EVAL '*)
    ":y-block"),
  r("consonant vowel b|d|g|l|m|n|p|r|s|t y # -> 963,162",
  // y-block-261, 
    // act963 = (CAT N T EVAL '-IES)
    // act162 = (CAT ADJ T EVAL '*)
    ":y-block"),
  r("consonant y # -> 35,964,162,965",
  // y-block-262, 
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act964 = (CAT N T EVAL (PROGN (MARK-DICT LEX 'GUESSED 'T) '-IES))
    // act162 = (CAT ADJ T EVAL '*)
    // act965 = (CAT V *GUESS-VERB-FLAG* EVAL (PROGN (MARK-DICT LEX 'PENALTI...
    ":y-block"),
  r(" -> 180,158",
  // y-block-263, 
    // act180 = (TEST T)
    // act158 = (DO DEFAULT-RULE)
    ":y-block"),
 };

 protected static MorphRule[] cBlock = {//":c-block"
  r("a n t i c # -> 22,32,966",
  // c-block-1, conditional phase-one
    // act22 = (ADD S)
    // act32 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-KNOW...
    // act966 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'NN)) ...
    ":c-block", false, true, false),
  r("a n t i c # -> 19,967,968,969",
  // c-block-2, conditional phase-one
    // act19 = (KILL 3)
    // act967 = (ADD C Y)
    // act968 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (POLYSYLLABIC ROOT) (MORPH-...
    // act969 = (CAT ADJ T EVAL (MAKE-SUFFIX-DEF LEX ROOT 'ANTIC))
    ":c-block", false, true, false),
  r("e t i c # -> 19,292,970,971",
  // c-block-3, conditional phase-one
    // act19 = (KILL 3)
    // act292 = (ADD S I S)
    // act970 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (POLYSYLLABIC ROOT) (MORPH-...
    // act971 = (CAT ADJ T EVAL (MAKE-SUFFIX-DEF LEX ROOT 'ETIC))
    ":c-block", false, true, false),
  r("a c e t i c # -> 102,972,973",
  // c-block-4, conditional phase-one
    // act102 = (KILL 6)
    // act972 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-ROOT...
    // act973 = (CAT ADJ T EVAL (PROGN (MARK-DICT LEX 'KINDOF 'ACETIC) (MARK...
    ":c-block", false, true, false),
  r("e t i c # -> 19,972,971",
  // c-block-5, conditional phase-one
    // act19 = (KILL 3)
    // act972 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-ROOT...
    // act971 = (CAT ADJ T EVAL (MAKE-SUFFIX-DEF LEX ROOT 'ETIC))
    ":c-block", false, true, false),
  r("e t i c # -> 61,972,971",
  // c-block-6, conditional phase-one
    // act61 = (KILL 4)
    // act972 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-ROOT...
    // act971 = (CAT ADJ T EVAL (MAKE-SUFFIX-DEF LEX ROOT 'ETIC))
    ":c-block", false, true, false),
  r("e t i c # -> 61,31,974,971",
  // c-block-7, conditional phase-one
    // act61 = (KILL 4)
    // act31 = (ADD Y)
    // act974 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-KNOW...
    // act971 = (CAT ADJ T EVAL (MAKE-SUFFIX-DEF LEX ROOT 'ETIC))
    ":c-block", false, true, false),
  r("e t i c # -> 975,162",
  // c-block-8, 
    // act975 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT-PRE...
    // act162 = (CAT ADJ T EVAL '*)
    ":c-block"),
  r("m a t i c # -> 19,974,976,977",
  // c-block-9, conditional phase-one
    // act19 = (KILL 3)
    // act974 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-KNOW...
    // act976 = (CAT ADJ T EVAL (MAKE-SUFFIX-DEF LEX ROOT 'ATIC))
    // act977 = (CAT N T EVAL (MAKE-SUFFIX-DEF LEX ROOT 'ATIC))
    ":c-block", false, true, false),
  r("a t i c # -> 61,972,976",
  // c-block-10, conditional phase-one
    // act61 = (KILL 4)
    // act972 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-ROOT...
    // act976 = (CAT ADJ T EVAL (MAKE-SUFFIX-DEF LEX ROOT 'ATIC))
    ":c-block", false, true, false),
  r("a t i c # -> 61,68,978,976",
  // c-block-11, conditional phase-one
    // act61 = (KILL 4)
    // act68 = (ADD E)
    // act978 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-ROOT...
    // act976 = (CAT ADJ T EVAL (MAKE-SUFFIX-DEF LEX ROOT 'ATIC))
    ":c-block", false, true, false),
  r("consonant vowel b|d|g|k|l|m|n|p|r|t & a t i c # -> 57,972,976",
  // c-block-12, conditional phase-one
    // act57 = (KILL 5)
    // act972 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-ROOT...
    // act976 = (CAT ADJ T EVAL (MAKE-SUFFIX-DEF LEX ROOT 'ATIC))
    ":c-block", false, true, false),
  r("a t i c # -> 61,117,972,976",
  // c-block-13, conditional phase-one
    // act61 = (KILL 4)
    // act117 = (ADD A)
    // act972 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-ROOT...
    // act976 = (CAT ADJ T EVAL (MAKE-SUFFIX-DEF LEX ROOT 'ATIC))
    ":c-block", false, true, false),
  r("i s t i c # -> 50,979,980,981",
  // c-block-14, conditional phase-one
    // act50 = (KILL 2)
    // act979 = (TEST (AND (MORPH-ROOT STATE) (IS-KNOWN-WORD ROOT) (IS-ROOT-...
    // act980 = (SETQ SUFFIX 'IC)
    // act981 = (CAT ADJ T EVAL (MAKE-SUFFIX-DEF LEX ROOT SUFFIX))
    ":c-block", false, true, false),
  r("i s t i c # -> 57,982,983",
  // c-block-15, conditional phase-one
    // act57 = (KILL 5)
    // act982 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (> (NCHARS ROOT) 2) (MORPH-...
    // act983 = (CAT ADJ T EVAL (MAKE-SUFFIX-DEF LEX ROOT 'ISTIC))
    ":c-block", false, true, false),
  r("i s t i c # -> 57,68,984,983",
  // c-block-16, conditional phase-one
    // act57 = (KILL 5)
    // act68 = (ADD E)
    // act984 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (> (NCHARS ROOT) 2) (NEED-F...
    // act983 = (CAT ADJ T EVAL (MAKE-SUFFIX-DEF LEX ROOT 'ISTIC))
    ":c-block", false, true, false),
  r("i s t i c # -> 57,31,985,983",
  // c-block-17, conditional phase-one
    // act57 = (KILL 5)
    // act31 = (ADD Y)
    // act985 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (> (NCHARS ROOT) 2) (MORPH-...
    // act983 = (CAT ADJ T EVAL (MAKE-SUFFIX-DEF LEX ROOT 'ISTIC))
    ":c-block", false, true, false),
  r("o t i c # -> 19,292,972,986",
  // c-block-18, conditional phase-one
    // act19 = (KILL 3)
    // act292 = (ADD S I S)
    // act972 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-ROOT...
    // act986 = (CAT ADJ T EVAL (MAKE-SUFFIX-DEF LEX ROOT 'OTIC))
    ":c-block", false, true, false),
  r("o t i c # -> 19,22,987,986",
  // c-block-19, conditional phase-one
    // act19 = (KILL 3)
    // act22 = (ADD S)
    // act987 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-KNOW...
    // act986 = (CAT ADJ T EVAL (MAKE-SUFFIX-DEF LEX ROOT 'OTIC))
    ":c-block", false, true, false),
  r("o t i c # -> 19,988,989",
  // c-block-20, conditional phase-one
    // act19 = (KILL 3)
    // act988 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-KNOW...
    // act989 = (CAT ADJ T EVAL (PROGN (MARK-DICT LEX 'HAS-SUFFIX 'OTIC T T)...
    ":c-block", false, true, false),
  r("consonant r i c # -> 19,72,972,980,981",
  // c-block-21, conditional phase-one
    // act19 = (KILL 3)
    // act72 = (ADD E R)
    // act972 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-ROOT...
    // act980 = (SETQ SUFFIX 'IC)
    // act981 = (CAT ADJ T EVAL (MAKE-SUFFIX-DEF LEX ROOT SUFFIX))
    ":c-block", false, true, false),
  r("i c # -> 50,142,31,980,990",
  // c-block-22, conditional phase-one
    // act50 = (KILL 2)
    // act142 = (TEST (POLYSYLLABIC ROOT))
    // act31 = (ADD Y)
    // act980 = (SETQ SUFFIX 'IC)
    // act990 = (CAT ADJ (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-K...
    ":c-block", false, true, false),
  r("i c # -> 50,68,991,980,981",
  // c-block-23, phase-one
    // act50 = (KILL 2)
    // act68 = (ADD E)
    // act991 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-KNOW...
    // act980 = (SETQ SUFFIX 'IC)
    // act981 = (CAT ADJ T EVAL (MAKE-SUFFIX-DEF LEX ROOT SUFFIX))
    ":c-block", true, false, false),
  r("i c # -> 50,974,980,981",
  // c-block-24, phase-one
    // act50 = (KILL 2)
    // act974 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-KNOW...
    // act980 = (SETQ SUFFIX 'IC)
    // act981 = (CAT ADJ T EVAL (MAKE-SUFFIX-DEF LEX ROOT SUFFIX))
    ":c-block", true, false, false),
  r("i c # -> 22,32,966",
  // c-block-25, conditional phase-one
    // act22 = (ADD S)
    // act32 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-KNOW...
    // act966 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'NN)) ...
    ":c-block", false, true, false),
  r("i c # -> 50,37,992,980,981",
  // c-block-26, conditional phase-one
    // act50 = (KILL 2)
    // act37 = (ADD O)
    // act992 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-KNOW...
    // act980 = (SETQ SUFFIX 'IC)
    // act981 = (CAT ADJ T EVAL (MAKE-SUFFIX-DEF LEX ROOT SUFFIX))
    ":c-block", false, true, false),
  r("i c # -> 50,117,993,980,981",
  // c-block-27, conditional phase-one
    // act50 = (KILL 2)
    // act117 = (ADD A)
    // act993 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-KNOW...
    // act980 = (SETQ SUFFIX 'IC)
    // act981 = (CAT ADJ T EVAL (MAKE-SUFFIX-DEF LEX ROOT SUFFIX))
    ":c-block", false, true, false),
  r("i c # -> 50,68,978,980,981",
  // c-block-28, conditional phase-one
    // act50 = (KILL 2)
    // act68 = (ADD E)
    // act978 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-ROOT...
    // act980 = (SETQ SUFFIX 'IC)
    // act981 = (CAT ADJ T EVAL (MAKE-SUFFIX-DEF LEX ROOT SUFFIX))
    ":c-block", false, true, false),
  r("i c # -> 50,994,980,981",
  // c-block-29, conditional phase-one
    // act50 = (KILL 2)
    // act994 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-ROOT...
    // act980 = (SETQ SUFFIX 'IC)
    // act981 = (CAT ADJ T EVAL (MAKE-SUFFIX-DEF LEX ROOT SUFFIX))
    ":c-block", false, true, false),
  r("i c # -> 50,68,995,980,981",
  // c-block-30, conditional phase-one
    // act50 = (KILL 2)
    // act68 = (ADD E)
    // act995 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-ROOT...
    // act980 = (SETQ SUFFIX 'IC)
    // act981 = (CAT ADJ T EVAL (MAKE-SUFFIX-DEF LEX ROOT SUFFIX))
    ":c-block", false, true, false),
  r("vowel b|d|g|k|l|m|n|p|r|s|t|z & i c # -> 19,972,980,981",
  // c-block-31, conditional phase-one
    // act19 = (KILL 3)
    // act972 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-ROOT...
    // act980 = (SETQ SUFFIX 'IC)
    // act981 = (CAT ADJ T EVAL (MAKE-SUFFIX-DEF LEX ROOT SUFFIX))
    ":c-block", false, true, false),
  r("vowel b i c # -> 50,539,996,980,981",
  // c-block-32, conditional phase-one
    // act50 = (KILL 2)
    // act539 = (ADD L E)
    // act996 = (TEST (AND (POLYSYLLABIC ROOT) (PLAUSIBLE-ROOT ROOT) (MORPH-...
    // act980 = (SETQ SUFFIX 'IC)
    // act981 = (CAT ADJ T EVAL (MAKE-SUFFIX-DEF LEX ROOT SUFFIX))
    ":c-block", false, true, false),
  r("i c # -> 24,117,997,980,109",
  // c-block-33, conditional phase-one
    // act24 = (KILL 1)
    // act117 = (ADD A)
    // act997 = (TEST (AND (POLYSYLLABIC ROOT) (PLAUSIBLE-ROOT ROOT) (MORPH-...
    // act980 = (SETQ SUFFIX 'IC)
    // act109 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'N)) E...
    ":c-block", false, true, false),
  r("i c # -> 50,194,998,980,981",
  // c-block-34, conditional phase-one
    // act50 = (KILL 2)
    // act194 = (ADD U S)
    // act998 = (TEST (AND (POLYSYLLABIC ROOT) (PLAUSIBLE-ROOT ROOT) (MORPH-...
    // act980 = (SETQ SUFFIX 'IC)
    // act981 = (CAT ADJ T EVAL (MAKE-SUFFIX-DEF LEX ROOT SUFFIX))
    ":c-block", false, true, false),
  r("i c # -> 50,116,999,980,981",
  // c-block-35, conditional phase-one
    // act50 = (KILL 2)
    // act116 = (ADD U M)
    // act999 = (TEST (AND (POLYSYLLABIC ROOT) (PLAUSIBLE-ROOT ROOT) (MORPH-...
    // act980 = (SETQ SUFFIX 'IC)
    // act981 = (CAT ADJ T EVAL (MAKE-SUFFIX-DEF LEX ROOT SUFFIX))
    ":c-block", false, true, false),
  r("i c # -> 50,54,999,980,981",
  // c-block-36, conditional phase-one
    // act50 = (KILL 2)
    // act54 = (ADD I S)
    // act999 = (TEST (AND (POLYSYLLABIC ROOT) (PLAUSIBLE-ROOT ROOT) (MORPH-...
    // act980 = (SETQ SUFFIX 'IC)
    // act981 = (CAT ADJ T EVAL (MAKE-SUFFIX-DEF LEX ROOT SUFFIX))
    ":c-block", false, true, false),
  r("i c # -> 50,450,996,980,981",
  // c-block-37, conditional phase-one
    // act50 = (KILL 2)
    // act450 = (ADD I E)
    // act996 = (TEST (AND (POLYSYLLABIC ROOT) (PLAUSIBLE-ROOT ROOT) (MORPH-...
    // act980 = (SETQ SUFFIX 'IC)
    // act981 = (CAT ADJ T EVAL (MAKE-SUFFIX-DEF LEX ROOT SUFFIX))
    ":c-block", false, true, false),
  r("i f i c # -> 50,31,1000,980,981",
  // c-block-38, conditional phase-one
    // act50 = (KILL 2)
    // act31 = (ADD Y)
    // act1000 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-ROOT...
    // act980 = (SETQ SUFFIX 'IC)
    // act981 = (CAT ADJ T EVAL (MAKE-SUFFIX-DEF LEX ROOT SUFFIX))
    ":c-block", false, true, false),
  r("i c # -> 50,1001,996,980,981",
  // c-block-39, conditional phase-one
    // act50 = (KILL 2)
    // act1001 = (ADD I A N)
    // act996 = (TEST (AND (POLYSYLLABIC ROOT) (PLAUSIBLE-ROOT ROOT) (MORPH-...
    // act980 = (SETQ SUFFIX 'IC)
    // act981 = (CAT ADJ T EVAL (MAKE-SUFFIX-DEF LEX ROOT SUFFIX))
    ":c-block", false, true, false),
  r("i c # -> 50,287,996,980,981",
  // c-block-40, conditional phase-one
    // act50 = (KILL 2)
    // act287 = (ADD I S M)
    // act996 = (TEST (AND (POLYSYLLABIC ROOT) (PLAUSIBLE-ROOT ROOT) (MORPH-...
    // act980 = (SETQ SUFFIX 'IC)
    // act981 = (CAT ADJ T EVAL (MAKE-SUFFIX-DEF LEX ROOT SUFFIX))
    ":c-block", false, true, false),
  r("i c # -> 24,999,980,981",
  // c-block-41, conditional phase-one
    // act24 = (KILL 1)
    // act999 = (TEST (AND (POLYSYLLABIC ROOT) (PLAUSIBLE-ROOT ROOT) (MORPH-...
    // act980 = (SETQ SUFFIX 'IC)
    // act981 = (CAT ADJ T EVAL (MAKE-SUFFIX-DEF LEX ROOT SUFFIX))
    ":c-block", false, true, false),
  r("c i c # -> 19,20,996,980,981",
  // c-block-42, conditional phase-one
    // act19 = (KILL 3)
    // act20 = (ADD X)
    // act996 = (TEST (AND (POLYSYLLABIC ROOT) (PLAUSIBLE-ROOT ROOT) (MORPH-...
    // act980 = (SETQ SUFFIX 'IC)
    // act981 = (CAT ADJ T EVAL (MAKE-SUFFIX-DEF LEX ROOT SUFFIX))
    ":c-block", false, true, false),
  r("i a c # -> 19,1002,1003,162",
  // c-block-43, conditional phase-one
    // act19 = (KILL 3)
    // act1002 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-ROOT...
    // act1003 = (CAT N T EVAL (PROGN (MARK-DICT LEX 'KINDOF 'PERSON T T) (MA...
    // act162 = (CAT ADJ T EVAL '*)
    ":c-block", false, true, false),
  r("consonant i a c # -> 19,68,1002,1003,162",
  // c-block-44, conditional phase-one
    // act19 = (KILL 3)
    // act68 = (ADD E)
    // act1002 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-ROOT...
    // act1003 = (CAT N T EVAL (PROGN (MARK-DICT LEX 'KINDOF 'PERSON T T) (MA...
    // act162 = (CAT ADJ T EVAL '*)
    ":c-block", false, true, false),
  r("i a c # -> 24,1002,1003,162",
  // c-block-45, conditional phase-one
    // act24 = (KILL 1)
    // act1002 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-ROOT...
    // act1003 = (CAT N T EVAL (PROGN (MARK-DICT LEX 'KINDOF 'PERSON T T) (MA...
    // act162 = (CAT ADJ T EVAL '*)
    ":c-block", false, true, false),
  r("i a c # -> 24,68,1004,1003,162",
  // c-block-46, conditional phase-one
    // act24 = (KILL 1)
    // act68 = (ADD E)
    // act1004 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-ROOT...
    // act1003 = (CAT N T EVAL (PROGN (MARK-DICT LEX 'KINDOF 'PERSON T T) (MA...
    // act162 = (CAT ADJ T EVAL '*)
    ":c-block", false, true, false),
  r("i a c # -> 19,31,1005,1003,162",
  // c-block-47, conditional phase-one
    // act19 = (KILL 3)
    // act31 = (ADD Y)
    // act1005 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-ROOT...
    // act1003 = (CAT N T EVAL (PROGN (MARK-DICT LEX 'KINDOF 'PERSON T T) (MA...
    // act162 = (CAT ADJ T EVAL '*)
    ":c-block", false, true, false),
  r("s c o p i c # -> 102,1006,1007",
  // c-block-48, conditional phase-one
    // act102 = (KILL 6)
    // act1006 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-ROOT...
    // act1007 = (CAT ADJ T EVAL (PROGN (MARK-DICT LEX 'KINDOF (MAKE-STRUCTUR...
    ":c-block", false, true, false),
  r("t r o p i c # -> 50,31,980,1008",
  // c-block-49, 
    // act50 = (KILL 2)
    // act31 = (ADD Y)
    // act980 = (SETQ SUFFIX 'IC)
    // act1008 = (CAT ADJ (AND (PLAUSIBLE-ROOT ROOT) (POLYSYLLABIC ROOT)) EVA...
    ":c-block"),
  r("t r o p i c # -> 102,1009",
  // c-block-50, conditional phase-one
    // act102 = (KILL 6)
    // act1009 = (CAT ADJ (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-R...
    ":c-block", false, true, false),
  r("o t i c # -> 19,292,35,980,981",
  // c-block-51, 
    // act19 = (KILL 3)
    // act292 = (ADD S I S)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act980 = (SETQ SUFFIX 'IC)
    // act981 = (CAT ADJ T EVAL (MAKE-SUFFIX-DEF LEX ROOT SUFFIX))
    ":c-block"),
  r("a|o l o g i c # -> 50,31,35,980,1010",
  // c-block-52, conditional phase-one
    // act50 = (KILL 2)
    // act31 = (ADD Y)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act980 = (SETQ SUFFIX 'IC)
    // act1010 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'N)) E...
    ":c-block", false, true, false),
  r("a|o l o g i c # -> 57,35,980,1011",
  // c-block-53, conditional phase-one
    // act57 = (KILL 5)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act980 = (SETQ SUFFIX 'IC)
    // act1011 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-FORM-OF-CAT ROOT 'PREFI...
    ":c-block", false, true, false),
  r("a|o l o g i c # -> 50,31,35,980,981",
  // c-block-54, 
    // act50 = (KILL 2)
    // act31 = (ADD Y)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act980 = (SETQ SUFFIX 'IC)
    // act981 = (CAT ADJ T EVAL (MAKE-SUFFIX-DEF LEX ROOT SUFFIX))
    ":c-block"),
  r("z o i c # -> 35,1012,1013",
  // c-block-55, 
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act1012 = (CAT ADJ T EVAL (PROGN (MARK-DICT LEX 'HAS-SUFFIX 'ZOIC T T)...
    // act1013 = (CAT N T EVAL 'UNIQUE)
    ":c-block"),
  r("o v i c # -> 152",
  // c-block-56, 
    // act152 = (CAT LASTNAME (PLAUSIBLE-ROOT ROOT) EVAL '*)
    ":c-block"),
  r("i c # -> 131,1014",
  // c-block-57, 
    // act131 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (POLYSYLLABIC ROOT)))
    // act1014 = (CAT ADJ T EVAL (PROGN (MARK-DICT LEX 'GUESSED 'T) '*))
    ":c-block"),
  r("i a c # -> 24,35,1015,162",
  // c-block-58, 
    // act24 = (KILL 1)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act1015 = (CAT N T EVAL (PROGN (MARK-DICT LEX 'KINDOF 'PERSON T T) '-S...
    // act162 = (CAT ADJ T EVAL '*)
    ":c-block"),
  r(" -> 180,158",
  // c-block-59, 
    // act180 = (TEST T)
    // act158 = (DO DEFAULT-RULE)
    ":c-block"),
 };

 protected static MorphRule[] miscBlock = {//":misc-block"
  r("s ' # -> 24,1016",
  // misc-block-1, 
    // act24 = (KILL 1)
    // act1016 = (CAT N (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT 'N)) EVAL (L...
    ":misc-block"),
  r("a t a # -> 50,1017,1018,1019,24,116,1020,1018,1021,132,1021",
  // misc-block-2, conditional phase-one
    // act50 = (KILL 2)
    // act1017 = (SETQ SUFFIX 'ATA)
    // act1018 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (IS...
    // act1019 = (CAT N (AND (MORPH-ROOT STATE) (TEST-ICODE ROOT 'NN '-ATA)) ...
    // act24 = (KILL 1)
    // act116 = (ADD U M)
    // act1020 = (SETQ SUFFIX 'A)
    // act1018 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (IS...
    // act1021 = (CAT N (AND (MORPH-ROOT STATE) (TEST-ICODE ROOT 'N '-A)) EVA...
    // act132 = (ADD O N)
    // act1021 = (CAT N (AND (MORPH-ROOT STATE) (TEST-ICODE ROOT 'N '-A)) EVA...
    ":misc-block", false, true, true),
  r("i s t a # -> 61,1022,1023,1024",
  // misc-block-3, conditional phase-one
    // act61 = (KILL 4)
    // act1022 = (TEST (AND (MORPH-ROOT STATE) (IS-KNOWN-WORD ROOT) (PLAUSIBL...
    // act1023 = (SETQ SUFFIX 'ISTA)
    // act1024 = (CAT NC T EVAL (LIST LEX '(NUMBER SG) (LIST 'ROOT ROOT) (LIS...
    ":misc-block", false, true, false),
  r("a # -> 24,1020,1025,116,1021,132,1021",
  // misc-block-4, conditional phase-one
    // act24 = (KILL 1)
    // act1020 = (SETQ SUFFIX 'A)
    // act1025 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (> (NCHARS ROOT) 2) (MORPH-...
    // act116 = (ADD U M)
    // act1021 = (CAT N (AND (MORPH-ROOT STATE) (TEST-ICODE ROOT 'N '-A)) EVA...
    // act132 = (ADD O N)
    // act1021 = (CAT N (AND (MORPH-ROOT STATE) (TEST-ICODE ROOT 'N '-A)) EVA...
    ":misc-block", false, true, true),
  r("i # -> 24,194,1026,1027",
  // misc-block-5, conditional phase-one
    // act24 = (KILL 1)
    // act194 = (ADD U S)
    // act1026 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (IS...
    // act1027 = (CAT N (AND (MORPH-ROOT STATE) (TEST-ICODE ROOT 'N '-I)) EVA...
    ":misc-block", false, true, false),
  r("i # -> 24,37,1028,1027",
  // misc-block-6, conditional phase-one
    // act24 = (KILL 1)
    // act37 = (ADD O)
    // act1028 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (> (NCHARS ROOT) 2) (MORPH-...
    // act1027 = (CAT N (AND (MORPH-ROOT STATE) (TEST-ICODE ROOT 'N '-I)) EVA...
    ":misc-block", false, true, false),
  r("i # -> 24,68,1028,1027",
  // misc-block-7, conditional phase-one
    // act24 = (KILL 1)
    // act68 = (ADD E)
    // act1028 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (> (NCHARS ROOT) 2) (MORPH-...
    // act1027 = (CAT N (AND (MORPH-ROOT STATE) (TEST-ICODE ROOT 'N '-I)) EVA...
    ":misc-block", false, true, false),
  r("i # -> 24,1028,1027",
  // misc-block-8, conditional phase-one
    // act24 = (KILL 1)
    // act1028 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (> (NCHARS ROOT) 2) (MORPH-...
    // act1027 = (CAT N (AND (MORPH-ROOT STATE) (TEST-ICODE ROOT 'N '-I)) EVA...
    ":misc-block", false, true, false),
  r("i # -> 24,1029,162,1030",
  // misc-block-9, conditional phase-one
    // act24 = (KILL 1)
    // act1029 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (POLYSYLLABIC ROOT) (MORPH-...
    // act162 = (CAT ADJ T EVAL '*)
    // act1030 = (CAT N T EVAL (PROGN (MARK-DICT LEX 'KINDOF 'PERSON T T) (MA...
    ":misc-block", false, true, false),
  r("a t a # -> 50,1017,1025,1031,24,116,1020,1032,1031,132,1031",
  // misc-block-10, conditional phase-one
    // act50 = (KILL 2)
    // act1017 = (SETQ SUFFIX 'ATA)
    // act1025 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (> (NCHARS ROOT) 2) (MORPH-...
    // act1031 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'NN)) EV...
    // act24 = (KILL 1)
    // act116 = (ADD U M)
    // act1020 = (SETQ SUFFIX 'A)
    // act1032 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (> (NCHARS ROOT) 4) (MORPH-...
    // act1031 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'NN)) EV...
    // act132 = (ADD O N)
    // act1031 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'NN)) EV...
    ":misc-block", false, true, true),
  r("a # -> 24,116,1033,1031",
  // misc-block-11, conditional phase-one
    // act24 = (KILL 1)
    // act116 = (ADD U M)
    // act1033 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (POLYSYLLABIC ROOT) (MORPH-...
    // act1031 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'NN)) EV...
    ":misc-block", false, true, false),
  r("a # -> 24,132,1034,1031",
  // misc-block-12, conditional phase-one
    // act24 = (KILL 1)
    // act132 = (ADD O N)
    // act1034 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (POLYSYLLABIC ROOT) (MORPH-...
    // act1031 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'NN)) EV...
    ":misc-block", false, true, false),
  r("consonant i # -> 24,31,1018,402",
  // misc-block-13, conditional phase-one
    // act24 = (KILL 1)
    // act31 = (ADD Y)
    // act1018 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (IS...
    // act402 = (CAT FEMALEFIRSTNAME (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT...
    ":misc-block", false, true, false),
  r("i # -> 24,194,1032,1031",
  // misc-block-14, conditional phase-one
    // act24 = (KILL 1)
    // act194 = (ADD U S)
    // act1032 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (> (NCHARS ROOT) 4) (MORPH-...
    // act1031 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'NN)) EV...
    ":misc-block", false, true, false),
  r("i # -> 24,37,1035,1031",
  // misc-block-15, conditional phase-one
    // act24 = (KILL 1)
    // act37 = (ADD O)
    // act1035 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (POLYSYLLABIC ROOT) (> (NCH...
    // act1031 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'NN)) EV...
    ":misc-block", false, true, false),
  r("consonant vowel b|d|g|k|l|m|n|p|r|t & e t h # -> 61,1018,1036",
  // misc-block-16, conditional phase-one
    // act61 = (KILL 4)
    // act1018 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (IS...
    // act1036 = (CAT V (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'V)) EVA...
    ":misc-block", false, true, false),
  r("q u vowel b|d|g|k|l|m|n|p|r|t & e t h # -> 61,1018,1036",
  // misc-block-17, conditional phase-one
    // act61 = (KILL 4)
    // act1018 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (IS...
    // act1036 = (CAT V (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'V)) EVA...
    ":misc-block", false, true, false),
  r("consonant vowel b|d|g|k|l|m|n|p|r|t e t h # -> 50,1018,1036",
  // misc-block-18, conditional phase-one
    // act50 = (KILL 2)
    // act1018 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (IS...
    // act1036 = (CAT V (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'V)) EVA...
    ":misc-block", false, true, false),
  r("q u vowel b|d|g|k|l|m|n|p|r|t e t h # -> 50,1018,1036",
  // misc-block-19, conditional phase-one
    // act50 = (KILL 2)
    // act1018 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (IS...
    // act1036 = (CAT V (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'V)) EVA...
    ":misc-block", false, true, false),
  r("consonant vowel b|d|g|k|l|m|n|p|r|t e t h # -> 50,1018,1037",
  // misc-block-20, phase-one
    // act50 = (KILL 2)
    // act1018 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (IS...
    // act1037 = (CAT V (AND (MORPH-ROOT STATE) (NOT (POLYSYLLABIC ROOT))) EV...
    ":misc-block", true, false, false),
  r("q u vowel b|d|g|k|l|m|n|p|r|t e t h # -> 50,1018,1038",
  // misc-block-21, phase-one
    // act50 = (KILL 2)
    // act1018 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (IS...
    // act1038 = (CAT V T EVAL (PROGN (MARK-DICT LEX 'GUESSED 'T) (LIST ROOT ...
    ":misc-block", true, false, false),
  r("consonant i e t h # -> 61,31,1018,1036",
  // misc-block-22, conditional phase-one
    // act61 = (KILL 4)
    // act31 = (ADD Y)
    // act1018 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (IS...
    // act1036 = (CAT V (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'V)) EVA...
    ":misc-block", false, true, false),
  r("e t h # -> 50,1018,1036",
  // misc-block-23, conditional phase-one
    // act50 = (KILL 2)
    // act1018 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (IS...
    // act1036 = (CAT V (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'V)) EVA...
    ":misc-block", false, true, false),
  r("e t h # -> 19,1018,1036",
  // misc-block-24, conditional phase-one
    // act19 = (KILL 3)
    // act1018 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (IS...
    // act1036 = (CAT V (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'V)) EVA...
    ":misc-block", false, true, false),
  r("f i s h # -> 61,35,1039",
  // misc-block-25, conditional phase-one
    // act61 = (KILL 4)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act1039 = (CAT NMSP (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(ADJ...
    ":misc-block", false, true, false),
  r("i s h # -> 19,68,35,1040,1041",
  // misc-block-26, conditional phase-one
    // act19 = (KILL 3)
    // act68 = (ADD E)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act1040 = (SETQ SUFFIX 'ISH)
    // act1041 = (CAT ADJ (AND (MORPH-ROOT STATE) (OR (IS-ROOT-OF-CAT ROOT '(...
    ":misc-block", false, true, false),
  r("consonant vowel b|d|g|k|l|m|n|p|r|s|t|z & i s h # -> 61,35,1040,1041",
  // misc-block-27, conditional phase-one
    // act61 = (KILL 4)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act1040 = (SETQ SUFFIX 'ISH)
    // act1041 = (CAT ADJ (AND (MORPH-ROOT STATE) (OR (IS-ROOT-OF-CAT ROOT '(...
    ":misc-block", false, true, false),
  r("q u vowel b|d|g|k|l|m|n|p|r|s|t|z & i s h # -> 61,35,1040,1041",
  // misc-block-28, conditional phase-one
    // act61 = (KILL 4)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act1040 = (SETQ SUFFIX 'ISH)
    // act1041 = (CAT ADJ (AND (MORPH-ROOT STATE) (OR (IS-ROOT-OF-CAT ROOT '(...
    ":misc-block", false, true, false),
  r("i s h # -> 19,269,1040,1041",
  // misc-block-29, conditional phase-one
    // act19 = (KILL 3)
    // act269 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (NE...
    // act1040 = (SETQ SUFFIX 'ISH)
    // act1041 = (CAT ADJ (AND (MORPH-ROOT STATE) (OR (IS-ROOT-OF-CAT ROOT '(...
    ":misc-block", false, true, false),
  r("s m a n s h i p # -> 111,1042",
  // misc-block-30, conditional phase-one
    // act111 = (KILL 8)
    // act1042 = (CAT NM (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-RO...
    ":misc-block", false, true, false),
  r("m a n s h i p # -> 113,1043",
  // misc-block-31, conditional phase-one
    // act113 = (KILL 7)
    // act1043 = (CAT NM (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-RO...
    ":misc-block", false, true, false),
  r("s h i p # -> 61,204,1044",
  // misc-block-32, conditional phase-one
    // act61 = (KILL 4)
    // act204 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-ROOT...
    // act1044 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'NN)) EV...
    ":misc-block", false, true, false),
  r("s h i p # -> 61,68,1045,1044",
  // misc-block-33, conditional phase-one
    // act61 = (KILL 4)
    // act68 = (ADD E)
    // act1045 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (PA...
    // act1044 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'NN)) EV...
    ":misc-block", false, true, false),
  r("s h i p # -> 61,68,105,1044",
  // misc-block-34, conditional phase-one
    // act61 = (KILL 4)
    // act68 = (ADD E)
    // act105 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (NEED-FINAL-E ROOT)))
    // act1044 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'NN)) EV...
    ":misc-block", false, true, false),
  r("s h i p # -> 61,35,1044",
  // misc-block-35, conditional phase-one
    // act61 = (KILL 4)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act1044 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'NN)) EV...
    ":misc-block", false, true, false),
  r("p r o o f # -> 57,1046,1047,1048",
  // misc-block-36, conditional phase-one
    // act57 = (KILL 5)
    // act1046 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-ROOT...
    // act1047 = (CAT ADJ T EVAL (LIST LEX (LIST 'PREFIX ROOT) '(ROOT PROOF) ...
    // act1048 = (CAT V T EVAL (PROGN (MARK-DICT LEX 'FEATURES '(TRANS PASSIV...
    ":misc-block", false, true, false),
  r("p r o o f # -> 57,35,1049,1048",
  // misc-block-37, 
    // act57 = (KILL 5)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act1049 = (CAT ADJ T EVAL (PROGN (MARK-DICT LEX 'GUESSED 'T) (LIST LEX...
    // act1048 = (CAT V T EVAL (PROGN (MARK-DICT LEX 'FEATURES '(TRANS PASSIV...
    ":misc-block"),
  r("s p e a k # -> 57,1050,1051",
  // misc-block-38, conditional phase-one
    // act57 = (KILL 5)
    // act1050 = (TEST (AND (MORPH-ROOT STATE) (NOT (IS-FORM-OF-CAT ROOT 'PRE...
    // act1051 = (CAT NM (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-RO...
    ":misc-block", false, true, false),
  r("i a # -> 50,37,32,1052",
  // misc-block-39, conditional phase-one
    // act50 = (KILL 2)
    // act37 = (ADD O)
    // act32 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-KNOW...
    // act1052 = (CAT NM (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'PREFIX...
    ":misc-block", false, true, false),
  r("i a # -> 24,546,32,1053",
  // misc-block-40, conditional phase-one
    // act24 = (KILL 1)
    // act546 = (ADD C)
    // act32 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-KNOW...
    // act1053 = (CAT NM (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADJ)) ...
    ":misc-block", false, true, false),
  r("z o a # -> 19,615,1054",
  // misc-block-41, conditional phase-one
    // act19 = (KILL 3)
    // act615 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (POLYSYLLABIC ROOT) (MORPH-...
    // act1054 = (CAT N T EVAL (PROGN (MARK-DICT LEX 'FALSE-ROOT ROOT T T) (M...
    ":misc-block", false, true, false),
  r("t r i x # -> 19,69,35,1055",
  // misc-block-42, conditional phase-one
    // act19 = (KILL 3)
    // act69 = (ADD O R)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act1055 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'N)) EVA...
    ":misc-block", false, true, false),
  r("vowel t r i x # -> 19,35,1056",
  // misc-block-43, conditional phase-one
    // act19 = (KILL 3)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act1056 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'V)) EVA...
    ":misc-block", false, true, false),
  r("vowel t r i x # -> 19,68,105,1056",
  // misc-block-44, conditional phase-one
    // act19 = (KILL 3)
    // act68 = (ADD E)
    // act105 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (NEED-FINAL-E ROOT)))
    // act1056 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'V)) EVA...
    ":misc-block", false, true, false),
  r("t r i x # -> 19,72,35,1055",
  // misc-block-45, conditional phase-one
    // act19 = (KILL 3)
    // act72 = (ADD E R)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act1055 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'N)) EVA...
    ":misc-block", false, true, false),
  r("a|i|o b r a n c h # -> 102,35,1057",
  // misc-block-46, conditional phase-one
    // act102 = (KILL 6)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act1057 = (CAT NC (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(PREFI...
    ":misc-block", false, true, false),
  r("p o d a # -> 24,1020,1058",
  // misc-block-47, 
    // act24 = (KILL 1)
    // act1020 = (SETQ SUFFIX 'A)
    // act1058 = (CAT N (POLYSYLLABIC ROOT) EVAL (LIST LEX '(NUMBER SG/PL) (L...
    ":misc-block"),
  r("t o d a # -> 24,68,1020,1058",
  // misc-block-48, 
    // act24 = (KILL 1)
    // act68 = (ADD E)
    // act1020 = (SETQ SUFFIX 'A)
    // act1058 = (CAT N (POLYSYLLABIC ROOT) EVAL (LIST LEX '(NUMBER SG/PL) (L...
    ":misc-block"),
  r("o m a # -> 192",
  // misc-block-49, 
    // act192 = (CAT N T EVAL '-S)
    ":misc-block"),
  r("i a # -> 1059",
  // misc-block-50, 
    // act1059 = (CAT N T EVAL 'MASS)
    ":misc-block"),
  r("t u r a # -> 1059",
  // misc-block-51, 
    // act1059 = (CAT N T EVAL 'MASS)
    ":misc-block"),
  r("f i s h # -> 61,35,1060",
  // misc-block-52, 
    // act61 = (KILL 4)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act1060 = (CAT N T EVAL (PROGN (LIST LEX (LIST 'PREFIX ROOT) '(ROOT FI...
    ":misc-block"),
  r("consonant vowel b|d|g|k|l|m|n|p|r|s|t|z & i s h # -> 61,1040,424",
  // misc-block-53, 
    // act61 = (KILL 4)
    // act1040 = (SETQ SUFFIX 'ISH)
    // act424 = (CAT ADJ (PLAUSIBLE-ROOT ROOT) EVAL (LIST LEX (LIST 'ROOT RO...
    ":misc-block"),
  r("q u vowel b|d|g|k|l|m|n|p|r|s|t|z & i s h # -> 61,1040,424",
  // misc-block-54, 
    // act61 = (KILL 4)
    // act1040 = (SETQ SUFFIX 'ISH)
    // act424 = (CAT ADJ (PLAUSIBLE-ROOT ROOT) EVAL (LIST LEX (LIST 'ROOT RO...
    ":misc-block"),
  r("i s h # -> 19,1040,1061",
  // misc-block-55, 
    // act19 = (KILL 3)
    // act1040 = (SETQ SUFFIX 'ISH)
    // act1061 = (CAT ADJ (PLAUSIBLE-ROOT ROOT) EVAL (MAKE-SUFFIX-DEF LEX ROO...
    ":misc-block"),
  r("l i t h # -> 270",
  // misc-block-56, 
    // act270 = (CAT N (POLYSYLLABIC ROOT) EVAL '-S)
    ":misc-block"),
  r("consonant vowel b|d|g|k|l|m|n|p|r|t & e t h # -> 61,35,1062",
  // misc-block-57, 
    // act61 = (KILL 4)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act1062 = (CAT V (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT 'V)) EVAL (L...
    ":misc-block"),
  r("q u vowel b|d|g|k|l|m|n|p|r|t & e t h # -> 61,35,1062",
  // misc-block-58, 
    // act61 = (KILL 4)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act1062 = (CAT V (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT 'V)) EVAL (L...
    ":misc-block"),
  r("consonant vowel b|d|g|k|l|m|n|p|r|t e t h # -> 50,35,1062",
  // misc-block-59, 
    // act50 = (KILL 2)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act1062 = (CAT V (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT 'V)) EVAL (L...
    ":misc-block"),
  r("q u vowel b|d|g|k|l|m|n|p|r|t e t h # -> 50,35,1062",
  // misc-block-60, 
    // act50 = (KILL 2)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act1062 = (CAT V (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT 'V)) EVAL (L...
    ":misc-block"),
  r("vowel consonant e t h # -> 19,68,105,1062",
  // misc-block-61, 
    // act19 = (KILL 3)
    // act68 = (ADD E)
    // act105 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (NEED-FINAL-E ROOT)))
    // act1062 = (CAT V (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT 'V)) EVAL (L...
    ":misc-block"),
  r("consonant e t h # -> 19,35,1062",
  // misc-block-62, 
    // act19 = (KILL 3)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act1062 = (CAT V (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT 'V)) EVAL (L...
    ":misc-block"),
  r("t h # -> 50,1063,1064,162,1065,1066",
  // misc-block-63, conditional phase-one
    // act50 = (KILL 2)
    // act1063 = (TEST (AND (MORPH-ROOT STATE) (OR (IS-FORM-OF-CAT ROOT '(INT...
    // act1064 = (CAT ORD T EVAL '*)
    // act162 = (CAT ADJ T EVAL '*)
    // act1065 = (CAT N T EVAL (PROGN (MARK-DICT LEX 'PENALTIES '(N 1 ADV 2) ...
    // act1066 = (CAT ADV T EVAL (PROGN (MARK-DICT LEX 'KINDOF (MAKE-STRUCTUR...
    ":misc-block", false, true, false),
  r("i l l i o n t h # -> 50,1067,1064,162,1065,1068",
  // misc-block-64, phase-one
    // act50 = (KILL 2)
    // act1067 = (TEST (AND (MORPH-ROOT STATE) (MORPH-CHECK ROOT 'N) (MAKE-RE...
    // act1064 = (CAT ORD T EVAL '*)
    // act162 = (CAT ADJ T EVAL '*)
    // act1065 = (CAT N T EVAL (PROGN (MARK-DICT LEX 'PENALTIES '(N 1 ADV 2) ...
    // act1068 = (CAT ADV T EVAL (PROGN (MARK-DICT LEX 'KINDOF (MAKE-STRUCTUR...
    ":misc-block", true, false, false),
  r("consonant t h # -> 50,1069,1070",
  // misc-block-65, conditional phase-one
    // act50 = (KILL 2)
    // act1069 = (TEST (AND (MORPH-ROOT STATE) (IS-KNOWN-WORD ROOT) (> (NCHAR...
    // act1070 = (CAT NM T EVAL (PROGN (MARK-DICT LEX 'HAS-SUFFIX 'TH T T) (M...
    ":misc-block", false, true, false),
  r("t t i # -> 152",
  // misc-block-66, 
    // act152 = (CAT LASTNAME (PLAUSIBLE-ROOT ROOT) EVAL '*)
    ":misc-block"),
  r("i n i # -> 24,194,87",
  // misc-block-67, conditional phase-one
    // act24 = (KILL 1)
    // act194 = (ADD U S)
    // act87 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'N)) EVA...
    ":misc-block", false, true, false),
  r("i n i # -> 24,37,87",
  // misc-block-68, conditional phase-one
    // act24 = (KILL 1)
    // act37 = (ADD O)
    // act87 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'N)) EVA...
    ":misc-block", false, true, false),
  r("i n i # -> 24,68,87",
  // misc-block-69, conditional phase-one
    // act24 = (KILL 1)
    // act68 = (ADD E)
    // act87 = (CAT N (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'N)) EVA...
    ":misc-block", false, true, false),
  r("r i n i # -> 152",
  // misc-block-70, 
    // act152 = (CAT LASTNAME (PLAUSIBLE-ROOT ROOT) EVAL '*)
    ":misc-block"),
  r("i a n i # -> 152",
  // misc-block-71, 
    // act152 = (CAT LASTNAME (PLAUSIBLE-ROOT ROOT) EVAL '*)
    ":misc-block"),
  r("s k i # -> 152",
  // misc-block-72, 
    // act152 = (CAT LASTNAME (PLAUSIBLE-ROOT ROOT) EVAL '*)
    ":misc-block"),
  r("consonant u l i # -> 24,194,131,56",
  // misc-block-73, 
    // act24 = (KILL 1)
    // act194 = (ADD U S)
    // act131 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (POLYSYLLABIC ROOT)))
    // act56 = (CAT N T EVAL (LIST ROOT '(NUMBER PL)))
    ":misc-block"),
  r("vowel u l i # -> 131,192",
  // misc-block-74, 
    // act131 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (POLYSYLLABIC ROOT)))
    // act192 = (CAT N T EVAL '-S)
    ":misc-block"),
  r("h|l|n i # -> 24,1071,1072",
  // misc-block-75, phase-one
    // act24 = (KILL 1)
    // act1071 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (PA...
    // act1072 = (CAT N T EVAL (PROGN (MARK-DICT LEX 'KINDOF 'PERSON T T) (MA...
    ":misc-block", true, false, false),
  r("i # -> 24,1073,1074",
  // misc-block-76, conditional phase-one
    // act24 = (KILL 1)
    // act1073 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (PA...
    // act1074 = (CAT N T EVAL (PROGN (MARK-DICT LEX 'GUESSED 'T NIL T) (LIST...
    ":misc-block", false, true, false),
  r("i # -> 35,1075,1076",
  // misc-block-77, 
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act1075 = (CAT N T EVAL (PROGN (MARK-DICT LEX 'GUESSED 'T NIL T) (LIST...
    // act1076 = (CAT N T EVAL (LIST LEX '(NUMBER SG)))
    ":misc-block"),
  r("b r o o k # -> 35,264,154",
  // misc-block-78, 
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act264 = (CAT CITY T EVAL '*)
    // act154 = (CAT LASTNAME T EVAL '*)
    ":misc-block"),
  r("b u r g h # -> 35,264,154",
  // misc-block-79, 
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act264 = (CAT CITY T EVAL '*)
    // act154 = (CAT LASTNAME T EVAL '*)
    ":misc-block"),
  r("e n t o # -> 192",
  // misc-block-80, 
    // act192 = (CAT N T EVAL '-S)
    ":misc-block"),
  r("i o s o # -> 50,194,1077,1078,301",
  // misc-block-81, conditional phase-one
    // act50 = (KILL 2)
    // act194 = (ADD U S)
    // act1077 = (TEST (AND (MORPH-ROOT STATE) (IS-KNOWN-WORD ROOT) (IS-FORM-...
    // act1078 = (CAT ADJ T EVAL (PROGN (MARK-DICT LEX 'KINDOF ROOT) '*))
    // act301 = (CAT ADV T EVAL '*)
    ":misc-block", false, true, false),
  r("i o s o # -> 50,1079,1077,1078,301",
  // misc-block-82, conditional phase-one
    // act50 = (KILL 2)
    // act1079 = (ADD S E)
    // act1077 = (TEST (AND (MORPH-ROOT STATE) (IS-KNOWN-WORD ROOT) (IS-FORM-...
    // act1078 = (CAT ADJ T EVAL (PROGN (MARK-DICT LEX 'KINDOF ROOT) '*))
    // act301 = (CAT ADV T EVAL '*)
    ":misc-block", false, true, false),
  r("i o s o # -> 35,1080,162,301",
  // misc-block-83, 
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act1080 = (CAT N T EVAL '-I)
    // act162 = (CAT ADJ T EVAL '*)
    // act301 = (CAT ADV T EVAL '*)
    ":misc-block"),
  r(" -> 180,158",
  // misc-block-84, 
    // act180 = (TEST T)
    // act158 = (DO DEFAULT-RULE)
    ":misc-block"),
 };

 protected static MorphRule[] tionBlock = {//":tion-block"
  r("u c t i o n # -> 61,68,35,1081",
  // tion-block-1, conditional phase-one
    // act61 = (KILL 4)
    // act68 = (ADD E)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act1081 = (CAT NMC (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(V AD...
    ":tion-block", false, true, false),
  r("i p t i o n # -> 57,317,35,1081",
  // tion-block-2, conditional phase-one
    // act57 = (KILL 5)
    // act317 = (ADD B E)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act1081 = (CAT NMC (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(V AD...
    ":tion-block", false, true, false),
  r("u m p t i o n # -> 57,68,35,1081",
  // tion-block-3, conditional phase-one
    // act57 = (KILL 5)
    // act68 = (ADD E)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act1081 = (CAT NMC (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(V AD...
    ":tion-block", false, true, false),
  r("r p t i o n # -> 57,316,35,1081",
  // tion-block-4, conditional phase-one
    // act57 = (KILL 5)
    // act316 = (ADD B)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act1081 = (CAT NMC (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(V AD...
    ":tion-block", false, true, false),
  r("e p t i o n # -> 57,282,35,1081",
  // tion-block-5, conditional phase-one
    // act57 = (KILL 5)
    // act282 = (ADD I V E)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act1081 = (CAT NMC (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(V AD...
    ":tion-block", false, true, false),
  r("e n t i o n # -> 61,344,32,1082",
  // tion-block-6, conditional phase-one
    // act61 = (KILL 4)
    // act344 = (ADD D)
    // act32 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-KNOW...
    // act1082 = (CAT NMC (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(V)))...
    ":tion-block", false, true, false),
  r("vowel s i t i o n # -> 57,68,35,1082",
  // tion-block-7, conditional phase-one
    // act57 = (KILL 5)
    // act68 = (ADD E)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act1082 = (CAT NMC (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(V)))...
    ":tion-block", false, true, false),
  r("i s|z a t i o n # -> 102,542,1083",
  // tion-block-8, conditional phase-one
    // act102 = (KILL 6)
    // act542 = (ADD Z E)
    // act1083 = (CAT NMC (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(V)))...
    ":tion-block", false, true, false),
  r("s t a t i o n # -> 1084,1085",
  // tion-block-9, 
    // act1084 = (CAT N (AND (MORPH-ROOT STATE) (IS-COMPOUND-CAT LEX 'N)) EVA...
    // act1085 = (CAT V (AND (MORPH-ROOT STATE) (IS-COMPOUND-CAT LEX 'V)) EVA...
    ":tion-block"),
  r("a t i o n # -> 19,68,485,1086",
  // tion-block-10, conditional phase-one
    // act19 = (KILL 3)
    // act68 = (ADD E)
    // act485 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-KNOW...
    // act1086 = (CAT NMC (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(ADJ ...
    ":tion-block", false, true, false),
  r("a t i o n # -> 57,68,493,1087",
  // tion-block-11, conditional phase-one
    // act57 = (KILL 5)
    // act68 = (ADD E)
    // act493 = (TEST (AND (PLAUSIBLE-ROOT ROOT)))
    // act1087 = (CAT NMC (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(ADJ ...
    ":tion-block", false, true, false),
  r("a t i o n # -> 19,68,32,1086",
  // tion-block-12, conditional phase-one
    // act19 = (KILL 3)
    // act68 = (ADD E)
    // act32 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-KNOW...
    // act1086 = (CAT NMC (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(ADJ ...
    ":tion-block", false, true, false),
  r("consonant i c a t i o n # -> 113,31,32,1083",
  // tion-block-13, conditional phase-one
    // act113 = (KILL 7)
    // act31 = (ADD Y)
    // act32 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-KNOW...
    // act1083 = (CAT NMC (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(V)))...
    ":tion-block", false, true, false),
  r("i c a t i o n # -> 19,68,32,1082",
  // tion-block-14, conditional phase-one
    // act19 = (KILL 3)
    // act68 = (ADD E)
    // act32 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-KNOW...
    // act1082 = (CAT NMC (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(V)))...
    ":tion-block", false, true, false),
  r("i a t i o n # -> 102,31,32,1088",
  // tion-block-15, conditional phase-one
    // act102 = (KILL 6)
    // act31 = (ADD Y)
    // act32 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-KNOW...
    // act1088 = (CAT NMC (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(V)))...
    ":tion-block", false, true, false),
  r("a t i o n # -> 57,68,105,1088",
  // tion-block-16, conditional phase-one
    // act57 = (KILL 5)
    // act68 = (ADD E)
    // act105 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (NEED-FINAL-E ROOT)))
    // act1088 = (CAT NMC (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(V)))...
    ":tion-block", false, true, false),
  r("a t i o n # -> 57,35,1088",
  // tion-block-17, conditional phase-one
    // act57 = (KILL 5)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act1088 = (CAT NMC (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(V)))...
    ":tion-block", false, true, false),
  r("a t i o n # -> 57,68,35,1088",
  // tion-block-18, conditional phase-one
    // act57 = (KILL 5)
    // act68 = (ADD E)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act1088 = (CAT NMC (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(V)))...
    ":tion-block", false, true, false),
  r("a t i o n # -> 19,68,32,1082",
  // tion-block-19, conditional phase-one
    // act19 = (KILL 3)
    // act68 = (ADD E)
    // act32 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-KNOW...
    // act1082 = (CAT NMC (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(V)))...
    ":tion-block", false, true, false),
  r("t i o n # -> 19,68,174,1081",
  // tion-block-20, conditional phase-one
    // act19 = (KILL 3)
    // act68 = (ADD E)
    // act174 = (TEST (AND (NEED-FINAL-E ROOT) (PLAUSIBLE-ROOT ROOT)))
    // act1081 = (CAT NMC (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(V AD...
    ":tion-block", false, true, false),
  r("t i o n # -> 19,35,1081",
  // tion-block-21, conditional phase-one
    // act19 = (KILL 3)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act1081 = (CAT NMC (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(V AD...
    ":tion-block", false, true, false),
  r("t i o n # -> 19,68,35,1081",
  // tion-block-22, conditional phase-one
    // act19 = (KILL 3)
    // act68 = (ADD E)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act1081 = (CAT NMC (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(V AD...
    ":tion-block", false, true, false),
  r("a t i o n # -> 57,35,1089",
  // tion-block-23, conditional phase-one
    // act57 = (KILL 5)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act1089 = (CAT NMC (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(V AD...
    ":tion-block", false, true, false),
  r("a t i o n # -> 57,68,35,1089",
  // tion-block-24, conditional phase-one
    // act57 = (KILL 5)
    // act68 = (ADD E)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act1089 = (CAT NMC (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(V AD...
    ":tion-block", false, true, false),
  r("consonant vowel consonant & a t i o n # -> 102,68,35,1089",
  // tion-block-25, conditional phase-one
    // act102 = (KILL 6)
    // act68 = (ADD E)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act1089 = (CAT NMC (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(V AD...
    ":tion-block", false, true, false),
  r("f i c a t i o n # -> 113,31,1090",
  // tion-block-26, 
    // act113 = (KILL 7)
    // act31 = (ADD Y)
    // act1090 = (CAT NMC (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT '(V))) EVA...
    ":tion-block"),
  r("consonant l|r|u a t i o n # -> 19,68,1091",
  // tion-block-27, 
    // act19 = (KILL 3)
    // act68 = (ADD E)
    // act1091 = (CAT NMC (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT '(V ADJ)))...
    ":tion-block"),
  r("vowel c|l|n|v a t i o n # -> 19,68,1091",
  // tion-block-28, 
    // act19 = (KILL 3)
    // act68 = (ADD E)
    // act1091 = (CAT NMC (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT '(V ADJ)))...
    ":tion-block"),
  r("consonant vowel b|g|k|s|v|z a t i o n # -> 57,68,1092",
  // tion-block-29, 
    // act57 = (KILL 5)
    // act68 = (ADD E)
    // act1092 = (CAT NMC (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT '(V ADJ)))...
    ":tion-block"),
  r("consonant l|v a t i o n # -> 57,68,1092",
  // tion-block-30, 
    // act57 = (KILL 5)
    // act68 = (ADD E)
    // act1092 = (CAT NMC (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT '(V ADJ)))...
    ":tion-block"),
  r("consonant t a t i o n # -> 57,1092",
  // tion-block-31, 
    // act57 = (KILL 5)
    // act1092 = (CAT NMC (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT '(V ADJ)))...
    ":tion-block"),
  r("e n a t i o n # -> 57,1092",
  // tion-block-32, 
    // act57 = (KILL 5)
    // act1092 = (CAT NMC (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT '(V ADJ)))...
    ":tion-block"),
  r("consonant vowel & b|d|f|g|k|l|m|n|p|r|s|t|v|z a t i o n # -> 57,1092",
  // tion-block-33, 
    // act57 = (KILL 5)
    // act1092 = (CAT NMC (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT '(V ADJ)))...
    ":tion-block"),
  r("consonant vowel b|d|f|g|k|l|m|n|p|r|s|t|v|z a t i o n # -> 19,68,1091",
  // tion-block-34, 
    // act19 = (KILL 3)
    // act68 = (ADD E)
    // act1091 = (CAT NMC (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT '(V ADJ)))...
    ":tion-block"),
  r("a t i o n # -> 19,68,1091",
  // tion-block-35, 
    // act19 = (KILL 3)
    // act68 = (ADD E)
    // act1091 = (CAT NMC (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT '(V ADJ)))...
    ":tion-block"),
  r("t i o n # -> 789",
  // tion-block-36, 
    // act789 = (CAT NMC (POLYSYLLABIC ROOT) EVAL '-S)
    ":tion-block"),
  r(" -> 180,158",
  // tion-block-37, 
    // act180 = (TEST T)
    // act158 = (DO DEFAULT-RULE)
    ":tion-block"),
 };

 protected static MorphRule[] estBlock = {//":est-block"
  r("y i e s t # -> 61,624,1093,35,1094,1095,1096,1097",
  // est-block-1, conditional phase-one
    // act61 = (KILL 4)
    // act624 = (ADD E Y)
    // act1093 = (SETQ SUFFIX 'EST)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act1094 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADJ) ...
    // act1095 = (CAT ADV (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADV) ...
    // act1096 = (CAT V (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'V)) EVA...
    // act1097 = (CAT V (AND (MORPH-ROOT STATE) (IS-FORM-OF-CAT ROOT 'PAST)) ...
    ":est-block", false, true, false),
  r("i e s t # -> 61,31,1093,35,1098,1099,1096,1097",
  // est-block-2, conditional phase-one
    // act61 = (KILL 4)
    // act31 = (ADD Y)
    // act1093 = (SETQ SUFFIX 'EST)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act1098 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADJ))...
    // act1099 = (CAT ADV (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADV))...
    // act1096 = (CAT V (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'V)) EVA...
    // act1097 = (CAT V (AND (MORPH-ROOT STATE) (IS-FORM-OF-CAT ROOT 'PAST)) ...
    ":est-block", false, true, false),
  r("any & e s t # -> 61,1093,35,1100,1101,1096,1097",
  // est-block-3, conditional phase-one
    // act61 = (KILL 4)
    // act1093 = (SETQ SUFFIX 'EST)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act1100 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADJ) ...
    // act1101 = (CAT ADV (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADV) ...
    // act1096 = (CAT V (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'V)) EVA...
    // act1097 = (CAT V (AND (MORPH-ROOT STATE) (IS-FORM-OF-CAT ROOT 'PAST)) ...
    ":est-block", false, true, false),
  r("consonant vowel b|d|g|k|l|m|n|p|r|t e s t # -> 50,1093,35,1102,1103,1096,1097",
  // est-block-4, conditional phase-one
    // act50 = (KILL 2)
    // act1093 = (SETQ SUFFIX 'EST)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act1102 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADJ) ...
    // act1103 = (CAT ADV (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADV) ...
    // act1096 = (CAT V (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'V)) EVA...
    // act1097 = (CAT V (AND (MORPH-ROOT STATE) (IS-FORM-OF-CAT ROOT 'PAST)) ...
    ":est-block", false, true, false),
  r("e s t # -> 19,1093,35,1104,1105,1096,1097,50,35,1098,1099,1096,1097",
  // est-block-5, conditional phase-one
    // act19 = (KILL 3)
    // act1093 = (SETQ SUFFIX 'EST)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act1104 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADJ) ...
    // act1105 = (CAT ADV (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADV) ...
    // act1096 = (CAT V (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'V)) EVA...
    // act1097 = (CAT V (AND (MORPH-ROOT STATE) (IS-FORM-OF-CAT ROOT 'PAST)) ...
    // act50 = (KILL 2)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act1098 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADJ))...
    // act1099 = (CAT ADV (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADV))...
    // act1096 = (CAT V (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'V)) EVA...
    // act1097 = (CAT V (AND (MORPH-ROOT STATE) (IS-FORM-OF-CAT ROOT 'PAST)) ...
    ":est-block", false, true, true),
  r("c k e s t # -> 61,1093,35,1106,1107,1096,1097",
  // est-block-6, conditional phase-one
    // act61 = (KILL 4)
    // act1093 = (SETQ SUFFIX 'EST)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act1106 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADJ) ...
    // act1107 = (CAT ADV (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADV) ...
    // act1096 = (CAT V (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'V)) EVA...
    // act1097 = (CAT V (AND (MORPH-ROOT STATE) (IS-FORM-OF-CAT ROOT 'PAST)) ...
    ":est-block", false, true, false),
  r("i e s t # -> 61,31,1093,35,1098,1099,1096,1097",
  // est-block-7, conditional phase-one
    // act61 = (KILL 4)
    // act31 = (ADD Y)
    // act1093 = (SETQ SUFFIX 'EST)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act1098 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADJ))...
    // act1099 = (CAT ADV (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADV))...
    // act1096 = (CAT V (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'V)) EVA...
    // act1097 = (CAT V (AND (MORPH-ROOT STATE) (IS-FORM-OF-CAT ROOT 'PAST)) ...
    ":est-block", false, true, false),
  r("i e s t # -> 61,624,1093,35,1098,1099,1096,1097",
  // est-block-8, conditional phase-one
    // act61 = (KILL 4)
    // act624 = (ADD E Y)
    // act1093 = (SETQ SUFFIX 'EST)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act1098 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADJ))...
    // act1099 = (CAT ADV (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADV))...
    // act1096 = (CAT V (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'V)) EVA...
    // act1097 = (CAT V (AND (MORPH-ROOT STATE) (IS-FORM-OF-CAT ROOT 'PAST)) ...
    ":est-block", false, true, false),
  r("i e s t # -> 61,68,1093,204,31,1108,1109,1096,1097",
  // est-block-9, conditional phase-one
    // act61 = (KILL 4)
    // act68 = (ADD E)
    // act1093 = (SETQ SUFFIX 'EST)
    // act204 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-ROOT...
    // act31 = (ADD Y)
    // act1108 = (CAT ADJ T EVAL (LIST ROOT '(SUPERLATIVE)))
    // act1109 = (CAT ADV T EVAL (LIST ROOT '(SUPERLATIVE)))
    // act1096 = (CAT V (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'V)) EVA...
    // act1097 = (CAT V (AND (MORPH-ROOT STATE) (IS-FORM-OF-CAT ROOT 'PAST)) ...
    ":est-block", false, true, false),
  r("i e s t # -> 61,1093,204,31,1108,1109,1096,1097",
  // est-block-10, conditional phase-one
    // act61 = (KILL 4)
    // act1093 = (SETQ SUFFIX 'EST)
    // act204 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-ROOT...
    // act31 = (ADD Y)
    // act1108 = (CAT ADJ T EVAL (LIST ROOT '(SUPERLATIVE)))
    // act1109 = (CAT ADV T EVAL (LIST ROOT '(SUPERLATIVE)))
    // act1096 = (CAT V (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'V)) EVA...
    // act1097 = (CAT V (AND (MORPH-ROOT STATE) (IS-FORM-OF-CAT ROOT 'PAST)) ...
    ":est-block", false, true, false),
  r("consonant vowel b|d|g|k|m|n|p|r|t & i e s t # -> 57,1093,204,61,31,1108,1109,1096,1097",
  // est-block-11, conditional phase-one
    // act57 = (KILL 5)
    // act1093 = (SETQ SUFFIX 'EST)
    // act204 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-ROOT...
    // act61 = (KILL 4)
    // act31 = (ADD Y)
    // act1108 = (CAT ADJ T EVAL (LIST ROOT '(SUPERLATIVE)))
    // act1109 = (CAT ADV T EVAL (LIST ROOT '(SUPERLATIVE)))
    // act1096 = (CAT V (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'V)) EVA...
    // act1097 = (CAT V (AND (MORPH-ROOT STATE) (IS-FORM-OF-CAT ROOT 'PAST)) ...
    ":est-block", false, true, false),
  r("q u vowel b|d|g|k|m|n|p|r|t & i e s t # -> 57,1093,204,61,31,1108,1109,1096,1097",
  // est-block-12, conditional phase-one
    // act57 = (KILL 5)
    // act1093 = (SETQ SUFFIX 'EST)
    // act204 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-ROOT...
    // act61 = (KILL 4)
    // act31 = (ADD Y)
    // act1108 = (CAT ADJ T EVAL (LIST ROOT '(SUPERLATIVE)))
    // act1109 = (CAT ADV T EVAL (LIST ROOT '(SUPERLATIVE)))
    // act1096 = (CAT V (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'V)) EVA...
    // act1097 = (CAT V (AND (MORPH-ROOT STATE) (IS-FORM-OF-CAT ROOT 'PAST)) ...
    ":est-block", false, true, false),
  r("consonant vowel b|d|g|k|m|n|p|r|t & e s t # -> 61,1093,35,1098,1099,1096,1097",
  // est-block-13, conditional phase-one
    // act61 = (KILL 4)
    // act1093 = (SETQ SUFFIX 'EST)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act1098 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADJ))...
    // act1099 = (CAT ADV (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADV))...
    // act1096 = (CAT V (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'V)) EVA...
    // act1097 = (CAT V (AND (MORPH-ROOT STATE) (IS-FORM-OF-CAT ROOT 'PAST)) ...
    ":est-block", false, true, false),
  r("q u vowel b|d|g|k|m|n|p|r|t & e s t # -> 61,1093,35,1098,1099,1096,1097",
  // est-block-14, conditional phase-one
    // act61 = (KILL 4)
    // act1093 = (SETQ SUFFIX 'EST)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act1098 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADJ))...
    // act1099 = (CAT ADV (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADV))...
    // act1096 = (CAT V (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'V)) EVA...
    // act1097 = (CAT V (AND (MORPH-ROOT STATE) (IS-FORM-OF-CAT ROOT 'PAST)) ...
    ":est-block", false, true, false),
  r("consonant vowel l|s|z & e s t # -> 19,1093,35,1098,1099,1096,1097",
  // est-block-15, conditional phase-one
    // act19 = (KILL 3)
    // act1093 = (SETQ SUFFIX 'EST)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act1098 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADJ))...
    // act1099 = (CAT ADV (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADV))...
    // act1096 = (CAT V (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'V)) EVA...
    // act1097 = (CAT V (AND (MORPH-ROOT STATE) (IS-FORM-OF-CAT ROOT 'PAST)) ...
    ":est-block", false, true, false),
  r("e s t # -> 50,1093,105,1098,1099,1096,1097",
  // est-block-16, conditional phase-one
    // act50 = (KILL 2)
    // act1093 = (SETQ SUFFIX 'EST)
    // act105 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (NEED-FINAL-E ROOT)))
    // act1098 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADJ))...
    // act1099 = (CAT ADV (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADV))...
    // act1096 = (CAT V (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'V)) EVA...
    // act1097 = (CAT V (AND (MORPH-ROOT STATE) (IS-FORM-OF-CAT ROOT 'PAST)) ...
    ":est-block", false, true, false),
  r("consonant vowel b|d|f|g|k|l|m|n|p|r|s|t|v|z e s t # -> 50,1093,35,1098,1099,1096,1097",
  // est-block-17, conditional phase-one
    // act50 = (KILL 2)
    // act1093 = (SETQ SUFFIX 'EST)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act1098 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADJ))...
    // act1099 = (CAT ADV (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADV))...
    // act1096 = (CAT V (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'V)) EVA...
    // act1097 = (CAT V (AND (MORPH-ROOT STATE) (IS-FORM-OF-CAT ROOT 'PAST)) ...
    ":est-block", false, true, false),
  r("q u a|i|o|u b|d|f|g|k|l|m|n|p|r|s|t|v|z e s t # -> 50,1093,35,1098,1099,1096,1097",
  // est-block-18, conditional phase-one
    // act50 = (KILL 2)
    // act1093 = (SETQ SUFFIX 'EST)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act1098 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADJ))...
    // act1099 = (CAT ADV (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADV))...
    // act1096 = (CAT V (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'V)) EVA...
    // act1097 = (CAT V (AND (MORPH-ROOT STATE) (IS-FORM-OF-CAT ROOT 'PAST)) ...
    ":est-block", false, true, false),
  r("l|r s|v e s t # -> 50,1093,35,1098,1099,1096,1097",
  // est-block-19, conditional phase-one
    // act50 = (KILL 2)
    // act1093 = (SETQ SUFFIX 'EST)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act1098 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADJ))...
    // act1099 = (CAT ADV (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADV))...
    // act1096 = (CAT V (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'V)) EVA...
    // act1097 = (CAT V (AND (MORPH-ROOT STATE) (IS-FORM-OF-CAT ROOT 'PAST)) ...
    ":est-block", false, true, false),
  r("u e s t # -> 50,1093,35,1098,1099,1096,1097",
  // est-block-20, conditional phase-one
    // act50 = (KILL 2)
    // act1093 = (SETQ SUFFIX 'EST)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act1098 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADJ))...
    // act1099 = (CAT ADV (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADV))...
    // act1096 = (CAT V (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'V)) EVA...
    // act1097 = (CAT V (AND (MORPH-ROOT STATE) (IS-FORM-OF-CAT ROOT 'PAST)) ...
    ":est-block", false, true, false),
  r("consonant vowel & b|d|f|g|k|l|m|n|p|r|s|t|v|z e s t # -> 19,1093,35,1098,1099,1096,1097",
  // est-block-21, conditional phase-one
    // act19 = (KILL 3)
    // act1093 = (SETQ SUFFIX 'EST)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act1098 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADJ))...
    // act1099 = (CAT ADV (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADV))...
    // act1096 = (CAT V (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'V)) EVA...
    // act1097 = (CAT V (AND (MORPH-ROOT STATE) (IS-FORM-OF-CAT ROOT 'PAST)) ...
    ":est-block", false, true, false),
  r("consonant vowel b|c|d|f|g|k|l|m|n|p|q|r|t|v|w|y e s t # -> 50,1093,35,1098,1099,1096,1097",
  // est-block-22, conditional phase-one
    // act50 = (KILL 2)
    // act1093 = (SETQ SUFFIX 'EST)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act1098 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADJ))...
    // act1099 = (CAT ADV (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADV))...
    // act1096 = (CAT V (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'V)) EVA...
    // act1097 = (CAT V (AND (MORPH-ROOT STATE) (IS-FORM-OF-CAT ROOT 'PAST)) ...
    ":est-block", false, true, false),
  r("i n g e s t # -> 19,1093,35,1098,1099,1096,1097,50,35,1098,1099,1096,1097",
  // est-block-23, conditional phase-one
    // act19 = (KILL 3)
    // act1093 = (SETQ SUFFIX 'EST)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act1098 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADJ))...
    // act1099 = (CAT ADV (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADV))...
    // act1096 = (CAT V (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'V)) EVA...
    // act1097 = (CAT V (AND (MORPH-ROOT STATE) (IS-FORM-OF-CAT ROOT 'PAST)) ...
    // act50 = (KILL 2)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act1098 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADJ))...
    // act1099 = (CAT ADV (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADV))...
    // act1096 = (CAT V (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'V)) EVA...
    // act1097 = (CAT V (AND (MORPH-ROOT STATE) (IS-FORM-OF-CAT ROOT 'PAST)) ...
    ":est-block", false, true, true),
  r("c|g e s t # -> 50,1093,35,1098,1099,1096,1097",
  // est-block-24, conditional phase-one
    // act50 = (KILL 2)
    // act1093 = (SETQ SUFFIX 'EST)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act1098 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADJ))...
    // act1099 = (CAT ADV (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADV))...
    // act1096 = (CAT V (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'V)) EVA...
    // act1097 = (CAT V (AND (MORPH-ROOT STATE) (IS-FORM-OF-CAT ROOT 'PAST)) ...
    ":est-block", false, true, false),
  r("l|n|r c|g e s t # -> 50,1093,35,1098,1099,1096,1097",
  // est-block-25, conditional phase-one
    // act50 = (KILL 2)
    // act1093 = (SETQ SUFFIX 'EST)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act1098 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADJ))...
    // act1099 = (CAT ADV (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADV))...
    // act1096 = (CAT V (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'V)) EVA...
    // act1097 = (CAT V (AND (MORPH-ROOT STATE) (IS-FORM-OF-CAT ROOT 'PAST)) ...
    ":est-block", false, true, false),
  r("l|r s|v e s t # -> 50,1093,35,1098,1099,1096,1097",
  // est-block-26, conditional phase-one
    // act50 = (KILL 2)
    // act1093 = (SETQ SUFFIX 'EST)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act1098 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADJ))...
    // act1099 = (CAT ADV (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADV))...
    // act1096 = (CAT V (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'V)) EVA...
    // act1097 = (CAT V (AND (MORPH-ROOT STATE) (IS-FORM-OF-CAT ROOT 'PAST)) ...
    ":est-block", false, true, false),
  r("e s t # -> 50,1093,1110,1098,1099,1096,1097",
  // est-block-27, conditional phase-one
    // act50 = (KILL 2)
    // act1093 = (SETQ SUFFIX 'EST)
    // act1110 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (OR (IS-...
    // act1098 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADJ))...
    // act1099 = (CAT ADV (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADV))...
    // act1096 = (CAT V (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'V)) EVA...
    // act1097 = (CAT V (AND (MORPH-ROOT STATE) (IS-FORM-OF-CAT ROOT 'PAST)) ...
    ":est-block", false, true, false),
  r("e s t # -> 50,1093,35,737,738",
  // est-block-28, conditional phase-one
    // act50 = (KILL 2)
    // act1093 = (SETQ SUFFIX 'EST)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act737 = (CAT V (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'V)) EVA...
    // act738 = (CAT V (AND (MORPH-ROOT STATE) (IS-FORM-OF-CAT ROOT 'PAST)) ...
    ":est-block", false, true, false),
  r("e s t # -> 19,1093,35,1098,1099,1096,1097",
  // est-block-29, conditional phase-one
    // act19 = (KILL 3)
    // act1093 = (SETQ SUFFIX 'EST)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act1098 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADJ))...
    // act1099 = (CAT ADV (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADV))...
    // act1096 = (CAT V (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'V)) EVA...
    // act1097 = (CAT V (AND (MORPH-ROOT STATE) (IS-FORM-OF-CAT ROOT 'PAST)) ...
    ":est-block", false, true, false),
  r("y e s t # -> 50,1093,35,1098,1099,1096,1097",
  // est-block-30, conditional phase-one
    // act50 = (KILL 2)
    // act1093 = (SETQ SUFFIX 'EST)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act1098 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADJ))...
    // act1099 = (CAT ADV (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADV))...
    // act1096 = (CAT V (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'V)) EVA...
    // act1097 = (CAT V (AND (MORPH-ROOT STATE) (IS-FORM-OF-CAT ROOT 'PAST)) ...
    ":est-block", false, true, false),
  r("l e s t # -> 50,1093,35,1098,1099,1096,1097",
  // est-block-31, conditional phase-one
    // act50 = (KILL 2)
    // act1093 = (SETQ SUFFIX 'EST)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act1098 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADJ))...
    // act1099 = (CAT ADV (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADV))...
    // act1096 = (CAT V (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'V)) EVA...
    // act1097 = (CAT V (AND (MORPH-ROOT STATE) (IS-FORM-OF-CAT ROOT 'PAST)) ...
    ":est-block", false, true, false),
  r("consonant vowel b|d|f|g|l|m|n|p|r|s|t|k|v|z e s t # -> 50,1093,35,1098,1099,1096,1097",
  // est-block-32, conditional phase-one
    // act50 = (KILL 2)
    // act1093 = (SETQ SUFFIX 'EST)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act1098 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADJ))...
    // act1099 = (CAT ADV (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADV))...
    // act1096 = (CAT V (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'V)) EVA...
    // act1097 = (CAT V (AND (MORPH-ROOT STATE) (IS-FORM-OF-CAT ROOT 'PAST)) ...
    ":est-block", false, true, false),
  r("consonant vowel b|d|g|k|m|n|p|r|t & e s t # -> 61,35,737,738",
  // est-block-33, conditional phase-one
    // act61 = (KILL 4)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act737 = (CAT V (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'V)) EVA...
    // act738 = (CAT V (AND (MORPH-ROOT STATE) (IS-FORM-OF-CAT ROOT 'PAST)) ...
    ":est-block", false, true, false),
  r("q u vowel b|d|g|k|m|n|p|r|t & e s t # -> 61,35,737,738",
  // est-block-34, conditional phase-one
    // act61 = (KILL 4)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act737 = (CAT V (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'V)) EVA...
    // act738 = (CAT V (AND (MORPH-ROOT STATE) (IS-FORM-OF-CAT ROOT 'PAST)) ...
    ":est-block", false, true, false),
  r("consonant vowel b|d|g|k|m|n|p|r|t e s t # -> 50,35,737,738",
  // est-block-35, conditional phase-one
    // act50 = (KILL 2)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act737 = (CAT V (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'V)) EVA...
    // act738 = (CAT V (AND (MORPH-ROOT STATE) (IS-FORM-OF-CAT ROOT 'PAST)) ...
    ":est-block", false, true, false),
  r("q u vowel b|d|g|k|m|n|p|r|t e s t # -> 50,35,737,738",
  // est-block-36, conditional phase-one
    // act50 = (KILL 2)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act737 = (CAT V (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'V)) EVA...
    // act738 = (CAT V (AND (MORPH-ROOT STATE) (IS-FORM-OF-CAT ROOT 'PAST)) ...
    ":est-block", false, true, false),
  r("consonant i e s t # -> 61,31,35,737,738",
  // est-block-37, conditional phase-one
    // act61 = (KILL 4)
    // act31 = (ADD Y)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act737 = (CAT V (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'V)) EVA...
    // act738 = (CAT V (AND (MORPH-ROOT STATE) (IS-FORM-OF-CAT ROOT 'PAST)) ...
    ":est-block", false, true, false),
  r("e s t # -> 19,35,737,738",
  // est-block-38, conditional phase-one
    // act19 = (KILL 3)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act737 = (CAT V (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'V)) EVA...
    // act738 = (CAT V (AND (MORPH-ROOT STATE) (IS-FORM-OF-CAT ROOT 'PAST)) ...
    ":est-block", false, true, false),
  r("e s t # -> 19,35,68,737,738",
  // est-block-39, conditional phase-one
    // act19 = (KILL 3)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act68 = (ADD E)
    // act737 = (CAT V (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'V)) EVA...
    // act738 = (CAT V (AND (MORPH-ROOT STATE) (IS-FORM-OF-CAT ROOT 'PAST)) ...
    ":est-block", false, true, false),
  r("consonant i e s t # -> 61,31,1111,1112",
  // est-block-40, 
    // act61 = (KILL 4)
    // act31 = (ADD Y)
    // act1111 = (CAT ADJ (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT 'ADJ)) EVA...
    // act1112 = (CAT ADV (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT 'ADV)) EVA...
    ":est-block"),
  r("e e s t # -> 50,1111,1112",
  // est-block-41, 
    // act50 = (KILL 2)
    // act1111 = (CAT ADJ (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT 'ADJ)) EVA...
    // act1112 = (CAT ADV (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT 'ADV)) EVA...
    ":est-block"),
  r("consonant vowel b|d|g|k|m|n|p|r|t & e s t # -> 61,1111,1112",
  // est-block-42, 
    // act61 = (KILL 4)
    // act1111 = (CAT ADJ (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT 'ADJ)) EVA...
    // act1112 = (CAT ADV (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT 'ADV)) EVA...
    ":est-block"),
  r("q u vowel b|d|g|k|m|n|p|r|t & e s t # -> 61,1111,1112",
  // est-block-43, 
    // act61 = (KILL 4)
    // act1111 = (CAT ADJ (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT 'ADJ)) EVA...
    // act1112 = (CAT ADV (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT 'ADV)) EVA...
    ":est-block"),
  r("consonant vowel b|d|g|k|m|n|p|r|t & e s t # -> 61,1113,1114",
  // est-block-44, 
    // act61 = (KILL 4)
    // act1113 = (CAT ADJ (POLYSYLLABIC ROOT) EVAL (LIST ROOT '(SUPERLATIVE))...
    // act1114 = (CAT ADV (POLYSYLLABIC ROOT) EVAL (LIST ROOT '(SUPERLATIVE))...
    ":est-block"),
  r("q u vowel b|d|g|k|m|n|p|r|t & e s t # -> 61,1113,1114",
  // est-block-45, 
    // act61 = (KILL 4)
    // act1113 = (CAT ADJ (POLYSYLLABIC ROOT) EVAL (LIST ROOT '(SUPERLATIVE))...
    // act1114 = (CAT ADV (POLYSYLLABIC ROOT) EVAL (LIST ROOT '(SUPERLATIVE))...
    ":est-block"),
  r("consonant vowel l|s|z & e s t # -> 19,1111,1112",
  // est-block-46, 
    // act19 = (KILL 3)
    // act1111 = (CAT ADJ (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT 'ADJ)) EVA...
    // act1112 = (CAT ADV (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT 'ADV)) EVA...
    ":est-block"),
  r("consonant e r e s t # -> 19,1113,1114",
  // est-block-47, 
    // act19 = (KILL 3)
    // act1113 = (CAT ADJ (POLYSYLLABIC ROOT) EVAL (LIST ROOT '(SUPERLATIVE))...
    // act1114 = (CAT ADV (POLYSYLLABIC ROOT) EVAL (LIST ROOT '(SUPERLATIVE))...
    ":est-block"),
  r("consonant vowel b|d|f|g|l|m|n|p|r|s|t|k|v|z e s t # -> 50,1111,1112",
  // est-block-48, 
    // act50 = (KILL 2)
    // act1111 = (CAT ADJ (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT 'ADJ)) EVA...
    // act1112 = (CAT ADV (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT 'ADV)) EVA...
    ":est-block"),
  r("e s t # -> 50,148,1111,1112",
  // est-block-49, 
    // act50 = (KILL 2)
    // act148 = (TEST (NEED-FINAL-E ROOT))
    // act1111 = (CAT ADJ (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT 'ADJ)) EVA...
    // act1112 = (CAT ADV (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT 'ADV)) EVA...
    ":est-block"),
  r("consonant vowel & b|d|f|g|l|m|n|p|r|s|t|k|v|z e s t # -> 19,1111,1112",
  // est-block-50, 
    // act19 = (KILL 3)
    // act1111 = (CAT ADJ (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT 'ADJ)) EVA...
    // act1112 = (CAT ADV (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT 'ADV)) EVA...
    ":est-block"),
  r("i n g e s t # -> 19,1093,1098,1115,50,1098",
  // est-block-51, conditional phase-one
    // act19 = (KILL 3)
    // act1093 = (SETQ SUFFIX 'EST)
    // act1098 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADJ))...
    // act1115 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADV))...
    // act50 = (KILL 2)
    // act1098 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADJ))...
    ":est-block", false, true, true),
  r("c|g e s t # -> 50,1111,1112",
  // est-block-52, 
    // act50 = (KILL 2)
    // act1111 = (CAT ADJ (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT 'ADJ)) EVA...
    // act1112 = (CAT ADV (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT 'ADV)) EVA...
    ":est-block"),
  r("c|s h e s t # -> 19,1111,1112",
  // est-block-53, 
    // act19 = (KILL 3)
    // act1111 = (CAT ADJ (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT 'ADJ)) EVA...
    // act1112 = (CAT ADV (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT 'ADV)) EVA...
    ":est-block"),
  r("s|z & e s t # -> 19,1111,1112",
  // est-block-54, 
    // act19 = (KILL 3)
    // act1111 = (CAT ADJ (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT 'ADJ)) EVA...
    // act1112 = (CAT ADV (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT 'ADV)) EVA...
    ":est-block"),
  r("s|z e s t # -> 50,1111,1112",
  // est-block-55, 
    // act50 = (KILL 2)
    // act1111 = (CAT ADJ (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT 'ADJ)) EVA...
    // act1112 = (CAT ADV (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT 'ADV)) EVA...
    ":est-block"),
  r("vowel f|l|s|z & e s t # -> 19,1111,1112",
  // est-block-56, 
    // act19 = (KILL 3)
    // act1111 = (CAT ADJ (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT 'ADJ)) EVA...
    // act1112 = (CAT ADV (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT 'ADV)) EVA...
    ":est-block"),
  r("vowel consonant & e s t # -> 61,1111",
  // est-block-57, 
    // act61 = (KILL 4)
    // act1111 = (CAT ADJ (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT 'ADJ)) EVA...
    ":est-block"),
  r("e s t # -> 19,1111,1112",
  // est-block-58, 
    // act19 = (KILL 3)
    // act1111 = (CAT ADJ (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT 'ADJ)) EVA...
    // act1112 = (CAT ADV (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT 'ADV)) EVA...
    ":est-block"),
 };

 protected static MorphRule[] iformBlock = {//":iform-block"
  r("i f o r m # -> 57,194,1116,1117",
  // iform-block-1, conditional phase-one
    // act57 = (KILL 5)
    // act194 = (ADD U S)
    // act1116 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-KNOW...
    // act1117 = (CAT ADJ T EVAL (PROGN (MARK-DICT LEX 'HAS-SUFFIX 'IFORM T T...
    ":iform-block", false, true, false),
  r("i f o r m # -> 57,116,1116,1117",
  // iform-block-2, conditional phase-one
    // act57 = (KILL 5)
    // act116 = (ADD U M)
    // act1116 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-KNOW...
    // act1117 = (CAT ADJ T EVAL (PROGN (MARK-DICT LEX 'HAS-SUFFIX 'IFORM T T...
    ":iform-block", false, true, false),
  r("i c i f o r m # -> 113,1118,1116,1117",
  // iform-block-3, conditional phase-one
    // act113 = (KILL 7)
    // act1118 = (ADD E X)
    // act1116 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-KNOW...
    // act1117 = (CAT ADJ T EVAL (PROGN (MARK-DICT LEX 'HAS-SUFFIX 'IFORM T T...
    ":iform-block", false, true, false),
  r("c i f o r m # -> 102,20,1116,1117",
  // iform-block-4, conditional phase-one
    // act102 = (KILL 6)
    // act20 = (ADD X)
    // act1116 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-KNOW...
    // act1117 = (CAT ADJ T EVAL (PROGN (MARK-DICT LEX 'HAS-SUFFIX 'IFORM T T...
    ":iform-block", false, true, false),
  r("i f o r m # -> 57,68,1119,1117",
  // iform-block-5, conditional phase-one
    // act57 = (KILL 5)
    // act68 = (ADD E)
    // act1119 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (NEED-FINAL-E ROOT) (MORPH-...
    // act1117 = (CAT ADJ T EVAL (PROGN (MARK-DICT LEX 'HAS-SUFFIX 'IFORM T T...
    ":iform-block", false, true, false),
  r("i f o r m # -> 57,117,1116,1117",
  // iform-block-6, conditional phase-one
    // act57 = (KILL 5)
    // act117 = (ADD A)
    // act1116 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-KNOW...
    // act1117 = (CAT ADJ T EVAL (PROGN (MARK-DICT LEX 'HAS-SUFFIX 'IFORM T T...
    ":iform-block", false, true, false),
  r("i f o r m # -> 57,1120,1116,1117",
  // iform-block-7, conditional phase-one
    // act57 = (KILL 5)
    // act1120 = (ADD I U M)
    // act1116 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-KNOW...
    // act1117 = (CAT ADJ T EVAL (PROGN (MARK-DICT LEX 'HAS-SUFFIX 'IFORM T T...
    ":iform-block", false, true, false),
  r("i f o r m # -> 57,54,1116,1117",
  // iform-block-8, conditional phase-one
    // act57 = (KILL 5)
    // act54 = (ADD I S)
    // act1116 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-KNOW...
    // act1117 = (CAT ADJ T EVAL (PROGN (MARK-DICT LEX 'HAS-SUFFIX 'IFORM T T...
    ":iform-block", false, true, false),
  r("i f o r m # -> 57,1121,1116,1117",
  // iform-block-9, conditional phase-one
    // act57 = (KILL 5)
    // act1121 = (ADD O S)
    // act1116 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-KNOW...
    // act1117 = (CAT ADJ T EVAL (PROGN (MARK-DICT LEX 'HAS-SUFFIX 'IFORM T T...
    ":iform-block", false, true, false),
  r("i f o r m # -> 57,1116,1117",
  // iform-block-10, conditional phase-one
    // act57 = (KILL 5)
    // act1116 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-KNOW...
    // act1117 = (CAT ADJ T EVAL (PROGN (MARK-DICT LEX 'HAS-SUFFIX 'IFORM T T...
    ":iform-block", false, true, false),
  r("i f o r m # -> 57,68,1116,1117",
  // iform-block-11, conditional phase-one
    // act57 = (KILL 5)
    // act68 = (ADD E)
    // act1116 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-KNOW...
    // act1117 = (CAT ADJ T EVAL (PROGN (MARK-DICT LEX 'HAS-SUFFIX 'IFORM T T...
    ":iform-block", false, true, false),
  r("i f o r m # -> 57,37,209,1122",
  // iform-block-12, conditional phase-one
    // act57 = (KILL 5)
    // act37 = (ADD O)
    // act209 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-KNOW...
    // act1122 = (CAT ADJ T EVAL (PROGN (MARK-DICT LEX 'HAS-SUFFIX 'IFORM T T...
    ":iform-block", false, true, false),
  r("i f o r m # -> 57,120,1123,1117",
  // iform-block-13, conditional phase-one
    // act57 = (KILL 5)
    // act120 = (ADD A L)
    // act1123 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-KNOW...
    // act1117 = (CAT ADJ T EVAL (PROGN (MARK-DICT LEX 'HAS-SUFFIX 'IFORM T T...
    ":iform-block", false, true, false),
  r("i f o r m # -> 57,1124,1116,1117",
  // iform-block-14, conditional phase-one
    // act57 = (KILL 5)
    // act1124 = (ADD A R Y)
    // act1116 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-KNOW...
    // act1117 = (CAT ADJ T EVAL (PROGN (MARK-DICT LEX 'HAS-SUFFIX 'IFORM T T...
    ":iform-block", false, true, false),
  r("i f o r m # -> 57,118,467,1117",
  // iform-block-15, conditional phase-one
    // act57 = (KILL 5)
    // act118 = (ADD I C)
    // act467 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-ROOT...
    // act1117 = (CAT ADJ T EVAL (PROGN (MARK-DICT LEX 'HAS-SUFFIX 'IFORM T T...
    ":iform-block", false, true, false),
  r("i f o r m # -> 57,290,1125,1122",
  // iform-block-16, conditional phase-one
    // act57 = (KILL 5)
    // act290 = (ADD I)
    // act1125 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-KNOW...
    // act1122 = (CAT ADJ T EVAL (PROGN (MARK-DICT LEX 'HAS-SUFFIX 'IFORM T T...
    ":iform-block", false, true, false),
  r("i f o r m # -> 57,68,1126,1117",
  // iform-block-17, conditional phase-one
    // act57 = (KILL 5)
    // act68 = (ADD E)
    // act1126 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-KNOW...
    // act1117 = (CAT ADJ T EVAL (PROGN (MARK-DICT LEX 'HAS-SUFFIX 'IFORM T T...
    ":iform-block", false, true, false),
  r("i f o r m # -> 1127",
  // iform-block-18, 
    // act1127 = (CAT ADJ (PLAUSIBLE-ROOT ROOT) EVAL (PROGN (MARK-DICT LEX 'H...
    ":iform-block"),
 };

 protected static MorphRule[] itisBlock = {//":itis-block"
  r("i t i s # -> 61,68,1128,1129",
  // itis-block-1, conditional phase-one
    // act61 = (KILL 4)
    // act68 = (ADD E)
    // act1128 = (TEST (AND (NEED-FINAL-E ROOT) (MORPH-ROOT STATE) (IS-KINDOF...
    // act1129 = (CAT NM (AND (SYLLABIC ROOT) (MORPH-ROOT STATE) (IS-FORM-OF-...
    ":itis-block", false, true, false),
  r("i t i s # -> 61,1130,1129",
  // itis-block-2, conditional phase-one
    // act61 = (KILL 4)
    // act1130 = (TEST (AND (MORPH-ROOT STATE) (IS-KINDOF ROOT 'BODYPART)))
    // act1129 = (CAT NM (AND (SYLLABIC ROOT) (MORPH-ROOT STATE) (IS-FORM-OF-...
    ":itis-block", false, true, false),
  r("consonant vowel b|d|g|k|l|m|n|p|r|t & i t i s # -> 57,1130,1129",
  // itis-block-3, conditional phase-one
    // act57 = (KILL 5)
    // act1130 = (TEST (AND (MORPH-ROOT STATE) (IS-KINDOF ROOT 'BODYPART)))
    // act1129 = (CAT NM (AND (SYLLABIC ROOT) (MORPH-ROOT STATE) (IS-FORM-OF-...
    ":itis-block", false, true, false),
  r("i t i s # -> 61,117,1130,1129",
  // itis-block-4, conditional phase-one
    // act61 = (KILL 4)
    // act117 = (ADD A)
    // act1130 = (TEST (AND (MORPH-ROOT STATE) (IS-KINDOF ROOT 'BODYPART)))
    // act1129 = (CAT NM (AND (SYLLABIC ROOT) (MORPH-ROOT STATE) (IS-FORM-OF-...
    ":itis-block", false, true, false),
  r("i t i s # -> 61,291,1130,1129",
  // itis-block-5, conditional phase-one
    // act61 = (KILL 4)
    // act291 = (ADD I A)
    // act1130 = (TEST (AND (MORPH-ROOT STATE) (IS-KINDOF ROOT 'BODYPART)))
    // act1129 = (CAT NM (AND (SYLLABIC ROOT) (MORPH-ROOT STATE) (IS-FORM-OF-...
    ":itis-block", false, true, false),
  r("i t i s # -> 61,132,1130,1129",
  // itis-block-6, conditional phase-one
    // act61 = (KILL 4)
    // act132 = (ADD O N)
    // act1130 = (TEST (AND (MORPH-ROOT STATE) (IS-KINDOF ROOT 'BODYPART)))
    // act1129 = (CAT NM (AND (SYLLABIC ROOT) (MORPH-ROOT STATE) (IS-FORM-OF-...
    ":itis-block", false, true, false),
  r("i t i s # -> 61,194,1130,1129",
  // itis-block-7, conditional phase-one
    // act61 = (KILL 4)
    // act194 = (ADD U S)
    // act1130 = (TEST (AND (MORPH-ROOT STATE) (IS-KINDOF ROOT 'BODYPART)))
    // act1129 = (CAT NM (AND (SYLLABIC ROOT) (MORPH-ROOT STATE) (IS-FORM-OF-...
    ":itis-block", false, true, false),
  r("i t i s # -> 61,116,1130,1129",
  // itis-block-8, conditional phase-one
    // act61 = (KILL 4)
    // act116 = (ADD U M)
    // act1130 = (TEST (AND (MORPH-ROOT STATE) (IS-KINDOF ROOT 'BODYPART)))
    // act1129 = (CAT NM (AND (SYLLABIC ROOT) (MORPH-ROOT STATE) (IS-FORM-OF-...
    ":itis-block", false, true, false),
  r("i t i s # -> 61,1131,1130,1129",
  // itis-block-9, conditional phase-one
    // act61 = (KILL 4)
    // act1131 = (ADD O I D)
    // act1130 = (TEST (AND (MORPH-ROOT STATE) (IS-KINDOF ROOT 'BODYPART)))
    // act1129 = (CAT NM (AND (SYLLABIC ROOT) (MORPH-ROOT STATE) (IS-FORM-OF-...
    ":itis-block", false, true, false),
  r("i t i s # -> 61,31,1130,1129",
  // itis-block-10, conditional phase-one
    // act61 = (KILL 4)
    // act31 = (ADD Y)
    // act1130 = (TEST (AND (MORPH-ROOT STATE) (IS-KINDOF ROOT 'BODYPART)))
    // act1129 = (CAT NM (AND (SYLLABIC ROOT) (MORPH-ROOT STATE) (IS-FORM-OF-...
    ":itis-block", false, true, false),
  r("i t i s # -> 61,1132,1130,1129",
  // itis-block-11, conditional phase-one
    // act61 = (KILL 4)
    // act1132 = (ADD E S)
    // act1130 = (TEST (AND (MORPH-ROOT STATE) (IS-KINDOF ROOT 'BODYPART)))
    // act1129 = (CAT NM (AND (SYLLABIC ROOT) (MORPH-ROOT STATE) (IS-FORM-OF-...
    ":itis-block", false, true, false),
  r("i t i s # -> 61,54,1130,1129",
  // itis-block-12, conditional phase-one
    // act61 = (KILL 4)
    // act54 = (ADD I S)
    // act1130 = (TEST (AND (MORPH-ROOT STATE) (IS-KINDOF ROOT 'BODYPART)))
    // act1129 = (CAT NM (AND (SYLLABIC ROOT) (MORPH-ROOT STATE) (IS-FORM-OF-...
    ":itis-block", false, true, false),
  r("i t i s # -> 61,1133,1130,1129",
  // itis-block-13, conditional phase-one
    // act61 = (KILL 4)
    // act1133 = (ADD E U M)
    // act1130 = (TEST (AND (MORPH-ROOT STATE) (IS-KINDOF ROOT 'BODYPART)))
    // act1129 = (CAT NM (AND (SYLLABIC ROOT) (MORPH-ROOT STATE) (IS-FORM-OF-...
    ":itis-block", false, true, false),
  r("i t i s # -> 61,1134,1130,1129",
  // itis-block-14, conditional phase-one
    // act61 = (KILL 4)
    // act1134 = (ADD E A)
    // act1130 = (TEST (AND (MORPH-ROOT STATE) (IS-KINDOF ROOT 'BODYPART)))
    // act1129 = (CAT NM (AND (SYLLABIC ROOT) (MORPH-ROOT STATE) (IS-FORM-OF-...
    ":itis-block", false, true, false),
  r("i t i s # -> 61,1124,1130,1135",
  // itis-block-15, conditional phase-one
    // act61 = (KILL 4)
    // act1124 = (ADD A R Y)
    // act1130 = (TEST (AND (MORPH-ROOT STATE) (IS-KINDOF ROOT 'BODYPART)))
    // act1135 = (CAT NM (AND (SYLLABIC ROOT) (MORPH-ROOT STATE) (IS-FORM-OF-...
    ":itis-block", false, true, false),
  r("i t i s # -> 61,120,1130,1135",
  // itis-block-16, conditional phase-one
    // act61 = (KILL 4)
    // act120 = (ADD A L)
    // act1130 = (TEST (AND (MORPH-ROOT STATE) (IS-KINDOF ROOT 'BODYPART)))
    // act1135 = (CAT NM (AND (SYLLABIC ROOT) (MORPH-ROOT STATE) (IS-FORM-OF-...
    ":itis-block", false, true, false),
  r("i t i s # -> 61,37,1130,1136",
  // itis-block-17, conditional phase-one
    // act61 = (KILL 4)
    // act37 = (ADD O)
    // act1130 = (TEST (AND (MORPH-ROOT STATE) (IS-KINDOF ROOT 'BODYPART)))
    // act1136 = (CAT NM (AND (SYLLABIC ROOT) (MORPH-ROOT STATE) (IS-FORM-OF-...
    ":itis-block", false, true, false),
  r("i t i s # -> 61,68,148,1129",
  // itis-block-18, conditional phase-one
    // act61 = (KILL 4)
    // act68 = (ADD E)
    // act148 = (TEST (NEED-FINAL-E ROOT))
    // act1129 = (CAT NM (AND (SYLLABIC ROOT) (MORPH-ROOT STATE) (IS-FORM-OF-...
    ":itis-block", false, true, false),
  r("i t i s # -> 61,1129",
  // itis-block-19, conditional phase-one
    // act61 = (KILL 4)
    // act1129 = (CAT NM (AND (SYLLABIC ROOT) (MORPH-ROOT STATE) (IS-FORM-OF-...
    ":itis-block", false, true, false),
  r("consonant vowel b|d|g|k|l|m|n|p|r|t & i t i s # -> 57,1129",
  // itis-block-20, conditional phase-one
    // act57 = (KILL 5)
    // act1129 = (CAT NM (AND (SYLLABIC ROOT) (MORPH-ROOT STATE) (IS-FORM-OF-...
    ":itis-block", false, true, false),
  r("i t i s # -> 61,117,1129",
  // itis-block-21, conditional phase-one
    // act61 = (KILL 4)
    // act117 = (ADD A)
    // act1129 = (CAT NM (AND (SYLLABIC ROOT) (MORPH-ROOT STATE) (IS-FORM-OF-...
    ":itis-block", false, true, false),
  r("i t i s # -> 61,291,1129",
  // itis-block-22, conditional phase-one
    // act61 = (KILL 4)
    // act291 = (ADD I A)
    // act1129 = (CAT NM (AND (SYLLABIC ROOT) (MORPH-ROOT STATE) (IS-FORM-OF-...
    ":itis-block", false, true, false),
  r("i t i s # -> 61,132,1129",
  // itis-block-23, conditional phase-one
    // act61 = (KILL 4)
    // act132 = (ADD O N)
    // act1129 = (CAT NM (AND (SYLLABIC ROOT) (MORPH-ROOT STATE) (IS-FORM-OF-...
    ":itis-block", false, true, false),
  r("i t i s # -> 61,194,1129",
  // itis-block-24, conditional phase-one
    // act61 = (KILL 4)
    // act194 = (ADD U S)
    // act1129 = (CAT NM (AND (SYLLABIC ROOT) (MORPH-ROOT STATE) (IS-FORM-OF-...
    ":itis-block", false, true, false),
  r("i t i s # -> 61,116,1129",
  // itis-block-25, conditional phase-one
    // act61 = (KILL 4)
    // act116 = (ADD U M)
    // act1129 = (CAT NM (AND (SYLLABIC ROOT) (MORPH-ROOT STATE) (IS-FORM-OF-...
    ":itis-block", false, true, false),
  r("i t i s # -> 61,1131,1129",
  // itis-block-26, conditional phase-one
    // act61 = (KILL 4)
    // act1131 = (ADD O I D)
    // act1129 = (CAT NM (AND (SYLLABIC ROOT) (MORPH-ROOT STATE) (IS-FORM-OF-...
    ":itis-block", false, true, false),
  r("i t i s # -> 61,31,1129",
  // itis-block-27, conditional phase-one
    // act61 = (KILL 4)
    // act31 = (ADD Y)
    // act1129 = (CAT NM (AND (SYLLABIC ROOT) (MORPH-ROOT STATE) (IS-FORM-OF-...
    ":itis-block", false, true, false),
  r("i t i s # -> 61,1132,1129",
  // itis-block-28, conditional phase-one
    // act61 = (KILL 4)
    // act1132 = (ADD E S)
    // act1129 = (CAT NM (AND (SYLLABIC ROOT) (MORPH-ROOT STATE) (IS-FORM-OF-...
    ":itis-block", false, true, false),
  r("i t i s # -> 61,54,1129",
  // itis-block-29, conditional phase-one
    // act61 = (KILL 4)
    // act54 = (ADD I S)
    // act1129 = (CAT NM (AND (SYLLABIC ROOT) (MORPH-ROOT STATE) (IS-FORM-OF-...
    ":itis-block", false, true, false),
  r("i t i s # -> 61,1133,1129",
  // itis-block-30, conditional phase-one
    // act61 = (KILL 4)
    // act1133 = (ADD E U M)
    // act1129 = (CAT NM (AND (SYLLABIC ROOT) (MORPH-ROOT STATE) (IS-FORM-OF-...
    ":itis-block", false, true, false),
  r("i t i s # -> 61,1134,1129",
  // itis-block-31, conditional phase-one
    // act61 = (KILL 4)
    // act1134 = (ADD E A)
    // act1129 = (CAT NM (AND (SYLLABIC ROOT) (MORPH-ROOT STATE) (IS-FORM-OF-...
    ":itis-block", false, true, false),
  r("i t i s # -> 61,1124,1135",
  // itis-block-32, conditional phase-one
    // act61 = (KILL 4)
    // act1124 = (ADD A R Y)
    // act1135 = (CAT NM (AND (SYLLABIC ROOT) (MORPH-ROOT STATE) (IS-FORM-OF-...
    ":itis-block", false, true, false),
  r("i t i s # -> 61,120,1135",
  // itis-block-33, conditional phase-one
    // act61 = (KILL 4)
    // act120 = (ADD A L)
    // act1135 = (CAT NM (AND (SYLLABIC ROOT) (MORPH-ROOT STATE) (IS-FORM-OF-...
    ":itis-block", false, true, false),
  r("i t i s # -> 61,37,1136",
  // itis-block-34, conditional phase-one
    // act61 = (KILL 4)
    // act37 = (ADD O)
    // act1136 = (CAT NM (AND (SYLLABIC ROOT) (MORPH-ROOT STATE) (IS-FORM-OF-...
    ":itis-block", false, true, false),
 };

 protected static MorphRule[] defaultRule = {//":default-rule"
  r(" -> 1137,1138,1139",
  // default-rule-1, 
    // act1137 = (TEST *WORD-LIST-CHECK-FLAG*)
    // act1138 = (CAT N (AND (MORPH-ROOT STATE) (WORD-LIST-CHECK LEX 'N)) EVA...
    // act1139 = (CAT V (AND (MORPH-ROOT STATE) (WORD-LIST-CHECK LEX 'V)) EVA...
    ":default-rule"),
  r("e # -> 35,259,1140",
  // default-rule-2, 
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act259 = (CAT N T EVAL (PROGN (MARK-DICT LEX 'GUESSED 'T) '-S))
    // act1140 = (CAT V *GUESS-VERB-FLAG* EVAL (PROGN (MARK-DICT LEX 'PENALTI...
    ":default-rule"),
  r("c|s h # -> 35,167,1141",
  // default-rule-3, 
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act167 = (CAT N T EVAL (PROGN (MARK-DICT LEX 'GUESSED 'T) '-ES))
    // act1141 = (CAT V *GUESS-VERB-FLAG* EVAL (PROGN (MARK-DICT LEX 'PENALTI...
    ":default-rule"),
  r("j|s|x|z # -> 35,167,1141",
  // default-rule-4, 
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act167 = (CAT N T EVAL (PROGN (MARK-DICT LEX 'GUESSED 'T) '-ES))
    // act1141 = (CAT V *GUESS-VERB-FLAG* EVAL (PROGN (MARK-DICT LEX 'PENALTI...
    ":default-rule"),
  r("consonant e r # -> 35,259,1142",
  // default-rule-5, 
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act259 = (CAT N T EVAL (PROGN (MARK-DICT LEX 'GUESSED 'T) '-S))
    // act1142 = (CAT V *GUESS-VERB-FLAG* EVAL (PROGN (MARK-DICT LEX 'PENALTI...
    ":default-rule"),
  r("consonant vowel b|d|g|l|m|n|p|r|t # -> 35,259,1143",
  // default-rule-6, 
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act259 = (CAT N T EVAL (PROGN (MARK-DICT LEX 'GUESSED 'T) '-S))
    // act1143 = (CAT V *GUESS-VERB-FLAG* EVAL (PROGN (MARK-DICT LEX 'PENALTI...
    ":default-rule"),
  r("- # -> 1144,301",
  // default-rule-7, 
    // act1144 = (CAT ADJ T EVAL 'MORE-MOST)
    // act301 = (CAT ADV T EVAL '*)
    ":default-rule"),
  r("any & # -> 35,259,1142",
  // default-rule-8, 
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act259 = (CAT N T EVAL (PROGN (MARK-DICT LEX 'GUESSED 'T) '-S))
    // act1142 = (CAT V *GUESS-VERB-FLAG* EVAL (PROGN (MARK-DICT LEX 'PENALTI...
    ":default-rule"),
  r("i c # -> 35,259,1145",
  // default-rule-9, 
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act259 = (CAT N T EVAL (PROGN (MARK-DICT LEX 'GUESSED 'T) '-S))
    // act1145 = (CAT V *GUESS-VERB-FLAG* EVAL (PROGN (MARK-DICT LEX 'PENALTI...
    ":default-rule"),
  r(" -> 419,259,1142",
  // default-rule-10, 
    // act419 = (TEST (SYLLABIC ROOT))
    // act259 = (CAT N T EVAL (PROGN (MARK-DICT LEX 'GUESSED 'T) '-S))
    // act1142 = (CAT V *GUESS-VERB-FLAG* EVAL (PROGN (MARK-DICT LEX 'PENALTI...
    ":default-rule"),
  r(" -> 1146",
  // default-rule-11, 
    // act1146 = (CAT NPR T EVAL (PROGN (MARK-DICT LEX 'GUESSED 'T) '*))
    ":default-rule"),
 };

 protected static MorphRule[] prefixDispatch = {//":prefix-dispatch"
  r(" -> 1147,1148",
  // prefix-dispatch-1, 
    // act1147 = (KILL-LEFT 1)
    // act1148 = (CAT NAME (AND *RECOGNIZE-INITIAL+LASTNAME-FLAG* (MORPH-ROOT...
    ":prefix-dispatch"),
  r("# a -> 1149",
  // prefix-dispatch-2, 
    // act1149 = (TRY A-PREFIXES)
    ":prefix-dispatch"),
  r("# b -> 1150",
  // prefix-dispatch-3, 
    // act1150 = (TRY B-PREFIXES)
    ":prefix-dispatch"),
  r("# c -> 1151",
  // prefix-dispatch-4, 
    // act1151 = (TRY C-PREFIXES)
    ":prefix-dispatch"),
  r("# d -> 1152",
  // prefix-dispatch-5, 
    // act1152 = (TRY D-PREFIXES)
    ":prefix-dispatch"),
  r("# e -> 1153",
  // prefix-dispatch-6, 
    // act1153 = (TRY E-PREFIXES)
    ":prefix-dispatch"),
  r("# h -> 1154",
  // prefix-dispatch-7, 
    // act1154 = (TRY H-PREFIXES)
    ":prefix-dispatch"),
  r("# i -> 1155",
  // prefix-dispatch-8, 
    // act1155 = (TRY I-PREFIXES)
    ":prefix-dispatch"),
  r("# m -> 1156",
  // prefix-dispatch-9, 
    // act1156 = (TRY M-PREFIXES)
    ":prefix-dispatch"),
  r("# n -> 1157",
  // prefix-dispatch-10, 
    // act1157 = (TRY N-PREFIXES)
    ":prefix-dispatch"),
  r("# o -> 1158",
  // prefix-dispatch-11, 
    // act1158 = (TRY O-PREFIXES)
    ":prefix-dispatch"),
  r("# p -> 1159",
  // prefix-dispatch-12, 
    // act1159 = (TRY P-PREFIXES)
    ":prefix-dispatch"),
  r("# r -> 1160",
  // prefix-dispatch-13, 
    // act1160 = (TRY R-PREFIXES)
    ":prefix-dispatch"),
  r("# s -> 1161",
  // prefix-dispatch-14, 
    // act1161 = (TRY S-PREFIXES)
    ":prefix-dispatch"),
  r("# t -> 1162",
  // prefix-dispatch-15, 
    // act1162 = (TRY T-PREFIXES)
    ":prefix-dispatch"),
  r("# u -> 1163",
  // prefix-dispatch-16, 
    // act1163 = (TRY U-PREFIXES)
    ":prefix-dispatch"),
  r("# f|g|l|q|v -> 1164",
  // prefix-dispatch-17, 
    // act1164 = (TRY MISC-PREFIXES)
    ":prefix-dispatch"),
  r(" -> 1165",
  // prefix-dispatch-18, 
    // act1165 = (TRY LEXICAL-PREFIX-RULES)
    ":prefix-dispatch"),
 };

 protected static MorphRule[] aPrefixes = {//":a-prefixes"
  r("# a l l -> 1166,1167,1168,1169",
  // a-prefixes-1, 
    // act1166 = (KILL-LEFT 3)
    // act1167 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (IS...
    // act1168 = (SETQ PREFIX 'ALL)
    // act1169 = (CAT ADJ (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT ...
    ":a-prefixes"),
  r("# a l l o -> 1170,1167,1171,1172,1173",
  // a-prefixes-2, 
    // act1170 = (KILL-LEFT 4)
    // act1167 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (IS...
    // act1171 = (SETQ PREFIX 'ALLO)
    // act1172 = (CAT ADJ (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-R...
    // act1173 = (CAT N (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-NON...
    ":a-prefixes"),
  r("# a e r o -> 1170,1167,1174,1175,1176,1177,1178,1179,1180",
  // a-prefixes-3, 
    // act1170 = (KILL-LEFT 4)
    // act1167 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (IS...
    // act1174 = (SETQ PREFIX 'AERO)
    // act1175 = (CAT NM (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-FO...
    // act1176 = (CAT ADJ (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-F...
    // act1177 = (CAT V (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-FOR...
    // act1178 = (CAT N (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (I...
    // act1179 = (CAT ADJ (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT ...
    // act1180 = (CAT ADV (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-R...
    ":a-prefixes"),
  r("# a n t e -> 1170,1026,1181,1182,1173",
  // a-prefixes-4, 
    // act1170 = (KILL-LEFT 4)
    // act1026 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (IS...
    // act1181 = (SETQ PREFIX 'ANTE)
    // act1182 = (CAT ADJ (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-R...
    // act1173 = (CAT N (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-NON...
    ":a-prefixes"),
  r("# a n t i -> 1170,1026,1183,1184,1173",
  // a-prefixes-5, 
    // act1170 = (KILL-LEFT 4)
    // act1026 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (IS...
    // act1183 = (SETQ PREFIX 'ANTI)
    // act1184 = (CAT ADJ (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-F...
    // act1173 = (CAT N (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-NON...
    ":a-prefixes"),
  r("# a n a -> 1166,1167,1185,1172,1173",
  // a-prefixes-6, 
    // act1166 = (KILL-LEFT 3)
    // act1167 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (IS...
    // act1185 = (SETQ PREFIX 'ANA)
    // act1172 = (CAT ADJ (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-R...
    // act1173 = (CAT N (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-NON...
    ":a-prefixes"),
  r("# a u t o -> 1170,1186,1187,1175,1176,1177,1178,1179,1180",
  // a-prefixes-7, 
    // act1170 = (KILL-LEFT 4)
    // act1186 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (IS...
    // act1187 = (SETQ PREFIX 'AUTO)
    // act1175 = (CAT NM (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-FO...
    // act1176 = (CAT ADJ (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-F...
    // act1177 = (CAT V (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-FOR...
    // act1178 = (CAT N (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (I...
    // act1179 = (CAT ADJ (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT ...
    // act1180 = (CAT ADV (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-R...
    ":a-prefixes"),
  r("# a d e n o -> 1188,1186,1189,1190,1191,1192,1193,1194,1195,1196",
  // a-prefixes-8, 
    // act1188 = (KILL-LEFT 5)
    // act1186 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (IS...
    // act1189 = (SETQ PREFIX 'ADENO)
    // act1190 = (TEST (AND PREFIX (PLAUSIBLE-ROOT ROOT)))
    // act1191 = (CAT NM (AND (MORPH-ROOT STATE) (IS-FORM-OF-CAT ROOT 'PRESPA...
    // act1192 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-FORM-OF-CAT ROOT '(PRES...
    // act1193 = (CAT V (AND (MORPH-ROOT STATE) (IS-FORM-OF-CAT ROOT 'V)) EVA...
    // act1194 = (CAT N (AND (MORPH-ROOT STATE) (NOT (IS-FORM-OF-CAT ROOT 'PR...
    // act1195 = (CAT ADJ (AND (MORPH-ROOT STATE) (NOT (IS-FORM-OF-CAT ROOT '...
    // act1196 = (CAT ADV (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADV))...
    ":a-prefixes"),
  r("# a d e n o -> 1170,1186,1189,1190,1191,1192,1193,1194,1195,1196",
  // a-prefixes-9, 
    // act1170 = (KILL-LEFT 4)
    // act1186 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (IS...
    // act1189 = (SETQ PREFIX 'ADENO)
    // act1190 = (TEST (AND PREFIX (PLAUSIBLE-ROOT ROOT)))
    // act1191 = (CAT NM (AND (MORPH-ROOT STATE) (IS-FORM-OF-CAT ROOT 'PRESPA...
    // act1192 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-FORM-OF-CAT ROOT '(PRES...
    // act1193 = (CAT V (AND (MORPH-ROOT STATE) (IS-FORM-OF-CAT ROOT 'V)) EVA...
    // act1194 = (CAT N (AND (MORPH-ROOT STATE) (NOT (IS-FORM-OF-CAT ROOT 'PR...
    // act1195 = (CAT ADJ (AND (MORPH-ROOT STATE) (NOT (IS-FORM-OF-CAT ROOT '...
    // act1196 = (CAT ADV (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADV))...
    ":a-prefixes"),
  r("# a consonant -> 1147,1197,1198,1199,1200,1201",
  // a-prefixes-10, 
    // act1147 = (KILL-LEFT 1)
    // act1197 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (IS...
    // act1198 = (SETQ PREFIX 'A)
    // act1199 = (CAT ADJ T EVAL (LIST LEX (MAKE-LEX-PROP 'FROM (MAKE-SENSE-N...
    // act1200 = (CAT ADV T EVAL (LIST LEX (MAKE-LEX-PROP 'FROM (MAKE-SENSE-N...
    // act1201 = (CAT V T EVAL (FORMS-WITH-PREFIX ROOT 'VI PREFIX))
    ":a-prefixes"),
  r("# a consonant -> 1147,1202,1198,1203,1204,1205",
  // a-prefixes-11, 
    // act1147 = (KILL-LEFT 1)
    // act1202 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (IS...
    // act1198 = (SETQ PREFIX 'A)
    // act1203 = (CAT ADJ T EVAL (LIST LEX (MAKE-LEX-PROP 'FROM (MAKE-SENSE-N...
    // act1204 = (CAT ADV T EVAL (LIST LEX (MAKE-LEX-PROP 'FROM (MAKE-SENSE-N...
    // act1205 = (CAT V T EVAL (FORMS-WITH-PREFIX ROOT 'V PREFIX))
    ":a-prefixes"),
  r("# a consonant -> 1147,1206,1198,1207,1208",
  // a-prefixes-12, 
    // act1147 = (KILL-LEFT 1)
    // act1206 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (IS...
    // act1198 = (SETQ PREFIX 'A)
    // act1207 = (CAT ADJ T EVAL (LIST LEX (MAKE-LEX-PROP 'FROM (MAKE-SENSE-N...
    // act1208 = (CAT ADV T EVAL (LIST LEX (MAKE-LEX-PROP 'FROM (MAKE-SENSE-N...
    ":a-prefixes"),
  r("# a consonant -> 1147,1209,1198,1210",
  // a-prefixes-13, 
    // act1147 = (KILL-LEFT 1)
    // act1209 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (IS...
    // act1198 = (SETQ PREFIX 'A)
    // act1210 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADJ) ...
    ":a-prefixes"),
  r("# a n a|e|i|o|u|h -> 1211,1212,1213,1214,1215,1216,1217",
  // a-prefixes-14, 
    // act1211 = (KILL-LEFT 2)
    // act1212 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (IS...
    // act1213 = (SETQ PREFIX 'AN)
    // act1214 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADJ))...
    // act1215 = (CAT N (AND (MORPH-ROOT STATE) (IS-NONNAME-ROOT-OF-CAT ROOT ...
    // act1216 = (CAT NM (AND (MORPH-ROOT STATE) (IS-NONNAME-ROOT-OF-CAT ROOT...
    // act1217 = (CAT NMC (AND (MORPH-ROOT STATE) (IS-NONNAME-ROOT-OF-CAT ROO...
    ":a-prefixes"),
  r("# a b -> 1211,1167,1218,1219,1220",
  // a-prefixes-15, 
    // act1211 = (KILL-LEFT 2)
    // act1167 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (IS...
    // act1218 = (SETQ PREFIX 'AB)
    // act1219 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADJ))...
    // act1220 = (CAT UNIT (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(UNI...
    ":a-prefixes"),
  r("# a c|f|g|l|p|s|t & -> 1211,1221,1222,1191,1192,1223",
  // a-prefixes-16, 
    // act1211 = (KILL-LEFT 2)
    // act1221 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (IS...
    // act1222 = (SETQ PREFIX 'AD)
    // act1191 = (CAT NM (AND (MORPH-ROOT STATE) (IS-FORM-OF-CAT ROOT 'PRESPA...
    // act1192 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-FORM-OF-CAT ROOT '(PRES...
    // act1223 = (CAT V (AND (MORPH-ROOT STATE) (IS-FORM-OF-CAT ROOT 'V)) EVA...
    ":a-prefixes"),
  r("# a consonant -> 1147,1221,1198,1224",
  // a-prefixes-17, 
    // act1147 = (KILL-LEFT 1)
    // act1221 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (IS...
    // act1198 = (SETQ PREFIX 'A)
    // act1224 = (CAT ADJ (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-R...
    ":a-prefixes"),
  r("# a consonant -> 1147,1221,1198,1225",
  // a-prefixes-18, 
    // act1147 = (KILL-LEFT 1)
    // act1221 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (IS...
    // act1198 = (SETQ PREFIX 'A)
    // act1225 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(VI))...
    ":a-prefixes"),
 };

 protected static MorphRule[] bPrefixes = {//":b-prefixes"
  r("# b e -> 1211,1226,1227,1191,1192,1228",
  // b-prefixes-1, 
    // act1211 = (KILL-LEFT 2)
    // act1226 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (IS...
    // act1227 = (SETQ PREFIX 'BE)
    // act1191 = (CAT NM (AND (MORPH-ROOT STATE) (IS-FORM-OF-CAT ROOT 'PRESPA...
    // act1192 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-FORM-OF-CAT ROOT '(PRES...
    // act1228 = (CAT V T EVAL (PROGN (MARK-DICT LEX 'HAS-PREFIX PREFIX T T) ...
    ":b-prefixes"),
  r("# b e -> 1211,1229,1227,1230",
  // b-prefixes-2, 
    // act1211 = (KILL-LEFT 2)
    // act1229 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (IS...
    // act1227 = (SETQ PREFIX 'BE)
    // act1230 = (CAT V (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(ADJ N)...
    ":b-prefixes"),
  r("# b i o -> 1166,1231,1232,1172,1173",
  // b-prefixes-3, 
    // act1166 = (KILL-LEFT 3)
    // act1231 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (IS...
    // act1232 = (SETQ PREFIX 'BIO)
    // act1172 = (CAT ADJ (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-R...
    // act1173 = (CAT N (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-NON...
    ":b-prefixes"),
  r("# b i -> 1211,1233,1234,1235,1236",
  // b-prefixes-4, 
    // act1211 = (KILL-LEFT 2)
    // act1233 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (IS...
    // act1234 = (SETQ PREFIX 'BI)
    // act1235 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-NONNAME-ROOT-OF-CAT ROO...
    // act1236 = (CAT N (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-NON...
    ":b-prefixes"),
  r("# b a c k -> 1170,1026,1237,1191,1238,1239,1240,1241",
  // b-prefixes-5, 
    // act1170 = (KILL-LEFT 4)
    // act1026 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (IS...
    // act1237 = (SETQ PREFIX 'BACK)
    // act1191 = (CAT NM (AND (MORPH-ROOT STATE) (IS-FORM-OF-CAT ROOT 'PRESPA...
    // act1238 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-FORM-OF-CAT ROOT '(PRES...
    // act1239 = (CAT ADV (AND (MORPH-ROOT STATE) (IS-FORM-OF-CAT ROOT '(PRES...
    // act1240 = (CAT V (AND (MORPH-ROOT STATE) (IS-FORM-OF-CAT ROOT 'V)) EVA...
    // act1241 = (CAT N (AND (MORPH-ROOT STATE) (IS-NONNAME-FORM-OF-CAT ROOT ...
    ":b-prefixes"),
  r("# b a r e -> 1170,1242,1243,1244,301",
  // b-prefixes-6, 
    // act1170 = (KILL-LEFT 4)
    // act1242 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (IS...
    // act1243 = (SETQ PREFIX 'BARE)
    // act1244 = (CAT ADJ T EVAL (PROGN (WHEN (IS-KNOWN-KIND-OF ROOT 'BODYPAR...
    // act301 = (CAT ADV T EVAL '*)
    ":b-prefixes"),
 };

 protected static MorphRule[] cPrefixes = {//":c-prefixes"
  r("# c h e m o -> 1188,1026,1245,1172,1173",
  // c-prefixes-1, 
    // act1188 = (KILL-LEFT 5)
    // act1026 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (IS...
    // act1245 = (SETQ PREFIX 'CHEMO)
    // act1172 = (CAT ADJ (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-R...
    // act1173 = (CAT N (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-NON...
    ":c-prefixes"),
  r("# c o u n t e r -> 1246,1186,1247,1190,1191,1192,1193,1194,1195,1196",
  // c-prefixes-2, 
    // act1246 = (KILL-LEFT 7)
    // act1186 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (IS...
    // act1247 = (SETQ PREFIX 'COUNTER)
    // act1190 = (TEST (AND PREFIX (PLAUSIBLE-ROOT ROOT)))
    // act1191 = (CAT NM (AND (MORPH-ROOT STATE) (IS-FORM-OF-CAT ROOT 'PRESPA...
    // act1192 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-FORM-OF-CAT ROOT '(PRES...
    // act1193 = (CAT V (AND (MORPH-ROOT STATE) (IS-FORM-OF-CAT ROOT 'V)) EVA...
    // act1194 = (CAT N (AND (MORPH-ROOT STATE) (NOT (IS-FORM-OF-CAT ROOT 'PR...
    // act1195 = (CAT ADJ (AND (MORPH-ROOT STATE) (NOT (IS-FORM-OF-CAT ROOT '...
    // act1196 = (CAT ADV (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADV))...
    ":c-prefixes"),
  r("# c o n t r a -> 1248,1186,1249,1190,1191,1192,1193,1194,1195,1196",
  // c-prefixes-3, 
    // act1248 = (KILL-LEFT 6)
    // act1186 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (IS...
    // act1249 = (SETQ PREFIX 'CONTRA)
    // act1190 = (TEST (AND PREFIX (PLAUSIBLE-ROOT ROOT)))
    // act1191 = (CAT NM (AND (MORPH-ROOT STATE) (IS-FORM-OF-CAT ROOT 'PRESPA...
    // act1192 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-FORM-OF-CAT ROOT '(PRES...
    // act1193 = (CAT V (AND (MORPH-ROOT STATE) (IS-FORM-OF-CAT ROOT 'V)) EVA...
    // act1194 = (CAT N (AND (MORPH-ROOT STATE) (NOT (IS-FORM-OF-CAT ROOT 'PR...
    // act1195 = (CAT ADJ (AND (MORPH-ROOT STATE) (NOT (IS-FORM-OF-CAT ROOT '...
    // act1196 = (CAT ADV (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADV))...
    ":c-prefixes"),
  r("# c o c o -> 1170,1250,1251,1173",
  // c-prefixes-4, 
    // act1170 = (KILL-LEFT 4)
    // act1250 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (IS...
    // act1251 = (SETQ PREFIX 'COCO)
    // act1173 = (CAT N (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-NON...
    ":c-prefixes"),
  r("# c o -> 1211,1252,1253,1175,1176,1177,1178,1179,1180",
  // c-prefixes-5, 
    // act1211 = (KILL-LEFT 2)
    // act1252 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (IS...
    // act1253 = (SETQ PREFIX 'CO)
    // act1175 = (CAT NM (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-FO...
    // act1176 = (CAT ADJ (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-F...
    // act1177 = (CAT V (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-FOR...
    // act1178 = (CAT N (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (I...
    // act1179 = (CAT ADJ (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT ...
    // act1180 = (CAT ADV (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-R...
    ":c-prefixes"),
 };

 protected static MorphRule[] dPrefixes = {//":d-prefixes"
  r("# d e m i -> 1170,1026,1254,1175,1176,1177,1178,1179,1180",
  // d-prefixes-1, 
    // act1170 = (KILL-LEFT 4)
    // act1026 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (IS...
    // act1254 = (SETQ PREFIX 'DEMI)
    // act1175 = (CAT NM (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-FO...
    // act1176 = (CAT ADJ (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-F...
    // act1177 = (CAT V (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-FOR...
    // act1178 = (CAT N (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (I...
    // act1179 = (CAT ADJ (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT ...
    // act1180 = (CAT ADV (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-R...
    ":d-prefixes"),
  r("# d e -> 1211,1255,1256,1257",
  // d-prefixes-2, 
    // act1211 = (KILL-LEFT 2)
    // act1255 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (IS...
    // act1256 = (SETQ PREFIX 'DE)
    // act1257 = (CAT V (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'N)) EVA...
    ":d-prefixes"),
  r("# d e -> 1211,1186,1256,1258,1191,1192,1228",
  // d-prefixes-3, 
    // act1211 = (KILL-LEFT 2)
    // act1186 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (IS...
    // act1256 = (SETQ PREFIX 'DE)
    // act1258 = (TEST (AND PREFIX (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (...
    // act1191 = (CAT NM (AND (MORPH-ROOT STATE) (IS-FORM-OF-CAT ROOT 'PRESPA...
    // act1192 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-FORM-OF-CAT ROOT '(PRES...
    // act1228 = (CAT V T EVAL (PROGN (MARK-DICT LEX 'HAS-PREFIX PREFIX T T) ...
    ":d-prefixes"),
  r("# d i s c o a|b|c|d|f|g|h|j|k|l|m|n|p|t -> 1188,1026,1259,1260",
  // d-prefixes-4, 
    // act1188 = (KILL-LEFT 5)
    // act1026 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (IS...
    // act1259 = (SETQ PREFIX 'DISCO)
    // act1260 = (CAT N (AND (MORPH-ROOT STATE) (IS-FORM-OF-CAT ROOT 'N)) EVA...
    ":d-prefixes"),
  r("# d i s -> 1166,1186,1261,1175,1176,1177,1178,1179,1180,1262",
  // d-prefixes-5, 
    // act1166 = (KILL-LEFT 3)
    // act1186 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (IS...
    // act1261 = (SETQ PREFIX 'DIS)
    // act1175 = (CAT NM (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-FO...
    // act1176 = (CAT ADJ (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-F...
    // act1177 = (CAT V (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-FOR...
    // act1178 = (CAT N (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (I...
    // act1179 = (CAT ADJ (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT ...
    // act1180 = (CAT ADV (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-R...
    // act1262 = (CAT V (AND (MORPH-ROOT STATE) (IS-NONNAME-ROOT-OF-CAT ROOT ...
    ":d-prefixes"),
  r("# d i a -> 1166,1263,1264,1175,1176,1177,1178,1179,1180",
  // d-prefixes-6, 
    // act1166 = (KILL-LEFT 3)
    // act1263 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (IS...
    // act1264 = (SETQ PREFIX 'DIA)
    // act1175 = (CAT NM (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-FO...
    // act1176 = (CAT ADJ (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-F...
    // act1177 = (CAT V (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-FOR...
    // act1178 = (CAT N (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (I...
    // act1179 = (CAT ADJ (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT ...
    // act1180 = (CAT ADV (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-R...
    ":d-prefixes"),
  r("# d i n o -> 1170,1265,1266,1175,1176,1177,1178,1179,1180",
  // d-prefixes-7, 
    // act1170 = (KILL-LEFT 4)
    // act1265 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (IS...
    // act1266 = (SETQ PREFIX 'DINO)
    // act1175 = (CAT NM (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-FO...
    // act1176 = (CAT ADJ (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-F...
    // act1177 = (CAT V (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-FOR...
    // act1178 = (CAT N (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (I...
    // act1179 = (CAT ADJ (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT ...
    // act1180 = (CAT ADV (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-R...
    ":d-prefixes"),
  r("# d i -> 1211,1026,1267,1175,1176,1177,1178,1179,1180",
  // d-prefixes-8, 
    // act1211 = (KILL-LEFT 2)
    // act1026 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (IS...
    // act1267 = (SETQ PREFIX 'DI)
    // act1175 = (CAT NM (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-FO...
    // act1176 = (CAT ADJ (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-F...
    // act1177 = (CAT V (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-FOR...
    // act1178 = (CAT N (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (I...
    // act1179 = (CAT ADJ (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT ...
    // act1180 = (CAT ADV (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-R...
    ":d-prefixes"),
  r("# d o w n -> 1170,1268,1269,1270,1190,1191,1192,1193,1194,1195,1196",
  // d-prefixes-9, 
    // act1170 = (KILL-LEFT 4)
    // act1268 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (IS...
    // act1269 = (SETQ PREFIX 'DOWN)
    // act1270 = (CAT ADV (AND (MORPH-ROOT STATE) (IS-NONNAME-ROOT-OF-CAT ROO...
    // act1190 = (TEST (AND PREFIX (PLAUSIBLE-ROOT ROOT)))
    // act1191 = (CAT NM (AND (MORPH-ROOT STATE) (IS-FORM-OF-CAT ROOT 'PRESPA...
    // act1192 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-FORM-OF-CAT ROOT '(PRES...
    // act1193 = (CAT V (AND (MORPH-ROOT STATE) (IS-FORM-OF-CAT ROOT 'V)) EVA...
    // act1194 = (CAT N (AND (MORPH-ROOT STATE) (NOT (IS-FORM-OF-CAT ROOT 'PR...
    // act1195 = (CAT ADJ (AND (MORPH-ROOT STATE) (NOT (IS-FORM-OF-CAT ROOT '...
    // act1196 = (CAT ADV (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADV))...
    ":d-prefixes"),
 };

 protected static MorphRule[] ePrefixes = {//":e-prefixes"
  r("# e n -> 1211,1271,1272,1191,1273,1274",
  // e-prefixes-1, 
    // act1211 = (KILL-LEFT 2)
    // act1271 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (IS...
    // act1272 = (SETQ PREFIX 'EN)
    // act1191 = (CAT NM (AND (MORPH-ROOT STATE) (IS-FORM-OF-CAT ROOT 'PRESPA...
    // act1273 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-FORM-OF-CAT ROOT '(PAST...
    // act1274 = (CAT V T EVAL (PROGN (MARK-DICT LEX 'KINDOF (MAKE-SENSE-NAME...
    ":e-prefixes"),
  r("# e n -> 1211,1026,1272,1275",
  // e-prefixes-2, 
    // act1211 = (KILL-LEFT 2)
    // act1026 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (IS...
    // act1272 = (SETQ PREFIX 'EN)
    // act1275 = (CAT V (AND (MORPH-ROOT STATE) (IS-NONNAME-ROOT-OF-CAT ROOT ...
    ":e-prefixes"),
  r("# e m b|m|p -> 1211,1271,1276,1191,1273,1277",
  // e-prefixes-3, 
    // act1211 = (KILL-LEFT 2)
    // act1271 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (IS...
    // act1276 = (SETQ PREFIX 'EM)
    // act1191 = (CAT NM (AND (MORPH-ROOT STATE) (IS-FORM-OF-CAT ROOT 'PRESPA...
    // act1273 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-FORM-OF-CAT ROOT '(PAST...
    // act1277 = (CAT V T EVAL (PROGN (MARK-DICT LEX 'KINDOF ROOT T T) (FORMS...
    ":e-prefixes"),
  r("# e m b|m|p -> 1211,1026,1276,1278",
  // e-prefixes-4, 
    // act1211 = (KILL-LEFT 2)
    // act1026 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (IS...
    // act1276 = (SETQ PREFIX 'EM)
    // act1278 = (CAT V (AND (MORPH-ROOT STATE) (IS-NONNAME-ROOT-OF-CAT ROOT ...
    ":e-prefixes"),
  r("# e n -> 1279,1272,1211,1280,1281",
  // e-prefixes-5, 
    // act1279 = (TEST (AND (> (NCHARS LEX) 4) (PATTERN-CHECK LEX '(E N))))
    // act1272 = (SETQ PREFIX 'EN)
    // act1211 = (KILL-LEFT 2)
    // act1280 = (KILL-RIGHT 1)
    // act1281 = (CAT V (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (P...
    ":e-prefixes"),
  r("# e n -> 1282,1272,1211,1283,1281",
  // e-prefixes-6, 
    // act1282 = (TEST (AND (> (NCHARS LEX) 4) (PATTERN-CHECK LEX '(E N)) (MO...
    // act1272 = (SETQ PREFIX 'EN)
    // act1211 = (KILL-LEFT 2)
    // act1283 = (KILL-RIGHT 2)
    // act1281 = (CAT V (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (P...
    ":e-prefixes"),
  r("# e m b|m|p -> 1279,1276,1211,1280,1284",
  // e-prefixes-7, 
    // act1279 = (TEST (AND (> (NCHARS LEX) 4) (PATTERN-CHECK LEX '(E N))))
    // act1276 = (SETQ PREFIX 'EM)
    // act1211 = (KILL-LEFT 2)
    // act1280 = (KILL-RIGHT 1)
    // act1284 = (CAT V (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (P...
    ":e-prefixes"),
  r("# e m b|m|p -> 1282,1276,1211,1283,1284",
  // e-prefixes-8, 
    // act1282 = (TEST (AND (> (NCHARS LEX) 4) (PATTERN-CHECK LEX '(E N)) (MO...
    // act1276 = (SETQ PREFIX 'EM)
    // act1211 = (KILL-LEFT 2)
    // act1283 = (KILL-RIGHT 2)
    // act1284 = (CAT V (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (P...
    ":e-prefixes"),
  r("# e n -> 1279,1272,1211,1280,1285",
  // e-prefixes-9, 
    // act1279 = (TEST (AND (> (NCHARS LEX) 4) (PATTERN-CHECK LEX '(E N))))
    // act1272 = (SETQ PREFIX 'EN)
    // act1211 = (KILL-LEFT 2)
    // act1280 = (KILL-RIGHT 1)
    // act1285 = (CAT V (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (P...
    ":e-prefixes"),
  r("# e n -> 1282,1272,1211,1283,1285",
  // e-prefixes-10, 
    // act1282 = (TEST (AND (> (NCHARS LEX) 4) (PATTERN-CHECK LEX '(E N)) (MO...
    // act1272 = (SETQ PREFIX 'EN)
    // act1211 = (KILL-LEFT 2)
    // act1283 = (KILL-RIGHT 2)
    // act1285 = (CAT V (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (P...
    ":e-prefixes"),
  r("# e m b|m|p -> 1279,1276,1211,1280,1286",
  // e-prefixes-11, 
    // act1279 = (TEST (AND (> (NCHARS LEX) 4) (PATTERN-CHECK LEX '(E N))))
    // act1276 = (SETQ PREFIX 'EM)
    // act1211 = (KILL-LEFT 2)
    // act1280 = (KILL-RIGHT 1)
    // act1286 = (CAT V (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (P...
    ":e-prefixes"),
  r("# e m b|m|p -> 1282,1276,1211,1283,1286",
  // e-prefixes-12, 
    // act1282 = (TEST (AND (> (NCHARS LEX) 4) (PATTERN-CHECK LEX '(E N)) (MO...
    // act1276 = (SETQ PREFIX 'EM)
    // act1211 = (KILL-LEFT 2)
    // act1283 = (KILL-RIGHT 2)
    // act1286 = (CAT V (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (P...
    ":e-prefixes"),
  r("# e f f -> 1211,1287,1288,1175,1176,1177,1178,1179,1180",
  // e-prefixes-13, 
    // act1211 = (KILL-LEFT 2)
    // act1287 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (IS...
    // act1288 = (SETQ PREFIX 'EX)
    // act1175 = (CAT NM (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-FO...
    // act1176 = (CAT ADJ (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-F...
    // act1177 = (CAT V (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-FOR...
    // act1178 = (CAT N (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (I...
    // act1179 = (CAT ADJ (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT ...
    // act1180 = (CAT ADV (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-R...
    ":e-prefixes"),
  r("# e x t r a -> 1188,1026,1289,1290",
  // e-prefixes-14, 
    // act1188 = (KILL-LEFT 5)
    // act1026 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (IS...
    // act1289 = (SETQ PREFIX 'EXTRA)
    // act1290 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADJ))...
    ":e-prefixes"),
  r("# e x -> 1211,1268,1288,1175,1176,1177,1178,1179,1180,1291",
  // e-prefixes-15, 
    // act1211 = (KILL-LEFT 2)
    // act1268 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (IS...
    // act1288 = (SETQ PREFIX 'EX)
    // act1175 = (CAT NM (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-FO...
    // act1176 = (CAT ADJ (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-F...
    // act1177 = (CAT V (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-FOR...
    // act1178 = (CAT N (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (I...
    // act1179 = (CAT ADJ (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT ...
    // act1180 = (CAT ADV (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-R...
    // act1291 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'N)) E...
    ":e-prefixes"),
  r("# e x -> 1211,1292,1287,1288,1293,1294",
  // e-prefixes-16, 
    // act1211 = (KILL-LEFT 2)
    // act1292 = (ADD-LEFT I N)
    // act1287 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (IS...
    // act1288 = (SETQ PREFIX 'EX)
    // act1293 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADJ))...
    // act1294 = (CAT N (AND (MORPH-ROOT STATE) (IS-NONNAME-ROOT-OF-CAT ROOT ...
    ":e-prefixes"),
  r("# e x t r a -> 1188,1026,1289,1295",
  // e-prefixes-17, 
    // act1188 = (KILL-LEFT 5)
    // act1026 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (IS...
    // act1289 = (SETQ PREFIX 'EXTRA)
    // act1295 = (CAT ADJ (AND (MORPH-ROOT STATE) (MAY-BE-CAT ROOT 'ADJ)) EVA...
    ":e-prefixes"),
 };

 protected static MorphRule[] hPrefixes = {//":h-prefixes"
  r("# h e m i -> 1170,1026,1296,1175,1176,1177,1178,1179,1180",
  // h-prefixes-1, 
    // act1170 = (KILL-LEFT 4)
    // act1026 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (IS...
    // act1296 = (SETQ PREFIX 'HEMI)
    // act1175 = (CAT NM (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-FO...
    // act1176 = (CAT ADJ (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-F...
    // act1177 = (CAT V (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-FOR...
    // act1178 = (CAT N (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (I...
    // act1179 = (CAT ADJ (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT ...
    // act1180 = (CAT ADV (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-R...
    ":h-prefixes"),
  r("# h e r e -> 1170,1026,1297,1298",
  // h-prefixes-2, 
    // act1170 = (KILL-LEFT 4)
    // act1026 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (IS...
    // act1297 = (SETQ PREFIX 'HERE)
    // act1298 = (CAT ADV (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'PREP)...
    ":h-prefixes"),
  r("# h y p e r -> 1188,1026,1299,1175,1176,1177,1178,1179,1180",
  // h-prefixes-3, 
    // act1188 = (KILL-LEFT 5)
    // act1026 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (IS...
    // act1299 = (SETQ PREFIX 'HYPER)
    // act1175 = (CAT NM (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-FO...
    // act1176 = (CAT ADJ (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-F...
    // act1177 = (CAT V (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-FOR...
    // act1178 = (CAT N (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (I...
    // act1179 = (CAT ADJ (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT ...
    // act1180 = (CAT ADV (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-R...
    ":h-prefixes"),
  r("# h y p n o -> 1188,1026,1300,1175,1176,1177,1178,1179,1180",
  // h-prefixes-4, 
    // act1188 = (KILL-LEFT 5)
    // act1026 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (IS...
    // act1300 = (SETQ PREFIX 'HYPNO)
    // act1175 = (CAT NM (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-FO...
    // act1176 = (CAT ADJ (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-F...
    // act1177 = (CAT V (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-FOR...
    // act1178 = (CAT N (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (I...
    // act1179 = (CAT ADJ (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT ...
    // act1180 = (CAT ADV (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-R...
    ":h-prefixes"),
  r("# h y p o -> 1170,1026,1301,1175,1176,1177,1178,1179,1180",
  // h-prefixes-5, 
    // act1170 = (KILL-LEFT 4)
    // act1026 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (IS...
    // act1301 = (SETQ PREFIX 'HYPO)
    // act1175 = (CAT NM (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-FO...
    // act1176 = (CAT ADJ (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-F...
    // act1177 = (CAT V (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-FOR...
    // act1178 = (CAT N (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (I...
    // act1179 = (CAT ADJ (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT ...
    // act1180 = (CAT ADV (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-R...
    ":h-prefixes"),
  r("# h y p o -> 1170,1302,1026,1301,1191,1192,1303,1304,1305,1196",
  // h-prefixes-6, 
    // act1170 = (KILL-LEFT 4)
    // act1302 = (ADD-LEFT H Y P E R)
    // act1026 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (IS...
    // act1301 = (SETQ PREFIX 'HYPO)
    // act1191 = (CAT NM (AND (MORPH-ROOT STATE) (IS-FORM-OF-CAT ROOT 'PRESPA...
    // act1192 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-FORM-OF-CAT ROOT '(PRES...
    // act1303 = (CAT V (AND (MORPH-ROOT STATE) (IS-FORM-OF-CAT ROOT 'V)) EVA...
    // act1304 = (CAT N (AND (MORPH-ROOT STATE) (NOT (IS-FORM-OF-CAT ROOT 'PR...
    // act1305 = (CAT ADJ (AND (MORPH-ROOT STATE) (NOT (IS-FORM-OF-CAT ROOT '...
    // act1196 = (CAT ADV (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADV))...
    ":h-prefixes"),
 };

 protected static MorphRule[] iPrefixes = {//":i-prefixes"
  r("# i l l -> 1211,1026,1306,1214,1307",
  // i-prefixes-1, 
    // act1211 = (KILL-LEFT 2)
    // act1026 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (IS...
    // act1306 = (SETQ PREFIX 'IL)
    // act1214 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADJ))...
    // act1307 = (CAT ADV (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADV))...
    ":i-prefixes"),
  r("# i m b|m|p -> 1211,1026,1308,1309",
  // i-prefixes-2, 
    // act1211 = (KILL-LEFT 2)
    // act1026 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (IS...
    // act1308 = (SETQ PREFIX 'IM)
    // act1309 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADJ) ...
    ":i-prefixes"),
  r("# i m b|m|p -> 1211,1310,1308,1191,1273,1311",
  // i-prefixes-3, 
    // act1211 = (KILL-LEFT 2)
    // act1310 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (IS...
    // act1308 = (SETQ PREFIX 'IM)
    // act1191 = (CAT NM (AND (MORPH-ROOT STATE) (IS-FORM-OF-CAT ROOT 'PRESPA...
    // act1273 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-FORM-OF-CAT ROOT '(PAST...
    // act1311 = (CAT V T EVAL (PROGN (MARK-DICT LEX 'KINDOF (MAKE-SENSE-NAME...
    ":i-prefixes"),
  r("# i m b|m|p -> 1211,1026,1308,1312",
  // i-prefixes-4, 
    // act1211 = (KILL-LEFT 2)
    // act1026 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (IS...
    // act1308 = (SETQ PREFIX 'IM)
    // act1312 = (CAT V (AND (MORPH-ROOT STATE) (NOT (IS-FORM-OF-CAT ROOT 'V)...
    ":i-prefixes"),
  r("# i n t e r -> 1188,1026,1313,1190,1191,1192,1193,1194,1195,1196",
  // i-prefixes-5, 
    // act1188 = (KILL-LEFT 5)
    // act1026 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (IS...
    // act1313 = (SETQ PREFIX 'INTER)
    // act1190 = (TEST (AND PREFIX (PLAUSIBLE-ROOT ROOT)))
    // act1191 = (CAT NM (AND (MORPH-ROOT STATE) (IS-FORM-OF-CAT ROOT 'PRESPA...
    // act1192 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-FORM-OF-CAT ROOT '(PRES...
    // act1193 = (CAT V (AND (MORPH-ROOT STATE) (IS-FORM-OF-CAT ROOT 'V)) EVA...
    // act1194 = (CAT N (AND (MORPH-ROOT STATE) (NOT (IS-FORM-OF-CAT ROOT 'PR...
    // act1195 = (CAT ADJ (AND (MORPH-ROOT STATE) (NOT (IS-FORM-OF-CAT ROOT '...
    // act1196 = (CAT ADV (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADV))...
    ":i-prefixes"),
  r("# i n t r a -> 1188,1026,1314,1190,1191,1192,1193,1194,1195,1196",
  // i-prefixes-6, 
    // act1188 = (KILL-LEFT 5)
    // act1026 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (IS...
    // act1314 = (SETQ PREFIX 'INTRA)
    // act1190 = (TEST (AND PREFIX (PLAUSIBLE-ROOT ROOT)))
    // act1191 = (CAT NM (AND (MORPH-ROOT STATE) (IS-FORM-OF-CAT ROOT 'PRESPA...
    // act1192 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-FORM-OF-CAT ROOT '(PRES...
    // act1193 = (CAT V (AND (MORPH-ROOT STATE) (IS-FORM-OF-CAT ROOT 'V)) EVA...
    // act1194 = (CAT N (AND (MORPH-ROOT STATE) (NOT (IS-FORM-OF-CAT ROOT 'PR...
    // act1195 = (CAT ADJ (AND (MORPH-ROOT STATE) (NOT (IS-FORM-OF-CAT ROOT '...
    // act1196 = (CAT ADV (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADV))...
    ":i-prefixes"),
  r("# i n -> 1211,1315,1316,1214",
  // i-prefixes-7, 
    // act1211 = (KILL-LEFT 2)
    // act1315 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (IS...
    // act1316 = (SETQ PREFIX 'IN)
    // act1214 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADJ))...
    ":i-prefixes"),
  r("# i n -> 1211,1317,1316,1175,1176,1177,1178,1179,1180",
  // i-prefixes-8, 
    // act1211 = (KILL-LEFT 2)
    // act1317 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (IS...
    // act1316 = (SETQ PREFIX 'IN)
    // act1175 = (CAT NM (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-FO...
    // act1176 = (CAT ADJ (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-F...
    // act1177 = (CAT V (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-FOR...
    // act1178 = (CAT N (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (I...
    // act1179 = (CAT ADJ (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT ...
    // act1180 = (CAT ADV (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-R...
    ":i-prefixes"),
  r("# i n -> 1211,1026,1316,1318",
  // i-prefixes-9, 
    // act1211 = (KILL-LEFT 2)
    // act1026 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (IS...
    // act1316 = (SETQ PREFIX 'IN)
    // act1318 = (CAT N (AND (MORPH-ROOT STATE) (IS-NONNAME-FORM-OF-CAT ROOT ...
    ":i-prefixes"),
  r("# i r r -> 1211,1026,1319,1214",
  // i-prefixes-10, 
    // act1211 = (KILL-LEFT 2)
    // act1026 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (IS...
    // act1319 = (SETQ PREFIX 'IR)
    // act1214 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADJ))...
    ":i-prefixes"),
  r("# i n n e r -> 1188,1026,1320,1173",
  // i-prefixes-11, 
    // act1188 = (KILL-LEFT 5)
    // act1026 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (IS...
    // act1320 = (SETQ PREFIX 'INNER)
    // act1173 = (CAT N (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-NON...
    ":i-prefixes"),
  r("# i s o -> 1166,1026,1321,1322,1323",
  // i-prefixes-12, 
    // act1166 = (KILL-LEFT 3)
    // act1026 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (IS...
    // act1321 = (SETQ PREFIX 'ISO)
    // act1322 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADJ))...
    // act1323 = (CAT N (AND (MORPH-ROOT STATE) (IS-NONNAME-FORM-OF-CAT ROOT ...
    ":i-prefixes"),
  r("# i s vowel -> 1211,1026,1321,1322,1323",
  // i-prefixes-13, 
    // act1211 = (KILL-LEFT 2)
    // act1026 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (IS...
    // act1321 = (SETQ PREFIX 'ISO)
    // act1322 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADJ))...
    // act1323 = (CAT N (AND (MORPH-ROOT STATE) (IS-NONNAME-FORM-OF-CAT ROOT ...
    ":i-prefixes"),
 };

 protected static MorphRule[] mPrefixes = {//":m-prefixes"
  r("# m a c -> 1166,35,1324,1325",
  // m-prefixes-1, 
    // act1166 = (KILL-LEFT 3)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act1324 = (SETQ PREFIX 'MAC)
    // act1325 = (CAT LASTNAME (AND (MORPH-ROOT STATE) (IS-FORM-OF-CAT ROOT '...
    ":m-prefixes"),
  r("# m c -> 1211,35,1326,1325",
  // m-prefixes-2, 
    // act1211 = (KILL-LEFT 2)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act1326 = (SETQ PREFIX 'MC)
    // act1325 = (CAT LASTNAME (AND (MORPH-ROOT STATE) (IS-FORM-OF-CAT ROOT '...
    ":m-prefixes"),
  r("# m c -> 1211,35,1326,1327",
  // m-prefixes-3, 
    // act1211 = (KILL-LEFT 2)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act1326 = (SETQ PREFIX 'MC)
    // act1327 = (CAT LASTNAME (AND (MORPH-ROOT STATE) (NOT (PATTERN-CHECK RO...
    ":m-prefixes"),
  r("# m a l -> 1166,1328,1329,1330,1331",
  // m-prefixes-4, 
    // act1166 = (KILL-LEFT 3)
    // act1328 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (IS...
    // act1329 = (SETQ PREFIX 'MAL)
    // act1330 = (CAT N (AND (MORPH-ROOT STATE) (IS-NONNAME-FORM-OF-CAT ROOT ...
    // act1331 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-FORM-OF-CAT ROOT 'ADJ) ...
    ":m-prefixes"),
  r("# m a x i -> 1170,1186,1332,1172,1173",
  // m-prefixes-5, 
    // act1170 = (KILL-LEFT 4)
    // act1186 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (IS...
    // act1332 = (SETQ PREFIX 'MAXI)
    // act1172 = (CAT ADJ (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-R...
    // act1173 = (CAT N (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-NON...
    ":m-prefixes"),
  r("# m i d -> 1166,1333,1334,1335,1182,1173",
  // m-prefixes-6, 
    // act1166 = (KILL-LEFT 3)
    // act1333 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (IS...
    // act1334 = (SETQ PREFIX 'MID)
    // act1335 = (CAT ADV (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(ADV ...
    // act1182 = (CAT ADJ (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-R...
    // act1173 = (CAT N (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-NON...
    ":m-prefixes"),
  r("# m i n i -> 1170,1333,1336,1173",
  // m-prefixes-7, 
    // act1170 = (KILL-LEFT 4)
    // act1333 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (IS...
    // act1336 = (SETQ PREFIX 'MINI)
    // act1173 = (CAT N (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-NON...
    ":m-prefixes"),
  r("# m e s o -> 1170,1333,1337,1172,1173",
  // m-prefixes-8, 
    // act1170 = (KILL-LEFT 4)
    // act1333 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (IS...
    // act1337 = (SETQ PREFIX 'MESO)
    // act1172 = (CAT ADJ (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-R...
    // act1173 = (CAT N (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-NON...
    ":m-prefixes"),
  r("# m o n o -> 1170,1333,1338,1172,1173",
  // m-prefixes-9, 
    // act1170 = (KILL-LEFT 4)
    // act1333 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (IS...
    // act1338 = (SETQ PREFIX 'MONO)
    // act1172 = (CAT ADJ (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-R...
    // act1173 = (CAT N (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-NON...
    ":m-prefixes"),
  r("# m o n vowel -> 1166,1333,1338,1172,1173",
  // m-prefixes-10, 
    // act1166 = (KILL-LEFT 3)
    // act1333 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (IS...
    // act1338 = (SETQ PREFIX 'MONO)
    // act1172 = (CAT ADJ (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-R...
    // act1173 = (CAT N (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-NON...
    ":m-prefixes"),
  r("# m u l t i -> 1188,1333,1339,1340,1173,1180",
  // m-prefixes-11, 
    // act1188 = (KILL-LEFT 5)
    // act1333 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (IS...
    // act1339 = (SETQ PREFIX 'MULTI)
    // act1340 = (CAT ADJ (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-R...
    // act1173 = (CAT N (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-NON...
    // act1180 = (CAT ADV (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-R...
    ":m-prefixes"),
  r("# m i s -> 1166,1186,1341,1175,1176,1177,1178,1179,1180",
  // m-prefixes-12, 
    // act1166 = (KILL-LEFT 3)
    // act1186 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (IS...
    // act1341 = (SETQ PREFIX 'MIS)
    // act1175 = (CAT NM (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-FO...
    // act1176 = (CAT ADJ (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-F...
    // act1177 = (CAT V (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-FOR...
    // act1178 = (CAT N (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (I...
    // act1179 = (CAT ADJ (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT ...
    // act1180 = (CAT ADV (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-R...
    ":m-prefixes"),
 };

 protected static MorphRule[] nPrefixes = {//":n-prefixes"
  r("# n e o -> 1166,1026,1342,1172,1173,1180",
  // n-prefixes-1, 
    // act1166 = (KILL-LEFT 3)
    // act1026 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (IS...
    // act1342 = (SETQ PREFIX 'NEO)
    // act1172 = (CAT ADJ (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-R...
    // act1173 = (CAT N (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-NON...
    // act1180 = (CAT ADV (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-R...
    ":n-prefixes"),
  r("# n e u r o -> 1188,1026,1343,1172,1173,1180",
  // n-prefixes-2, 
    // act1188 = (KILL-LEFT 5)
    // act1026 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (IS...
    // act1343 = (SETQ PREFIX 'NEURO)
    // act1172 = (CAT ADJ (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-R...
    // act1173 = (CAT N (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-NON...
    // act1180 = (CAT ADV (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-R...
    ":n-prefixes"),
  r("# n o n -> 1166,1026,1344,1345,1346,1347",
  // n-prefixes-3, 
    // act1166 = (KILL-LEFT 3)
    // act1026 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (IS...
    // act1344 = (SETQ PREFIX 'NON)
    // act1345 = (CAT ADJ (AND (MORPH-ROOT STATE) (OR (IS-FORM-OF-CAT ROOT 'A...
    // act1346 = (CAT N (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-FOR...
    // act1347 = (CAT ADV (AND (MORPH-ROOT STATE) (IS-FORM-OF-CAT ROOT 'ADV))...
    ":n-prefixes"),
  r("# n o -> 1211,1348,1349,1350,1351",
  // n-prefixes-4, 
    // act1211 = (KILL-LEFT 2)
    // act1348 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (IS...
    // act1349 = (SETQ PREFIX 'NO)
    // act1350 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-NONNAME-ROOT-OF-CAT ROO...
    // act1351 = (CAT N (AND (MORPH-ROOT STATE) (IS-NONNAME-ROOT-OF-CAT ROOT ...
    ":n-prefixes"),
 };

 protected static MorphRule[] oPrefixes = {//":o-prefixes"
  r("# o c t o -> 1170,1026,1352,1172,1173",
  // o-prefixes-1, 
    // act1170 = (KILL-LEFT 4)
    // act1026 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (IS...
    // act1352 = (SETQ PREFIX 'OCTO)
    // act1172 = (CAT ADJ (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-R...
    // act1173 = (CAT N (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-NON...
    ":o-prefixes"),
  r("# o f f -> 1166,1268,1353,1354,1175,1176,1355,1356,1357",
  // o-prefixes-2, 
    // act1166 = (KILL-LEFT 3)
    // act1268 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (IS...
    // act1353 = (SETQ PREFIX 'OFF)
    // act1354 = (CAT ADV (AND (MORPH-ROOT STATE) (IS-NONNAME-ROOT-OF-CAT ROO...
    // act1175 = (CAT NM (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-FO...
    // act1176 = (CAT ADJ (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-F...
    // act1355 = (CAT V (AND (MORPH-ROOT STATE) (IS-FORM-OF-CAT ROOT 'V)) EVA...
    // act1356 = (CAT N (AND (MORPH-ROOT STATE) (IS-NONNAME-FORM-OF-CAT ROOT ...
    // act1357 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-NONNAME-ROOT-OF-CAT ROO...
    ":o-prefixes"),
  r("# o n -> 1211,1026,1358,1190,1191,1192,1193,1194,1195,1196",
  // o-prefixes-3, 
    // act1211 = (KILL-LEFT 2)
    // act1026 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (IS...
    // act1358 = (SETQ PREFIX 'ON)
    // act1190 = (TEST (AND PREFIX (PLAUSIBLE-ROOT ROOT)))
    // act1191 = (CAT NM (AND (MORPH-ROOT STATE) (IS-FORM-OF-CAT ROOT 'PRESPA...
    // act1192 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-FORM-OF-CAT ROOT '(PRES...
    // act1193 = (CAT V (AND (MORPH-ROOT STATE) (IS-FORM-OF-CAT ROOT 'V)) EVA...
    // act1194 = (CAT N (AND (MORPH-ROOT STATE) (NOT (IS-FORM-OF-CAT ROOT 'PR...
    // act1195 = (CAT ADJ (AND (MORPH-ROOT STATE) (NOT (IS-FORM-OF-CAT ROOT '...
    // act1196 = (CAT ADV (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADV))...
    ":o-prefixes"),
  r("# o r t h o -> 1188,1026,1359,1172,1173",
  // o-prefixes-4, 
    // act1188 = (KILL-LEFT 5)
    // act1026 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (IS...
    // act1359 = (SETQ PREFIX 'ORTHO)
    // act1172 = (CAT ADJ (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-R...
    // act1173 = (CAT N (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-NON...
    ":o-prefixes"),
  r("# o u t e r -> 1188,1026,1360,1361",
  // o-prefixes-5, 
    // act1188 = (KILL-LEFT 5)
    // act1026 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (IS...
    // act1360 = (SETQ PREFIX 'OUTER)
    // act1361 = (CAT N (AND (MORPH-ROOT STATE) (IS-NONNAME-FORM-OF-CAT ROOT ...
    ":o-prefixes"),
  r("# o u t -> 1166,1362,1363,1191,1192,1364,1323",
  // o-prefixes-6, 
    // act1166 = (KILL-LEFT 3)
    // act1362 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (IS...
    // act1363 = (SETQ PREFIX 'OUT)
    // act1191 = (CAT NM (AND (MORPH-ROOT STATE) (IS-FORM-OF-CAT ROOT 'PRESPA...
    // act1192 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-FORM-OF-CAT ROOT '(PRES...
    // act1364 = (CAT VT T EVAL (FORMS-WITH-PREFIX ROOT 'V PREFIX (LIST (LIST...
    // act1323 = (CAT N (AND (MORPH-ROOT STATE) (IS-NONNAME-FORM-OF-CAT ROOT ...
    ":o-prefixes"),
  r("# o u t -> 1166,1268,1363,1365,1323",
  // o-prefixes-7, 
    // act1166 = (KILL-LEFT 3)
    // act1268 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (IS...
    // act1363 = (SETQ PREFIX 'OUT)
    // act1365 = (CAT VT (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(ADJ N...
    // act1323 = (CAT N (AND (MORPH-ROOT STATE) (IS-NONNAME-FORM-OF-CAT ROOT ...
    ":o-prefixes"),
  r("# o v e r -> 1170,1366,1367,1175,1176,1177,1178,1179,1180",
  // o-prefixes-8, 
    // act1170 = (KILL-LEFT 4)
    // act1366 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (IS...
    // act1367 = (SETQ PREFIX 'OVER)
    // act1175 = (CAT NM (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-FO...
    // act1176 = (CAT ADJ (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-F...
    // act1177 = (CAT V (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-FOR...
    // act1178 = (CAT N (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (I...
    // act1179 = (CAT ADJ (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT ...
    // act1180 = (CAT ADV (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-R...
    ":o-prefixes"),
  r("# o v e r -> 1170,1368,1367,1369,1370,1371,1372",
  // o-prefixes-9, 
    // act1170 = (KILL-LEFT 4)
    // act1368 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (IS...
    // act1367 = (SETQ PREFIX 'OVER)
    // act1369 = (CAT V (AND (MORPH-ROOT STATE) (IS-NONPENALTY-FORM-OF-CAT RO...
    // act1370 = (CAT N (AND (MORPH-ROOT STATE) (IS-FORM-OF-CAT ROOT 'NN)) EV...
    // act1371 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-FORM-OF-CAT ROOT 'ADJ))...
    // act1372 = (CAT ADV (AND (MORPH-ROOT STATE) (IS-FORM-OF-CAT ROOT 'ADV))...
    ":o-prefixes"),
  r("# o x y -> 1166,1026,1373,1172,1173",
  // o-prefixes-10, 
    // act1166 = (KILL-LEFT 3)
    // act1026 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (IS...
    // act1373 = (SETQ PREFIX 'OXY)
    // act1172 = (CAT ADJ (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-R...
    // act1173 = (CAT N (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-NON...
    ":o-prefixes"),
  r("# o ' -> 1026,1374,154",
  // o-prefixes-11, 
    // act1026 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (IS...
    // act1374 = (SETQ PREFIX 'O)
    // act154 = (CAT LASTNAME T EVAL '*)
    ":o-prefixes"),
 };

 protected static MorphRule[] pPrefixes = {//":p-prefixes"
  r("# p a l e o -> 1188,1026,1375,1172,1173",
  // p-prefixes-1, 
    // act1188 = (KILL-LEFT 5)
    // act1026 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (IS...
    // act1375 = (SETQ PREFIX 'PALEO)
    // act1172 = (CAT ADJ (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-R...
    // act1173 = (CAT N (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-NON...
    ":p-prefixes"),
  r("# p s e u d o -> 1248,726,1376,1172,1173,1180",
  // p-prefixes-2, 
    // act1248 = (KILL-LEFT 6)
    // act726 = (TEST (AND (MORPH-ROOT STATE) (NOT (IS-HYPHENATED ROOT))))
    // act1376 = (SETQ PREFIX 'PSEUDO)
    // act1172 = (CAT ADJ (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-R...
    // act1173 = (CAT N (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-NON...
    // act1180 = (CAT ADV (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-R...
    ":p-prefixes"),
  r("# p s e u d a|e|i|o -> 1188,1026,1376,1172,1173,1180",
  // p-prefixes-3, 
    // act1188 = (KILL-LEFT 5)
    // act1026 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (IS...
    // act1376 = (SETQ PREFIX 'PSEUDO)
    // act1172 = (CAT ADJ (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-R...
    // act1173 = (CAT N (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-NON...
    // act1180 = (CAT ADV (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-R...
    ":p-prefixes"),
  r("# p a n -> 1166,1026,1377,1172,1173",
  // p-prefixes-4, 
    // act1166 = (KILL-LEFT 3)
    // act1026 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (IS...
    // act1377 = (SETQ PREFIX 'PAN)
    // act1172 = (CAT ADJ (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-R...
    // act1173 = (CAT N (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-NON...
    ":p-prefixes"),
  r("# p a r a -> 1170,1026,1378,1172,1173",
  // p-prefixes-5, 
    // act1170 = (KILL-LEFT 4)
    // act1026 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (IS...
    // act1378 = (SETQ PREFIX 'PARA)
    // act1172 = (CAT ADJ (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-R...
    // act1173 = (CAT N (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-NON...
    ":p-prefixes"),
  r("# p e t r o -> 1188,1026,1379,1172,1173",
  // p-prefixes-6, 
    // act1188 = (KILL-LEFT 5)
    // act1026 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (IS...
    // act1379 = (SETQ PREFIX 'PETRO)
    // act1172 = (CAT ADJ (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-R...
    // act1173 = (CAT N (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-NON...
    ":p-prefixes"),
  r("# p o l y -> 1170,1026,1380,1182,1173",
  // p-prefixes-7, 
    // act1170 = (KILL-LEFT 4)
    // act1026 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (IS...
    // act1380 = (SETQ PREFIX 'POLY)
    // act1182 = (CAT ADJ (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-R...
    // act1173 = (CAT N (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-NON...
    ":p-prefixes"),
  r("# p o s t -> 1170,493,1381,1382,1190,1191,1192,1193,1194,1195,1196",
  // p-prefixes-8, 
    // act1170 = (KILL-LEFT 4)
    // act493 = (TEST (AND (PLAUSIBLE-ROOT ROOT)))
    // act1381 = (SETQ PREFIX 'POST)
    // act1382 = (CAT ADV (AND (MORPH-ROOT STATE) (IS-NONNAME-ROOT-OF-CAT ROO...
    // act1190 = (TEST (AND PREFIX (PLAUSIBLE-ROOT ROOT)))
    // act1191 = (CAT NM (AND (MORPH-ROOT STATE) (IS-FORM-OF-CAT ROOT 'PRESPA...
    // act1192 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-FORM-OF-CAT ROOT '(PRES...
    // act1193 = (CAT V (AND (MORPH-ROOT STATE) (IS-FORM-OF-CAT ROOT 'V)) EVA...
    // act1194 = (CAT N (AND (MORPH-ROOT STATE) (NOT (IS-FORM-OF-CAT ROOT 'PR...
    // act1195 = (CAT ADJ (AND (MORPH-ROOT STATE) (NOT (IS-FORM-OF-CAT ROOT '...
    // act1196 = (CAT ADV (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADV))...
    ":p-prefixes"),
  r("# p h o t o -> 1188,1026,1383,1175,1176,1177,1178,1179,1180",
  // p-prefixes-9, 
    // act1188 = (KILL-LEFT 5)
    // act1026 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (IS...
    // act1383 = (SETQ PREFIX 'PHOTO)
    // act1175 = (CAT NM (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-FO...
    // act1176 = (CAT ADJ (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-F...
    // act1177 = (CAT V (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-FOR...
    // act1178 = (CAT N (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (I...
    // act1179 = (CAT ADJ (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT ...
    // act1180 = (CAT ADV (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-R...
    ":p-prefixes"),
  r("# p y r o -> 1170,1026,1384,1175,1176,1177,1178,1179,1180",
  // p-prefixes-10, 
    // act1170 = (KILL-LEFT 4)
    // act1026 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (IS...
    // act1384 = (SETQ PREFIX 'PYRO)
    // act1175 = (CAT NM (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-FO...
    // act1176 = (CAT ADJ (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-F...
    // act1177 = (CAT V (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-FOR...
    // act1178 = (CAT N (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (I...
    // act1179 = (CAT ADJ (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT ...
    // act1180 = (CAT ADV (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-R...
    ":p-prefixes"),
  r("# p r e -> 1166,1385,1386,1191,1192,1193,1194,1387,1388",
  // p-prefixes-11, 
    // act1166 = (KILL-LEFT 3)
    // act1385 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (IS...
    // act1386 = (SETQ PREFIX 'PRE)
    // act1191 = (CAT NM (AND (MORPH-ROOT STATE) (IS-FORM-OF-CAT ROOT 'PRESPA...
    // act1192 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-FORM-OF-CAT ROOT '(PRES...
    // act1193 = (CAT V (AND (MORPH-ROOT STATE) (IS-FORM-OF-CAT ROOT 'V)) EVA...
    // act1194 = (CAT N (AND (MORPH-ROOT STATE) (NOT (IS-FORM-OF-CAT ROOT 'PR...
    // act1387 = (CAT ADJ (AND (MORPH-ROOT STATE) (NOT (IS-FORM-OF-CAT ROOT '...
    // act1388 = (CAT ADV (AND (MORPH-ROOT STATE) (IS-NONNAME-ROOT-OF-CAT ROO...
    ":p-prefixes"),
  r("# p r o -> 1166,1389,1390,1391,1392",
  // p-prefixes-12, 
    // act1166 = (KILL-LEFT 3)
    // act1389 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (IS...
    // act1390 = (SETQ PREFIX 'PRO)
    // act1391 = (CAT N (AND (MORPH-ROOT STATE) (IS-NONNAME-ROOT-OF-CAT ROOT ...
    // act1392 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(ADJ ...
    ":p-prefixes"),
 };

 protected static MorphRule[] rPrefixes = {//":r-prefixes"
  r("# r e - -> 1166,1393,1394,1191,1192,1395,1396,1305",
  // r-prefixes-1, 
    // act1166 = (KILL-LEFT 3)
    // act1393 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (IS...
    // act1394 = (SETQ PREFIX 'RE)
    // act1191 = (CAT NM (AND (MORPH-ROOT STATE) (IS-FORM-OF-CAT ROOT 'PRESPA...
    // act1192 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-FORM-OF-CAT ROOT '(PRES...
    // act1395 = (CAT V T EVAL (PROGN (MARK-DICT LEX 'KINDOF (LIST ROOT '!V/R...
    // act1396 = (CAT N (AND (MORPH-ROOT STATE) (NOT (IS-FORM-OF-CAT ROOT 'PR...
    // act1305 = (CAT ADJ (AND (MORPH-ROOT STATE) (NOT (IS-FORM-OF-CAT ROOT '...
    ":r-prefixes"),
  r("# r e -> 1211,1397,1394,1191,1192,1398,1399,1305",
  // r-prefixes-2, 
    // act1211 = (KILL-LEFT 2)
    // act1397 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (IS...
    // act1394 = (SETQ PREFIX 'RE)
    // act1191 = (CAT NM (AND (MORPH-ROOT STATE) (IS-FORM-OF-CAT ROOT 'PRESPA...
    // act1192 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-FORM-OF-CAT ROOT '(PRES...
    // act1398 = (CAT V T EVAL (PROGN (MARK-DICT LEX 'KINDOF (APPEND (MAKE-SE...
    // act1399 = (CAT N (AND (MORPH-ROOT STATE) (NOT (IS-FORM-OF-CAT ROOT 'PR...
    // act1305 = (CAT ADJ (AND (MORPH-ROOT STATE) (NOT (IS-FORM-OF-CAT ROOT '...
    ":r-prefixes"),
  r("# r e - -> 1166,1400,1394,1401",
  // r-prefixes-3, 
    // act1166 = (KILL-LEFT 3)
    // act1400 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (IS...
    // act1394 = (SETQ PREFIX 'RE)
    // act1401 = (CAT V (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(NN ADJ...
    ":r-prefixes"),
  r("# r e -> 1211,1400,1394,1402",
  // r-prefixes-4, 
    // act1211 = (KILL-LEFT 2)
    // act1400 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (IS...
    // act1394 = (SETQ PREFIX 'RE)
    // act1402 = (CAT V (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT '(NN ADJ...
    ":r-prefixes"),
 };

 protected static MorphRule[] sPrefixes = {//":s-prefixes"
  r("# s e m i -> 1170,1026,1403,1404,1405,1406,1173",
  // s-prefixes-1, 
    // act1170 = (KILL-LEFT 4)
    // act1026 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (IS...
    // act1403 = (SETQ PREFIX 'SEMI)
    // act1404 = (CAT ADV (AND (MORPH-ROOT STATE) (IS-NONNAME-ROOT-OF-CAT ROO...
    // act1405 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADJ))...
    // act1406 = (CAT V (AND (MORPH-ROOT STATE) (IS-FORM-OF-CAT ROOT 'V)) EVA...
    // act1173 = (CAT N (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-NON...
    ":s-prefixes"),
  r("# s t e p -> 1170,1407,1408,1409",
  // s-prefixes-2, 
    // act1170 = (KILL-LEFT 4)
    // act1407 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (IS...
    // act1408 = (SETQ PREFIX 'STEP)
    // act1409 = (CAT N T EVAL (PROGN (MARK-DICT LEX 'KINDOF (LIST (LIST 'HAL...
    ":s-prefixes"),
  r("# s u b -> 1166,1026,1410,1175,1176,1177,1178,1179,1180",
  // s-prefixes-3, 
    // act1166 = (KILL-LEFT 3)
    // act1026 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (IS...
    // act1410 = (SETQ PREFIX 'SUB)
    // act1175 = (CAT NM (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-FO...
    // act1176 = (CAT ADJ (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-F...
    // act1177 = (CAT V (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-FOR...
    // act1178 = (CAT N (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (I...
    // act1179 = (CAT ADJ (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT ...
    // act1180 = (CAT ADV (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-R...
    ":s-prefixes"),
  r("# s u p e r -> 1188,1026,1411,1175,1176,1177,1178,1179,1180",
  // s-prefixes-4, 
    // act1188 = (KILL-LEFT 5)
    // act1026 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (IS...
    // act1411 = (SETQ PREFIX 'SUPER)
    // act1175 = (CAT NM (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-FO...
    // act1176 = (CAT ADJ (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-F...
    // act1177 = (CAT V (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-FOR...
    // act1178 = (CAT N (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (I...
    // act1179 = (CAT ADJ (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT ...
    // act1180 = (CAT ADV (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-R...
    ":s-prefixes"),
  r("# s u p r a -> 1188,1026,1412,1172,1173",
  // s-prefixes-5, 
    // act1188 = (KILL-LEFT 5)
    // act1026 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (IS...
    // act1412 = (SETQ PREFIX 'SUPRA)
    // act1172 = (CAT ADJ (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-R...
    // act1173 = (CAT N (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-NON...
    ":s-prefixes"),
 };

 protected static MorphRule[] tPrefixes = {//":t-prefixes"
  r("# t r a n s -> 1188,1413,1414,1415,1190,1191,1192,1193,1194,1195,1196",
  // t-prefixes-1, 
    // act1188 = (KILL-LEFT 5)
    // act1413 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (IS...
    // act1414 = (SETQ PREFIX 'TRANS)
    // act1415 = (CAT ADJ (AND (MORPH-ROOT STATE) (NOT (IS-FORM-OF-CAT ROOT '...
    // act1190 = (TEST (AND PREFIX (PLAUSIBLE-ROOT ROOT)))
    // act1191 = (CAT NM (AND (MORPH-ROOT STATE) (IS-FORM-OF-CAT ROOT 'PRESPA...
    // act1192 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-FORM-OF-CAT ROOT '(PRES...
    // act1193 = (CAT V (AND (MORPH-ROOT STATE) (IS-FORM-OF-CAT ROOT 'V)) EVA...
    // act1194 = (CAT N (AND (MORPH-ROOT STATE) (NOT (IS-FORM-OF-CAT ROOT 'PR...
    // act1195 = (CAT ADJ (AND (MORPH-ROOT STATE) (NOT (IS-FORM-OF-CAT ROOT '...
    // act1196 = (CAT ADV (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADV))...
    ":t-prefixes"),
  r("# t r i -> 1166,1026,1416,1182,1173",
  // t-prefixes-2, 
    // act1166 = (KILL-LEFT 3)
    // act1026 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (IS...
    // act1416 = (SETQ PREFIX 'TRI)
    // act1182 = (CAT ADJ (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-R...
    // act1173 = (CAT N (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-NON...
    ":t-prefixes"),
  r("# t h e r e -> 1188,1026,1417,1298",
  // t-prefixes-3, 
    // act1188 = (KILL-LEFT 5)
    // act1026 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (IS...
    // act1417 = (SETQ PREFIX 'THERE)
    // act1298 = (CAT ADV (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'PREP)...
    ":t-prefixes"),
 };

 protected static MorphRule[] uPrefixes = {//":u-prefixes"
  r("# u l t r a -> 1188,1026,1418,1175,1176,1177,1178,1179,1180",
  // u-prefixes-1, 
    // act1188 = (KILL-LEFT 5)
    // act1026 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (IS...
    // act1418 = (SETQ PREFIX 'ULTRA)
    // act1175 = (CAT NM (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-FO...
    // act1176 = (CAT ADJ (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-F...
    // act1177 = (CAT V (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-FOR...
    // act1178 = (CAT N (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (I...
    // act1179 = (CAT ADJ (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT ...
    // act1180 = (CAT ADV (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-R...
    ":u-prefixes"),
  r("# u n d e r -> 1188,1026,1419,1258,1191,1192,1228,1194,1305",
  // u-prefixes-2, 
    // act1188 = (KILL-LEFT 5)
    // act1026 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (IS...
    // act1419 = (SETQ PREFIX 'UNDER)
    // act1258 = (TEST (AND PREFIX (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (...
    // act1191 = (CAT NM (AND (MORPH-ROOT STATE) (IS-FORM-OF-CAT ROOT 'PRESPA...
    // act1192 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-FORM-OF-CAT ROOT '(PRES...
    // act1228 = (CAT V T EVAL (PROGN (MARK-DICT LEX 'HAS-PREFIX PREFIX T T) ...
    // act1194 = (CAT N (AND (MORPH-ROOT STATE) (NOT (IS-FORM-OF-CAT ROOT 'PR...
    // act1305 = (CAT ADJ (AND (MORPH-ROOT STATE) (NOT (IS-FORM-OF-CAT ROOT '...
    ":u-prefixes"),
  r("# u n d e r -> 1188,1026,1419,1172,1173",
  // u-prefixes-3, 
    // act1188 = (KILL-LEFT 5)
    // act1026 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (IS...
    // act1419 = (SETQ PREFIX 'UNDER)
    // act1172 = (CAT ADJ (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-R...
    // act1173 = (CAT N (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-NON...
    ":u-prefixes"),
  r("# u n -> 1211,1420,1421,1422,1423,1424,1191,1205",
  // u-prefixes-4, 
    // act1211 = (KILL-LEFT 2)
    // act1420 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (IS...
    // act1421 = (SETQ PREFIX 'UN)
    // act1422 = (CAT ADJ T EVAL (PROGN (MARK-DICT LEX 'KINDOF (LIST (LIST 'N...
    // act1423 = (CAT ADV (AND (MORPH-ROOT STATE) (IS-FORM-OF-CAT ROOT 'PASTP...
    // act1424 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-UNDO...
    // act1191 = (CAT NM (AND (MORPH-ROOT STATE) (IS-FORM-OF-CAT ROOT 'PRESPA...
    // act1205 = (CAT V T EVAL (FORMS-WITH-PREFIX ROOT 'V PREFIX))
    ":u-prefixes"),
  r("# u n -> 1211,1425,1421,1205,1426,1427",
  // u-prefixes-5, 
    // act1211 = (KILL-LEFT 2)
    // act1425 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (IS...
    // act1421 = (SETQ PREFIX 'UN)
    // act1205 = (CAT V T EVAL (FORMS-WITH-PREFIX ROOT 'V PREFIX))
    // act1426 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADJ))...
    // act1427 = (CAT ADV (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADV))...
    ":u-prefixes"),
  r("# u n -> 1211,1428,1421,1426,1427",
  // u-prefixes-6, 
    // act1211 = (KILL-LEFT 2)
    // act1428 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (IS...
    // act1421 = (SETQ PREFIX 'UN)
    // act1426 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADJ))...
    // act1427 = (CAT ADV (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'ADV))...
    ":u-prefixes"),
  r("# u n -> 1211,1429,1421,1430",
  // u-prefixes-7, 
    // act1211 = (KILL-LEFT 2)
    // act1429 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (IS...
    // act1421 = (SETQ PREFIX 'UN)
    // act1430 = (CAT V (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT ROOT 'NN) (NO...
    ":u-prefixes"),
  r("# u n -> 1211,1431,1421,1432",
  // u-prefixes-8, 
    // act1211 = (KILL-LEFT 2)
    // act1431 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (IS...
    // act1421 = (SETQ PREFIX 'UN)
    // act1432 = (CAT NM (AND (MORPH-ROOT STATE) (IS-FORM-OF-CAT ROOT 'NM)) E...
    ":u-prefixes"),
  r("# u n -> 1211,1433,1421,1434",
  // u-prefixes-9, 
    // act1211 = (KILL-LEFT 2)
    // act1433 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (IS...
    // act1421 = (SETQ PREFIX 'UN)
    // act1434 = (CAT NC (AND (MORPH-ROOT STATE) (IS-FORM-OF-CAT ROOT 'NN)) E...
    ":u-prefixes"),
  r("# u n i -> 1166,1026,1435,1436,1437",
  // u-prefixes-10, 
    // act1166 = (KILL-LEFT 3)
    // act1026 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (IS...
    // act1435 = (SETQ PREFIX 'UNI)
    // act1436 = (CAT ADJ (AND (MORPH-ROOT STATE) (OR (AND (MORPH-CHECK ROOT ...
    // act1437 = (CAT N (AND (MORPH-ROOT STATE) (IS-NONNAME-ROOT-OF-CAT ROOT ...
    ":u-prefixes"),
  r("# u p -> 1211,1438,1439,1440,1175,1176,1177,1178,1179,1180",
  // u-prefixes-11, 
    // act1211 = (KILL-LEFT 2)
    // act1438 = (TEST (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (IS...
    // act1439 = (SETQ PREFIX 'UP)
    // act1440 = (CAT ADV (AND (MORPH-ROOT STATE) (IS-NONNAME-ROOT-OF-CAT ROO...
    // act1175 = (CAT NM (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-FO...
    // act1176 = (CAT ADJ (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-F...
    // act1177 = (CAT V (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-FOR...
    // act1178 = (CAT N (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (I...
    // act1179 = (CAT ADJ (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT ...
    // act1180 = (CAT ADV (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-R...
    ":u-prefixes"),
 };

 protected static MorphRule[] miscPrefixes = {//":misc-prefixes"
  r("# f o r e -> 1170,1441,1175,1176,1177,1178,1179,1180",
  // misc-prefixes-1, 
    // act1170 = (KILL-LEFT 4)
    // act1441 = (SETQ PREFIX 'FORE)
    // act1175 = (CAT NM (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-FO...
    // act1176 = (CAT ADJ (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-F...
    // act1177 = (CAT V (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-FOR...
    // act1178 = (CAT N (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (I...
    // act1179 = (CAT ADJ (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT ...
    // act1180 = (CAT ADV (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-R...
    ":misc-prefixes"),
  r("# f o r -> 1166,1442,1441,1175,1176,1177,1178,1179,1180",
  // misc-prefixes-2, 
    // act1166 = (KILL-LEFT 3)
    // act1442 = (TEST (AND (MORPH-ROOT STATE) (NOT (PATTERN-CHECK-LEFT ROOT ...
    // act1441 = (SETQ PREFIX 'FORE)
    // act1175 = (CAT NM (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-FO...
    // act1176 = (CAT ADJ (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-F...
    // act1177 = (CAT V (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-FOR...
    // act1178 = (CAT N (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (I...
    // act1179 = (CAT ADJ (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT ...
    // act1180 = (CAT ADV (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-R...
    ":misc-prefixes"),
  r("# f i t z -> 1170,35,1443",
  // misc-prefixes-3, 
    // act1170 = (KILL-LEFT 4)
    // act35 = (TEST (PLAUSIBLE-ROOT ROOT))
    // act1443 = (CAT LASTNAME (AND (MORPH-ROOT STATE) (IS-FORM-OF-CAT ROOT '...
    ":misc-prefixes"),
  r("# f i t z -> 1444",
  // misc-prefixes-4, 
    // act1444 = (CAT LASTNAME T EVAL (PROGN (MARK-DICT LEX 'HAS-PREFIX 'FITZ...
    ":misc-prefixes"),
  r("# g a s t r o -> 1248,1445,1172,1173",
  // misc-prefixes-5, 
    // act1248 = (KILL-LEFT 6)
    // act1445 = (SETQ PREFIX 'GASTRO)
    // act1172 = (CAT ADJ (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-R...
    // act1173 = (CAT N (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-NON...
    ":misc-prefixes"),
  r("# g e o -> 1166,1446,1447,1172,1173",
  // misc-prefixes-6, 
    // act1166 = (KILL-LEFT 3)
    // act1446 = (TEST (AND (MORPH-ROOT STATE) (IS-KNOWN-WORD ROOT)))
    // act1447 = (SETQ PREFIX 'GEO)
    // act1172 = (CAT ADJ (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-R...
    // act1173 = (CAT N (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-NON...
    ":misc-prefixes"),
  r("# l i t h o -> 1188,1448,1175,1176,1177,1178,1179,1180",
  // misc-prefixes-7, 
    // act1188 = (KILL-LEFT 5)
    // act1448 = (SETQ PREFIX 'LITHO)
    // act1175 = (CAT NM (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-FO...
    // act1176 = (CAT ADJ (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-F...
    // act1177 = (CAT V (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-FOR...
    // act1178 = (CAT N (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (I...
    // act1179 = (CAT ADJ (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT ...
    // act1180 = (CAT ADV (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-R...
    ":misc-prefixes"),
  r("# q u a s i -> 1188,1449,1175,1176,1177,1178,1179,1180",
  // misc-prefixes-8, 
    // act1188 = (KILL-LEFT 5)
    // act1449 = (SETQ PREFIX 'QUASI)
    // act1175 = (CAT NM (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-FO...
    // act1176 = (CAT ADJ (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-F...
    // act1177 = (CAT V (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-FOR...
    // act1178 = (CAT N (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT (I...
    // act1179 = (CAT ADJ (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (NOT ...
    // act1180 = (CAT ADV (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-R...
    ":misc-prefixes"),
  r("# q u a d r i -> 1248,1450,1172,1173",
  // misc-prefixes-9, 
    // act1248 = (KILL-LEFT 6)
    // act1450 = (SETQ PREFIX 'QUADRI)
    // act1172 = (CAT ADJ (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-R...
    // act1173 = (CAT N (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-NON...
    ":misc-prefixes"),
  r("# q u a d r u -> 1248,1450,1172,1173",
  // misc-prefixes-10, 
    // act1248 = (KILL-LEFT 6)
    // act1450 = (SETQ PREFIX 'QUADRI)
    // act1172 = (CAT ADJ (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-R...
    // act1173 = (CAT N (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-NON...
    ":misc-prefixes"),
  r("# q u a d r a -> 1248,1450,1172,1173",
  // misc-prefixes-11, 
    // act1248 = (KILL-LEFT 6)
    // act1450 = (SETQ PREFIX 'QUADRI)
    // act1172 = (CAT ADJ (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-R...
    // act1173 = (CAT N (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-NON...
    ":misc-prefixes"),
  r("# q u a d r -> 1188,1450,1172,1173",
  // misc-prefixes-12, 
    // act1188 = (KILL-LEFT 5)
    // act1450 = (SETQ PREFIX 'QUADRI)
    // act1172 = (CAT ADJ (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-R...
    // act1173 = (CAT N (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-NON...
    ":misc-prefixes"),
  r("# v a r i -> 1170,1451,1452,1172,1173",
  // misc-prefixes-13, 
    // act1170 = (KILL-LEFT 4)
    // act1451 = (TEST (AND (MORPH-ROOT STATE) (NOT-SUFFIX ROOT '(ISM IST ITY...
    // act1452 = (SETQ PREFIX 'VARI)
    // act1172 = (CAT ADJ (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-R...
    // act1173 = (CAT N (AND (PLAUSIBLE-ROOT ROOT) (MORPH-ROOT STATE) (IS-NON...
    ":misc-prefixes"),
 };

 protected static MorphRule[] lexicalPrefixRules = {//":lexical-prefix-rules"
  r(" -> 1453,1454,1455,1456,1457,1458,1459,1460",
  // lexical-prefix-rules-1, 
    // act1453 = (TEST (AND (MORPH-ROOT STATE) (LEXICAL-PREFIX-TEST LEX)))
    // act1454 = (SETQ PREFIX (WORD1 LEX))
    // act1455 = (CAT NM (AND (MORPH-ROOT STATE) (IS-FORM-OF-CAT (WORD2 LEX) ...
    // act1456 = (CAT ADJ (AND (MORPH-ROOT STATE) (IS-FORM-OF-CAT (WORD2 LEX)...
    // act1457 = (CAT V (AND (MORPH-ROOT STATE) (IS-FORM-OF-CAT (WORD2 LEX) '...
    // act1458 = (CAT N (AND (MORPH-ROOT STATE) (NOT (IS-FORM-OF-CAT (WORD2 L...
    // act1459 = (CAT ADJ (AND (MORPH-ROOT STATE) (NOT (IS-FORM-OF-CAT (WORD2...
    // act1460 = (CAT ADV (AND (MORPH-ROOT STATE) (IS-ROOT-OF-CAT (WORD2 LEX)...
    ":lexical-prefix-rules"),
 };

 protected static MorphRule[] tempMorphCompoundRules = {//":temp-morph-compound-rules"
  r("tens digits -> 1461",
  // temp-morph-compound-rules-1, 
    // act1461 = (CAT INTEGER T EVAL (LIST (OF-TYPE INTEGER (+ (NUMERICAL-VAL...
    ":temp-morph-compound-rules"),
  r("number number -> 1462,1463",
  // temp-morph-compound-rules-2, 
    // act1462 = (TEST (AND CONNECTOR (MEMBR CONNECTOR '(- -))))
    // act1463 = (CAT ADJ (AND (NOT (NUMBERP WORD1)) (NOT (ROMAN-NUMERAL-P WO...
    ":temp-morph-compound-rules"),
  r("nn/v/adj nn/v/adj -> 1464",
  // temp-morph-compound-rules-3, 
    // act1464 = (CAT N (AND CONNECTOR (MEMBR CONNECTOR '(- -)) (EQ WORD1 WOR...
    ":temp-morph-compound-rules"),
  r("n/v/adj/adv n/v/adj/adv -> 1465",
  // temp-morph-compound-rules-4, 
    // act1465 = (CAT ADJ (AND CONNECTOR (MEMBR CONNECTOR '(- -)) (EQ WORD1 W...
    ":temp-morph-compound-rules"),
  r("prep n -> 1466,1467,1468",
  // temp-morph-compound-rules-5, 
    // act1466 = (TEST (AND CONNECTOR (MEMBR CONNECTOR '(- -)) (LOOKS-LIKE WO...
    // act1467 = (CAT ADJ T EVAL (PROGN (MARK-DICT LEX 'COMPOUND-OF (LIST (LI...
    // act1468 = (CAT N (AND (IS-FORM-OF-CAT WORD1 'ADJ) (IS-FORM-OF-CAT WORD...
    ":temp-morph-compound-rules"),
  r("prep v -> 1469",
  // temp-morph-compound-rules-6, 
    // act1469 = (CAT ADJ (AND CONNECTOR (MEMBR CONNECTOR '(- -)) (EQ WORD1 '...
    ":temp-morph-compound-rules"),
  r("vi prep -> 1470",
  // temp-morph-compound-rules-7, 
    // act1470 = (CAT ADJ (AND CONNECTOR (MEMBR CONNECTOR '(- -)) (IS-FORM-OF...
    ":temp-morph-compound-rules"),
  r("v n/v/adj -> 1471",
  // temp-morph-compound-rules-8, 
    // act1471 = (CAT ADJ (AND CONNECTOR (MEMBR CONNECTOR '(- -)) (MEMB WORD1...
    ":temp-morph-compound-rules"),
  r("n/v/adj n -> 1472,1473,1474",
  // temp-morph-compound-rules-9, 
    // act1472 = (TEST (AND CONNECTOR (MEMBR CONNECTOR '(- -)) (EQ WORD2 'TYP...
    // act1473 = (CAT ADJ (IS-FORM-OF-CAT WORD1 '(NPR ADJ)) EVAL (PROGN (MARK...
    // act1474 = (CAT N (IS-FORM-OF-CAT WORD1 'NN) EVAL (PROGN (MARK-DICT LEX...
    ":temp-morph-compound-rules"),
  r("v n/v/adj -> 1475",
  // temp-morph-compound-rules-10, 
    // act1475 = (CAT ADJ (AND CONNECTOR (MEMBR CONNECTOR '(- -)) (HYPHENADJ ...
    ":temp-morph-compound-rules"),
  r("prefix v -> 1476,1477,1478,1479,1480,1481",
  // temp-morph-compound-rules-11, 
    // act1476 = (TEST (AND (OR (AND (NULL CONNECTOR) (NOT (MEMB WORD1 *RULE-...
    // act1477 = (CAT V T EVAL (PROGN (MARK-DICT LEX 'KINDOF (LIST (LIST WORD...
    // act1478 = (CAT ADJ (OR (IS-FORM-OF-CAT WORD2 '(PRESPART PASTPART)) (AN...
    // act1479 = (CAT NM (AND (OR (IS-FORM-OF-CAT WORD2 '(PRESPART)) (AND (IS...
    // act1480 = (CAT NC (AND (IS-FORM-OF-CAT WORD2 'NC) (NOT (IS-FORM-OF-CAT...
    // act1481 = (CAT NCM (AND (OR (IS-FORM-OF-CAT WORD2 '(PRESPART)) (AND (I...
    ":temp-morph-compound-rules"),
  r("prefix adj/n -> 1482,1483,1484",
  // temp-morph-compound-rules-12, 
    // act1482 = (TEST (AND (OR CONNECTOR (NOT (MEMB WORD1 *RULE-PREFIXES*)))...
    // act1483 = (CAT ADJ (OR (IS-ROOT-OF-CAT WORD2 'ADJ) (AND (MEMB WORD1 *A...
    // act1484 = (CAT N (AND (IS-FORM-OF-CAT WORD2 'N) (NOT (AND (IS-PENALTY-...
    ":temp-morph-compound-rules"),
  r("adj adj/n -> 1485,1483,1486",
  // temp-morph-compound-rules-13, 
    // act1485 = (TEST (AND (MEMB WORD1 '(SELF))))
    // act1483 = (CAT ADJ (OR (IS-ROOT-OF-CAT WORD2 'ADJ) (AND (MEMB WORD1 *A...
    // act1486 = (CAT N (AND (IS-FORM-OF-CAT WORD2 'N) (NOT (IS-FORM-OF-CAT W...
    ":temp-morph-compound-rules"),
  r("adv/adj/integer adj/n -> 1487,1488",
  // temp-morph-compound-rules-14, 
    // act1487 = (CAT ADJ (AND CONNECTOR (MEMBR CONNECTOR '(- -)) (OR (IS-FOR...
    // act1488 = (CAT N (AND (NOT (IS-HYPHENATED WORD2)) (IS-FORM-OF-CAT WORD...
    ":temp-morph-compound-rules"),
  r("adj adj -> 1489,1467,1490,1491,1492,277",
  // temp-morph-compound-rules-15, 
    // act1489 = (TEST (AND CONNECTOR (MEMBR CONNECTOR '(- -)) (MEMB WORD1 '(...
    // act1467 = (CAT ADJ T EVAL (PROGN (MARK-DICT LEX 'COMPOUND-OF (LIST (LI...
    // act1490 = (TEST (AND CONNECTOR (MEMBR CONNECTOR '(- -)) (MEMB WORD1 '(...
    // act1491 = (CAT ADJ-PRED T EVAL (PROGN (MARK-DICT LEX 'INSTANCEOF 'COMP...
    // act1492 = (CAT ADV-PRED T EVAL '*)
    // act277 = (CAT NPR T EVAL '*)
    ":temp-morph-compound-rules"),
  r("n v -> 1493",
  // temp-morph-compound-rules-16, 
    // act1493 = (CAT N (AND CONNECTOR (MEMBR CONNECTOR '(- -)) (EQ WORD2 'TO...
    ":temp-morph-compound-rules"),
  r("adj n/v/adj -> 1494",
  // temp-morph-compound-rules-17, 
    // act1494 = (CAT ADJ (AND CONNECTOR (MEMBR CONNECTOR '(- -)) (HYPHENADJ ...
    ":temp-morph-compound-rules"),
  r("n n/v/adj/adv -> 1495,1496,301",
  // temp-morph-compound-rules-18, 
    // act1495 = (TEST (AND CONNECTOR (MEMBR CONNECTOR '(- -)) (HYPHENADJ WOR...
    // act1496 = (CAT ADJ T EVAL (PROGN (MARK-DICT LEX 'KINDOF WORD2 T T) (MA...
    // act301 = (CAT ADV T EVAL '*)
    ":temp-morph-compound-rules"),
  r("adj n/v/adj -> 1497,1498",
  // temp-morph-compound-rules-19, 
    // act1497 = (TEST (AND CONNECTOR (MEMBR CONNECTOR '(- -)) (HYPHENADJ WOR...
    // act1498 = (CAT ADJ T EVAL (PROGN (MARK-DICT LEX 'KINDOF WORD1 T T) (MA...
    ":temp-morph-compound-rules"),
  r("n n/v/adj -> 1499,162,1500",
  // temp-morph-compound-rules-20, 
    // act1499 = (TEST (AND CONNECTOR (MEMBR CONNECTOR '(- -)) (HYPHENADJ WOR...
    // act162 = (CAT ADJ T EVAL '*)
    // act1500 = (CAT N (AND (NOT (MEMB (FIRST-WORD WORD2) '(TO))) (NOT (AND ...
    ":temp-morph-compound-rules"),
  r("npl n/v/adj -> 1501,162,1502",
  // temp-morph-compound-rules-21, 
    // act1501 = (TEST (AND CONNECTOR (MEMBR CONNECTOR '(- -)) (GET-INFLECTIO...
    // act162 = (CAT ADJ T EVAL '*)
    // act1502 = (CAT N T EVAL (PROGN (MARK-DICT LEX 'KINDOF WORD1 T T) (LIST...
    ":temp-morph-compound-rules"),
  r("vt n/v/adj -> 1503",
  // temp-morph-compound-rules-22, 
    // act1503 = (CAT ADJ (AND CONNECTOR (MEMBR CONNECTOR '(- -)) (HYPHENADJ ...
    ":temp-morph-compound-rules"),
  r("n n/v/adj -> 1504",
  // temp-morph-compound-rules-23, 
    // act1504 = (CAT ADJ (AND CONNECTOR (MEMBR CONNECTOR '(- -)) (HYPHENADJ ...
    ":temp-morph-compound-rules"),
  r("adv/prep/det qword -> 1505",
  // temp-morph-compound-rules-24, 
    // act1505 = (CAT ADV (AND (MEMB WORD2 '(WHO WHAT WHEN WHERE WHY HOW WHIL...
    ":temp-morph-compound-rules"),
  r("prep prep -> 1506",
  // temp-morph-compound-rules-25, 
    // act1506 = (CAT ADJ T EVAL (PROGN (MARK-DICT LEX 'HAS-PREFIX WORD1 T T)...
    ":temp-morph-compound-rules"),
  r("pro prep -> 1507",
  // temp-morph-compound-rules-26, 
    // act1507 = (CAT ADV T EVAL (PROGN (MARK-DICT LEX 'HAS-PREFIX WORD1 T T)...
    ":temp-morph-compound-rules"),
  r("n adj -> 1508,1509,1510,1511,1512,1513",
  // temp-morph-compound-rules-27, 
    // act1508 = (TEST (AND (OR (AND (NULL CONNECTOR) (NOT (MEMB WORD1 *RULE-...
    // act1509 = (CAT NC (AND (IS-NONPENALTY-FORM-OF-CAT WORD2 'N) (NOR (AND ...
    // act1510 = (CAT NC (AND (OR (NULL CONNECTOR) (EQUAL CONNECTOR )) (IS-NO...
    // act1511 = (CAT ADJ (NOT (AND (IS-FORM-OF-CAT WORD2 'N) (OR (NOT (IS-FO...
    // act1512 = (CAT NMC (OR (AND *MAKE-GERUND-FLAG* (IS-FORM-OF-CAT WORD2 '...
    // act1513 = (CAT ADV (AND (IS-FORM-OF-CAT WORD1 'PRESPART) (IS-FORM-OF-C...
    ":temp-morph-compound-rules"),
  r("adj/n v -> 1514,1515,1516,1517,1518,1519",
  // temp-morph-compound-rules-28, 
    // act1514 = (TEST (AND (OR (AND (NULL CONNECTOR) (IS-FORM-OF-CAT WORD1 '...
    // act1515 = (CAT V (NOR (AND CONNECTOR (IS-NONPENALTY-FORM-OF-CAT WORD2 ...
    // act1516 = (CAT ADJ (AND CONNECTOR (IS-FORM-OF-CAT WORD2 '(PRESPART PAS...
    // act1517 = (CAT NM (AND (IS-FORM-OF-CAT WORD2 '(PRESPART NM)) (NOT (IS-...
    // act1518 = (CAT NC (AND (IS-FORM-OF-CAT WORD2 'NC) (NOT (IS-FORM-OF-CAT...
    // act1519 = (CAT NCM (AND (IS-FORM-OF-CAT WORD2 '(PRESPART NM)) (IS-FORM...
    ":temp-morph-compound-rules"),
  r("adv/n prespart/pastpart -> 1520",
  // temp-morph-compound-rules-29, 
    // act1520 = (CAT ADJ (AND CONNECTOR (MEMBR CONNECTOR '(- -)) (NOT (HAS-H...
    ":temp-morph-compound-rules"),
  r("n number/n/npr -> 1521,162,1522",
  // temp-morph-compound-rules-30, 
    // act1521 = (TEST (AND CONNECTOR (MEMBR CONNECTOR '(- -)) (OR (NUMBERP W...
    // act162 = (CAT ADJ T EVAL '*)
    // act1522 = (CAT N T EVAL (PROGN (MARK-DICT LEX 'KINDOF (LIST (LIST WORD...
    ":temp-morph-compound-rules"),
  r("adv prep -> 1523,1524",
  // temp-morph-compound-rules-31, 
    // act1523 = (TEST (AND CONNECTOR (MEMBR CONNECTOR '(- - _ _)) (NOT (IS-F...
    // act1524 = (CAT PREP T EVAL (PROGN (MARK-DICT LEX 'COMPOUND-OF (LIST (L...
    ":temp-morph-compound-rules"),
  r("prespart adv/adj/prep -> 1525",
  // temp-morph-compound-rules-32, 
    // act1525 = (CAT NM (AND CONNECTOR (MEMBR CONNECTOR '(- - _ _))) EVAL (P...
    ":temp-morph-compound-rules"),
  r("adv v -> 1526",
  // temp-morph-compound-rules-33, 
    // act1526 = (CAT V (AND CONNECTOR (MEMBR CONNECTOR '(- _ - _)) (LOOKS-LI...
    ":temp-morph-compound-rules"),
  r("v adv -> 1527",
  // temp-morph-compound-rules-34, 
    // act1527 = (CAT N (AND (NULL CONNECTOR) (IS-ROOT-OF-CAT WORD1 'V) (IS-N...
    ":temp-morph-compound-rules"),
  r("v adv -> 1528,1529,1530,1531,1532",
  // temp-morph-compound-rules-35, 
    // act1528 = (TEST (AND CONNECTOR (MEMBR CONNECTOR '(- -)) (IS-FORM-OF-CA...
    // act1529 = (CAT ADJ (OR (IS-ROOT-OF-CAT WORD1 'V) (IS-FORM-OF-CAT WORD1...
    // act1530 = (CAT NM (IS-FORM-OF-CAT WORD1 'PRESPART) EVAL '-S)
    // act1531 = (CAT N (IS-ROOT-OF-CAT WORD1 'V) EVAL '-S)
    // act1532 = (CAT V T EVAL (PROGN (MARK-DICT LEX 'ENTAILS (LIST WORD1 WOR...
    ":temp-morph-compound-rules"),
  r("n/adj/adv/prefix adv -> 1533",
  // temp-morph-compound-rules-36, 
    // act1533 = (CAT ADV (AND CONNECTOR (MEMBR CONNECTOR '(- -))) EVAL (PROG...
    ":temp-morph-compound-rules"),
  r("adj n/v/adj/adv -> 1462,1534,1535,1536",
  // temp-morph-compound-rules-37, 
    // act1462 = (TEST (AND CONNECTOR (MEMBR CONNECTOR '(- -))))
    // act1534 = (CAT ADJ (OR (IS-FORM-OF-CAT WORD2 '(N V ADJ)) (AND (IS-ROOT...
    // act1535 = (CAT ADV (IS-FORM-OF-CAT WORD2 '(ADV)) EVAL (PROGN (MARK-DIC...
    // act1536 = (CAT N (OR (AND (IS-ROOT-OF-CAT WORD1 'V) (IS-ROOT-OF-CAT WO...
    ":temp-morph-compound-rules"),
  r("n/v/adj/adv/prefix/prep prespart -> 1537,1538,162,1539",
  // temp-morph-compound-rules-38, 
    // act1537 = (TEST (AND (IS-ROOT-OF-CAT WORD1 '(N V ADJ ADV PREFIX PREP))...
    // act1538 = (CAT V T EVAL (PROGN (MAKE-FORMS-FOR-COMPOUND WORD1 WORD2 'V...
    // act162 = (CAT ADJ T EVAL '*)
    // act1539 = (CAT NM T EVAL (PROGN (MARK-DICT LEX 'KINDOF (LIST (LIST WOR...
    ":temp-morph-compound-rules"),
  r("nn/v/adj/adv/prefix/prep/conj v -> 1540,1541,1542",
  // temp-morph-compound-rules-39, 
    // act1540 = (TEST (AND (IS-ROOT-OF-CAT WORD1 '(NN V ADJ PREFIX PREP CONJ...
    // act1541 = (CAT V (AND (NOT (GET-V-ROOTS WORD2)) (NOT (MEMB WORD2 '(MAN...
    // act1542 = (CAT N (AND (IS-FORM-OF-CAT WORD2 'N) (NOT (GET-INFLECTION-R...
    ":temp-morph-compound-rules"),
  r("nn/v/adj/adv/prefix/prep/conj v -> 1543,1544,1545,1546",
  // temp-morph-compound-rules-40, 
    // act1543 = (TEST (AND (IS-ROOT-OF-CAT WORD1 '(NN V ADJ PREFIX PREP CONJ...
    // act1544 = (CAT V T EVAL (PROGN (MARK-DICT LEX 'HAS-PREFIX WORD1 T T) (...
    // act1545 = (CAT ADJ (IS-FORM-OF-CAT WORD2 '(PRESPART PASTPART ADJ)) EVA...
    // act1546 = (CAT N (AND (IS-FORM-OF-CAT WORD2 '(N PRESPART)) (NOT (AND (...
    ":temp-morph-compound-rules"),
  r("nn/v/adj/adv/prefix/prep adj -> 1537,1547",
  // temp-morph-compound-rules-41, 
    // act1537 = (TEST (AND (IS-ROOT-OF-CAT WORD1 '(N V ADJ ADV PREFIX PREP))...
    // act1547 = (CAT ADJ (AND (LOOKS-LIKE WORD2 'ADJ) (NOT (IS-FORM-OF-CAT W...
    ":temp-morph-compound-rules"),
  r("nn/v/adj/prefix/prep/conj n -> 1548",
  // temp-morph-compound-rules-42, 
    // act1548 = (CAT N (AND (IS-ROOT-OF-CAT WORD2 'NN) (NOT (GET-INFLECTION-...
    ":temp-morph-compound-rules"),
  r("nn/v/adj/prefix/prep/conj n -> 1549",
  // temp-morph-compound-rules-43, 
    // act1549 = (CAT N (AND (NOT (AND (IS-PENALTY-FORM-OF-CAT WORD2 'N 2) (I...
    ":temp-morph-compound-rules"),
  r("n/v/adj/adv pastpart -> 1550,1551",
  // temp-morph-compound-rules-44, 
    // act1550 = (TEST (AND *TRY-COMPOUND-PARTICIPLES* (LET ((APPARENT-ROOT (...
    // act1551 = (CAT ADJ (AND CONNECTOR (MEMB CONNECTOR '(- -))) EVAL (PROGN...
    ":temp-morph-compound-rules"),
  r("n pastpart -> 1550,1552,1538",
  // temp-morph-compound-rules-45, 
    // act1550 = (TEST (AND *TRY-COMPOUND-PARTICIPLES* (LET ((APPARENT-ROOT (...
    // act1552 = (CAT ADJ T EVAL (PROGN (MARK-DICT LEX 'KINDOF (LIST (LIST WO...
    // act1538 = (CAT V T EVAL (PROGN (MAKE-FORMS-FOR-COMPOUND WORD1 WORD2 'V...
    ":temp-morph-compound-rules"),
  r("n pastpart -> 1553",
  // temp-morph-compound-rules-46, 
    // act1553 = (CAT ADJ (AND *TRY-COMPOUND-PARTICIPLES* (LET ((APPARENT-ROO...
    ":temp-morph-compound-rules"),
  r("n pastpart -> 1554",
  // temp-morph-compound-rules-47, 
    // act1554 = (CAT ADJ (AND *TRY-COMPOUND-PARTICIPLES* (IS-NONPENALTY-FORM...
    ":temp-morph-compound-rules"),
  r("n pastpart -> 1555,1556",
  // temp-morph-compound-rules-48, 
    // act1555 = (TEST (NOT (IS-FORM-OF-CAT WORD1 'PREFIX)))
    // act1556 = (CAT ADJ T EVAL (PROGN (MARK-DICT LEX 'KINDOF WORD2 T T) (MA...
    ":temp-morph-compound-rules"),
  r("adv pastpart -> 1557,1558",
  // temp-morph-compound-rules-49, 
    // act1557 = (TEST (AND (NOT (IS-FORM-OF-CAT WORD1 'PREFIX)) (NOT (MEMB W...
    // act1558 = (CAT ADJ (AND *TRY-COMPOUND-PARTICIPLES* (IS-ROOT-OF-CAT WOR...
    ":temp-morph-compound-rules"),
  r("nn/v/adj/adv/prefix/prep/conj v -> 1540,1559",
  // temp-morph-compound-rules-50, 
    // act1540 = (TEST (AND (IS-ROOT-OF-CAT WORD1 '(NN V ADJ PREFIX PREP CONJ...
    // act1559 = (CAT V (NOT (GET-V-ROOTS WORD2)) EVAL (PROGN (MARK-DICT LEX ...
    ":temp-morph-compound-rules"),
  r("nn/v/adj/adv/prefix/prep/conj v -> 1540,1560",
  // temp-morph-compound-rules-51, 
    // act1540 = (TEST (AND (IS-ROOT-OF-CAT WORD1 '(NN V ADJ PREFIX PREP CONJ...
    // act1560 = (CAT V T EVAL (PROGN (MARK-DICT LEX 'ENTAILS WORD1 T T) (MAR...
    ":temp-morph-compound-rules"),
  r("firstname firstname -> 1561,1562,1563,1564",
  // temp-morph-compound-rules-52, 
    // act1561 = (TEST (AND (IS-KNOWN-WORD WORD1) (IS-KNOWN-WORD WORD2)))
    // act1562 = (CAT FEMALEFIRSTNAME (OR (IS-FORM-OF-CAT WORD1 'FEMALEFIRSTN...
    // act1563 = (CAT MALEFIRSTNAME (OR (IS-FORM-OF-CAT WORD1 'MALEFIRSTNAME)...
    // act1564 = (CAT FIRSTNAME (NOR (IS-FORM-OF-CAT WORD1 'FEMALEFIRSTNAME) ...
    ":temp-morph-compound-rules"),
  r("prep n -> 1565,162",
  // temp-morph-compound-rules-53, 
    // act1565 = (TEST (AND CONNECTOR (MEMBR CONNECTOR '(- -)) NIL))
    // act162 = (CAT ADJ T EVAL '*)
    ":temp-morph-compound-rules"),
  r("prefix suffix -> 162,1566",
  // temp-morph-compound-rules-54, 
    // act162 = (CAT ADJ T EVAL '*)
    // act1566 = (CAT N T EVAL (PROGN (MARK-DICT LEX 'HAS-SUFFIX WORD2 T T) (...
    ":temp-morph-compound-rules"),
  r("prefix prefix -> 1567",
  // temp-morph-compound-rules-55, 
    // act1567 = (CAT PREFIX T EVAL (PROGN (MARK-DICT LEX 'COMPOUND-OF (LIST ...
    ":temp-morph-compound-rules"),
 };

 protected static MorphRule[] ordinalRules = {//":ordinal-rules"
  r("n d t h # -> 61,1568,1569",
  // ordinal-rules-1, conditional phase-one
    // act61 = (KILL 4)
    // act1568 = (TEST (AND (NUMBERP ROOT) (MORPH-ROOT STATE) (EQUAL (MOD ROO...
    // act1569 = (CAT N T EVAL (PROGN (MARK-DICT LEX 'VALUE ROOT T T) (LIST L...
    ":ordinal-rules", false, true, false),
  r("t h # -> 50,555,1064,1065,162,1068",
  // ordinal-rules-2, 
    // act50 = (KILL 2)
    // act555 = (TEST (NUMBERP ROOT))
    // act1064 = (CAT ORD T EVAL '*)
    // act1065 = (CAT N T EVAL (PROGN (MARK-DICT LEX 'PENALTIES '(N 1 ADV 2) ...
    // act162 = (CAT ADJ T EVAL '*)
    // act1068 = (CAT ADV T EVAL (PROGN (MARK-DICT LEX 'KINDOF (MAKE-STRUCTUR...
    ":ordinal-rules"),
  r("s t # -> 50,1570,1571,1572,162,1573",
  // ordinal-rules-3, conditional phase-one
    // act50 = (KILL 2)
    // act1570 = (TEST (AND (NUMBERP ROOT) (MORPH-ROOT STATE) (EQUAL (MOD ROO...
    // act1571 = (CAT ORD T EVAL (PROGN (MARK-DICT LEX 'INSTANCEOF 'ORDINAL T...
    // act1572 = (CAT N T EVAL (LIST LEX '(NUMBER SG) '(PENALTY 1) '(INSTANCE...
    // act162 = (CAT ADJ T EVAL '*)
    // act1573 = (CAT ADV T EVAL (LIST LEX '(PENALTY 2) (LIST 'KINDOF (LIST '...
    ":ordinal-rules", false, true, false),
  r("n d # -> 50,1568,1571,162,1573",
  // ordinal-rules-4, conditional phase-one
    // act50 = (KILL 2)
    // act1568 = (TEST (AND (NUMBERP ROOT) (MORPH-ROOT STATE) (EQUAL (MOD ROO...
    // act1571 = (CAT ORD T EVAL (PROGN (MARK-DICT LEX 'INSTANCEOF 'ORDINAL T...
    // act162 = (CAT ADJ T EVAL '*)
    // act1573 = (CAT ADV T EVAL (LIST LEX '(PENALTY 2) (LIST 'KINDOF (LIST '...
    ":ordinal-rules", false, true, false),
  r("r d # -> 50,1574,1571,1572,162,1573",
  // ordinal-rules-5, conditional phase-one
    // act50 = (KILL 2)
    // act1574 = (TEST (AND (NUMBERP ROOT) (MORPH-ROOT STATE) (EQUAL (MOD ROO...
    // act1571 = (CAT ORD T EVAL (PROGN (MARK-DICT LEX 'INSTANCEOF 'ORDINAL T...
    // act1572 = (CAT N T EVAL (LIST LEX '(NUMBER SG) '(PENALTY 1) '(INSTANCE...
    // act162 = (CAT ADJ T EVAL '*)
    // act1573 = (CAT ADV T EVAL (LIST LEX '(PENALTY 2) (LIST 'KINDOF (LIST '...
    ":ordinal-rules", false, true, false),
  r("n d t h s # -> 57,1575",
  // ordinal-rules-6, conditional phase-one
    // act57 = (KILL 5)
    // act1575 = (CAT N (AND (NUMBERP ROOT) (MORPH-ROOT STATE) (EQUAL (MOD RO...
    ":ordinal-rules", false, true, false),
  r("t h s # -> 19,1576",
  // ordinal-rules-7, conditional phase-one
    // act19 = (KILL 3)
    // act1576 = (CAT N (AND (NUMBERP ROOT)) EVAL (PROGN (MARK-DICT LEX 'VALU...
    ":ordinal-rules", false, true, false),
  r("s t s # -> 19,1577",
  // ordinal-rules-8, conditional phase-one
    // act19 = (KILL 3)
    // act1577 = (CAT N (AND (NUMBERP ROOT) (MORPH-ROOT STATE) (EQUAL (MOD RO...
    ":ordinal-rules", false, true, false),
  r("n d s # -> 19,1578",
  // ordinal-rules-9, conditional phase-one
    // act19 = (KILL 3)
    // act1578 = (CAT N (AND (NUMBERP ROOT) (MORPH-ROOT STATE) (EQUAL (MOD RO...
    ":ordinal-rules", false, true, false),
  r("r d s # -> 19,1579",
  // ordinal-rules-10, conditional phase-one
    // act19 = (KILL 3)
    // act1579 = (CAT N (AND (NUMBERP ROOT) (MORPH-ROOT STATE) (EQUAL (MOD RO...
    ":ordinal-rules", false, true, false),
  r("n d t h # -> 61,1580,1581",
  // ordinal-rules-11, conditional phase-one
    // act61 = (KILL 4)
    // act1580 = (TEST (AND (MORPH-ROOT STATE) (IS-FORM-OF-CAT ROOT 'NUMBER) ...
    // act1581 = (CAT NUMBER T EVAL (PROGN (MARK-DICT LEX 'VALUE (NUMERICAL-V...
    ":ordinal-rules", false, true, false),
  r("t h # -> 50,1582,1583",
  // ordinal-rules-12, conditional phase-one
    // act50 = (KILL 2)
    // act1582 = (TEST (AND (MORPH-ROOT STATE) (IS-FORM-OF-CAT ROOT 'NUMBER) ...
    // act1583 = (CAT NUMBER T EVAL (PROGN (MARK-DICT LEX 'VALUE (NUMERICAL-V...
    ":ordinal-rules", false, true, false),
  r("s t # -> 50,1584,1585",
  // ordinal-rules-13, conditional phase-one
    // act50 = (KILL 2)
    // act1584 = (TEST (AND (MORPH-ROOT STATE) (IS-FORM-OF-CAT ROOT 'NUMBER) ...
    // act1585 = (CAT NUMBER T EVAL (PROGN (MARK-DICT LEX 'VALUE (NUMERICAL-V...
    ":ordinal-rules", false, true, false),
  r("n d # -> 50,1580,1586",
  // ordinal-rules-14, conditional phase-one
    // act50 = (KILL 2)
    // act1580 = (TEST (AND (MORPH-ROOT STATE) (IS-FORM-OF-CAT ROOT 'NUMBER) ...
    // act1586 = (CAT NUMBER T EVAL (PROGN (MARK-DICT LEX 'VALUE (NUMERICAL-V...
    ":ordinal-rules", false, true, false),
  r("r d # -> 50,1587,1588",
  // ordinal-rules-15, conditional phase-one
    // act50 = (KILL 2)
    // act1587 = (TEST (AND (MORPH-ROOT STATE) (IS-FORM-OF-CAT ROOT 'NUMBER) ...
    // act1588 = (CAT NUMBER T EVAL (PROGN (MARK-DICT LEX 'VALUE (NUMERICAL-V...
    ":ordinal-rules", false, true, false),
  r("n d t h s # -> 57,1580,1589",
  // ordinal-rules-16, conditional phase-one
    // act57 = (KILL 5)
    // act1580 = (TEST (AND (MORPH-ROOT STATE) (IS-FORM-OF-CAT ROOT 'NUMBER) ...
    // act1589 = (CAT NUMBER T EVAL (PROGN (MARK-DICT LEX 'VALUE (NUMERICAL-V...
    ":ordinal-rules", false, true, false),
  r("t h s # -> 19,1582,1590",
  // ordinal-rules-17, conditional phase-one
    // act19 = (KILL 3)
    // act1582 = (TEST (AND (MORPH-ROOT STATE) (IS-FORM-OF-CAT ROOT 'NUMBER) ...
    // act1590 = (CAT NUMBER T EVAL (PROGN (MARK-DICT LEX 'VALUE (NUMERICAL-V...
    ":ordinal-rules", false, true, false),
  r("s t s # -> 19,1584,1591",
  // ordinal-rules-18, conditional phase-one
    // act19 = (KILL 3)
    // act1584 = (TEST (AND (MORPH-ROOT STATE) (IS-FORM-OF-CAT ROOT 'NUMBER) ...
    // act1591 = (CAT NUMBER T EVAL (PROGN (MARK-DICT LEX 'VALUE (NUMERICAL-V...
    ":ordinal-rules", false, true, false),
  r("n d s # -> 19,1580,1592",
  // ordinal-rules-19, conditional phase-one
    // act19 = (KILL 3)
    // act1580 = (TEST (AND (MORPH-ROOT STATE) (IS-FORM-OF-CAT ROOT 'NUMBER) ...
    // act1592 = (CAT NUMBER T EVAL (PROGN (MARK-DICT LEX 'VALUE (NUMERICAL-V...
    ":ordinal-rules", false, true, false),
  r("r d s # -> 19,1587,1593",
  // ordinal-rules-20, conditional phase-one
    // act19 = (KILL 3)
    // act1587 = (TEST (AND (MORPH-ROOT STATE) (IS-FORM-OF-CAT ROOT 'NUMBER) ...
    // act1593 = (CAT NUMBER T EVAL (PROGN (MARK-DICT LEX 'VALUE (NUMERICAL-V...
    ":ordinal-rules", false, true, false),
 };

 protected static MorphRule[] pluralRule = {//":plural-rule"
  r(" -> 1594,22,1595",
  // plural-rule-1, conditional phase-one
    // act1594 = (TEST (AND (MORPH-ROOT STATE) (TEST-ICODE ROOT 'N '(-S))))
    // act22 = (ADD S)
    // act1595 = (RETURN)
    ":plural-rule", false, true, false),
  r(" -> 1596,1132,1595",
  // plural-rule-2, conditional phase-one
    // act1596 = (TEST (AND (MORPH-ROOT STATE) (TEST-ICODE ROOT 'N '(-ES))))
    // act1132 = (ADD E S)
    // act1595 = (RETURN)
    ":plural-rule", false, true, false),
  r(" -> 1597,1598,1595",
  // plural-rule-3, conditional phase-one
    // act1597 = (TEST (AND (MORPH-ROOT STATE) (TEST-ICODE ROOT 'N '(-APOSTRO...
    // act1598 = (ADD ' S)
    // act1595 = (RETURN)
    ":plural-rule", false, true, false),
  r("f # -> 1599,24,1600,1595",
  // plural-rule-4, conditional phase-one
    // act1599 = (TEST (AND (MORPH-ROOT STATE) (TEST-ICODE ROOT 'N '(-VES))))
    // act24 = (KILL 1)
    // act1600 = (ADD V E S)
    // act1595 = (RETURN)
    ":plural-rule", false, true, false),
  r("x # -> 1601,24,1602,1595",
  // plural-rule-5, conditional phase-one
    // act1601 = (TEST (AND (MORPH-ROOT STATE) (TEST-ICODE ROOT 'N '(-CES))))
    // act24 = (KILL 1)
    // act1602 = (ADD C E S)
    // act1595 = (RETURN)
    ":plural-rule", false, true, false),
  r("consonant # -> 1603,1604,1595",
  // plural-rule-6, conditional phase-one
    // act1603 = (TEST (AND (MORPH-ROOT STATE) (TEST-ICODE ROOT 'N '(-*ES))))
    // act1604 = (ADD & E S)
    // act1595 = (RETURN)
    ":plural-rule", false, true, false),
  r("y # -> 1605,24,1606,1595",
  // plural-rule-7, conditional phase-one
    // act1605 = (TEST (AND (MORPH-ROOT STATE) (TEST-ICODE ROOT 'N '(-IES))))
    // act24 = (KILL 1)
    // act1606 = (ADD I E S)
    // act1595 = (RETURN)
    ":plural-rule", false, true, false),
  r(" -> 1607,1595",
  // plural-rule-8, conditional phase-one
    // act1607 = (TEST (AND (MORPH-ROOT STATE) (TEST-ICODE ROOT 'N '(NOPL UNI...
    // act1595 = (RETURN)
    ":plural-rule", false, true, false),
  r(" -> 1608,225,1595",
  // plural-rule-9, conditional phase-one
    // act1608 = (TEST (AND (MORPH-ROOT STATE) (TEST-ICODE ROOT 'N '(-EN))))
    // act225 = (ADD E N)
    // act1595 = (RETURN)
    ":plural-rule", false, true, false),
  r("m a n # -> 1609,50,225,1595",
  // plural-rule-10, conditional phase-one
    // act1609 = (TEST (AND (MORPH-ROOT STATE) (TEST-ICODE ROOT 'N '(-MEN))))
    // act50 = (KILL 2)
    // act225 = (ADD E N)
    // act1595 = (RETURN)
    ":plural-rule", false, true, false),
  r("a # -> 272,68,1595",
  // plural-rule-11, conditional phase-one
    // act272 = (TEST (AND (MORPH-ROOT STATE) (TEST-ICODE ROOT 'N '-AE)))
    // act68 = (ADD E)
    // act1595 = (RETURN)
    ":plural-rule", false, true, false),
  r("u s # -> 1610,50,290,1595",
  // plural-rule-12, conditional phase-one
    // act1610 = (TEST (AND (MORPH-ROOT STATE) (TEST-ICODE ROOT 'N '-I)))
    // act50 = (KILL 2)
    // act290 = (ADD I)
    // act1595 = (RETURN)
    ":plural-rule", false, true, false),
  r("o # -> 1610,24,290,1595",
  // plural-rule-13, conditional phase-one
    // act1610 = (TEST (AND (MORPH-ROOT STATE) (TEST-ICODE ROOT 'N '-I)))
    // act24 = (KILL 1)
    // act290 = (ADD I)
    // act1595 = (RETURN)
    ":plural-rule", false, true, false),
  r("e # -> 1610,24,290,1595",
  // plural-rule-14, conditional phase-one
    // act1610 = (TEST (AND (MORPH-ROOT STATE) (TEST-ICODE ROOT 'N '-I)))
    // act24 = (KILL 1)
    // act290 = (ADD I)
    // act1595 = (RETURN)
    ":plural-rule", false, true, false),
  r(" -> 1610,290,1595",
  // plural-rule-15, conditional phase-one
    // act1610 = (TEST (AND (MORPH-ROOT STATE) (TEST-ICODE ROOT 'N '-I)))
    // act290 = (ADD I)
    // act1595 = (RETURN)
    ":plural-rule", false, true, false),
  r("u m # -> 1611,50,117,1595",
  // plural-rule-16, conditional phase-one
    // act1611 = (TEST (AND (MORPH-ROOT STATE) (TEST-ICODE ROOT 'N '-A)))
    // act50 = (KILL 2)
    // act117 = (ADD A)
    // act1595 = (RETURN)
    ":plural-rule", false, true, false),
  r("o n # -> 1611,50,117,1595",
  // plural-rule-17, conditional phase-one
    // act1611 = (TEST (AND (MORPH-ROOT STATE) (TEST-ICODE ROOT 'N '-A)))
    // act50 = (KILL 2)
    // act117 = (ADD A)
    // act1595 = (RETURN)
    ":plural-rule", false, true, false),
  r("vowel consonant # -> 1611,50,117,1595",
  // plural-rule-18, conditional phase-one
    // act1611 = (TEST (AND (MORPH-ROOT STATE) (TEST-ICODE ROOT 'N '-A)))
    // act50 = (KILL 2)
    // act117 = (ADD A)
    // act1595 = (RETURN)
    ":plural-rule", false, true, false),
  r("i s # -> 1612,50,1132,1595",
  // plural-rule-19, conditional phase-one
    // act1612 = (TEST (AND (MORPH-ROOT STATE) (TEST-ICODE ROOT 'N 'IS-ES)))
    // act50 = (KILL 2)
    // act1132 = (ADD E S)
    // act1595 = (RETURN)
    ":plural-rule", false, true, false),
  r("o # -> 1610,24,290,1595",
  // plural-rule-20, conditional phase-one
    // act1610 = (TEST (AND (MORPH-ROOT STATE) (TEST-ICODE ROOT 'N '-I)))
    // act24 = (KILL 1)
    // act290 = (ADD I)
    // act1595 = (RETURN)
    ":plural-rule", false, true, false),
  r(" -> 1613,1598,1595",
  // plural-rule-21, 
    // act1613 = (TEST (AND (MORPH-ROOT STATE) (OR (< (NCHARS LEX) 3) (NOT (A...
    // act1598 = (ADD ' S)
    // act1595 = (RETURN)
    ":plural-rule"),
  r("consonant vowel s|z # -> 1614,1604,1595",
  // plural-rule-22, 
    // act1614 = (TEST (AND (MORPH-ROOT STATE) (FINAL-STRESS ROOT)))
    // act1604 = (ADD & E S)
    // act1595 = (RETURN)
    ":plural-rule"),
  r("q u vowel s|z # -> 1614,1604,1595",
  // plural-rule-23, 
    // act1614 = (TEST (AND (MORPH-ROOT STATE) (FINAL-STRESS ROOT)))
    // act1604 = (ADD & E S)
    // act1595 = (RETURN)
    ":plural-rule"),
  r("c|s h # -> 1132,1595",
  // plural-rule-24, 
    // act1132 = (ADD E S)
    // act1595 = (RETURN)
    ":plural-rule"),
  r("j|s|x|z # -> 1132,1595",
  // plural-rule-25, 
    // act1132 = (ADD E S)
    // act1595 = (RETURN)
    ":plural-rule"),
  r(" -> 1615,22,1595",
  // plural-rule-26, 
    // act1615 = (TEST (AND (MORPH-ROOT STATE) (LAST-CHAR-CAPITALIZED-P)))
    // act22 = (ADD S)
    // act1595 = (RETURN)
    ":plural-rule"),
  r("a t u m # -> 50,117,1595,553,22,1595",
  // plural-rule-27, 
    // act50 = (KILL 2)
    // act117 = (ADD A)
    // act1595 = (RETURN)
    // act553 = (KILL 0)
    // act22 = (ADD S)
    // act1595 = (RETURN)
    ":plural-rule"),
  r("consonant y # -> 24,1606,1595",
  // plural-rule-28, 
    // act24 = (KILL 1)
    // act1606 = (ADD I E S)
    // act1595 = (RETURN)
    ":plural-rule"),
  r("q u y # -> 24,1606,1595",
  // plural-rule-29, 
    // act24 = (KILL 1)
    // act1606 = (ADD I E S)
    // act1595 = (RETURN)
    ":plural-rule"),
  r("h u m a n # -> 22,1595",
  // plural-rule-30, 
    // act22 = (ADD S)
    // act1595 = (RETURN)
    ":plural-rule"),
  r("g e r m a n # -> 22,1595",
  // plural-rule-31, 
    // act22 = (ADD S)
    // act1595 = (RETURN)
    ":plural-rule"),
  r("m a n # -> 1616,22,1595,1617,19,1618,1595",
  // plural-rule-32, conditional phase-one
    // act1616 = (TEST (AND (MORPH-ROOT STATE) (IS-FORM-OF-CAT LEX '(NPR LAST...
    // act22 = (ADD S)
    // act1595 = (RETURN)
    // act1617 = (TEST (AND *INFLECT-MAN-MEN-FLAG* (MORPH-ROOT STATE) (IS-ROO...
    // act19 = (KILL 3)
    // act1618 = (ADD M E N)
    // act1595 = (RETURN)
    ":plural-rule", false, true, false),
  r("m a n # -> 1619,50,225,1595",
  // plural-rule-33, 
    // act1619 = (TEST *INFLECT-MAN-MEN-FLAG*)
    // act50 = (KILL 2)
    // act225 = (ADD E N)
    // act1595 = (RETURN)
    ":plural-rule"),
  r("w i f e # -> 50,1600,1595",
  // plural-rule-34, 
    // act50 = (KILL 2)
    // act1600 = (ADD V E S)
    // act1595 = (RETURN)
    ":plural-rule"),
  r("- i n - l a w # -> 113,1620,1595",
  // plural-rule-35, 
    // act113 = (KILL 7)
    // act1620 = (ADD S - I N - L A W)
    // act1595 = (RETURN)
    ":plural-rule"),
  r(" -> 1621,1598,1595",
  // plural-rule-36, 
    // act1621 = (TEST (AND (MORPH-ROOT STATE) (NOT (ALPHA-CHAR-P (CHAR (MKST...
    // act1598 = (ADD ' S)
    // act1595 = (RETURN)
    ":plural-rule"),
  r(" -> 22,1595",
  // plural-rule-37, 
    // act22 = (ADD S)
    // act1595 = (RETURN)
    ":plural-rule"),
 };

 protected static MorphRule[] thirdSingRule = {//":third-sing-rule"
  r(" -> 1622,22,1595",
  // third-sing-rule-1, conditional phase-one
    // act1622 = (TEST (AND (MORPH-ROOT STATE) (TEST-ICODE ROOT 'V '(S-D S-ED...
    // act22 = (ADD S)
    // act1595 = (RETURN)
    ":third-sing-rule", false, true, false),
  r(" -> 1623,1132,1595",
  // third-sing-rule-2, conditional phase-one
    // act1623 = (TEST (AND (MORPH-ROOT STATE) (TEST-ICODE ROOT 'V '(ES-ED ES...
    // act1132 = (ADD E S)
    // act1595 = (RETURN)
    ":third-sing-rule", false, true, false),
  r("consonant # -> 1624,1604,1595",
  // third-sing-rule-3, conditional phase-one
    // act1624 = (TEST (AND (MORPH-ROOT STATE) (TEST-ICODE ROOT 'V '(*ES-*ED)...
    // act1604 = (ADD & E S)
    // act1595 = (RETURN)
    ":third-sing-rule", false, true, false),
  r("y # -> 1625,24,1606,1595",
  // third-sing-rule-4, conditional phase-one
    // act1625 = (TEST (AND (MORPH-ROOT STATE) (TEST-ICODE ROOT 'V '(IES-IED)...
    // act24 = (KILL 1)
    // act1606 = (ADD I E S)
    // act1595 = (RETURN)
    ":third-sing-rule", false, true, false),
  r("c|s h # -> 1132,1595",
  // third-sing-rule-5, 
    // act1132 = (ADD E S)
    // act1595 = (RETURN)
    ":third-sing-rule"),
  r("s|x|z # -> 1132,1595",
  // third-sing-rule-6, 
    // act1132 = (ADD E S)
    // act1595 = (RETURN)
    ":third-sing-rule"),
  r(" -> 1615,22,1595",
  // third-sing-rule-7, 
    // act1615 = (TEST (AND (MORPH-ROOT STATE) (LAST-CHAR-CAPITALIZED-P)))
    // act22 = (ADD S)
    // act1595 = (RETURN)
    ":third-sing-rule"),
  r("consonant y # -> 24,1606,1595",
  // third-sing-rule-8, 
    // act24 = (KILL 1)
    // act1606 = (ADD I E S)
    // act1595 = (RETURN)
    ":third-sing-rule"),
  r("q u y # -> 24,1606,1595",
  // third-sing-rule-9, 
    // act24 = (KILL 1)
    // act1606 = (ADD I E S)
    // act1595 = (RETURN)
    ":third-sing-rule"),
  r(" -> 22,1595",
  // third-sing-rule-10, 
    // act22 = (ADD S)
    // act1595 = (RETURN)
    ":third-sing-rule"),
 };

 protected static MorphRule[] pastRule = {//":past-rule"
  r(" -> 1626,344,1595",
  // past-rule-1, conditional phase-one
    // act1626 = (TEST (AND (MORPH-ROOT STATE) (TEST-ICODE ROOT 'V '(S-D))))
    // act344 = (ADD D)
    // act1595 = (RETURN)
    ":past-rule", false, true, false),
  r(" -> 1627,1628,1595",
  // past-rule-2, conditional phase-one
    // act1627 = (TEST (AND (MORPH-ROOT STATE) (TEST-ICODE ROOT 'V '(S-KED)))...
    // act1628 = (ADD K E D)
    // act1595 = (RETURN)
    ":past-rule", false, true, false),
  r(" -> 1629,1630,1595",
  // past-rule-3, conditional phase-one
    // act1629 = (TEST (AND (MORPH-ROOT STATE) (TEST-ICODE ROOT 'V '(S-ED ES-...
    // act1630 = (ADD E D)
    // act1595 = (RETURN)
    ":past-rule", false, true, false),
  r("consonant # -> 1631,1632,1595",
  // past-rule-4, conditional phase-one
    // act1631 = (TEST (AND (MORPH-ROOT STATE) (TEST-ICODE ROOT 'V '(S-*ED ES...
    // act1632 = (ADD & E D)
    // act1595 = (RETURN)
    ":past-rule", false, true, false),
  r(" -> 1633,1630,1595,1632,1595",
  // past-rule-5, conditional phase-one
    // act1633 = (TEST (AND (MORPH-ROOT STATE) (TEST-ICODE ROOT 'V '(S-ED-*ED...
    // act1630 = (ADD E D)
    // act1595 = (RETURN)
    // act1632 = (ADD & E D)
    // act1595 = (RETURN)
    ":past-rule", false, true, false),
  r("e # -> 1615,344,1595",
  // past-rule-6, 
    // act1615 = (TEST (AND (MORPH-ROOT STATE) (LAST-CHAR-CAPITALIZED-P)))
    // act344 = (ADD D)
    // act1595 = (RETURN)
    ":past-rule"),
  r(" -> 1615,1630,1595",
  // past-rule-7, 
    // act1615 = (TEST (AND (MORPH-ROOT STATE) (LAST-CHAR-CAPITALIZED-P)))
    // act1630 = (ADD E D)
    // act1595 = (RETURN)
    ":past-rule"),
  r("y # -> 1625,24,1634,1595",
  // past-rule-8, conditional phase-one
    // act1625 = (TEST (AND (MORPH-ROOT STATE) (TEST-ICODE ROOT 'V '(IES-IED)...
    // act24 = (KILL 1)
    // act1634 = (ADD I E D)
    // act1595 = (RETURN)
    ":past-rule", false, true, false),
  r("consonant vowel b|d|g|l|m|n|p|r|s|t # -> 1635,1632,1595",
  // past-rule-9, conditional phase-one
    // act1635 = (TEST (AND (MORPH-ROOT STATE) (GETDICT ROOT 'COMPOUND-OF) (T...
    // act1632 = (ADD & E D)
    // act1595 = (RETURN)
    ":past-rule", false, true, false),
  r("q u vowel b|d|g|l|m|n|p|r|s|t # -> 1635,1632,1595",
  // past-rule-10, conditional phase-one
    // act1635 = (TEST (AND (MORPH-ROOT STATE) (GETDICT ROOT 'COMPOUND-OF) (T...
    // act1632 = (ADD & E D)
    // act1595 = (RETURN)
    ":past-rule", false, true, false),
  r("consonant vowel b|d|g|l|m|n|p|r|s|t # -> 1636,1632,1595,142,1630,1595",
  // past-rule-11, 
    // act1636 = (TEST (AND (MORPH-ROOT STATE) (NOT (GETDICT ROOT 'HAS-PREFIX...
    // act1632 = (ADD & E D)
    // act1595 = (RETURN)
    // act142 = (TEST (POLYSYLLABIC ROOT))
    // act1630 = (ADD E D)
    // act1595 = (RETURN)
    ":past-rule"),
  r("q u vowel b|d|g|l|m|n|p|r|s|t # -> 1632,1595,142,1630,1595",
  // past-rule-12, 
    // act1632 = (ADD & E D)
    // act1595 = (RETURN)
    // act142 = (TEST (POLYSYLLABIC ROOT))
    // act1630 = (ADD E D)
    // act1595 = (RETURN)
    ":past-rule"),
  r("consonant y # -> 24,1634,1595",
  // past-rule-13, 
    // act24 = (KILL 1)
    // act1634 = (ADD I E D)
    // act1595 = (RETURN)
    ":past-rule"),
  r("q u y # -> 24,1634,1595",
  // past-rule-14, 
    // act24 = (KILL 1)
    // act1634 = (ADD I E D)
    // act1595 = (RETURN)
    ":past-rule"),
  r("vowel c # -> 1628,1595",
  // past-rule-15, 
    // act1628 = (ADD K E D)
    // act1595 = (RETURN)
    ":past-rule"),
  r("e # -> 344,1595",
  // past-rule-16, 
    // act344 = (ADD D)
    // act1595 = (RETURN)
    ":past-rule"),
  r(" -> 1630,1595",
  // past-rule-17, 
    // act1630 = (ADD E D)
    // act1595 = (RETURN)
    ":past-rule"),
 };

 protected static MorphRule[] ingRule = {//":ing-rule"
  r(" -> 1615,1637,1595",
  // ing-rule-1, 
    // act1615 = (TEST (AND (MORPH-ROOT STATE) (LAST-CHAR-CAPITALIZED-P)))
    // act1637 = (ADD I N G)
    // act1595 = (RETURN)
    ":ing-rule"),
  r("consonant i e # -> 50,1638,1595",
  // ing-rule-2, 
    // act50 = (KILL 2)
    // act1638 = (ADD Y I N G)
    // act1595 = (RETURN)
    ":ing-rule"),
  r("e e # -> 1637,1595",
  // ing-rule-3, 
    // act1637 = (ADD I N G)
    // act1595 = (RETURN)
    ":ing-rule"),
  r("e # -> 24,1639,1637,1595",
  // ing-rule-4, conditional phase-one
    // act24 = (KILL 1)
    // act1639 = (TEST (AND (MORPH-ROOT STATE) (TEST-ICODE LEX 'V '(S-D)) (NO...
    // act1637 = (ADD I N G)
    // act1595 = (RETURN)
    ":ing-rule", false, true, false),
  r("vowel consonant e # -> 24,1640,1637,1595",
  // ing-rule-5, 
    // act24 = (KILL 1)
    // act1640 = (TEST (AND (MORPH-ROOT STATE) (NOT (IS-ROOT-OF-CAT ROOT '(V ...
    // act1637 = (ADD I N G)
    // act1595 = (RETURN)
    ":ing-rule"),
  r("consonant vowel b|d|g|l|m|n|p|r|s|t e # -> 24,1637,1595",
  // ing-rule-6, 
    // act24 = (KILL 1)
    // act1637 = (ADD I N G)
    // act1595 = (RETURN)
    ":ing-rule"),
  r("q u vowel b|d|g|l|m|n|p|r|s|t e # -> 24,1637,1595",
  // ing-rule-7, 
    // act24 = (KILL 1)
    // act1637 = (ADD I N G)
    // act1595 = (RETURN)
    ":ing-rule"),
  r("e # -> 1626,1637,1595",
  // ing-rule-8, conditional phase-one
    // act1626 = (TEST (AND (MORPH-ROOT STATE) (TEST-ICODE ROOT 'V '(S-D))))
    // act1637 = (ADD I N G)
    // act1595 = (RETURN)
    ":ing-rule", false, true, false),
  r(" -> 1627,1641,1595",
  // ing-rule-9, conditional phase-one
    // act1627 = (TEST (AND (MORPH-ROOT STATE) (TEST-ICODE ROOT 'V '(S-KED)))...
    // act1641 = (ADD K I N G)
    // act1595 = (RETURN)
    ":ing-rule", false, true, false),
  r(" -> 1642,1637,1595",
  // ing-rule-10, conditional phase-one
    // act1642 = (TEST (AND (MORPH-ROOT STATE) (TEST-ICODE ROOT 'V '(ES-ED S-...
    // act1637 = (ADD I N G)
    // act1595 = (RETURN)
    ":ing-rule", false, true, false),
  r("consonant # -> 1643,1644,1595",
  // ing-rule-11, conditional phase-one
    // act1643 = (TEST (AND (MORPH-ROOT STATE) (TEST-ICODE ROOT 'V '(*ES-*ED ...
    // act1644 = (ADD & I N G)
    // act1595 = (RETURN)
    ":ing-rule", false, true, false),
  r("consonant vowel b|d|g|l|m|n|p|r|s|t # -> 1635,1644,1595",
  // ing-rule-12, conditional phase-one
    // act1635 = (TEST (AND (MORPH-ROOT STATE) (GETDICT ROOT 'COMPOUND-OF) (T...
    // act1644 = (ADD & I N G)
    // act1595 = (RETURN)
    ":ing-rule", false, true, false),
  r("q u vowel b|d|g|l|m|n|p|r|s|t # -> 1635,1644,1595",
  // ing-rule-13, conditional phase-one
    // act1635 = (TEST (AND (MORPH-ROOT STATE) (GETDICT ROOT 'COMPOUND-OF) (T...
    // act1644 = (ADD & I N G)
    // act1595 = (RETURN)
    ":ing-rule", false, true, false),
  r("consonant vowel b|d|g|l|m|n|p|r|s|t # -> 1636,1644,1595,142,1637,1595",
  // ing-rule-14, 
    // act1636 = (TEST (AND (MORPH-ROOT STATE) (NOT (GETDICT ROOT 'HAS-PREFIX...
    // act1644 = (ADD & I N G)
    // act1595 = (RETURN)
    // act142 = (TEST (POLYSYLLABIC ROOT))
    // act1637 = (ADD I N G)
    // act1595 = (RETURN)
    ":ing-rule"),
  r("q u vowel b|d|g|l|m|n|p|r|s|t # -> 1636,1644,1595,142,1637,1595",
  // ing-rule-15, 
    // act1636 = (TEST (AND (MORPH-ROOT STATE) (NOT (GETDICT ROOT 'HAS-PREFIX...
    // act1644 = (ADD & I N G)
    // act1595 = (RETURN)
    // act142 = (TEST (POLYSYLLABIC ROOT))
    // act1637 = (ADD I N G)
    // act1595 = (RETURN)
    ":ing-rule"),
  r("vowel c # -> 1641,1595",
  // ing-rule-16, 
    // act1641 = (ADD K I N G)
    // act1595 = (RETURN)
    ":ing-rule"),
  r("consonant l e # -> 24,1637,1595",
  // ing-rule-17, 
    // act24 = (KILL 1)
    // act1637 = (ADD I N G)
    // act1595 = (RETURN)
    ":ing-rule"),
  r("l|r v e # -> 24,1637,1595",
  // ing-rule-18, 
    // act24 = (KILL 1)
    // act1637 = (ADD I N G)
    // act1595 = (RETURN)
    ":ing-rule"),
  r("vowel consonant e # -> 1637,1595",
  // ing-rule-19, 
    // act1637 = (ADD I N G)
    // act1595 = (RETURN)
    ":ing-rule"),
  r("c|g e # -> 24,1640,1637,1595",
  // ing-rule-20, 
    // act24 = (KILL 1)
    // act1640 = (TEST (AND (MORPH-ROOT STATE) (NOT (IS-ROOT-OF-CAT ROOT '(V ...
    // act1637 = (ADD I N G)
    // act1595 = (RETURN)
    ":ing-rule"),
  r("c|g e # -> 1637,1595",
  // ing-rule-21, 
    // act1637 = (ADD I N G)
    // act1595 = (RETURN)
    ":ing-rule"),
  r("vowel e # -> 1637,1595",
  // ing-rule-22, 
    // act1637 = (ADD I N G)
    // act1595 = (RETURN)
    ":ing-rule"),
  r("e # -> 24,1640,1637,1595",
  // ing-rule-23, 
    // act24 = (KILL 1)
    // act1640 = (TEST (AND (MORPH-ROOT STATE) (NOT (IS-ROOT-OF-CAT ROOT '(V ...
    // act1637 = (ADD I N G)
    // act1595 = (RETURN)
    ":ing-rule"),
  r(" -> 1637,1595",
  // ing-rule-24, 
    // act1637 = (ADD I N G)
    // act1595 = (RETURN)
    ":ing-rule"),
 };

 protected static MorphRule[] doerRule = {//":doer-rule"
  r(" -> 1615,72,1595",
  // doer-rule-1, 
    // act1615 = (TEST (AND (MORPH-ROOT STATE) (LAST-CHAR-CAPITALIZED-P)))
    // act72 = (ADD E R)
    // act1595 = (RETURN)
    ":doer-rule"),
  r(" -> 1626,694,1595",
  // doer-rule-2, conditional phase-one
    // act1626 = (TEST (AND (MORPH-ROOT STATE) (TEST-ICODE ROOT 'V '(S-D))))
    // act694 = (ADD R)
    // act1595 = (RETURN)
    ":doer-rule", false, true, false),
  r(" -> 1627,1645,1595",
  // doer-rule-3, conditional phase-one
    // act1627 = (TEST (AND (MORPH-ROOT STATE) (TEST-ICODE ROOT 'V '(S-KED)))...
    // act1645 = (ADD K E R)
    // act1595 = (RETURN)
    ":doer-rule", false, true, false),
  r(" -> 1642,72,1595",
  // doer-rule-4, conditional phase-one
    // act1642 = (TEST (AND (MORPH-ROOT STATE) (TEST-ICODE ROOT 'V '(ES-ED S-...
    // act72 = (ADD E R)
    // act1595 = (RETURN)
    ":doer-rule", false, true, false),
  r("consonant # -> 1643,1646,1595",
  // doer-rule-5, conditional phase-one
    // act1643 = (TEST (AND (MORPH-ROOT STATE) (TEST-ICODE ROOT 'V '(*ES-*ED ...
    // act1646 = (ADD & E R)
    // act1595 = (RETURN)
    ":doer-rule", false, true, false),
  r("y # -> 1625,24,1647,1595",
  // doer-rule-6, conditional phase-one
    // act1625 = (TEST (AND (MORPH-ROOT STATE) (TEST-ICODE ROOT 'V '(IES-IED)...
    // act24 = (KILL 1)
    // act1647 = (ADD I E R)
    // act1595 = (RETURN)
    ":doer-rule", false, true, false),
  r("consonant vowel b|d|g|l|m|n|p|r|s|t # -> 1635,1646,1595",
  // doer-rule-7, conditional phase-one
    // act1635 = (TEST (AND (MORPH-ROOT STATE) (GETDICT ROOT 'COMPOUND-OF) (T...
    // act1646 = (ADD & E R)
    // act1595 = (RETURN)
    ":doer-rule", false, true, false),
  r("q u vowel b|d|g|l|m|n|p|r|s|t # -> 1635,1646,1595",
  // doer-rule-8, conditional phase-one
    // act1635 = (TEST (AND (MORPH-ROOT STATE) (GETDICT ROOT 'COMPOUND-OF) (T...
    // act1646 = (ADD & E R)
    // act1595 = (RETURN)
    ":doer-rule", false, true, false),
  r("consonant vowel b|d|g|l|m|n|p|r|s|t # -> 1636,1646,1595,142,72,1595",
  // doer-rule-9, 
    // act1636 = (TEST (AND (MORPH-ROOT STATE) (NOT (GETDICT ROOT 'HAS-PREFIX...
    // act1646 = (ADD & E R)
    // act1595 = (RETURN)
    // act142 = (TEST (POLYSYLLABIC ROOT))
    // act72 = (ADD E R)
    // act1595 = (RETURN)
    ":doer-rule"),
  r("q u vowel b|d|g|l|m|n|p|r|s|t # -> 1636,1646,1595,142,72,1595",
  // doer-rule-10, 
    // act1636 = (TEST (AND (MORPH-ROOT STATE) (NOT (GETDICT ROOT 'HAS-PREFIX...
    // act1646 = (ADD & E R)
    // act1595 = (RETURN)
    // act142 = (TEST (POLYSYLLABIC ROOT))
    // act72 = (ADD E R)
    // act1595 = (RETURN)
    ":doer-rule"),
  r("consonant y # -> 24,1647,1595",
  // doer-rule-11, 
    // act24 = (KILL 1)
    // act1647 = (ADD I E R)
    // act1595 = (RETURN)
    ":doer-rule"),
  r("i c # -> 1645,1595",
  // doer-rule-12, 
    // act1645 = (ADD K E R)
    // act1595 = (RETURN)
    ":doer-rule"),
  r("vowel c t # -> 69,1595",
  // doer-rule-13, 
    // act69 = (ADD O R)
    // act1595 = (RETURN)
    ":doer-rule"),
  r("e # -> 694,1595",
  // doer-rule-14, 
    // act694 = (ADD R)
    // act1595 = (RETURN)
    ":doer-rule"),
  r(" -> 72,1595",
  // doer-rule-15, 
    // act72 = (ADD E R)
    // act1595 = (RETURN)
    ":doer-rule"),
 };

 protected static MorphRule[] comparativeRule = {//":comparative-rule"
  r(" -> 1615,72,1595",
  // comparative-rule-1, 
    // act1615 = (TEST (AND (MORPH-ROOT STATE) (LAST-CHAR-CAPITALIZED-P)))
    // act72 = (ADD E R)
    // act1595 = (RETURN)
    ":comparative-rule"),
  r(" -> 1648,694,1595",
  // comparative-rule-2, conditional phase-one
    // act1648 = (TEST (AND (MORPH-ROOT STATE) (TEST-ICODE ROOT 'ADJ '(R-ST))...
    // act694 = (ADD R)
    // act1595 = (RETURN)
    ":comparative-rule", false, true, false),
  r(" -> 1649,1645,1595",
  // comparative-rule-3, conditional phase-one
    // act1649 = (TEST (AND (MORPH-ROOT STATE) (TEST-ICODE ROOT 'ADJ '(KER-KE...
    // act1645 = (ADD K E R)
    // act1595 = (RETURN)
    ":comparative-rule", false, true, false),
  r(" -> 1650,72,1595",
  // comparative-rule-4, conditional phase-one
    // act1650 = (TEST (AND (MORPH-ROOT STATE) (TEST-ICODE ROOT 'ADJ '(ER-EST...
    // act72 = (ADD E R)
    // act1595 = (RETURN)
    ":comparative-rule", false, true, false),
  r("consonant # -> 1651,1646,1595",
  // comparative-rule-5, conditional phase-one
    // act1651 = (TEST (AND (MORPH-ROOT STATE) (TEST-ICODE ROOT 'ADJ '(*ER-*E...
    // act1646 = (ADD & E R)
    // act1595 = (RETURN)
    ":comparative-rule", false, true, false),
  r("y # -> 1652,24,1647,1595",
  // comparative-rule-6, conditional phase-one
    // act1652 = (TEST (AND (MORPH-ROOT STATE) (TEST-ICODE ROOT 'ADJ '(IER-IE...
    // act24 = (KILL 1)
    // act1647 = (ADD I E R)
    // act1595 = (RETURN)
    ":comparative-rule", false, true, false),
  r("consonant vowel b|d|g|l|m|n|p|r|s|t # -> 1646,1595,142,72,1595",
  // comparative-rule-7, 
    // act1646 = (ADD & E R)
    // act1595 = (RETURN)
    // act142 = (TEST (POLYSYLLABIC ROOT))
    // act72 = (ADD E R)
    // act1595 = (RETURN)
    ":comparative-rule"),
  r("q u vowel b|d|g|l|m|n|p|r|s|t # -> 1646,1595,142,72,1595",
  // comparative-rule-8, 
    // act1646 = (ADD & E R)
    // act1595 = (RETURN)
    // act142 = (TEST (POLYSYLLABIC ROOT))
    // act72 = (ADD E R)
    // act1595 = (RETURN)
    ":comparative-rule"),
  r("consonant y # -> 24,1647,1595",
  // comparative-rule-9, 
    // act24 = (KILL 1)
    // act1647 = (ADD I E R)
    // act1595 = (RETURN)
    ":comparative-rule"),
  r("i c # -> 1645,1595",
  // comparative-rule-10, 
    // act1645 = (ADD K E R)
    // act1595 = (RETURN)
    ":comparative-rule"),
  r("e # -> 694,1595",
  // comparative-rule-11, 
    // act694 = (ADD R)
    // act1595 = (RETURN)
    ":comparative-rule"),
  r(" -> 72,1595",
  // comparative-rule-12, 
    // act72 = (ADD E R)
    // act1595 = (RETURN)
    ":comparative-rule"),
 };

 protected static MorphRule[] superlativeRule = {//":superlative-rule"
  r(" -> 1615,1653,1595",
  // superlative-rule-1, 
    // act1615 = (TEST (AND (MORPH-ROOT STATE) (LAST-CHAR-CAPITALIZED-P)))
    // act1653 = (ADD E S T)
    // act1595 = (RETURN)
    ":superlative-rule"),
  r(" -> 1648,1654,1595",
  // superlative-rule-2, conditional phase-one
    // act1648 = (TEST (AND (MORPH-ROOT STATE) (TEST-ICODE ROOT 'ADJ '(R-ST))...
    // act1654 = (ADD S T)
    // act1595 = (RETURN)
    ":superlative-rule", false, true, false),
  r(" -> 1649,1655,1595",
  // superlative-rule-3, conditional phase-one
    // act1649 = (TEST (AND (MORPH-ROOT STATE) (TEST-ICODE ROOT 'ADJ '(KER-KE...
    // act1655 = (ADD K E S T)
    // act1595 = (RETURN)
    ":superlative-rule", false, true, false),
  r(" -> 1650,1653,1595",
  // superlative-rule-4, conditional phase-one
    // act1650 = (TEST (AND (MORPH-ROOT STATE) (TEST-ICODE ROOT 'ADJ '(ER-EST...
    // act1653 = (ADD E S T)
    // act1595 = (RETURN)
    ":superlative-rule", false, true, false),
  r("consonant # -> 1651,1656,1595",
  // superlative-rule-5, conditional phase-one
    // act1651 = (TEST (AND (MORPH-ROOT STATE) (TEST-ICODE ROOT 'ADJ '(*ER-*E...
    // act1656 = (ADD & E S T)
    // act1595 = (RETURN)
    ":superlative-rule", false, true, false),
  r("y # -> 1652,24,1657,1595",
  // superlative-rule-6, conditional phase-one
    // act1652 = (TEST (AND (MORPH-ROOT STATE) (TEST-ICODE ROOT 'ADJ '(IER-IE...
    // act24 = (KILL 1)
    // act1657 = (ADD I E S T)
    // act1595 = (RETURN)
    ":superlative-rule", false, true, false),
  r("consonant vowel b|d|g|l|m|n|p|r|s|t # -> 1656,1595,142,1653,1595",
  // superlative-rule-7, 
    // act1656 = (ADD & E S T)
    // act1595 = (RETURN)
    // act142 = (TEST (POLYSYLLABIC ROOT))
    // act1653 = (ADD E S T)
    // act1595 = (RETURN)
    ":superlative-rule"),
  r("q u vowel b|d|g|l|m|n|p|r|s|t # -> 1656,1595,142,1653,1595",
  // superlative-rule-8, 
    // act1656 = (ADD & E S T)
    // act1595 = (RETURN)
    // act142 = (TEST (POLYSYLLABIC ROOT))
    // act1653 = (ADD E S T)
    // act1595 = (RETURN)
    ":superlative-rule"),
  r("consonant y # -> 24,1657,1595",
  // superlative-rule-9, 
    // act24 = (KILL 1)
    // act1657 = (ADD I E S T)
    // act1595 = (RETURN)
    ":superlative-rule"),
  r("i c # -> 1655,1595",
  // superlative-rule-10, 
    // act1655 = (ADD K E S T)
    // act1595 = (RETURN)
    ":superlative-rule"),
  r("e # -> 1654,1595",
  // superlative-rule-11, 
    // act1654 = (ADD S T)
    // act1595 = (RETURN)
    ":superlative-rule"),
  r(" -> 1653,1595",
  // superlative-rule-12, 
    // act1653 = (ADD E S T)
    // act1595 = (RETURN)
    ":superlative-rule"),
 };

 protected static MorphRule[] adverbRule = {//":adverb-rule"
  r(" -> 1615,1658,1595",
  // adverb-rule-1, 
    // act1615 = (TEST (AND (MORPH-ROOT STATE) (LAST-CHAR-CAPITALIZED-P)))
    // act1658 = (ADD L Y)
    // act1595 = (RETURN)
    ":adverb-rule"),
  r("consonant y # -> 24,1659,1595",
  // adverb-rule-2, 
    // act24 = (KILL 1)
    // act1659 = (ADD I L Y)
    // act1595 = (RETURN)
    ":adverb-rule"),
  r("l l # -> 31,1595,1660,1595",
  // adverb-rule-3, 
    // act31 = (ADD Y)
    // act1595 = (RETURN)
    // act1660 = (ADD - L Y)
    // act1595 = (RETURN)
    ":adverb-rule"),
  r("i c # -> 1661,1595",
  // adverb-rule-4, 
    // act1661 = (ADD K L Y)
    // act1595 = (RETURN)
    ":adverb-rule"),
  r("a|i b l e # -> 24,31,1595",
  // adverb-rule-5, 
    // act24 = (KILL 1)
    // act31 = (ADD Y)
    // act1595 = (RETURN)
    ":adverb-rule"),
  r(" -> 1658,1595",
  // adverb-rule-6, 
    // act1658 = (ADD L Y)
    // act1595 = (RETURN)
    ":adverb-rule"),
 };

 protected static MorphRule[] nessRule = {//":ness-rule"
  r(" -> 1615,1662,1595",
  // ness-rule-1, 
    // act1615 = (TEST (AND (MORPH-ROOT STATE) (LAST-CHAR-CAPITALIZED-P)))
    // act1662 = (ADD N E S S)
    // act1595 = (RETURN)
    ":ness-rule"),
  r("consonant y # -> 24,1663,1595",
  // ness-rule-2, 
    // act24 = (KILL 1)
    // act1663 = (ADD I N E S S)
    // act1595 = (RETURN)
    ":ness-rule"),
  r("q u y # -> 24,1663,1595",
  // ness-rule-3, 
    // act24 = (KILL 1)
    // act1663 = (ADD I N E S S)
    // act1595 = (RETURN)
    ":ness-rule"),
  r(" -> 1662,1595",
  // ness-rule-4, 
    // act1662 = (ADD N E S S)
    // act1595 = (RETURN)
    ":ness-rule"),
 };

 protected static MorphRule[] ableRule = {//":able-rule"
  r(" -> 1615,1664,1595",
  // able-rule-1, 
    // act1615 = (TEST (AND (MORPH-ROOT STATE) (LAST-CHAR-CAPITALIZED-P)))
    // act1664 = (ADD A B L E)
    // act1595 = (RETURN)
    ":able-rule"),
  r("consonant i e # -> 50,1665,1595",
  // able-rule-2, 
    // act50 = (KILL 2)
    // act1665 = (ADD Y A B L E)
    // act1595 = (RETURN)
    ":able-rule"),
  r("e e # -> 1664,1595",
  // able-rule-3, 
    // act1664 = (ADD A B L E)
    // act1595 = (RETURN)
    ":able-rule"),
  r("e # -> 24,1639,1664,1595",
  // able-rule-4, conditional phase-one
    // act24 = (KILL 1)
    // act1639 = (TEST (AND (MORPH-ROOT STATE) (TEST-ICODE LEX 'V '(S-D)) (NO...
    // act1664 = (ADD A B L E)
    // act1595 = (RETURN)
    ":able-rule", false, true, false),
  r("vowel consonant e # -> 24,1640,1664,1595",
  // able-rule-5, 
    // act24 = (KILL 1)
    // act1640 = (TEST (AND (MORPH-ROOT STATE) (NOT (IS-ROOT-OF-CAT ROOT '(V ...
    // act1664 = (ADD A B L E)
    // act1595 = (RETURN)
    ":able-rule"),
  r("consonant vowel b|d|g|l|m|n|p|r|s|t e # -> 24,1664,1595",
  // able-rule-6, 
    // act24 = (KILL 1)
    // act1664 = (ADD A B L E)
    // act1595 = (RETURN)
    ":able-rule"),
  r("q u vowel b|d|g|l|m|n|p|r|s|t e # -> 24,1664,1595",
  // able-rule-7, 
    // act24 = (KILL 1)
    // act1664 = (ADD A B L E)
    // act1595 = (RETURN)
    ":able-rule"),
  r("e # -> 1626,1664,1595",
  // able-rule-8, conditional phase-one
    // act1626 = (TEST (AND (MORPH-ROOT STATE) (TEST-ICODE ROOT 'V '(S-D))))
    // act1664 = (ADD A B L E)
    // act1595 = (RETURN)
    ":able-rule", false, true, false),
  r(" -> 1627,1666,1595",
  // able-rule-9, conditional phase-one
    // act1627 = (TEST (AND (MORPH-ROOT STATE) (TEST-ICODE ROOT 'V '(S-KED)))...
    // act1666 = (ADD K A B L E)
    // act1595 = (RETURN)
    ":able-rule", false, true, false),
  r(" -> 1642,1664,1595",
  // able-rule-10, conditional phase-one
    // act1642 = (TEST (AND (MORPH-ROOT STATE) (TEST-ICODE ROOT 'V '(ES-ED S-...
    // act1664 = (ADD A B L E)
    // act1595 = (RETURN)
    ":able-rule", false, true, false),
  r("consonant # -> 1643,1667,1595",
  // able-rule-11, conditional phase-one
    // act1643 = (TEST (AND (MORPH-ROOT STATE) (TEST-ICODE ROOT 'V '(*ES-*ED ...
    // act1667 = (ADD & A B L E)
    // act1595 = (RETURN)
    ":able-rule", false, true, false),
  r("consonant vowel b|d|g|l|m|n|p|r|s|t # -> 1668,1667,1595,1664,1595",
  // able-rule-12, 
    // act1668 = (TEST (AND (POLYSYLLABIC ROOT) (MORPH-ROOT STATE) (NOT (GETD...
    // act1667 = (ADD & A B L E)
    // act1595 = (RETURN)
    // act1664 = (ADD A B L E)
    // act1595 = (RETURN)
    ":able-rule"),
  r("consonant vowel b|d|g|l|m|n|p|r|s|t # -> 1667,1595",
  // able-rule-13, 
    // act1667 = (ADD & A B L E)
    // act1595 = (RETURN)
    ":able-rule"),
  r("q u vowel b|d|g|l|m|n|p|r|s|t # -> 1668,1667,1595,1664,1595",
  // able-rule-14, 
    // act1668 = (TEST (AND (POLYSYLLABIC ROOT) (MORPH-ROOT STATE) (NOT (GETD...
    // act1667 = (ADD & A B L E)
    // act1595 = (RETURN)
    // act1664 = (ADD A B L E)
    // act1595 = (RETURN)
    ":able-rule"),
  r("q u vowel b|d|g|l|m|n|p|r|s|t # -> 1667,1595",
  // able-rule-15, 
    // act1667 = (ADD & A B L E)
    // act1595 = (RETURN)
    ":able-rule"),
  r("vowel c # -> 1666,1595",
  // able-rule-16, 
    // act1666 = (ADD K A B L E)
    // act1595 = (RETURN)
    ":able-rule"),
  r("consonant l e # -> 24,1664,1595",
  // able-rule-17, 
    // act24 = (KILL 1)
    // act1664 = (ADD A B L E)
    // act1595 = (RETURN)
    ":able-rule"),
  r("l|r v e # -> 24,1664,1595",
  // able-rule-18, 
    // act24 = (KILL 1)
    // act1664 = (ADD A B L E)
    // act1595 = (RETURN)
    ":able-rule"),
  r("vowel consonant e # -> 1664,1595",
  // able-rule-19, 
    // act1664 = (ADD A B L E)
    // act1595 = (RETURN)
    ":able-rule"),
  r("c|g e # -> 24,1640,1664,1595",
  // able-rule-20, 
    // act24 = (KILL 1)
    // act1640 = (TEST (AND (MORPH-ROOT STATE) (NOT (IS-ROOT-OF-CAT ROOT '(V ...
    // act1664 = (ADD A B L E)
    // act1595 = (RETURN)
    ":able-rule"),
  r("c|g e # -> 1664,1595",
  // able-rule-21, 
    // act1664 = (ADD A B L E)
    // act1595 = (RETURN)
    ":able-rule"),
  r("vowel e # -> 1664,1595",
  // able-rule-22, 
    // act1664 = (ADD A B L E)
    // act1595 = (RETURN)
    ":able-rule"),
  r("e # -> 24,1640,1664,1595",
  // able-rule-23, 
    // act24 = (KILL 1)
    // act1640 = (TEST (AND (MORPH-ROOT STATE) (NOT (IS-ROOT-OF-CAT ROOT '(V ...
    // act1664 = (ADD A B L E)
    // act1595 = (RETURN)
    ":able-rule"),
  r(" -> 1664,1595",
  // able-rule-24, 
    // act1664 = (ADD A B L E)
    // act1595 = (RETURN)
    ":able-rule"),
 };

  
// end of Lisp-generated defs for ruleSets
  
// methods used in morphological rules:

// top level dispatching actions:

  protected void act1(MorphState state) {
    //doTry(ordinalRules, ":ordinal-rules", state);
    //tbd include this in morphPrecheck? or use for chemical names?
    if (!state.cModeKnownFlag)
      doChemicalNameTest(state.lex, state);
  }

  protected void act2(MorphState state) {
    //doTry(morphPrecheckRules, ":morph-precheck-rules", state);
    if (!state.cModeKnownFlag)
      doMorphPrecheck(state.lex, state);
  }

  protected void act3(MorphState state) {
    //doTry(phaseOneRules, ":phase-one-rules", state);
    state.phaseOneFlag = true;
    doTry(morphDispatch, ":phase-one-rules", state);
    state.phaseOneFlag = false;
  }

  protected void act4(MorphState state) {
    if (!state.cModeKnownFlag) {
      state.prefixPhaseFlag = true;
      //state.phaseOneFlag = true;
      //prefix rules require the same known-root conditions as phase-one
      doTry(prefixDispatch, ":prefix-dispatch", state);
      //state.phaseOneFlag = false;
      state.prefixPhaseFlag = false;
    }
  }

  protected void act5(MorphState state) {
    //doTry(compoundRules, ":compound-rules", state);
    if (!state.cModeKnownFlag)
      doMorphCompoundTest(state.lex, state);
  }

  protected void act6(MorphState state) {
    //doTry(phaseTwoRules, ":phase-two-rules", state);
    state.phaseTwoFlag = true;
    if (!state.cModeKnownFlag)
      doTry(morphDispatch, ":phase-two-rules", state);
    state.phaseTwoFlag = false;
  }

// insert Lisp-generated acts and definition of doNumberedAction() here

 /* (IN-PACKAGE USER) */

 void act21( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            state.root.testIcode( category_N ,  atomSet_$Ces )) &&
          catPostTest( state ))
      addCatSense( state ,  category_N ,  state.root ,  new Value[] { atom_Number ,  atom_Pl });
 }


 void act23( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            state.root.testIcode( category_N ,  atomSet_$Des )) &&
          catPostTest( state ))
      addCatSense( state ,  category_N ,  state.root ,  new Value[] { atom_Number ,  atom_Pl });
 }


 void act26( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_V )) &&
          catPostTest( state ))
      addCatSense( state ,  category_V ,  state.root ,  new Value[] { atom_Tns ,  atom_Present ,  atom_Agr ,  atom_3sg });
 }


 void act27( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            state.root.testIcode( category_N ,  atomSet_$S )) &&
          catPostTest( state ))
      addCatSense( state ,  category_N ,  state.root ,  new Value[] { atom_Number ,  atom_Pl });
 }


 void act29( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            state.root.testIcode( category_N ,  atomSet_$Ves )) &&
          catPostTest( state ))
      addCatSense( state ,  category_N ,  state.root ,  new Value[] { atom_Number ,  atom_Pl });
 }


 void act32( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       morphRoot( state ) &&
       dict.isKnownWord( state.root )) &&
     testPostTest( state ));
 }


 void act34( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Anyn )) &&
          catPostTest( state ))
      { state.lex.addIkoParent( word_Science );
       state.lex.addSuffixes( new Word[] { state.suffix });
       state.lex.addRoot( state.root );
       addCatSense( state ,  category_Nm ,  state.lex ,  new Value[] { atom_Mass$Pure ,  atom_True ,  atom_Mass ,  atom_True ,  atom_Icode ,  atom_Nopl });
      }
 }


 void act35( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     plausibleRoot( state.root ) &&
     testPostTest( state ));
 }


 void act36( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Adj ) &&
             ( ! ( isRootOfCat( state.root ,  categorySet_Anyn )) )) &&
          catPostTest( state ))
      { state.lex.addIkoParent( word_Science );
       state.lex.addSuffixes( new Word[] { state.suffix });
       state.lex.addRoot( state.root );
       addCatSense( state ,  category_Nm ,  state.lex ,  new Value[] { atom_Mass$Pure ,  atom_True ,  atom_Mass ,  atom_True ,  atom_Icode ,  atom_Nopl });
      }
 }


 void act38( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (morphRoot( state ) &&
       isCompoundCat( state.root ,  category_Prefix )) &&
     testPostTest( state ));
 }


 void act39( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.addIkoParent( word_Animal );
       state.lex.addIioParent( word_Family_Of_Anima_Etc );
       state.lex.applyFalseRoot( state.root );
       addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Icode ,  atom_$Es });
      }
 }


 void act40( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       morphRoot( state ) &&
       isRootOfCat( state.root ,  categorySet_Adj$Prefix )) &&
     testPostTest( state ));
 }


 void act41( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.applyFalseRoot( state.root );
       state.lex.addIkoParent( word_Animal );
       state.lex.addSuffixes( wordSet_Pus );
       state.lex.addPrefixes( new Word[] { state.root });
       markDict( state ,  state.lex ,  atom_Derived$From , dict.makeList( new Word[] { state.root ,  word_Pus }),  true );
       addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Icode ,  atom_$Es });
      }
 }


 void act42( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (polysyllabic( state.root ) &&
       ( ( sp_knownWordFile  !=  null ) ||
          ( sp_knownWordList  !=  null )) &&
       morphRoot( state ) &&
        ( ! ( dict.isKnownWord( state.root )) )) &&
     testPostTest( state ));
 }


 void act43( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.applyFalseRoot( state.root );
       state.lex.addIkoParent( word_Festival );
       state.lex.addSuffixes( wordSet_Mas );
       addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Icode ,  atom_$Es });
      }
 }


 void act44( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (morphRoot( state ) &&
       state.root.testIcode( category_V ,  atomSet_S$D )) &&
     testPostTest( state ));
 }


 void act45( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      addCatSense( state ,  category_V ,  state.root ,  new Value[] { atom_Tns ,  atom_Present ,  atom_Agr ,  atom_3sg });
 }


 void act46( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Anyn ) &&
             ( ! ( checkVariant( state.root ,  2 ,  "Y" )) ) &&
             ( ! ( state.root.testIcode( category_N ,  atomSet_$Ies$$Es$$$Es$N_Etc )) )) &&
          catPostTest( state ))
      addCatSense( state ,  category_N ,  state.root ,  new Value[] { atom_Number ,  atom_Pl });
 }


 void act47( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (morphRoot( state ) &&
       state.root.testIcode( category_V ,  atomSet_Ies$Ied )) &&
     testPostTest( state ));
 }


 void act48( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Anyn ) &&
             ( ! ( checkVariant( state.root ,  1 ,  "IE" )) ) &&
             ( ! ( state.root.testIcode( category_N ,  atomSet_$S$$Es$$S$Es$$$_Etc )) )) &&
          catPostTest( state ))
      addCatSense( state ,  category_N ,  state.root ,  new Value[] { atom_Number ,  atom_Pl });
 }


 void act49( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Anyn ) &&
             ( ! ( state.root.testIcode( category_N ,  atomSet_$Ies$$Es$$S$Es$_Etc )) )) &&
          catPostTest( state ))
      addCatSense( state ,  category_N ,  state.root ,  new Value[] { atom_Number ,  atom_Pl });
 }


 void act51( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (morphRoot( state ) &&
       state.root.testIcode( category_V ,  atomSet_Es$Ed$Es$$Ed$Es_Etc )) &&
     testPostTest( state ));
 }


 void act52( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Anyn ) &&
             ( ! ( patternCheck( state.root ,  pattern_E )) ) &&
             ( ! ( state.root.testIcode( category_N ,  atomSet_$Ies$$S$$$Es )) )) &&
          catPostTest( state ))
      addCatSense( state ,  category_N ,  state.root ,  new Value[] { atom_Number ,  atom_Pl });
 }


 void act53( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Anyn ) &&
             ( ! ( state.root.testIcode( category_N ,  atomSet_$Ies$$Es$$$Es$N_Etc )) )) &&
          catPostTest( state ))
      addCatSense( state ,  category_N ,  state.root ,  new Value[] { atom_Number ,  atom_Pl });
 }


 void act55( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       patternCheck( state.root ,  pattern_S$I$S ) &&
       morphRoot( state ) &&
       isRootOfCat( state.root ,  categorySet_Nn ) &&
        (makeRealWord( state ,  state.root ) !=  null ) &&
       state.root.testIcode( category_N ,  atomSet_Is$Es )) &&
     testPostTest( state ));
 }


 void act56( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      addCatSense( state ,  category_N ,  state.root ,  new Value[] { atom_Number ,  atom_Pl });
 }


 void act59( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            (isFormOfCat( state.root ,  categorySet_Adj ) ||
              isRootOfCat( state.root ,  categorySet_Anyn$V ))) &&
          catPostTest( state ))
      { state.lex.addIkoParent( word_Mental_Somethin_Etc );
       { state.lex.addRoot( state.root );
        addCatSense( state ,  category_Nm ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Mass ,  atom_True ,  atom_Suffix ,  state.suffix });
       }
      }
 }


 void act60( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Anyn$V )) &&
          catPostTest( state ))
      { state.lex.addIkoParent( word_Mental_Somethin_Etc );
       { state.lex.addRoot(morphPackLex( state , state.root.getWordString(),  "Y" ));
        addCatSense( state ,  category_Nm ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Mass ,  atom_True ,  atom_Suffix ,  state.suffix });
       }
      }
 }


 void act62( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (morphRoot( state ) &&
       (plausibleRoot( state.root ) ||
         isFormOfCat( state.root ,  categorySet_Det ))) &&
     testPostTest( state ));
 }


 void act63( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            (isFormOfCat( state.root ,  categorySet_Adj$Det ) ||
              isRootOfCat( state.root ,  categorySet_Anyn$V ))) &&
          catPostTest( state ))
      { state.lex.addIkoParent( word_Mental_Somethin_Etc );
       { state.lex.addRoot( state.root );
        addCatSense( state ,  category_Nm ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Mass ,  atom_True ,  atom_Suffix ,  state.suffix });
       }
      }
 }


 void act64( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
             (morphCompoundTest( state.root ,  state ,  category_Adj ) !=  null )) &&
          catPostTest( state ))
      { state.lex.addIkoParent( word_Mental_Somethin_Etc );
       { state.lex.addRoot( state.root );
        addCatSense( state ,  category_Nm ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Mass ,  atom_True ,  atom_Suffix ,  state.suffix });
       }
      }
 }


 void act66( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_V$Anyn )) &&
          catPostTest( state ))
      { state.lex.addIkoParent(morphPackLex( state ,  "without_" , state.root.getWordString()));
       { state.lex.addRoot( state.root );
        addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] { atom_Suffix ,  state.suffix });
       }
      }
 }


 void act67( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Anyn ) &&
             ( ! ( isKnownKindOf( state.root ,  word_Mental_Somethin_Etc )) )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_Adv ,  state.lex ,  new Value[] { atom_Suffix ,  state.suffix });
      }
 }


 void act71( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Nn ) &&
             (state.root.getdict( feature_Compound$Of ) ==  null ) &&
            state.root.noPrefix()) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Suffix ,  state.suffix ,  atom_Feminine ,  atom_True });
      }
 }


 void act73( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       morphRoot( state ) &&
        ( ! ( patternCheck( state.root ,  pattern_D )) )) &&
     testPostTest( state ));
 }


 void act75( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (morphRoot( state ) &&
        ( ! ( patternCheck( state.root ,  pattern_$S_X_Z$ )) ) &&
       state.root.testIcode( category_V ,  atomSet_S$Ed$S$D$S$$Ed$_Etc )) &&
     testPostTest( state ));
 }


 void act76( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Anyn ) &&
             ( ! ( patternCheck( state.root ,  pattern_$S_Z_X$ )) ) &&
             ( ! ( state.root.testIcode( category_N ,  atomSet_$Ies$$Es$$$Es$N_Etc )) )) &&
          catPostTest( state ))
      addCatSense( state ,  category_N ,  state.root ,  new Value[] { atom_Number ,  atom_Pl });
 }


 void act77( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_V ) &&
             ( ! ( state.root.testIcode( category_V ,  atomSet_Es$Ed$Es$$Ed$Es_Etc$ )) )) &&
          catPostTest( state ))
      addCatSense( state ,  category_V ,  state.root ,  new Value[] { atom_Tns ,  atom_Present ,  atom_Agr ,  atom_3sg });
 }


 void act78( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Anyn ) &&
             ( ! ( checkVariant( state.root ,  1 ,  "IE" )) ) &&
             ( ! ( state.root.testIcode( category_N ,  atomSet_$S$$Es$$S$Es$No_Etc )) )) &&
          catPostTest( state ))
      addCatSense( state ,  category_N ,  state.root ,  new Value[] { atom_Number ,  atom_Pl });
 }


 void act79( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_V ) &&
             ( ! ( state.root.testIcode( category_V ,  atomSet_S$D$S$Ed$Es$Ed$_Etc )) )) &&
          catPostTest( state ))
      addCatSense( state ,  category_V ,  state.root ,  new Value[] { atom_Tns ,  atom_Present ,  atom_Agr ,  atom_3sg });
 }


 void act80( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (morphRoot( state ) &&
       isRootOfCat( state.root ,  categorySet_Anyn ) &&
        (makeRealWord( state ,  state.root ) !=  null ) &&
       state.root.testIcode( category_N ,  atomSet_$Ies )) &&
     testPostTest( state ));
 }


 void act81( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (morphRoot( state ) &&
       isRootOfCat( state.root ,  categorySet_Anyn ) &&
        (makeRealWord( state ,  state.root ) !=  null ) &&
       state.root.testIcode( category_N ,  atomSet_$S$$S$Es$Mass$M_Etc )) &&
     testPostTest( state ));
 }


 void act82( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_V ) &&
             ( ! ( state.root.testIcode( category_V ,  atomSet_Es$Ed$Ies$Ied$E_Etc )) )) &&
          catPostTest( state ))
      addCatSense( state ,  category_V ,  state.root ,  new Value[] { atom_Tns ,  atom_Present ,  atom_Agr ,  atom_3sg });
 }


 void act83( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       morphRoot( state ) &&
       isRootOfCat( state.root ,  categorySet_Anyn ) &&
        (makeRealWord( state ,  state.root ) !=  null ) &&
       (state.root.testIcode( category_N ,  atomSet_$Es$$S$Es ) ||
         (state.root.testIcode( category_N ,  atomSet_Mass$Mass$Sg$Ma_Etc ) &&
           (patternCheck( state.root ,  pattern_$C_S$$H ) ||
             patternCheck( state.root ,  pattern_$X_S_Z$ ) ||
             patternCheck( state.root ,  pattern_Consonant$O ))))) &&
     testPostTest( state ));
 }


 void act84( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_V ) &&
             ( ! ( state.root.testIcode( category_V ,  atomSet_S$D$S$Ed$S$$Ed$_Etc )) )) &&
          catPostTest( state ))
      addCatSense( state ,  category_V ,  state.root ,  new Value[] { atom_Tns ,  atom_Present ,  atom_Agr ,  atom_3sg });
 }


 void act85( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       morphRoot( state ) &&
       isRootOfCat( state.root ,  categorySet_Anyn ) &&
        (makeRealWord( state ,  state.root ) !=  null ) &&
       state.root.testIcode( category_N ,  atomSet_$S$$S$Es$Mass$M_Etc )) &&
     testPostTest( state ));
 }


 void act86( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (morphRoot( state ) &&
        ( ! ( patternCheck( state.root ,  pattern_$S_X_Z$ )) ) &&
       (state.root.testIcode( category_N ,  atomSet_$S$$S$Es ) ||
         (state.root.testIcode( category_N ,  atomSet_Mass$Mass$Sg$Ma_Etc ) &&
            ( ! ( patternCheck( state.root ,  pattern_$C_S$$H )) )))) &&
     testPostTest( state ));
 }


 void act87( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Anyn )) &&
          catPostTest( state ))
      addCatSense( state ,  category_N ,  state.root ,  new Value[] { atom_Number ,  atom_Pl });
 }


 void act88( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_V ) &&
             ( ! ( state.root.testIcode( category_V ,  atomSet_Es$Ed$Es$$Ed$Es_Etc$$ )) )) &&
          catPostTest( state ))
      addCatSense( state ,  category_V ,  state.root ,  new Value[] { atom_Tns ,  atom_Present ,  atom_Agr ,  atom_3sg });
 }


 void act89( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (morphRoot( state ) &&
       (isFormOfCat( state.root ,  categorySet_Anyn ) ||
         mayBeCat( state ,  state.root ,  category_N )) &&
       (state.root.testIcode( category_N ,  atomSet_$Apostrophe$S ) ||
          (nounInflectCode( state.root ) ==  atom_$Apostrophe$S ) ||
         isFormOfCat( state.root ,  categorySet_Number ) ||
          ( ! ( syllabic( state.root )) ))) &&
     testPostTest( state ));
 }


 void act90( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      addCatSense( state ,  category_N ,  state.root ,  new Value[] { atom_Poss ,  atom_True ,  atom_Penalty ,  word_1 });
 }


 void act91( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_V ) &&
             ( ! ( state.root.testIcode( category_V ,  atomSet_S$D$S$Ed$S$$Ed$_Etc$ )) )) &&
          catPostTest( state ))
      addCatSense( state ,  category_V ,  state.root ,  new Value[] { atom_Tns ,  atom_Present ,  atom_Agr ,  atom_3sg ,  atom_Penalty ,  word_1 });
 }


 void act92( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      addCatSense( state ,  category_N ,  state.root ,  new Value[] { atom_Poss ,  atom_True });
 }


 void act93( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Anyn ) &&
             ( ! ( patternCheck( state.root ,  pattern_E )) ) &&
            (patternCheck( state.root ,  pattern_$C_S$$H ) ||
              patternCheck( state.root ,  pattern_$X_S_Z$ ) ||
              patternCheck( state.root ,  pattern_Consonant$O )) &&
             ( ! ( state.root.testIcode( category_N ,  atomSet_$Ies$$S$$$Es$No_Etc )) )) &&
          catPostTest( state ))
      addCatSense( state ,  category_N ,  state.root ,  new Value[] { atom_Number ,  atom_Pl });
 }


 void act94( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_V ) &&
            (patternCheck( state.root ,  pattern_$C_S$$H ) ||
              patternCheck( state.root ,  pattern_$X_S_Z$ ) ||
              patternCheck( state.root ,  pattern_Consonant$O )) &&
             ( ! ( state.root.testIcode( category_V ,  atomSet_S$D$S$Ed$S$$Ed$_Etc )) )) &&
          catPostTest( state ))
      addCatSense( state ,  category_V ,  state.root ,  new Value[] { atom_Tns ,  atom_Present ,  atom_Agr ,  atom_3sg });
 }


 void act95( MorphState  state ) {
   if    (catPreTest( state ) &&
          (plausibleRoot( state.root ) &&
            morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Anyn ) &&
             ( ! ( state.root.testIcode( category_N ,  atomSet_$Ies$$Es$$$Es$N_Etc )) )) &&
          catPostTest( state ))
      addCatSense( state ,  category_N ,  state.root ,  new Value[] { atom_Number ,  atom_Pl });
 }


 void act96( MorphState  state ) {
   if    (catPreTest( state ) &&
          (patternCheck( state.root ,  pattern_S$I$S ) &&
            polysyllabic( state.root ) &&
            morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Nn ) &&
             ( ! ( state.root.testIcode( category_N ,  atomSet_$Ies$$S$$S$Es$$_Etc )) )) &&
          catPostTest( state ))
      addCatSense( state ,  category_N ,  state.root ,  new Value[] { atom_Number ,  atom_Pl });
 }


 void act97( MorphState  state ) {
    boolean  tempboolean1000 ;
   if    (catPreTest( state ))
      {  boolean  tempboolean1001 ;
       if    (morphRoot( state ) &&
               ( ! ( patternCheck( state.root ,  pattern_$S_X_Z$ )) ) &&
              isRootOfCat( state.root ,  categorySet_Anyn ) &&
               ( ! ( state.root.testIcode( category_N ,  atomSet_$Ies$$Es$$$Es$N_Etc )) ))
          {  boolean  tempboolean1002 ;
            Word[]  tempWordSet1003  = state.root.getInflectionRoots( category_N );
            tempboolean1002  =  false ;
           if     ( tempWordSet1003  !=  null )
              for ( int  i  =  0 ;  i  <  tempWordSet1003.length ;  i++ ) {
                  Word  subroot  =  tempWordSet1003[i] ;
                 { if    ((patternCheck( state.root ,  pattern_A ) &&
                            subroot.testIcode( category_N ,  atomSet_$A )) ||
                          (patternCheck( state.root ,  pattern_I ) &&
                            subroot.testIcode( category_N ,  atomSet_$I )))
                      {  tempboolean1002  =  true ;
                        break ;
                      }
                 }
              }
            tempboolean1001  =  ( !  tempboolean1002 );
          }

       else   tempboolean1001  =  false ;
       if    ( tempboolean1001 )
           tempboolean1000  = catPostTest( state );

       else   tempboolean1000  =  false ;
      }

   else   tempboolean1000  =  false ;
   if    ( tempboolean1000 )
      addCatSense( state ,  category_N ,  state.root ,  new Value[] { atom_Number ,  atom_Pl });
 }


 void act98( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (morphRoot( state ) &&
       dict.isKnownWord( state.root ) &&
       plausibleRoot( state.root ) &&
       (patternCheck( state.root ,  pattern_$C_S$$H ) ||
         patternCheck( state.root ,  pattern_$X_S_Z$ ) ||
         patternCheck( state.root ,  pattern_Consonant$O ))) &&
     testPostTest( state ));
 }


 void act99( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       polysyllabic( state.root ) &&
       patternCheck( state.root ,  pattern_S$I$S ) &&
       morphRoot( state ) &&
       isRootOfCat( state.root ,  categorySet_Nn ) &&
        ( ! ( state.root.testIcode( category_N ,  atomSet_$Ies$$S$$S$Es$$_Etc )) )) &&
     testPostTest( state ));
 }


 void act100( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (morphRoot( state ) &&
       state.root.testIcode( category_N ,  atomSet_$$Es )) &&
     testPostTest( state ));
 }


 void act101( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (morphRoot( state ) &&
       state.root.testIcode( category_V ,  atomSet_$Es$$Ed )) &&
     testPostTest( state ));
 }


 void act104( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Anyn$V )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] { atom_Suffix ,  state.suffix });
      }
 }


 void act105( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       needFinalE( state.root )) &&
     testPostTest( state ));
 }


 void act109( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Anyn )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] { atom_Suffix ,  state.suffix });
      }
 }


 void act110( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Prefix )) &&
          catPostTest( state ))
      { state.lex.applyFalseRoot( state.root );
       {  Word  modname  = state.root.normalizeIfNumber();
         Word  parentname ;
         parentname  = dict.makeStructuredConcept(morphPackLex( state ,  "with_" , modname.getWordString(),  "_offspring" ),  category_Adv , dict.makeList( new Value[] { word_Modifier , dict.makeList( wordSequence_Relation$With ), dict.makeList( new Value[] { word_Object , dict.makeList( new Value[] { word_Offspring , dict.makeList( new Value[] { word_Mod ,  modname })})})}));
        markDict( state ,  parentname ,  atom_Adj ,  wordSet_$ ,  false );
        state.lex.addIkoParent( parentname );
       }
       state.lex.addSuffixes( wordSet_Parous );
       state.lex.addPrefixes( new Word[] { state.root });
       markDict( state ,  state.lex ,  atom_Derived$From , dict.makeList( new Word[] { state.root ,  word_Parous }),  true );
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] {});
      }
 }


 void act112( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Anyn$Prefix )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       state.lex.addSuffixes( wordSet_Iferous );
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] {});
      }
 }


 void act114( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       polysyllabic( state.root ) &&
       morphRoot( state ) &&
       dict.isKnownWord( state.root )) &&
     testPostTest( state ));
 }


 void act115( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Nn )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] { atom_Suffix ,  state.suffix });
      }
 }


 void act119( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Adj )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] { atom_Suffix ,  state.suffix });
      }
 }


 void act122( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Anyn$V$Adj$Pref_Etc )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] { atom_Suffix ,  state.suffix });
      }
 }


 void act123( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Prefix )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] { atom_Suffix ,  state.suffix });
      }
 }


 void act124( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       morphRoot( state ) &&
        ( ! ( patternCheck( state.root ,  pattern_$A_E_I_O$ )) )) &&
     testPostTest( state ));
 }


 void act125( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Nn$V )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] { atom_Suffix ,  state.suffix });
      }
 }


 void act128( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Nn$Adj$Prefix )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] { atom_Suffix ,  state.suffix });
      }
 }


 void act129( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Anyn$Adj$Prefix )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] { atom_Suffix ,  state.suffix });
      }
 }


 void act130( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Prefix )) &&
          catPostTest( state ))
      { state.lex.applyFalseRoot( state.root );
       state.lex.addSuffixes( wordSet_Aceous );
       state.lex.addPrefixes( new Word[] { state.root });
       markDict( state ,  state.lex ,  atom_Derived$From , dict.makeList( new Word[] { state.root ,  word_Aceous }),  true );
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] {});
      }
 }


 void act131( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       polysyllabic( state.root )) &&
     testPostTest( state ));
 }


 void act133( MorphState  state ) {
   if    (catPreTest( state ) &&
          (polysyllabic( state.root ) &&
            morphRoot( state ) &&
            isFormOfCat( state.root ,  categorySet_Prefix )) &&
          catPostTest( state ))
      { state.lex.addIioParent( word_Condition );
       state.lex.addSuffixes( wordSet_Osis );
       state.lex.addPrefixes( new Word[] { state.root });
       state.lex.applyFalseRoot( state.root );
       addCatSense( state ,  category_Nm ,  state.lex ,  new Value[] { atom_Mass$Pure ,  atom_True ,  atom_Mass ,  atom_True ,  atom_Icode ,  atom_Is$Es });
      }
 }


 void act134( MorphState  state ) {
   if    (catPreTest( state ) &&
          (syllabic( state.root ) &&
            morphRoot( state ) &&
            isFormOfCat( state.root ,  categorySet_Nn )) &&
          catPostTest( state ))
      { state.lex.addIioParent( word_Condition );
       state.lex.addSuffixes( wordSet_Osis );
       state.lex.addRoot( state.root );
       addCatSense( state ,  category_Nm ,  state.lex ,  new Value[] { atom_Mass$Pure ,  atom_True ,  atom_Mass ,  atom_True ,  atom_Icode ,  atom_Is$Es });
      }
 }


 void act135( MorphState  state ) {
   if    (catPreTest( state ) &&
          (polysyllabic( state.root ) &&
            morphRoot( state ) &&
            isFormOfCat( state.root ,  categorySet_Nn )) &&
          catPostTest( state ))
      { state.lex.addIioParent( word_Condition );
       state.lex.addSuffixes( wordSet_Osis );
       state.lex.addRoot( state.root );
       addCatSense( state ,  category_Nm ,  state.lex ,  new Value[] { atom_Mass$Pure ,  atom_True ,  atom_Mass ,  atom_True ,  atom_Icode ,  atom_Is$Es });
      }
 }


 void act137( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       morphRoot( state ) &&
       isRootOfCat( state.root ,  categorySet_Adj$Anyn )) &&
     testPostTest( state ));
 }


 void act139( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_Adv ,  state.lex ,  new Value[] { atom_Suffix ,  state.suffix });
      }
 }


 void act140( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] { atom_Suffix ,  state.suffix });
      }
 }


 void act141( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_V )) &&
          catPostTest( state ))
      addCatSense( state ,  category_V ,  state.root ,  new Value[] { atom_Tns ,  atom_Present ,  atom_Agr ,  atom_3sg ,  atom_Penalty ,  word_2 });
 }


 void act142( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     polysyllabic( state.root ) &&
     testPostTest( state ));
 }


 void act143( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.addIkoParent( word_Animal );
       state.lex.addIioParent( word_Family_Of_Anima_Etc );
       addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Icode ,  atom_$Es });
      }
 }


 void act144( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (morphRoot( state ) &&
        ( ! ( patternCheck( state.root ,  pattern_$S_X_Z$ )) ) &&
       plausibleRoot( state.root ) &&
       dict.isKnownWord( state.root ) &&
       mayBeCat( state ,  state.root ,  category_N ) &&
        ( ! (patternCheck( state.root ,  pattern_$C_S$$H ) ||
           state.root.testIcode( category_N ,  atomSet_Nopl$Unique$Pl$_Etc ) ||
            (state.root.getInflectionRoots( category_N ) !=  null )))) &&
     testPostTest( state ));
 }


 void act145( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            morphCheck( state.root ,  category_N )) &&
          catPostTest( state ))
      addCatSense( state ,  category_N ,  state.root ,  new Value[] { atom_Number ,  atom_Pl });
 }


 void act146( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            mayBeCat( state ,  state.root ,  category_N )) &&
          catPostTest( state ))
      addCatSense( state ,  category_N ,  state.root ,  new Value[] { atom_Number ,  atom_Pl });
 }


 void act147( MorphState  state ) {
   if    (catPreTest( state ) &&
          ( sp_guessVerbFlag  &&
            morphRoot( state ) &&
            mayBeCat( state ,  state.root ,  category_V )) &&
          catPostTest( state ))
      addCatSense( state ,  category_V ,  state.root ,  new Value[] { atom_Tns ,  atom_Present ,  atom_Agr ,  atom_3sg });
 }


 void act148( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     needFinalE( state.root ) &&
     testPostTest( state ));
 }


 void act149( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            mayBeCat( state ,  state.root ,  category_V )) &&
          catPostTest( state ))
      addCatSense( state ,  category_V ,  state.root ,  new Value[] { atom_Tns ,  atom_Present ,  atom_Agr ,  atom_3sg });
 }


 void act151( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (patternCheck( state.root ,  pattern_$C_S$$H ) ||
       patternCheck( state.root ,  pattern_$X_S_Z$ ) ||
       patternCheck( state.root ,  pattern_Consonant$O )) &&
     testPostTest( state ));
 }


 void act152( MorphState  state ) {
   if    (catPreTest( state ) &&
          plausibleRoot( state.root ) &&
          catPostTest( state ))
      addCatSense( state ,  category_Lastname ,  state.lex ,  new Value[] {});
 }


 void act153( MorphState  state ) {
   if    (catPreTest( state ) &&
          polysyllabic( state.root ) &&
          catPostTest( state ))
      addCatSense( state ,  category_Lastname ,  state.lex ,  new Value[] {});
 }


 void act154( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      addCatSense( state ,  category_Lastname ,  state.lex ,  new Value[] {});
 }


 void act155( MorphState  state ) {
   if    (catPreTest( state ) &&
          polysyllabic( state.root ) &&
          catPostTest( state ))
      { state.lex.addIkoParent( word_Mental_Somethin_Etc );
       addCatSense( state ,  category_Nm ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Mass ,  atom_True ,  atom_Mass$Pure ,  atom_True ,  atom_Icode ,  atom_Mass });
      }
 }


 void act156( MorphState  state ) {
   if    (catPreTest( state ) &&
          plausibleRoot( state.root ) &&
          catPostTest( state ))
      addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] {});
 }


 void act157( MorphState  state ) {
   if    (catPreTest( state ) &&
          plausibleRoot( state.root ) &&
          catPostTest( state ))
      addCatSense( state ,  category_Adv ,  state.lex ,  new Value[] {});
 }


 void act159( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (morphRoot( state ) &&
        ( ! ( patternCheck( state.root ,  pattern_$S_X_Z$ )) ) &&
       plausibleRoot( state.root )) &&
     testPostTest( state ));
 }


 void act160( MorphState  state ) {
    boolean  tempboolean1004 ;
   if    (catPreTest( state ))
      {  boolean  tempboolean1005 ;
       if    (morphRoot( state ) &&
              isRootOfCat( state.root ,  categorySet_Anyn ))
          {  boolean  tempboolean1006 ;
            Word[]  tempWordSet1007  = state.root.getInflectionRoots( category_N );
            tempboolean1006  =  false ;
           if     ( tempWordSet1007  !=  null )
              for ( int  i  =  0 ;  i  <  tempWordSet1007.length ;  i++ ) {
                  Word  subroot  =  tempWordSet1007[i] ;
                 { if    ((patternCheck( state.root ,  pattern_A ) &&
                            subroot.testIcode( category_N ,  atomSet_$A )) ||
                          (patternCheck( state.root ,  pattern_I ) &&
                            subroot.testIcode( category_N ,  atomSet_$I )))
                      {  tempboolean1006  =  true ;
                        break ;
                      }
                 }
              }
            tempboolean1005  =  ( !  tempboolean1006 );
          }

       else   tempboolean1005  =  false ;
       if    ( tempboolean1005 )
           tempboolean1004  = catPostTest( state );

       else   tempboolean1004  =  false ;
      }

   else   tempboolean1004  =  false ;
   if    ( tempboolean1004 )
      addCatSense( state ,  category_N ,  state.root ,  new Value[] { atom_Number ,  atom_Pl });
 }


 void act161( MorphState  state ) {
   if    (catPreTest( state ) &&
          polysyllabic( state.root ) &&
          catPostTest( state ))
      addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Number ,  atom_Pl ,  atom_Mass ,  atom_True ,  atom_Mass$Pure ,  atom_True ,  atom_Icode ,  atom_Mass$Pl });
 }


 void act162( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] {});
 }


 void act163( MorphState  state ) {
   if    (catPreTest( state ) &&
          polysyllabic( state.root ) &&
          catPostTest( state ))
      addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Icode ,  atom_$Es });
 }


 void act164( MorphState  state ) {
   if    (catPreTest( state ) &&
          polysyllabic( state.root ) &&
          catPostTest( state ))
      addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] {});
 }


 void act165( MorphState  state ) {
   if    (catPreTest( state ) &&
          polysyllabic( state.root ) &&
          catPostTest( state ))
      addCatSense( state ,  category_Nm ,  state.lex ,  new Value[] { atom_Mass$Pure ,  atom_True ,  atom_Mass ,  atom_True ,  atom_Icode ,  atom_$Des });
 }


 void act166( MorphState  state ) {
   if    (catPreTest( state ) &&
          polysyllabic( state.root ) &&
          catPostTest( state ))
      addCatSense( state ,  category_Nm ,  state.lex ,  new Value[] { atom_Mass$Pure ,  atom_True ,  atom_Mass ,  atom_True ,  atom_Icode ,  atom_Is$Es });
 }


 void act167( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { markDict( state ,  state.lex ,  atom_Guessed ,  wordSet_T ,  false );
       addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Icode ,  atom_$Es });
      }
 }


 void act168( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            morphCheck( state.root ,  category_N ,  atom_Known )) &&
          catPostTest( state ))
      addCatSense( state ,  category_N ,  state.root ,  new Value[] { atom_Number ,  atom_Pl });
 }


 void act169( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            morphCheck( state.root ,  category_V ,  atom_Known )) &&
          catPostTest( state ))
      addCatSense( state ,  category_V ,  state.root ,  new Value[] { atom_Tns ,  atom_Present ,  atom_Agr ,  atom_3sg });
 }


 void act170( MorphState  state ) {
   if    (testPreTest( state ))
      {  boolean  tempboolean1008 ;
       if    (morphRoot( state ) &&
               ( ! ( patternCheck( state.root ,  pattern_$S_X_Z$ )) ) &&
              plausibleRoot( state.root ) &&
              morphCheck( state.root ,  category_N ,  atom_Known ))
          {  boolean  tempboolean1009 ;
            Word[]  tempWordSet1010  = state.root.getInflectionRoots( category_N );
            tempboolean1009  =  false ;
           if     ( tempWordSet1010  !=  null )
              for ( int  i  =  0 ;  i  <  tempWordSet1010.length ;  i++ ) {
                  Word  subroot  =  tempWordSet1010[i] ;
                 { if    ((patternCheck( state.root ,  pattern_A ) &&
                            subroot.testIcode( category_N ,  atomSet_$A )) ||
                          (patternCheck( state.root ,  pattern_I ) &&
                            subroot.testIcode( category_N ,  atomSet_$I )))
                      {  tempboolean1009  =  true ;
                        break ;
                      }
                 }
              }
            tempboolean1008  =  ( !  tempboolean1009 );
          }

       else   tempboolean1008  =  false ;
       if    ( tempboolean1008 )
           state.testval  = testPostTest( state );

       else   state.testval  =  false ;
      }

   else   state.testval  =  false ;
 }


 void act171( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       morphRoot( state ) &&
       morphCheck( state.root ,  category_V ,  atom_Known )) &&
     testPostTest( state ));
 }


 void act172( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { markDict( state ,  state.lex ,  atom_Guessed ,  wordSet_T ,  false );
       if    ( sp_guessVerbFlag )
          addPenalty( state.lex ,  category_V ,  1 );
       addCatSense( state ,  category_N ,  state.root ,  new Value[] { atom_Number ,  atom_Pl });
      }
 }


 void act173( MorphState  state ) {
   if    (catPreTest( state ) &&
           sp_guessVerbFlag  &&
          catPostTest( state ))
      addCatSense( state ,  category_V ,  state.root ,  new Value[] { atom_Tns ,  atom_Present ,  atom_Agr ,  atom_3sg });
 }


 void act174( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (needFinalE( state.root ) &&
       plausibleRoot( state.root )) &&
     testPostTest( state ));
 }


 void act175( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
             ( ! ( polysyllabic( state.root )) )) &&
          catPostTest( state ))
      addCatSense( state ,  category_Npr ,  state.lex ,  new Value[] {});
 }


 void act176( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            (state.root.testIcode( category_N ,  atomSet_$Apostrophe$S ) ||
               (nounInflectCode( state.root ) ==  atom_$Apostrophe$S ) ||
              isFormOfCat( state.root ,  categorySet_Number ) ||
              (isRootOfCat( state.root ,  categorySet_Npr ) &&
                 ( ! ( isFormOfCat( state.root ,  categorySet_Nn )) )))) &&
          catPostTest( state ))
      addCatSense( state ,  category_N ,  state.root ,  new Value[] { atom_Number ,  atom_Pl });
 }


 void act177( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            mayBeCat( state ,  state.root ,  category_N ) &&
             ( ! ( state.root.testIcode( category_N ,  atomSet_Nopl$Unique$Pl$_Etc )) )) &&
          catPostTest( state ))
      { markDict( state ,  state.lex ,  atom_Guessed ,  wordSet_T ,  false );
       if    ( sp_guessVerbFlag )
          addPenalty( state.lex ,  category_V ,  1 );
       addCatSense( state ,  category_N ,  state.root ,  new Value[] { atom_Number ,  atom_Pl });
      }
 }


 void act178( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       morphRoot( state ) &&
        ( ! ( patternCheck( state.root ,  pattern_$S_X_Z$ )) )) &&
     testPostTest( state ));
 }


 void act179( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
             (state.root.getInflectionRoots( category_N ) ==  null ) &&
             ( ! ( state.root.testIcode( category_N ,  atomSet_$Es$$$Es$$Ies$$_Etc )) )) &&
          catPostTest( state ))
      { markDict( state ,  state.lex ,  atom_Guessed ,  wordSet_T ,  false );
       addCatSense( state ,  category_N ,  state.root ,  new Value[] { atom_Number ,  atom_Pl });
      }
 }


 void act180( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
      true  &&
     testPostTest( state ));
 }


 void act181( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      addCatSense( state ,  category_V ,  state.root ,  new Value[] { atom_Tns ,  atom_Past ,  atom_Pastpart ,  atom_True });
 }


 void act182( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (morphRoot( state ) &&
       isFormOfCat( state.root ,  categorySet_Prefix$Anyn )) &&
     testPostTest( state ));
 }


 void act183( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.applyFalseRoot( state.root );
       state.lex.addPrefixes( new Word[] { state.root });
       state.lex.addRoot( word_Fed );
       addCompoundCatSenses( state ,  category_V ,  state.root ,  word_Fed ,  category_V ,  "-" );
      }
 }


 void act184( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.applyFalseRoot( state.root );
       state.lex.addPrefixes( new Word[] { state.root });
       state.lex.addRoot( word_Feed );
       addCompoundCatSenses( state ,  category_V ,  state.root ,  word_Feed ,  category_V ,  "-" );
      }
 }


 void act185( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (morphRoot( state ) &&
       state.root.testIcode( category_V ,  atomSet_Es$Ed$Ies$Ied )) &&
     testPostTest( state ));
 }


 void act186( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_V )) &&
          catPostTest( state ))
      addCatSense( state ,  category_V ,  state.root ,  new Value[] { atom_Tns ,  atom_Past ,  atom_Pastpart ,  atom_True });
 }


 void act188( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (morphRoot( state ) &&
       state.root.testIcode( category_V ,  atomSet_S$Ed$Es$Ed$S$Ed_Etc )) &&
     testPostTest( state ));
 }


 void act189( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_V )) &&
          catPostTest( state ))
      { if   (patternCheckLeft( state.root ,  pattern_U$N ))
          morphAnalyzePrefix( state ,  state.lex ,  atom_U$Prefixes );
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] {});
      }
 }


 void act190( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       needFinalE( state.root ) &&
       morphRoot( state ) &&
       isRootOfCat( state.root ,  categorySet_Adj$Nn )) &&
     testPostTest( state ));
 }


 void act191( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       state.lex.addSuffixes( wordSet_Oid );
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] {});
      }
 }


 void act192( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Icode ,  atom_$S });
 }


 void act193( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       morphRoot( state ) &&
       isRootOfCat( state.root ,  categorySet_Adj$Nn )) &&
     testPostTest( state ));
 }


 void act195( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       polysyllabic( state.root ) &&
       morphRoot( state ) &&
       isRootOfCat( state.root ,  categorySet_Adj$Nn )) &&
     testPostTest( state ));
 }


 void act196( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       morphRoot( state ) &&
       isRootOfCat( state.root ,  categorySet_Prefix )) &&
     testPostTest( state ));
 }


 void act197( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.applyFalseRoot( state.root );
       state.lex.addPrefixes( new Word[] { state.root });
       state.lex.addSuffixes( wordSet_Oid );
       markDict( state ,  state.lex ,  atom_Derived$From , dict.makeList( new Word[] { state.root ,  word_Oid }),  true );
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] {});
      }
 }


 void act198( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       morphRoot( state ) &&
       isRootOfCat( state.root ,  categorySet_Nn )) &&
     testPostTest( state ));
 }


 void act200( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] { atom_Suffix ,  state.suffix });
      }
 }


 void act201( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (morphRoot( state ) &&
       state.root.testIcode( category_V ,  atomSet_S$$Ed$Es$$Ed$$E_Etc )) &&
     testPostTest( state ));
 }


 void act202( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (morphRoot( state ) &&
       state.root.testIcode( category_V ,  atomSet_S$Ed$S$Ked$Irrv_Etc )) &&
     testPostTest( state ));
 }


 void act203( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       morphRoot( state ) &&
       isRootOfCat( state.root ,  categorySet_V )) &&
     testPostTest( state ));
 }


 void act204( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       morphRoot( state ) &&
       isRootOfCat( state.root ,  categorySet_Anyn )) &&
     testPostTest( state ));
 }


 void act205( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.addIkoParent(dict.makeStructuredConcept(morphPackLex( state ,  "with_" , state.root.getWordString()),  category_Adj , dict.makeList( new Value[] { word_With , dict.makeList( new Value[] { state.root })})));
       state.lex.addSuffixes( wordSet_Ed );
       state.lex.addRoot( state.root );
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] {});
      }
 }


 void act206( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_V ,  state.lex ,  new Value[] { atom_Tns ,  atom_Past ,  atom_Pastpart ,  atom_True });
      }
 }


 void act207( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (morphRoot( state ) &&
       sp_adjPrefixes.contains(state.root.getWordString())) &&
     testPostTest( state ));
 }


 void act208( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.applyFalseRoot( state.root );
       state.lex.addPrefixes( new Word[] { state.root });
       state.lex.addRoot( word_Breed );
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] {});
      }
 }


 void act209( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       morphRoot( state ) &&
       dict.isKnownWord( state.root ) &&
       isFormOfCat( state.root ,  categorySet_Prefix )) &&
     testPostTest( state ));
 }


 void act210( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.applyFalseRoot( state.root );
       state.lex.addIkoParent( word_Animal );
       state.lex.addPrefixes( new Word[] { state.root });
       state.lex.addRoot( word_Breed );
       addCatSense( state ,  category_Vti ,  state.lex ,  new Value[] { atom_Tns ,  atom_Present ,  atom_Agr ,  atom_Not3sg ,  atom_Untensed ,  atom_True ,  atom_Icode ,  atom_S$Ed });
      }
 }


 void act211( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       morphRoot( state ) &&
       dict.isKnownWord( state.root ) &&
       isFormOfCat( state.root ,  categorySet_Anyn$Adj$V )) &&
     testPostTest( state ));
 }


 void act212( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.applyFalseRoot( state.root );
       state.lex.addIkoParent( word_Animal );
       addCompoundSense( state.lex , dict.makeList( new Word[] { state.root ,  word_Breed }));
       state.lex.addPrefixes( new Word[] { state.root });
       state.lex.addRoot( word_Breed );
       addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Icode ,  atom_$S });
      }
 }


 void act213( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.applyFalseRoot( state.root );
       state.lex.addPrefixes( new Word[] { state.root });
       state.lex.addRoot( word_Seed );
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] {});
      }
 }


 void act214( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.applyFalseRoot( state.root );
       state.lex.addIkoParent( word_Seed );
       state.lex.addPrefixes( new Word[] { state.root });
       state.lex.addRoot( word_Seed );
       addCatSense( state ,  category_Vt ,  state.lex ,  new Value[] { atom_Tns ,  atom_Present ,  atom_Agr ,  atom_Not3sg ,  atom_Untensed ,  atom_True ,  atom_Icode ,  atom_S$Ed });
      }
 }


 void act215( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.applyFalseRoot( state.root );
       state.lex.addIkoParent( word_Seed );
       addCompoundSense( state.lex , dict.makeList( new Word[] { state.root ,  word_Seed }));
       state.lex.addPrefixes( new Word[] { state.root });
       state.lex.addRoot( word_Seed );
       addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Icode ,  atom_$S });
      }
 }


 void act216( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.applyFalseRoot( state.root );
       state.lex.addPrefixes( new Word[] { state.root });
       state.lex.addRoot( word_Speed );
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] {});
      }
 }


 void act217( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.applyFalseRoot( state.root );
       state.lex.addIioParent( word_Speed );
       state.lex.addPrefixes( new Word[] { state.root });
       state.lex.addRoot( word_Speed );
       addCatSense( state ,  category_Vit ,  state.lex ,  new Value[] { atom_Tns ,  atom_Present ,  atom_Agr ,  atom_Not3sg ,  atom_Untensed ,  atom_True ,  atom_Icode ,  atom_S$Ed });
      }
 }


 void act218( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.applyFalseRoot( state.root );
       state.lex.addIioParent( word_Speed );
       addCompoundSense( state.lex , dict.makeList( new Word[] { state.root ,  word_Speed }));
       state.lex.addPrefixes( new Word[] { state.root });
       state.lex.addRoot( word_Speed );
       addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Icode ,  atom_$S });
      }
 }


 void act219( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.applyFalseRoot( state.root );
       state.lex.addIkoParent( word_Weed );
       state.lex.addPrefixes( new Word[] { state.root });
       state.lex.addRoot( word_Weed );
       addCatSense( state ,  category_Vti ,  state.lex ,  new Value[] { atom_Tns ,  atom_Present ,  atom_Agr ,  atom_Not3sg ,  atom_Untensed ,  atom_True ,  atom_Icode ,  atom_S$Ed });
      }
 }


 void act220( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.applyFalseRoot( state.root );
       state.lex.addIkoParent( word_Weed );
       addCompoundSense( state.lex , dict.makeList( new Word[] { state.root ,  word_Weed }));
       state.lex.addPrefixes( new Word[] { state.root });
       state.lex.addRoot( word_Weed );
       addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Icode ,  atom_$S });
      }
 }


 void act221( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       needFinalE( state.root ) &&
       morphRoot( state ) &&
       isRootOfCat( state.root ,  categorySet_V )) &&
     testPostTest( state ));
 }


 void act222( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       morphRoot( state ) &&
       isRootOfCat( state.root ,  categorySet_V ) &&
        ( ! ( needDoubleLetter( state.root )) )) &&
     testPostTest( state ));
 }


 void act223( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       morphRoot( state ) &&
       isRootOfCat( state.root ,  categorySet_V )) &&
     testPostTest( state ));
 }


 void act224( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       morphRoot( state ) &&
       isRootOfCat( state.root ,  categorySet_Adj )) &&
     testPostTest( state ));
 }


 void act226( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       morphRoot( state ) &&
       (isRootOfCat( state.root ,  categorySet_Integer ) ||
         sp_quantityPrefixes.contains(state.root.getWordString()))) &&
     testPostTest( state ));
 }


 void act228( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.addIkoParent( word_Multiple );
       state.lex.addRoot( state.root );
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] { atom_Suffix ,  state.suffix });
      }
 }


 void act229( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.addIkoParent( word_$Adv$Multiply );
       state.lex.addRoot( state.root );
       addCatSense( state ,  category_Adv ,  state.lex ,  new Value[] { atom_Suffix ,  state.suffix });
      }
 }


 void act230( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Anyn$Adj$Adv$Pr_Etc ) &&
             ( ! ( isFormOfCat( state.root ,  categorySet_Prefix )) )) &&
          catPostTest( state ))
      { state.lex.addRoot( word_Bred );
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] { atom_Prefix ,  state.root });
      }
 }


 void act231( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (morphRoot( state ) &&
       isAdvPlusPastpart( state.root ,  false ,  word_Ied )) &&
     testPostTest( state ));
 }


 void act232( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      addCompoundSuffixCatSenses( state ,  category_Adj ,  state.lex ,  category_Adj ,  state.root ,  0 ,  word_Ied ,  word_Modified_By );
 }


 void act233( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (morphRoot( state ) &&
       isAdvPlusPastpart( state.root ,  false ,  word_D )) &&
     testPostTest( state ));
 }


 void act234( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      addCompoundSuffixCatSenses( state ,  category_Adj ,  state.lex ,  category_Adj ,  state.root ,  0 ,  word_D ,  word_Modified_By );
 }


 void act235( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (morphRoot( state ) &&
       isAdvPlusPastpart( state.root ,  false ,  word_Ed )) &&
     testPostTest( state ));
 }


 void act236( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      addCompoundSuffixCatSenses( state ,  category_Adj ,  state.lex ,  category_Adj ,  state.root ,  0 ,  word_Ed ,  word_Modified_By );
 }


 void act237( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (morphRoot( state ) &&
       isAdvPlusPastpart( state.root ,  true ,  word_Ed )) &&
     testPostTest( state ));
 }


 void act238( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      addCompoundSuffixCatSenses( state ,  category_Adj ,  state.lex ,  category_Adj ,  state.root ,  -1 ,  word_Ed ,  word_Modified_By );
 }


 void act239( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (morphRoot( state ) &&
       isNPlusPastpart( state.root ,  false ,  word_D )) &&
     testPostTest( state ));
 }


 void act240( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      addCompoundSuffixCatSenses( state ,  category_Adj ,  state.lex ,  category_Adj ,  state.root ,  0 ,  word_D ,  word_By );
 }


 void act241( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (morphRoot( state ) &&
       isNPlusPastpart( state.root ,  false ,  word_Ed )) &&
     testPostTest( state ));
 }


 void act242( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      addCompoundSuffixCatSenses( state ,  category_Adj ,  state.lex ,  category_Adj ,  state.root ,  0 ,  word_Ed ,  word_By );
 }


 void act243( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (morphRoot( state ) &&
       isNPlusPastpart( state.root ,  true ,  word_Ed )) &&
     testPostTest( state ));
 }


 void act244( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      addCompoundSuffixCatSenses( state ,  category_Adj ,  state.lex ,  category_Adj ,  state.root ,  -1 ,  word_Ed ,  word_By );
 }


 void act245( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       morphRoot( state ) &&
       isCompoundCat( state.root ,  category_N ) &&
        ( ! ( isFormOfCat( state.root ,  categorySet_V )) )) &&
     testPostTest( state ));
 }


 void act246( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.applyFalseRoot( state.root );
       state.lex.addSuffixes( wordSet_Ed );
        Word  rootname  = dict.makePhraseWord(state.root.getFirstDecomposition());
       state.lex.addRoot( rootname );
       state.lex.addIkoParent(dict.makeStructuredConcept(morphPackLex( state ,  "with_" , rootname.getWordString()),  category_Adj , dict.makeList( new Value[] { word_With ,  rootname })));
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] {});
      }
 }


 void act247( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       morphRoot( state ) &&
        ( ! ( patternCheck( state.root ,  pattern_Consonant$Vowel_Etc )) ) &&
       isCompoundCat( state.root ,  category_N ) &&
        ( ! ( isFormOfCat( state.root ,  categorySet_V )) ) &&
        ( ! ( needDoubleLetter( state.root )) )) &&
     testPostTest( state ));
 }


 void act248( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       morphRoot( state ) &&
       isRootOfCat( state.root ,  categorySet_Anyn ) &&
        ( ! ( isFormOfCat( state.root ,  categorySet_V )) ) &&
        (state.root.getPrefixes() !=  null ) &&
        (state.root.getRoot() !=  null )) &&
     testPostTest( state ));
 }


 void act249( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.applyFalseRoot( state.root );
       state.lex.addSuffixes( wordSet_Ed );
       state.lex.addRoot(state.root.getRoot());
       state.lex.addPrefixes(state.root.getPrefixes());
        Word  modname  = LexiconUtil.firstVal(state.root.getPrefixes()).normalizeIfNumber();
       state.lex.addIkoParent(dict.makeStructuredConcept(morphPackLex( state ,  "with_" , modname.getWordString(),  "_" , state.root.getRoot().getWordString()),  category_Adj , dict.makeList( new Value[] { word_With , dict.makeList( new Value[] {state.root.getRoot(), dict.makeList( new Value[] { word_Mod ,  modname })})})));
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] {});
      }
 }


 void act250( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       morphRoot( state ) &&
        ( ! ( patternCheck( state.root ,  pattern_Consonant$Vowel_Etc )) ) &&
       isRootOfCat( state.root ,  categorySet_Anyn ) &&
        ( ! ( isFormOfCat( state.root ,  categorySet_V )) ) &&
        (state.root.getPrefixes() !=  null ) &&
        (state.root.getRoot() !=  null ) &&
        ( ! ( needDoubleLetter( state.root )) )) &&
     testPostTest( state ));
 }


 void act251( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.applyFalseRoot( state.root );
       state.lex.addSuffixes( wordSet_Ed );
       state.lex.addPrefixes(state.root.getPrefixes());
       state.lex.addRoot(state.root.getRoot());
        Word  modname  = LexiconUtil.firstVal(state.root.getPrefixes()).normalizeIfNumber();
       state.lex.addIkoParent(dict.makeStructuredConcept(morphPackLex( state ,  "with_" , modname.getWordString(),  "_" , state.root.getRoot().getWordString()),  category_Adj , dict.makeList( new Value[] { word_With , dict.makeList( new Value[] {state.root.getRoot(), dict.makeList( new Value[] { word_Mod ,  modname })})})));
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] {});
      }
 }


 void act252( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       morphRoot( state ) &&
       dict.isKnownWord( state.root ) &&
       isRootOfCat( state.root ,  categorySet_Anyn ) &&
        ( ! ( isFormOfCat( state.root ,  categorySet_V )) )) &&
     testPostTest( state ));
 }


 void act253( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.addIkoParent(dict.makeStructuredConcept(morphPackLex( state ,  "with_" , state.root.getWordString()),  category_Adj , dict.makeList( new Value[] { word_With , dict.makeList( new Value[] { state.root })})));
       state.lex.addRoot( state.root );
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] {});
      }
 }


 void act254( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       morphRoot( state ) &&
        ( ! ( patternCheck( state.root ,  pattern_Consonant$Vowel_Etc )) ) &&
       dict.isKnownWord( state.root ) &&
       isRootOfCat( state.root ,  categorySet_Anyn ) &&
        ( ! ( isFormOfCat( state.root ,  categorySet_V )) ) &&
        ( ! ( needDoubleLetter( state.root )) )) &&
     testPostTest( state ));
 }


 void act255( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       morphRoot( state ) &&
       isRootOfCat( state.root ,  categorySet_Anyn ) &&
        ( ! ( isFormOfCat( state.root ,  categorySet_V )) )) &&
     testPostTest( state ));
 }


 void act256( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       morphRoot( state ) &&
        ( ! ( patternCheck( state.root ,  pattern_Consonant$Vowel_Etc )) ) &&
       isRootOfCat( state.root ,  categorySet_Anyn ) &&
        ( ! ( isFormOfCat( state.root ,  categorySet_V )) ) &&
        ( ! ( needDoubleLetter( state.root )) )) &&
     testPostTest( state ));
 }


 void act257( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       morphRoot( state ) &&
       mayBeCat( state ,  state.root ,  category_N$V )) &&
     testPostTest( state ));
 }


 void act258( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (morphRoot( state ) &&
       mayBeCat( state ,  state.root ,  category_N$V )) &&
     testPostTest( state ));
 }


 void act259( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { markDict( state ,  state.lex ,  atom_Guessed ,  wordSet_T ,  false );
       addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Icode ,  atom_$S });
      }
 }


 void act260( MorphState  state ) {
   if    (catPreTest( state ) &&
           sp_guessVerbFlag  &&
          catPostTest( state ))
      addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] {});
 }


 void act261( MorphState  state ) {
   if    (catPreTest( state ) &&
           sp_guessVerbFlag  &&
          catPostTest( state ))
      { addPenalty( state.lex ,  category_V ,  1 );
       addPenalty( state.lex ,  category_Adj ,  2 );
       addCatSense( state ,  category_V ,  state.lex ,  new Value[] { atom_Tns ,  atom_Present ,  atom_Agr ,  atom_Not3sg ,  atom_Untensed ,  atom_True ,  atom_Icode ,  atom_S$Ed });
      }
 }


 void act262( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       morphRoot( state ) &&
       isRootOfCat( state.root ,  categorySet_Nn$Adj )) &&
     testPostTest( state ));
 }


 void act264( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      addCatSense( state ,  category_City ,  state.lex ,  new Value[] {});
 }


 void act265( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       needFinalE( state.root ) &&
       morphRoot( state ) &&
       mayBeCat( state ,  state.root ,  category_N$V )) &&
     testPostTest( state ));
 }


 void act266( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (morphRoot( state ) &&
       isRootOfCat( state.root ,  categorySet_Anyn$V )) &&
     testPostTest( state ));
 }


 void act267( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.applyFalseRoot( state.root );
       state.lex.addPrefixes( new Word[] { state.root });
       state.lex.addRoot( word_Eyed );
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] {});
      }
 }


 void act268( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.addRoot( word_Eye );
       addCatSense( state ,  category_V , butLastChar( state.lex ),  new Value[] { atom_Tns ,  atom_Past ,  atom_Pastpart ,  atom_True ,  atom_Penalty ,  word_2 ,  atom_Has$Prefix ,  state.root });
      }
 }


 void act269( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       morphRoot( state ) &&
        ( ! ( needDoubleLetter( state.root )) )) &&
     testPostTest( state ));
 }


 void act270( MorphState  state ) {
   if    (catPreTest( state ) &&
          polysyllabic( state.root ) &&
          catPostTest( state ))
      addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Icode ,  atom_$S });
 }


 void act271( MorphState  state ) {
   if    (catPreTest( state ) &&
          polysyllabic( state.root ) &&
          catPostTest( state ))
      { markDict( state ,  state.lex ,  atom_Guessed ,  wordSet_T ,  false );
       addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Icode ,  atom_$S });
      }
 }


 void act272( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (morphRoot( state ) &&
       state.root.testIcode( category_N ,  atomSet_$Ae )) &&
     testPostTest( state ));
 }


 void act274( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_Adv ,  state.lex ,  new Value[] { atom_Suffix ,  state.suffix });
      }
 }


 void act275( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (polysyllabic( state.root ) &&
       morphRoot( state ) &&
       isFormOfCat( state.root ,  categorySet_Npr )) &&
     testPostTest( state ));
 }


 void act276( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.addIioParent(morphPackLex( state ,  "language_of_" , state.root.getWordString()));
       state.lex.addIkoParent(morphPackLex( state ,  "person_from_" , state.root.getWordString()));
       state.lex.addIkoParent(morphPackLex( state ,  "related_to_" , state.root.getWordString()));
       state.lex.addSuffixes( wordSet_Ese );
       state.lex.addRoot( state.root );
       addCatSense( state ,  category_Nmsp ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg$Pl ,  atom_Mass ,  atom_True ,  atom_Icode ,  atom_Nopl });
      }
 }


 void act277( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      addCatSense( state ,  category_Npr ,  state.lex ,  new Value[] {});
 }


 void act278( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       morphRoot( state ) &&
       isFormOfCat( state.root ,  categorySet_Nn )) &&
     testPostTest( state ));
 }


 void act279( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.addIioParent(morphPackLex( state ,  "language_of_" , makePlural( state.root )));
       state.lex.addIkoParent( word_Language );
       state.lex.addSuffixes( wordSet_Ese );
       state.lex.addRoot( state.root );
       addCatSense( state ,  category_Nm ,  state.lex ,  new Value[] { atom_Mass$Pure ,  atom_True ,  atom_Mass ,  atom_True ,  atom_Icode ,  atom_Nopl });
      }
 }


 void act280( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Adj$Anyn )) &&
          catPostTest( state ))
      { if   (patternCheck( state.lex ,  pattern_S$E ) ||
              patternCheck( state.lex ,  pattern_Y$$S_Z$$E ))
          { state.lex.addVariantOf(morphPackLex( state , state.root.getWordString(),  "IZE" ));
           markDict( state ,  state.lex ,  atom_Features ,  wordSet_British ,  true );
          }
       state.lex.addSuffixes( wordSet_Ize );
       state.lex.addRoot( state.root );
       addCatSense( state ,  category_V ,  state.lex ,  new Value[] { atom_Tns ,  atom_Present ,  atom_Agr ,  atom_Not3sg ,  atom_Untensed ,  atom_True ,  atom_Icode ,  atom_S$D });
      }
 }


 void act281( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Anyn$Adj$Prefix )) &&
          catPostTest( state ))
      { if   (patternCheck( state.lex ,  pattern_S$E ) ||
              patternCheck( state.lex ,  pattern_Y$$S_Z$$E ))
          { state.lex.addVariantOf(morphPackLex( state , state.root.getWordString(),  "TIZE" ));
           markDict( state ,  state.lex ,  atom_Features ,  wordSet_British ,  true );
          }
       state.lex.addSuffixes( wordSet_Ize );
       state.lex.addRoot( state.root );
       addCatSense( state ,  category_V ,  state.lex ,  new Value[] { atom_Tns ,  atom_Present ,  atom_Agr ,  atom_Not3sg ,  atom_Untensed ,  atom_True ,  atom_Icode ,  atom_S$D });
      }
 }


 void act283( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
        ( state.root.getWordString().length()  >  6 )) &&
     testPostTest( state ));
 }


 void act284( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Nn$Adj )) &&
          catPostTest( state ))
      { if   (patternCheck( state.lex ,  pattern_S$E ) ||
              patternCheck( state.lex ,  pattern_Y$$S_Z$$E ))
          { state.lex.addVariantOf(morphPackLex( state , state.root.getWordString(),  "IZE" ));
           markDict( state ,  state.lex ,  atom_Features ,  wordSet_British ,  true );
          }
       state.lex.addSuffixes( wordSet_Ize );
       state.lex.addRoot( state.root );
       addCatSense( state ,  category_V ,  state.lex ,  new Value[] { atom_Tns ,  atom_Present ,  atom_Agr ,  atom_Not3sg ,  atom_Untensed ,  atom_True ,  atom_Icode ,  atom_S$D });
      }
 }


 void act286( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Nn$Adj ) &&
            polysyllabic( state.root )) &&
          catPostTest( state ))
      { if   (patternCheck( state.lex ,  pattern_S$E ) ||
              patternCheck( state.lex ,  pattern_Y$$S_Z$$E ))
          { state.lex.addVariantOf(morphPackLex( state , state.root.getWordString(),  "IZE" ));
           markDict( state ,  state.lex ,  atom_Features ,  wordSet_British ,  true );
          }
       state.lex.addSuffixes( wordSet_Ize );
       state.lex.addRoot( state.root );
       addCatSense( state ,  category_V ,  state.lex ,  new Value[] { atom_Tns ,  atom_Present ,  atom_Agr ,  atom_Not3sg ,  atom_Untensed ,  atom_True ,  atom_Icode ,  atom_S$D });
      }
 }


 void act288( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Nn )) &&
          catPostTest( state ))
      { if   (patternCheck( state.lex ,  pattern_S$E ) ||
              patternCheck( state.lex ,  pattern_Y$$S_Z$$E ))
          { state.lex.addVariantOf(morphPackLex( state , state.root.getWordString(),  "IZE" ));
           markDict( state ,  state.lex ,  atom_Features ,  wordSet_British ,  true );
          }
       state.lex.addSuffixes( wordSet_Ize );
       state.lex.addRoot( state.root );
       addCatSense( state ,  category_V ,  state.lex ,  new Value[] { atom_Tns ,  atom_Present ,  atom_Agr ,  atom_Not3sg ,  atom_Untensed ,  atom_True ,  atom_Icode ,  atom_S$D });
      }
 }


 void act289( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Adj$Nn )) &&
          catPostTest( state ))
      { if   (patternCheck( state.lex ,  pattern_S$E ) ||
              patternCheck( state.lex ,  pattern_Y$$S_Z$$E ))
          { state.lex.addVariantOf(morphPackLex( state , state.root.getWordString(),  "IZE" ));
           markDict( state ,  state.lex ,  atom_Features ,  wordSet_British ,  true );
          }
       state.lex.addSuffixes( wordSet_Ize );
       state.lex.addRoot( state.root );
       addCatSense( state ,  category_V ,  state.lex ,  new Value[] { atom_Tns ,  atom_Present ,  atom_Agr ,  atom_Not3sg ,  atom_Untensed ,  atom_True ,  atom_Icode ,  atom_S$D });
      }
 }


 void act293( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Adj$Nn ) &&
            polysyllabic( state.root )) &&
          catPostTest( state ))
      { if   (patternCheck( state.lex ,  pattern_S$E ) ||
              patternCheck( state.lex ,  pattern_Y$$S_Z$$E ))
          { state.lex.addVariantOf(morphPackLex( state , state.root.getWordString(),  "IZE" ));
           markDict( state ,  state.lex ,  atom_Features ,  wordSet_British ,  true );
          }
       state.lex.addSuffixes( wordSet_Ize );
       state.lex.addRoot( state.root );
       addCatSense( state ,  category_V ,  state.lex ,  new Value[] { atom_Tns ,  atom_Present ,  atom_Agr ,  atom_Not3sg ,  atom_Untensed ,  atom_True ,  atom_Icode ,  atom_S$D });
      }
 }


 void act295( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       polysyllabic( state.root ) &&
       morphRoot( state ) &&
       dict.isKnownWord( state.root ) &&
       isRootOfCat( state.root ,  categorySet_V )) &&
     testPostTest( state ));
 }


 void act296( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.applyFalseRoot( state.root );
       state.lex.addIkoParent( word_Substance );
       state.lex.addIkoParent( word_Enzyme );
       state.lex.addSuffixes( wordSet_Ase );
       state.lex.addPrefixes( new Word[] { state.root });
       markDict( state ,  state.lex ,  atom_Domain ,  wordSet_Chemistry ,  true );
       markDict( state ,  state.lex ,  atom_Derived$From , dict.makeList( new Word[] { state.root ,  word_Ase }),  true );
       addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Icode ,  atom_$S });
      }
 }


 void act298( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       polysyllabic( state.root ) &&
       morphRoot( state ) &&
       isRootOfCat( state.root ,  categorySet_Anyn$Adj$Prefix )) &&
     testPostTest( state ));
 }


 void act299( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       morphRoot( state ) &&
       isRootOfCat( state.root ,  categorySet_Anyn )) &&
     testPostTest( state ));
 }


 void act300( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.addIkoParent(dict.makeStructuredConcept( category_Adj , dict.makeList( new Value[] { word_Beside ,  state.root })));
       state.lex.addRoot( state.root );
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] { atom_Suffix ,  word_Side });
      }
 }


 void act301( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      addCatSense( state ,  category_Adv ,  state.lex ,  new Value[] {});
 }


 void act302( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.addIkoParent(dict.makeStructuredConcept( category_N , dict.makeList( new Value[] { word_Side , dict.makeList( new Value[] { word_Of ,  state.root })})));
       state.lex.addRoot( word_Side );
       addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Prefix ,  state.root });
      }
 }


 void act303( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.addIkoParent(dict.makeStructuredConcept( category_Adj , dict.makeList( new Value[] { word_Throughout ,  state.root })));
       state.lex.addRoot( state.root );
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] { atom_Suffix ,  word_Wide });
      }
 }


 void act304( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.addIkoParent(dict.makeStructuredConcept( category_Adv , dict.makeList( new Value[] { word_Throughout ,  state.root })));
       state.lex.addRoot( state.root );
       addCatSense( state ,  category_Adv ,  state.lex ,  new Value[] { atom_Suffix ,  word_Wide });
      }
 }


 void act305( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.addIkoParent( word_Size );
       addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Prefix ,  state.root });
      }
 }


 void act306( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { if   (patternCheck( state.lex ,  pattern_S$E ) ||
              patternCheck( state.lex ,  pattern_Y$$S_Z$$E ))
          { state.lex.addVariantOf(morphPackLex( state , state.root.getWordString(),  "IZE" ));
           markDict( state ,  state.lex ,  atom_Features ,  wordSet_British ,  true );
          }
       state.lex.addSuffixes( wordSet_Ize );
       state.lex.addRoot( state.root );
       addCatSense( state ,  category_V ,  state.lex ,  new Value[] { atom_Tns ,  atom_Present ,  atom_Agr ,  atom_Not3sg ,  atom_Untensed ,  atom_True ,  atom_Icode ,  atom_S$D });
      }
 }


 void act308( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isFormOfCat( state.root ,  categorySet_Prefix )) &&
          catPostTest( state ))
      { state.lex.applyFalseRoot( state.root );
       state.lex.addPrefixes( new Word[] { state.root });
       state.lex.addSuffixes( wordSet_Some );
       state.lex.addIkoParent( word_Body );
       addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Icode ,  atom_$S });
      }
 }


 void act310( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Digits )) &&
          catPostTest( state ))
      { state.lex.addIkoParent( word_Group );
       state.lex.addRoot( state.root );
       addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Suffix ,  state.suffix });
      }
 }


 void act311( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Anyn$V$Adj )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] { atom_Suffix ,  state.suffix });
      }
 }


 void act319( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       morphRoot( state ) &&
       isFormOfCat( state.root ,  categorySet_Prefix )) &&
     testPostTest( state ));
 }


 void act320( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { markDict( state ,  state.lex ,  atom_Pastpart , (Value)(morphPackLex( state , state.root.getWordString(),  "DRIVEN" )),  true );
       markDict( state ,  state.lex ,  atom_Past , (Value)(morphPackLex( state , state.root.getWordString(),  "DROVE" )),  true );
       addCatSense( state ,  category_Vti ,  state.lex ,  new Value[] { atom_Tns ,  atom_Present ,  atom_Agr ,  atom_Not3sg ,  atom_Untensed ,  atom_True ,  atom_Icode ,  atom_Irr });
      }
 }


 void act321( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.applyFalseRoot( state.root );
       state.lex.addIkoParent( word_Drive );
       state.lex.addPrefixes( new Word[] { state.root });
       state.lex.addRoot( word_Drive );
       addCatSense( state ,  category_Nmc ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Mass ,  atom_True ,  atom_Icode ,  atom_$S });
      }
 }


 void act322( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       morphRoot( state ) &&
       isFormOfCat( state.root ,  categorySet_Anyn$V$Adj )) &&
     testPostTest( state ));
 }


 void act323( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.applyFalseRoot( state.root );
       state.lex.addIkoParent(dict.makeStructuredConcept( category_Nm , dict.makeList( new Value[] { word_Drive , dict.makeList( new Value[] { word_Mod ,  state.root })})));
       state.lex.addPrefixes( new Word[] { state.root });
       state.lex.addRoot( word_Drive );
       addCatSense( state ,  category_Nm ,  state.lex ,  new Value[] { atom_Mass$Pure ,  atom_True ,  atom_Mass ,  atom_True ,  atom_Icode ,  atom_$S });
      }
 }


 void act324( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.applyFalseRoot( state.root );
       state.lex.addIkoParent( word_Drive );
       state.lex.addPrefixes( new Word[] { state.root });
       state.lex.addRoot( word_Drive );
       addCatSense( state ,  category_Nm ,  state.lex ,  new Value[] { atom_Mass$Pure ,  atom_True ,  atom_Mass ,  atom_True ,  atom_Icode ,  atom_$S });
      }
 }


 void act325( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       polysyllabic( state.root ) &&
       needFinalE( state.root )) &&
     testPostTest( state ));
 }


 void act326( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       morphRoot( state ) &&
        (morphPrefix( state ,  state.root ) !=  null )) &&
     testPostTest( state ));
 }


 void act327( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isKnownFormOfCat( state.root ,  categorySet_Adj )) &&
          catPostTest( state ))
      addCatSense( state ,  category_Adj ,  state.lex , copyFeatures( state.root ,  category_Adj ));
 }


 void act328( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isKnownFormOfCat( state.root ,  categorySet_Adv )) &&
          catPostTest( state ))
      addCatSense( state ,  category_Adv ,  state.lex , copyFeatures( state.root ,  category_Adv ));
 }


 void act329( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isKnownFormOfCat( state.root ,  categorySet_Anyn )) &&
          catPostTest( state ))
      addCatSense( state ,  category_N ,  state.lex , copyFeatures( state.root ,  category_N ));
 }


 void act330( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isKnownFormOfCat( state.root ,  categorySet_V )) &&
          catPostTest( state ))
      addCatSense( state ,  category_V ,  state.lex , copyFeatures( state.root ,  category_V ));
 }


 void act334( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Anyn )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Suffix ,  state.suffix });
      }
 }


 void act335( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Anyn$Adj$V )) &&
          catPostTest( state ))
      { state.lex.addIkoParent( word_Person );
       state.lex.addRoot( word_Phile );
       addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Prefix ,  state.root });
      }
 }


 void act336( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       morphRoot( state ) &&
       dict.isKnownWord( state.root ) &&
        ( ! ( patternCheck( state.root ,  pattern_E$E )) )) &&
     testPostTest( state ));
 }


 void act338( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_V )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root.makeSenseNamesIfNeeded(categorySet_V)[0] );
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] { atom_Suffix ,  state.suffix });
      }
 }


 void act339( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Nn$Adj )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root.makeSenseNamesIfNeeded(categorySet_Nn$Adj)[0] );
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] { atom_Suffix ,  state.suffix });
      }
 }


 void act340( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Nn$V )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root.makeSenseNamesIfNeeded(categorySet_Nn$V)[0] );
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] { atom_Suffix ,  state.suffix });
      }
 }


 void act343( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_V )) &&
          catPostTest( state ))
      { markDict( state ,  state.lex ,  atom_Misspelling$Of , (Value)(morphPackLex( state , butLastCharString(state.root.getWordString(),  1 ),  "SSIBLE" )),  true );
       { state.lex.addRoot( state.root.makeSenseNamesIfNeeded(categorySet_V)[0] );
        addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] { atom_Suffix ,  state.suffix });
       }
      }
 }


 void act345( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     ( ( state.root.getWordString().length()  >  2 ) &&
       plausibleRoot( state.root ) &&
       morphRoot( state ) &&
        ( ! ( patternCheck( state.root ,  pattern_$L_N$ )) ) &&
       isRootOfCat( state.root ,  categorySet_Npr ) &&
       isKnownKindOf( state.root ,  word_Place )) &&
     testPostTest( state ));
 }


 void act346( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       state.lex.addSuffixes( wordSet_Ite );
       state.lex.addIkoParent( word_Person );
       state.lex.addIkoParent(morphPackLex( state ,  "person_from_" , state.root.getWordString()));
       addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Icode ,  atom_$S });
      }
 }


 void act347( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       needFinalE( state.root ) &&
       morphRoot( state ) &&
        ( ! ( patternCheck( state.root ,  pattern_$L_N$$E )) ) &&
       isRootOfCat( state.root ,  categorySet_Npr ) &&
       isKnownKindOf( state.root ,  word_Place )) &&
     testPostTest( state ));
 }


 void act348( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     ( ( state.root.getWordString().length()  >  2 ) &&
       plausibleRoot( state.root ) &&
       morphRoot( state ) &&
       isRootOfCat( state.root ,  categorySet_Lastname )) &&
     testPostTest( state ));
 }


 void act349( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       state.lex.addSuffixes( wordSet_Ite );
       state.lex.addIkoParent( word_Person );
       state.lex.addIkoParent(morphPackLex( state ,  "proponent_of_" , state.root.getWordString()));
       addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Icode ,  atom_$S });
      }
 }


 void act350( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       needFinalE( state.root ) &&
       morphRoot( state ) &&
       isRootOfCat( state.root ,  categorySet_Lastname )) &&
     testPostTest( state ));
 }


 void act351( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     ( ( state.root.getWordString().length()  >  2 ) &&
       plausibleRoot( state.root ) &&
       morphRoot( state ) &&
       dict.isKnownWord( state.root ) &&
       isRootOfCat( state.root ,  categorySet_Anyn )) &&
     testPostTest( state ));
 }


 void act352( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       state.lex.addSuffixes( wordSet_Ite );
       state.lex.addIkoParent( word_Substance );
       addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Icode ,  atom_$S });
      }
 }


 void act353( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
        ( state.root.getWordString().length()  >  3 ) &&
       needFinalE( state.root ) &&
       morphRoot( state ) &&
       dict.isKnownWord( state.root ) &&
       isRootOfCat( state.root ,  categorySet_Anyn )) &&
     testPostTest( state ));
 }


 void act354( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
        ( state.root.getWordString().length()  >  3 ) &&
       morphRoot( state ) &&
       dict.isKnownWord( state.root ) &&
       isRootOfCat( state.root ,  categorySet_Anyn )) &&
     testPostTest( state ));
 }


 void act355( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       polysyllabic( state.root ) &&
       morphRoot( state ) &&
       dict.isKnownWord( state.root ) &&
       isRootOfCat( state.root ,  categorySet_Anyn )) &&
     testPostTest( state ));
 }


 void act356( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.addIkoParent( word_Substance );
       addCatSense( state ,  category_Nm ,  state.lex ,  new Value[] { atom_Mass$Pure ,  atom_True ,  atom_Mass ,  atom_True ,  atom_Icode ,  atom_$S });
      }
 }


 void act357( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (morphRoot( state ) &&
       chemicalNameTest( state.root ) &&
        (makeRealWord( state ,  state.root ) !=  null )) &&
     testPostTest( state ));
 }


 void act358( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { markDict( state ,  state.lex ,  atom_Domain ,  wordSet_Chemistry ,  true );
       state.lex.addIioParent( word_Chemical );
       state.lex.addRoot( state.root );
       state.lex.addSuffixes( wordSet_Ate );
       addCatSense( state ,  category_Nm ,  state.lex ,  new Value[] { atom_Mass$Pure ,  atom_True ,  atom_Mass ,  atom_True ,  atom_Icode ,  atom_$S });
      }
 }


 void act359( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { markDict( state ,  state.lex ,  atom_Features ,  wordSet_Trans$Passive ,  true );
       addCatSense( state ,  category_V ,  state.lex ,  new Value[] { atom_Tns ,  atom_Present ,  atom_Agr ,  atom_Not3sg ,  atom_Untensed ,  atom_True ,  atom_Icode ,  atom_S$D });
      }
 }


 void act360( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     ( ( state.root.getWordString().length()  >  2 ) &&
       plausibleRoot( state.root )) &&
     testPostTest( state ));
 }


 void act361( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Nn )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       state.lex.addSuffixes( wordSet_Ate );
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] {});
      }
 }


 void act362( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_V$Adj$Nn )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       state.lex.addSuffixes( wordSet_Ate );
       addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Icode ,  atom_$S });
      }
 }


 void act363( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Nn$Adj$V )) &&
          catPostTest( state ))
      { markDict( state ,  state.lex ,  atom_Features ,  wordSet_Trans$Passive ,  true );
       state.lex.addRoot( state.root );
       state.lex.addSuffixes( wordSet_Ate );
       addCatSense( state ,  category_V ,  state.lex ,  new Value[] { atom_Tns ,  atom_Present ,  atom_Agr ,  atom_Not3sg ,  atom_Untensed ,  atom_True ,  atom_Icode ,  atom_S$D });
      }
 }


 void act364( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     ( ( state.root.getWordString().length()  >  2 ) &&
       plausibleRoot( state.root ) &&
       polysyllabic( state.root )) &&
     testPostTest( state ));
 }


 void act365( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_V$Adj$Nn )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       state.lex.addSuffixes( wordSet_Ate );
       addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Mass ,  atom_True ,  atom_Mass$Pure ,  atom_True ,  atom_Icode ,  atom_Mass });
      }
 }


 void act366( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Nn$Adj$V )) &&
          catPostTest( state ))
      { markDict( state ,  state.lex ,  atom_Features ,  wordSet_Trans$Passive ,  true );
       state.lex.addSuffixes( wordSet_Ate );
       addCatSense( state ,  category_V ,  state.lex ,  new Value[] { atom_Tns ,  atom_Present ,  atom_Agr ,  atom_Not3sg ,  atom_Untensed ,  atom_True ,  atom_Icode ,  atom_S$D });
      }
 }


 void act367( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Prefix )) &&
          catPostTest( state ))
      { state.lex.addPrefixes( new Word[] { state.root });
       state.lex.addSuffixes( wordSet_Ate );
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] {});
      }
 }


 void act368( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Prefix )) &&
          catPostTest( state ))
      { state.lex.addPrefixes( new Word[] { state.root });
       state.lex.addSuffixes( wordSet_Ate );
       addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Icode ,  atom_$S });
      }
 }


 void act369( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Prefix )) &&
          catPostTest( state ))
      { markDict( state ,  state.lex ,  atom_Features ,  wordSet_Trans$Passive ,  true );
       state.lex.addPrefixes( new Word[] { state.root });
       state.lex.addSuffixes( wordSet_Ate );
       addCatSense( state ,  category_V ,  state.lex ,  new Value[] { atom_Tns ,  atom_Present ,  atom_Agr ,  atom_Not3sg ,  atom_Untensed ,  atom_True ,  atom_Icode ,  atom_S$D });
      }
 }


 void act370( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     ( ( state.root.getWordString().length()  >  2 ) &&
       plausibleRoot( state.root ) &&
       polysyllabic( state.root ) &&
       morphRoot( state ) &&
       dict.isKnownWord( state.root )) &&
     testPostTest( state ));
 }


 void act371( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Adj )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       state.lex.addSuffixes( wordSet_Ate );
       addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Icode ,  atom_$S });
      }
 }


 void act372( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Nn$Adj )) &&
          catPostTest( state ))
      { markDict( state ,  state.lex ,  atom_Features ,  wordSet_Trans$Passive ,  true );
       state.lex.addRoot( state.root );
       state.lex.addSuffixes( wordSet_Ate );
       addCatSense( state ,  category_V ,  state.lex ,  new Value[] { atom_Tns ,  atom_Present ,  atom_Agr ,  atom_Not3sg ,  atom_Untensed ,  atom_True ,  atom_Icode ,  atom_S$D });
      }
 }


 void act374( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Adj )) &&
          catPostTest( state ))
      { markDict( state ,  state.lex ,  atom_Features ,  wordSet_Trans$Passive ,  true );
       state.lex.addRoot( state.root );
       state.lex.addSuffixes( wordSet_Ate );
       addCatSense( state ,  category_V ,  state.lex ,  new Value[] { atom_Tns ,  atom_Present ,  atom_Agr ,  atom_Not3sg ,  atom_Untensed ,  atom_True ,  atom_Icode ,  atom_S$D });
      }
 }


 void act375( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Adj$Anyn )) &&
          catPostTest( state ))
      { state.lex.addIkoParent( word_Utensil );
       state.lex.addSuffixes( wordSet_Ware );
       state.lex.addRoot( state.root );
       addCatSense( state ,  category_Nm ,  state.lex ,  new Value[] { atom_Mass$Pure ,  atom_True ,  atom_Mass ,  atom_True ,  atom_Icode ,  atom_Nopl });
      }
 }


 void act376( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Prefix )) &&
          catPostTest( state ))
      { state.lex.addSuffixes( wordSet_Phage );
       state.lex.addPrefixes( new Word[] { state.root });
       markDict( state ,  state.lex ,  atom_Derived$From , dict.makeList( new Word[] { state.root ,  word_Phage }),  true );
       state.lex.applyFalseRoot( state.root );
       addCatSense( state ,  category_Nc ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Icode ,  atom_$S });
      }
 }


 void act377( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Nn )) &&
          catPostTest( state ))
      { state.lex.addIkoParent( word_Poison );
       state.lex.addSuffixes( wordSet_Icide );
       state.lex.addRoot( state.root );
       addCatSense( state ,  category_Nmc ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Mass ,  atom_True ,  atom_Icode ,  atom_$S });
      }
 }


 void act379( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (morphRoot( state ) &&
       (patternCheckLeft( state.root ,  pattern_D$I$S ) ||
         ( ( ! ( patternCheck( state.lex ,  pattern_A$B$J$U$R$E )) ) &&
            ( ! ( patternCheck( state.lex ,  pattern_A$D$J$U$R$E )) ) &&
            ( ! ( patternCheck( state.lex ,  pattern_A$L$L$U$R$E )) ) &&
            ( ! ( patternCheck( state.lex ,  pattern_A$S$S$U$R$E )) ) &&
            ( ! ( patternCheck( state.lex ,  pattern_C$A$P$T$U$R$E )) ) &&
            ( ! ( patternCheck( state.lex ,  pattern_C$A$R$I$C$A$T$U_Etc )) ) &&
            ( ! ( patternCheck( state.lex ,  pattern_C$E$N$S$U$R$E )) ) &&
            ( ! ( patternCheck( state.lex ,  pattern_C$I$N$C$T$U$R$E )) ) &&
            ( ! ( patternCheck( state.lex ,  pattern_C$L$O$S$U$R$E )) ) &&
            ( ! ( patternCheck( state.lex ,  pattern_C$L$O$T$U$R$E )) ) &&
            ( ! ( patternCheck( state.lex ,  pattern_C$O$I$F$F$U$R$E )) ) &&
            ( ! ( patternCheck( state.lex ,  pattern_C$O$N$J$E$C$T$U_Etc )) ) &&
            ( ! ( patternCheck( state.lex ,  pattern_C$O$N$J$U$R$E )) ) &&
            ( ! ( patternCheck( state.lex ,  pattern_C$U$L$T$U$R$E )) ) &&
            ( ! ( patternCheck( state.lex ,  pattern_C$U$R$E )) ) &&
            ( ! ( patternCheck( state.lex ,  pattern_E$N$D$U$R$E )) ) &&
            ( ! ( patternCheck( state.lex ,  pattern_E$N$S$U$R$E )) ) &&
            ( ! ( patternCheck( state.lex ,  pattern_E$N$U$R$E )) ) &&
            ( ! ( patternCheck( state.lex ,  pattern_F$E$A$T$U$R$E )) ) &&
            ( ! ( patternCheck( state.lex ,  pattern_F$I$G$U$R$E )) ) &&
            ( ! ( patternCheck( state.lex ,  pattern_F$I$S$S$U$R$E )) ) &&
            ( ! ( patternCheck( state.lex ,  pattern_F$R$A$C$T$U$R$E )) ) &&
            ( ! ( patternCheck( state.lex ,  pattern_G$E$S$T$U$R$E )) ) &&
            ( ! ( patternCheck( state.lex ,  pattern_H$A$C$H$U$R$E )) ) &&
            ( ! ( patternCheck( state.lex ,  pattern_I$M$M$U$R$E )) ) &&
            ( ! ( patternCheck( state.lex ,  pattern_I$N$D$E$N$T$U$R_Etc )) ) &&
            ( ! ( patternCheck( state.lex ,  pattern_I$N$J$U$R$E )) ) &&
            ( ! ( patternCheck( state.lex ,  pattern_I$N$S$U$R$E )) ) &&
            ( ! ( patternCheck( state.lex ,  pattern_I$N$U$R$E )) ) &&
            ( ! ( patternCheck( state.lex ,  pattern_L$E$C$T$U$R$E )) ) &&
            ( ! ( patternCheck( state.lex ,  pattern_L$I$G$A$T$U$R$E )) ) &&
            ( ! ( patternCheck( state.lex ,  pattern_M$A$N$U$F$A$C$T_Etc )) ) &&
            ( ! ( patternCheck( state.lex ,  pattern_M$A$N$U$R$E )) ) &&
            ( ! ( patternCheck( state.lex ,  pattern_M$E$A$S$U$R$E )) ) &&
            ( ! ( patternCheck( state.lex ,  pattern_M$U$R$E )) ) &&
            ( ! ( patternCheck( state.lex ,  pattern_N$A$T$U$R$E )) ) &&
            ( ! ( patternCheck( state.lex ,  pattern_N$U$R$T$U$R$E )) ) &&
            ( ! ( patternCheck( state.lex ,  pattern_O$V$E$R$T$U$R$E )) ) &&
            ( ! ( patternCheck( state.lex ,  pattern_P$A$S$T$U$R$E )) ) &&
            ( ! ( patternCheck( state.lex ,  pattern_P$E$R$D$U$R$E )) ) &&
            ( ! ( patternCheck( state.lex ,  pattern_P$E$R$J$U$R$E )) ) &&
            ( ! ( patternCheck( state.lex ,  pattern_P$I$C$T$U$R$E )) ) &&
            ( ! ( patternCheck( state.lex ,  pattern_P$L$E$A$S$U$R$E )) ) &&
            ( ! ( patternCheck( state.lex ,  pattern_P$O$S$T$U$R$E )) ) &&
            ( ! ( patternCheck( state.lex ,  pattern_P$R$E$S$S$U$R$E )) ) &&
            ( ! ( patternCheck( state.lex ,  pattern_P$U$N$C$T$U$R$E )) ) &&
            ( ! ( patternCheck( state.lex ,  pattern_R$A$P$T$U$R$E )) ) &&
            ( ! ( patternCheck( state.lex ,  pattern_S$C$U$L$P$T$U$R_Etc )) ) &&
            ( ! ( patternCheck( state.lex ,  pattern_S$E$C$U$R$E )) ) &&
            ( ! ( patternCheck( state.lex ,  pattern_S$T$A$T$U$R$E )) ) &&
            ( ! ( patternCheck( state.lex ,  pattern_S$T$R$I$C$T$U$R_Etc )) ) &&
            ( ! ( patternCheck( state.lex ,  pattern_S$T$R$U$C$T$U$R_Etc )) ) &&
            ( ! ( patternCheck( state.lex ,  pattern_S$U$T$U$R$E )) ) &&
            ( ! ( patternCheck( state.lex ,  pattern_T$E$X$T$U$R$E )) ) &&
            ( ! ( patternCheck( state.lex ,  pattern_T$I$N$C$T$U$R$E )) ) &&
            ( ! ( patternCheck( state.lex ,  pattern_T$O$R$T$U$R$E )) ) &&
            ( ! ( patternCheck( state.lex ,  pattern_T$R$E$A$S$U$R$E )) ) &&
            ( ! ( patternCheck( state.lex ,  pattern_V$E$L$U$R$E )) ) &&
            ( ! ( patternCheck( state.lex ,  pattern_V$E$N$T$U$R$E )) ) &&
            ( ! ( patternCheck( state.lex ,  pattern_V$E$S$T$U$R$E )) )))) &&
     testPostTest( state ));
 }


 void act380( MorphState  state ) {
   if    (catPreTest( state ) &&
          (plausibleRoot( state.root ) &&
            morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Adj$V$Anyn )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Mass ,  atom_True ,  atom_Suffix ,  state.suffix });
      }
 }


 void act381( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       morphRoot( state ) &&
        ( ! ( patternCheck( state.lex ,  pattern_A$L$L$U$R$E )) ) &&
        ( ! ( patternCheck( state.lex ,  pattern_A$S$S$U$R$E )) ) &&
        ( ! ( patternCheck( state.lex ,  pattern_C$O$I$F$F$U$R$E )) ) &&
        ( ! ( patternCheck( state.lex ,  pattern_F$I$S$S$U$R$E )) ) &&
        ( ! ( patternCheck( state.lex ,  pattern_I$M$M$U$R$E )) ) &&
        ( ! ( patternCheck( state.lex ,  pattern_P$R$E$S$S$U$R$E )) )) &&
     testPostTest( state ));
 }


 void act382( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Adj$V$Anyn )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Mass ,  atom_True ,  atom_Suffix ,  state.suffix });
      }
 }


 void act384( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Nn )) &&
          catPostTest( state ))
      { state.lex.addVariantOf( state.root );
       state.lex.addRoot( state.root );
       addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Suffix ,  state.suffix });
      }
 }


 void act385( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       needFinalE( state.root ) &&
       morphRoot( state ) &&
       dict.isKnownWord( state.root ) &&
        ( ! ( patternCheck( state.root ,  pattern_E )) )) &&
     testPostTest( state ));
 }


 void act387( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       morphRoot( state ) &&
        ( ! ( patternCheck( state.root ,  pattern_E )) )) &&
     testPostTest( state ));
 }


 void act389( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Adj )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Mass ,  atom_True ,  atom_Suffix ,  state.suffix });
      }
 }


 void act391( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_V )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Mass ,  atom_True ,  atom_Suffix ,  state.suffix });
      }
 }


 void act392( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Adj$Anyn )) &&
          catPostTest( state ))
      { state.lex.addIkoParent( state.root );
       state.lex.addIioParent( word_Family_Of_Anima_Etc );
       state.lex.addSuffixes( wordSet_Aceae );
       state.lex.addRoot( state.root );
       addCatSense( state ,  category_Npr ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg$Pl });
      }
 }


 void act393( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Adj$Anyn )) &&
          catPostTest( state ))
      { state.lex.addIkoParent( word_Animal );
       state.lex.addIioParent( word_Family_Of_Anima_Etc );
       state.lex.addSuffixes( wordSet_Idae );
       state.lex.addRoot( state.root );
       addCatSense( state ,  category_Npr ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg$Pl });
      }
 }


 void act394( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Nn )) &&
          catPostTest( state ))
      { state.lex.addIkoParent( word_Animal );
       state.lex.addIioParent( word_Family_Of_Anima_Etc );
       state.lex.addSuffixes( wordSet_Idae );
       state.lex.addRoot( state.root );
       addCatSense( state ,  category_Npr ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg$Pl });
      }
 }


 void act395( MorphState  state ) {
   if    (catPreTest( state ) &&
          polysyllabic( state.root ) &&
          catPostTest( state ))
      { state.lex.addIkoParent( word_Animal );
       state.lex.addIioParent( word_Family_Of_Anima_Etc );
       state.lex.addSuffixes( wordSet_Idae );
       state.lex.addRoot( state.root );
       addCatSense( state ,  category_Npr ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg$Pl });
      }
 }


 void act396( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Adj$Anyn )) &&
          catPostTest( state ))
      { state.lex.addIkoParent( word_$N$Plant$Vegeta_Etc );
       state.lex.addIioParent( word_Family_Of_Plant );
       state.lex.addSuffixes( wordSet_Ae );
       state.lex.addRoot( state.root );
       addCatSense( state ,  category_Npr ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg$Pl });
      }
 }


 void act397( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Anyn )) &&
          catPostTest( state ))
      addCatSense( state ,  category_N ,  state.root ,  new Value[] { atom_Number ,  atom_Pl });
 }


 void act399( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_V )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root.makeSenseNamesIfNeeded(categorySet_V)[0] );
       addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Suffix ,  state.suffix });
      }
 }


 void act400( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       (needFinalE( state.root ) ||
         polysyllabic( state.root ))) &&
     testPostTest( state ));
 }


 void act401( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Femalefirstname ) &&
             ( ! ( isKnownKindOf( state.root ,  word_Nickname )) )) &&
          catPostTest( state ))
      { state.lex.addVariantOf( state.root );
       addCatSense( state ,  category_Femalefirstname ,  state.lex ,  new Value[] {});
      }
 }


 void act402( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Firstname )) &&
          catPostTest( state ))
      { state.lex.addVariantOf( state.root );
       state.lex.addIioParent( word_Nickname );
       addCatSense( state ,  category_Femalefirstname ,  state.lex ,  new Value[] {});
      }
 }


 void act403( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Nn )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root.makeSenseNamesIfNeeded(categorySet_Nn)[0] );
       addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Suffix ,  state.suffix });
      }
 }


 void act404( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_V )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root.makeSenseNamesIfNeeded(categorySet_V)[0] );
       addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Suffix ,  state.suffix });
      }
 }


 void act405( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            mayBeCat( state ,  state.root ,  category_V )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root.makeSenseNamesIfNeeded(categorySet_V)[0] );
       addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Suffix ,  state.suffix });
      }
 }


 void act406( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Adj )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       state.lex.addSuffixes( wordSet_Ie );
       state.lex.addIkoParent(morphPackLex( state , state.root.getWordString(),  "_THING" ));
       addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Icode ,  atom_$S });
      }
 }


 void act407( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Nn )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       state.lex.addSuffixes( wordSet_Ie );
       state.lex.addIkoParent(morphPackLex( state ,  "little_" , state.root.getWordString()));
       addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Icode ,  atom_$S });
      }
 }


 void act410( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Adj )) &&
          catPostTest( state ))
      { state.lex.addVariantOf( state.root );
       state.lex.addRoot( state.root );
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] { atom_Suffix ,  state.suffix });
      }
 }


 void act411( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Prefix )) &&
          catPostTest( state ))
      { state.lex.applyFalseRoot( state.root );
       state.lex.addIkoParent( word_Chemical );
       state.lex.addSuffixes( wordSet_Ose );
       state.lex.addPrefixes( new Word[] { state.root });
       markDict( state ,  state.lex ,  atom_Domain ,  wordSet_Chemistry ,  true );
       addCatSense( state ,  category_Nm ,  state.lex ,  new Value[] { atom_Mass$Pure ,  atom_True ,  atom_Mass ,  atom_True ,  atom_Icode ,  atom_$S });
      }
 }


 void act412( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Adj )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] { atom_Suffix ,  state.suffix });
      }
 }


 void act413( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Nn ) &&
             ( ! ( patternCheck( state.root ,  pattern_E )) ) &&
            plausibleRoot( state.root )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] { atom_Suffix ,  state.suffix });
      }
 }


 void act414( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] { atom_Suffix ,  state.suffix });
 }


 void act415( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.addIkoParent( word_$N$Plant$Vegeta_Etc );
       state.lex.addIioParent( word_Family_Of_Plant );
       state.lex.addSuffixes( wordSet_Aceae );
       addCatSense( state ,  category_Npr ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg$Pl });
      }
 }


 void act416( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.addIkoParent( word_$N$Plant$Vegeta_Etc );
       state.lex.addIioParent( word_Family_Of_Plant );
       state.lex.addSuffixes( wordSet_Phyceae );
       addCatSense( state ,  category_Npr ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg$Pl });
      }
 }


 void act417( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.addIkoParent( word_Animal );
       state.lex.addIioParent( word_Family_Of_Anima_Etc );
       state.lex.addSuffixes( wordSet_Idae );
       addCatSense( state ,  category_Npr ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg$Pl });
      }
 }


 void act418( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.addIkoParent( word_Animal );
       state.lex.addIioParent( word_Subfamily_Of_An_Etc );
       state.lex.addSuffixes( wordSet_Inae );
       addCatSense( state ,  category_Npr ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg$Pl });
      }
 }


 void act419( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     syllabic( state.root ) &&
     testPostTest( state ));
 }


 void act420( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Number ,  atom_Pl });
      }
 }


 void act422( MorphState  state ) {
   if    (catPreTest( state ) &&
          polysyllabic( state.root ) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] { atom_Suffix ,  state.suffix });
      }
 }


 void act423( MorphState  state ) {
   if    (catPreTest( state ) &&
          polysyllabic( state.root ) &&
          catPostTest( state ))
      addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] { atom_Suffix ,  state.suffix });
 }


 void act424( MorphState  state ) {
   if    (catPreTest( state ) &&
          plausibleRoot( state.root ) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] { atom_Suffix ,  state.suffix });
      }
 }


 void act425( MorphState  state ) {
   if    (catPreTest( state ) &&
          plausibleRoot( state.root ) &&
          catPostTest( state ))
      { if   (patternCheck( state.lex ,  pattern_S$E ) ||
              patternCheck( state.lex ,  pattern_Y$$S_Z$$E ))
          { state.lex.addVariantOf(morphPackLex( state , state.root.getWordString(),  "IZE" ));
           markDict( state ,  state.lex ,  atom_Features ,  wordSet_British ,  true );
          }
       state.lex.addSuffixes( wordSet_Ize );
       state.lex.addRoot( state.root );
       addCatSense( state ,  category_V ,  state.lex ,  new Value[] { atom_Tns ,  atom_Present ,  atom_Agr ,  atom_Not3sg ,  atom_Untensed ,  atom_True ,  atom_Icode ,  atom_S$D });
      }
 }


 void act426( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Anyn$V )) &&
          catPostTest( state ))
      { state.lex.addIkoParent( word_Borne );
       state.lex.addRoot( word_Borne );
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] { atom_Prefix ,  state.root });
      }
 }


 void act427( MorphState  state ) {
   if    (catPreTest( state ) &&
          plausibleRoot( state.root ) &&
          catPostTest( state ))
      { markDict( state ,  state.lex ,  atom_Guessed ,  wordSet_T ,  false );
       { state.lex.addIkoParent( word_Borne );
        state.lex.addRoot( word_Borne );
        addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] { atom_Prefix ,  state.root });
       }
      }
 }


 void act429( MorphState  state ) {
   if    (catPreTest( state ) &&
          plausibleRoot( state.root ) &&
          catPostTest( state ))
      { markDict( state ,  state.lex ,  atom_Guessed ,  wordSet_T ,  false );
       { state.lex.addRoot( state.root );
        addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] { atom_Suffix ,  state.suffix });
       }
      }
 }


 void act430( MorphState  state ) {
   if    (catPreTest( state ) &&
          plausibleRoot( state.root ) &&
          catPostTest( state ))
      { markDict( state ,  state.lex ,  atom_Guessed ,  wordSet_T ,  false );
       addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg });
      }
 }


 void act431( MorphState  state ) {
   if    (catPreTest( state ) &&
          plausibleRoot( state.root ) &&
          catPostTest( state ))
      { state.lex.addSuffixes( wordSet_Phile );
       addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Icode ,  atom_$S });
      }
 }


 void act432( MorphState  state ) {
   if    (catPreTest( state ) &&
          polysyllabic( state.root ) &&
          catPostTest( state ))
      { state.lex.addSuffixes( wordSet_Cide );
       addCatSense( state ,  category_Nmc ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Mass ,  atom_True ,  atom_Icode ,  atom_$S });
      }
 }


 void act433( MorphState  state ) {
   if    (catPreTest( state ) &&
          polysyllabic( state.root ) &&
          catPostTest( state ))
      addCatSense( state ,  category_Nm ,  state.lex ,  new Value[] { atom_Mass$Pure ,  atom_True ,  atom_Mass ,  atom_True ,  atom_Icode ,  atom_$S });
 }


 void act434( MorphState  state ) {
   if    (catPreTest( state ) &&
          plausibleRoot( state.root ) &&
          catPostTest( state ))
      addCatSense( state ,  category_V ,  state.lex ,  new Value[] { atom_Tns ,  atom_Present ,  atom_Agr ,  atom_Not3sg ,  atom_Untensed ,  atom_True ,  atom_Icode ,  atom_S$D });
 }


 void act435( MorphState  state ) {
   if    (catPreTest( state ) &&
          plausibleRoot( state.root ) &&
          catPostTest( state ))
      addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Icode ,  atom_$S });
 }


 void act436( MorphState  state ) {
   if    (catPreTest( state ) &&
          polysyllabic( state.root ) &&
          catPostTest( state ))
      { state.lex.addIkoParent( word_Utensil );
       addCatSense( state ,  category_Nm ,  state.lex ,  new Value[] { atom_Mass$Pure ,  atom_True ,  atom_Mass ,  atom_True ,  atom_Icode ,  atom_Nopl });
      }
 }


 void act437( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       morphRoot( state ) &&
       dict.isKnownWord( state.root ) &&
       isFormOfCat( state.root ,  categorySet_Anyn ) &&
       state.root.isKindOf( word_Person )) &&
     testPostTest( state ));
 }


 void act438( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.addSuffixes( wordSet_Ine );
       state.lex.addRoot( state.root );
       state.lex.addIkoParent( word_Female );
       state.lex.addIkoParent( state.root );
       addCatSense( state ,  category_Nc ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Icode ,  atom_$S });
      }
 }


 void act439( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isKnownFormOfCat( state.root ,  categorySet_Nm )) &&
          catPostTest( state ))
      addCatSense( state ,  category_Nm ,  state.lex , copyFeatures( state.root ,  category_Nm ));
 }


 void act440( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       morphRoot( state ) &&
       dict.isKnownWord( state.root ) &&
       polysyllabic( state.root ) &&
       isFormOfCat( state.root ,  categorySet_Anyn )) &&
     testPostTest( state ));
 }


 void act441( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.addSuffixes( wordSet_Ine );
       state.lex.addRoot( state.root );
       addCatSense( state ,  category_Nmc ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Mass ,  atom_True ,  atom_Icode ,  atom_$S });
      }
 }


 void act442( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       morphRoot( state ) &&
       dict.isKnownWord( state.root ) &&
       polysyllabic( state.root ) &&
       isFormOfCat( state.root ,  categorySet_Nn )) &&
     testPostTest( state ));
 }


 void act443( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       morphRoot( state ) &&
       isFormOfCat( state.root ,  categorySet_Anyn )) &&
     testPostTest( state ));
 }


 void act444( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       needFinalE( state.root ) &&
       morphRoot( state ) &&
       isFormOfCat( state.root ,  categorySet_Nn )) &&
     testPostTest( state ));
 }


 void act445( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      addCatSense( state ,  category_Nmc ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Mass ,  atom_True ,  atom_Icode ,  atom_$S });
 }


 void act446( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.addSuffixes( wordSet_One );
       markDict( state ,  state.lex ,  atom_Domain ,  wordSet_Chemistry ,  true );
       addCatSense( state ,  category_Nmc ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Mass ,  atom_True ,  atom_Icode ,  atom_$S });
      }
 }


 void act447( MorphState  state ) {
   if    (catPreTest( state ) &&
           sp_makeGerundFlag  &&
          catPostTest( state ))
      addCatSense( state ,  category_Nmc ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Mass ,  atom_True ,  atom_Icode ,  atom_$S });
 }


 void act448( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      addCatSense( state ,  category_V ,  state.root ,  new Value[] { atom_Prespart ,  atom_True });
 }


 void act449( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (morphRoot( state ) &&
       isRootOfCat( state.root ,  categorySet_V ) &&
       state.root.testIcode( category_V ,  atomSet_S$D$S$Ed$Irrv$I_Etc )) &&
     testPostTest( state ));
 }


 void act452( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (morphRoot( state ) &&
       isRootOfCat( state.root ,  categorySet_V ) &&
       state.root.testIcode( category_V ,  atomSet_S$D$S$Ed$Es$Ed$_Etc$ )) &&
     testPostTest( state ));
 }


 void act453( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (morphRoot( state ) &&
       isRootOfCat( state.root ,  categorySet_V ) &&
       state.root.testIcode( category_V ,  atomSet_S$D$Irrv$Irrv ) &&
        ( state.root  !=  word_Singe ) &&
        ( ! (state.root.hasRoot( word_Singe ) &&
            (state.root.getSuffixes() ==  null )))) &&
     testPostTest( state ));
 }


 void act454( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (morphRoot( state ) &&
       isRootOfCat( state.root ,  categorySet_V ) &&
       state.root.testIcode( category_V ,  atomSet_S$$Ed$Es$$Ed$$E_Etc$ )) &&
     testPostTest( state ));
 }


 void act455( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { if   (state.root.testIcode( category_V ,  atomSet_S$Ed$$Ed$Es$Ed$_Etc ))
          markDict( state ,  state.lex ,  atom_Sense$Kinds , dict.makeList( new Value[] {(Value)(morphPackLex(state, state.root.getWordString(), "ING").makeSenseName( category_N )), (Value)(morphPackLex(state, state.root.getWordString(), "ING").makeSenseName( category_Adj )), (Value)(state.root.makeSenseName( category_V ))}),  true );
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] {});
      }
 }


 void act456( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (morphRoot( state ) &&
       isRootOfCat( state.root ,  categorySet_V ) &&
       state.root.testIcode( category_V ,  atomSet_S$Ed$S$Ked$Irrv_Etc )) &&
     testPostTest( state ));
 }


 void act457( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.applyFalseRoot( state.root );
       state.lex.addPrefixes( new Word[] { state.root });
       state.lex.addRoot( word_Owning );
       state.lex.addIkoParent(dict.makeStructuredConcept( category_Nm , dict.makeList( new Value[] { word_Owning , dict.makeList( new Value[] { word_Of , dict.makeList( new Value[] { state.root })})})));
       addCatSense( state ,  category_Nm ,  state.lex ,  new Value[] { atom_Mass$Pure ,  atom_True ,  atom_Mass ,  atom_True ,  atom_Icode ,  atom_$S });
      }
 }


 void act458( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       morphRoot( state ) &&
        ( ! ( dict.isKnownWord( state.root )) ) &&
       isCompoundCat( state.root ,  category_V ) &&
        ( ! ( isRootOfCat( state.root ,  categorySet_Adj )) ) &&
       isRootOfCat(word1( state.root ),  categorySet_Anyn ) &&
       isRootOfCat(word2( state.root ),  categorySet_V )) &&
     testPostTest( state ));
 }


 void act459( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      {  Word  tempWord1011 ;
       if    (word2(state.root).looksLike( category_Vt ))
           tempWord1011  =  word_Of ;

       else   tempWord1011  =  word_Mod ;
       addCompoundSuffixCatSenses( state ,  category_Nm ,  state.lex ,  category_N ,  state.root ,  1 ,  word_Ing ,  tempWord1011 );
      }
 }


 void act460( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      {  Word  tempWord1013 ;
       if    (word2(state.root).looksLike( category_Vt ))
           tempWord1013  =  word_Of ;

       else   tempWord1013  =  word_Mod ;
       addCompoundSuffixCatSenses( state ,  category_Nm ,  state.lex ,  category_N ,  state.root ,  0 ,  word_Ing ,  tempWord1013 );
      }
 }


 void act461( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      {  Word  tempWord1015 ;
       if    (word2(state.root).looksLike( category_Vt ))
           tempWord1015  =  word_Of ;

       else   tempWord1015  =  word_Mod ;
       addCompoundSuffixCatSenses( state ,  category_Nm ,  state.lex ,  category_N ,  state.root ,  -1 ,  word_Ing ,  tempWord1015 );
      }
 }


 void act462( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       morphRoot( state ) &&
       isRootOfCat( state.root ,  categorySet_V ) &&
        ( ! ( needDoubleLetter( state.root )) )) &&
     testPostTest( state ));
 }


 void act463( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (morphRoot( state ) &&
       isRootOfCat( state.root ,  categorySet_V ) &&
       needFinalE( state.root ) &&
        ( state.root  !=  word_Singe ) &&
        ( ! (state.root.hasRoot( word_Singe ) &&
            (state.root.getSuffixes() ==  null )))) &&
     testPostTest( state ));
 }


 void act464( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       needFinalE( state.root ) &&
       morphRoot( state ) &&
       isRootOfCat( state.root ,  categorySet_V )) &&
     testPostTest( state ));
 }


 void act465( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (morphRoot( state ) &&
       isRootOfCat( state.root ,  categorySet_Nn )) &&
     testPostTest( state ));
 }


 void act466( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       needFinalE( state.root ) &&
       morphRoot( state ) &&
       isRootOfCat( state.root ,  categorySet_Nn )) &&
     testPostTest( state ));
 }


 void act467( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       morphRoot( state ) &&
       isRootOfCat( state.root ,  categorySet_Nn )) &&
     testPostTest( state ));
 }


 void act469( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Nn )) &&
          catPostTest( state ))
      { state.lex.addIkoParent(morphPackLex( state ,  "little_" , state.root.getWordString()));
       state.lex.addRoot( state.root );
       addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Suffix ,  state.suffix });
      }
 }


 void act470( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Adj )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Suffix ,  state.suffix });
      }
 }


 void act471( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (morphRoot( state ) &&
    		 LexiconUtil.isMembOfArray( state.root ,  wordSet_Tie$Die$Lie$Unt_Etc )) &&
     testPostTest( state ));
 }


 void act472( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_V ,  state.lex ,  new Value[] { atom_Prespart ,  atom_True });
      }
 }


 void act473( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (morphRoot( state ) &&
       mayBeCat( state ,  state.root ,  category_V$N )) &&
     testPostTest( state ));
 }


 void act474( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { markDict( state ,  state.lex ,  atom_Guessed , dict.makeAtom( "t" ),  false );
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] {});
      }
 }


 void act475( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (polysyllabic( state.root ) &&
       morphRoot( state ) &&
       ( (morphCompoundTest( state.root ,  state ,  category_V ) !=  null ) ||
          (morphCompoundTest( state.root ,  state ,  category_N ) !=  null ))) &&
     testPostTest( state ));
 }


 void act476( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (polysyllabic( state.root ) &&
       morphRoot( state ) &&
       mayBeCat( state ,  state.root ,  category_V$N )) &&
     testPostTest( state ));
 }


 void act477( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (needFinalE( state.root ) &&
       morphRoot( state ) &&
       mayBeCat( state ,  state.root ,  category_V$N )) &&
     testPostTest( state ));
 }


 void act478( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (morphRoot( state ) &&
       mayBeCat( state ,  state.root ,  category_V$N ) &&
        ( ! ( polysyllabic( state.root )) )) &&
     testPostTest( state ));
 }


 void act479( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (needFinalE(morphPackLex( state , state.root.getWordString(),  "E" )) &&
       morphRoot( state ) &&
       mayBeCat( state ,  state.root ,  category_V$N )) &&
     testPostTest( state ));
 }


 void act480( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      addCatSense( state ,  category_V ,  state.lex ,  new Value[] { atom_Tns ,  atom_Present ,  atom_Agr ,  atom_Not3sg ,  atom_Untensed ,  atom_True ,  atom_Icode ,  atom_S$Ed });
 }


 void act481( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (morphRoot( state ) &&
       mayBeCat( state ,  state.root ,  category_V$N ) &&
        ( ! ( needDoubleLetter( state.root )) )) &&
     testPostTest( state ));
 }


 void act482( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Nn$Adj ) &&
             ( ! ( isFormOfCat( state.root ,  categorySet_Prespart$Pastpa_Etc )) )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] { atom_Suffix ,  word_Ial });
      }
 }


 void act483( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Prefix ) &&
             ( ! ( isFormOfCat( state.root ,  categorySet_Prespart$Pastpa_Etc )) )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] { atom_Derived$From , dict.makeList( new Word[] { state.root ,  word_Ial }),  atom_Suffix ,  word_Ial });
      }
 }


 void act485( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       morphRoot( state ) &&
       dict.isKnownWord( state.root ) &&
       state.root.noPrefix()) &&
     testPostTest( state ));
 }


 void act486( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Nn$Adj ) &&
             ( ! ( isFormOfCat( state.root ,  categorySet_Prespart$Pastpa_Etc )) )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] { atom_Suffix ,  word_Eal });
      }
 }


 void act487( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Nn$Adj )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] { atom_Suffix ,  word_Al });
      }
 }


 void act488( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Anyn )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] { atom_Suffix ,  word_Ical });
      }
 }


 void act489( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Prefix )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] { atom_Suffix ,  word_Petal });
      }
 }


 void act490( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Nn$Adj$Prefix )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] { atom_Suffix ,  word_Al });
      }
 }


 void act491( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_V )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_Nmc ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Mass ,  atom_True ,  atom_Suffix ,  word_Al });
      }
 }


 void act492( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       morphRoot( state ) &&
       state.root.hasPrefix( wordSet_Re )) &&
     testPostTest( state ));
 }


 void act493( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root )) &&
     testPostTest( state ));
 }


 void act494( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (polysyllabic( state.root ) &&
       morphRoot( state ) &&
       dict.isKnownWord( state.root )) &&
     testPostTest( state ));
 }


 void act495( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Adj )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] { atom_Suffix ,  word_Al });
      }
 }


 void act496( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (polysyllabic( state.root ) &&
       morphRoot( state ) &&
        ( ! ( patternCheck( state.root ,  pattern_O$U$S )) )) &&
     testPostTest( state ));
 }


 void act497( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Nn )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] { atom_Suffix ,  word_Al });
      }
 }


 void act498( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (polysyllabic( state.root ) &&
        ( state.root.getWordString().length()  >  3 ) &&
       morphRoot( state ) &&
       dict.isKnownWord( state.root )) &&
     testPostTest( state ));
 }


 void act499( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            dict.isKnownWord( state.root ) &&
            isRootOfCat( state.root ,  categorySet_Prefix )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] { atom_Suffix ,  word_Al });
      }
 }


 void act500( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            dict.isKnownWord( state.root ) &&
            isRootOfCat( state.root ,  categorySet_Nn$Adj ) &&
            polysyllabic( state.root )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] { atom_Suffix ,  word_Ical });
      }
 }


 void act501( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Nn$Adj ) &&
            polysyllabic( state.root )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] { atom_Suffix ,  word_Ical });
      }
 }


 void act502( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
      ( state.root.getWordString().length()  >  4 ) &&
     testPostTest( state ));
 }


 void act503( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (polysyllabic( state.root ) &&
        ( state.root.getWordString().length()  >  3 )) &&
     testPostTest( state ));
 }


 void act504( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { markDict( state ,  state.lex ,  atom_Guessed ,  wordSet_T ,  false );
       addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Suffix ,  word_Al ,  atom_Prob ,  word_50 });
      }
 }


 void act505( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Anyn$V$Adj )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] { atom_Suffix ,  word_Ful });
      }
 }


 void act506( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Anyn ) &&
             ( ! ( state.root.testIcode( category_N ,  atomSet_$S$$Es$$S$Es$$$_Etc$ )) )) &&
          catPostTest( state ))
      { state.lex.addVariantOf(morphPackLex( state , state.root.getWordString(),  "FULS" ));
       state.lex.addRoot( state.root );
       addCatSense( state ,  category_N , morphPackLex( state , state.root.getWordString(),  "FULL" ),  new Value[] { atom_Number ,  atom_Pl ,  atom_Suffix ,  word_Full ,  atom_N$Takes$Preps ,  word_Of });
      }
 }


 void act507( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            dict.isKnownWord( state.root )) &&
          catPostTest( state ))
      { state.lex.addVariantOf(morphPackLex( state , state.root.getWordString(),  "FULS" ));
       state.lex.addRoot( state.root );
       addCatSense( state ,  category_N , morphPackLex( state , state.root.getWordString(),  "FULL" ),  new Value[] { atom_Number ,  atom_Pl ,  atom_Suffix ,  word_Full ,  atom_N$Takes$Preps ,  word_Of });
      }
 }


 void act508( MorphState  state ) {
   if    (catPreTest( state ) &&
          (needFinalE( state.root ) &&
            morphRoot( state ) &&
            mayBeCat( state ,  state.root ,  category_N )) &&
          catPostTest( state ))
      { state.lex.addVariantOf(morphPackLex( state , state.root.getWordString(),  "FULS" ));
       state.lex.addRoot( state.root );
       addCatSense( state ,  category_N , morphPackLex( state , state.root.getWordString(),  "FULL" ),  new Value[] { atom_Number ,  atom_Pl ,  atom_Suffix ,  word_Full ,  atom_N$Takes$Preps ,  word_Of });
      }
 }


 void act509( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            mayBeCat( state ,  state.root ,  category_N )) &&
          catPostTest( state ))
      { state.lex.addVariantOf(morphPackLex( state , state.root.getWordString(),  "FULS" ));
       state.lex.addRoot( state.root );
       addCatSense( state ,  category_N , morphPackLex( state , state.root.getWordString(),  "FULL" ),  new Value[] { atom_Number ,  atom_Pl ,  atom_Suffix ,  word_Full ,  atom_N$Takes$Preps ,  word_Of });
      }
 }


 void act510( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Anyn )) &&
          catPostTest( state ))
      { state.lex.addVariantOf(morphPackLex( state , state.root.getWordString(),  "FULS" ));
       state.lex.addRoot( state.root );
       addCatSense( state ,  category_N , morphPackLex( state , state.root.getWordString(),  "FULL" ),  new Value[] { atom_Number ,  atom_Pl ,  atom_Suffix ,  word_Full ,  atom_N$Takes$Preps ,  word_Of });
      }
 }


 void act511( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { markDict( state ,  state.lex ,  atom_Guessed ,  wordSet_T ,  false );
       { state.lex.addVariantOf(morphPackLex( state , state.root.getWordString(),  "FULS" ));
        state.lex.addRoot( state.root );
        addCatSense( state ,  category_N , morphPackLex( state , state.root.getWordString(),  "FULL" ),  new Value[] { atom_Number ,  atom_Pl ,  atom_Suffix ,  word_Full ,  atom_N$Takes$Preps ,  word_Of });
       }
      }
 }


 void act512( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
             ( ! ( polysyllabic( state.root )) )) &&
          catPostTest( state ))
      { markDict( state ,  state.lex ,  atom_Guessed ,  wordSet_T ,  false );
       { state.lex.addVariantOf(morphPackLex( state , state.root.getWordString(),  "FULS" ));
        state.lex.addRoot( state.root );
        addCatSense( state ,  category_N , morphPackLex( state , state.root.getWordString(),  "FULL" ),  new Value[] { atom_Number ,  atom_Pl ,  atom_Suffix ,  word_Full ,  atom_N$Takes$Preps ,  word_Of });
       }
      }
 }


 void act513( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Anyn )) &&
          catPostTest( state ))
      { state.lex.addVariantOf(morphPackLex( state , state.root.getWordString(),  "FUL" ));
       state.lex.addRoot( state.root );
       addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Suffix ,  word_Full });
      }
 }


 void act514( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       morphRoot( state ) &&
       isRootOfCat( state.root ,  categorySet_Nc ) &&
       state.root.someSenseIsKindOf( word_Container )) &&
     testPostTest( state ));
 }


 void act515( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.addIioParent( word_Unit_Of_Measure );
       state.lex.addIkoParent( word_Amount );
       { state.lex.addIioParent( word_Unit_Of_Measure );
        state.lex.addRoot( state.root );
        addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Suffix ,  word_Ful });
       }
      }
 }


 void act516( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       morphRoot( state ) &&
       isRootOfCat( state.root ,  categorySet_Nc ) &&
       ( ( ! ( isFormOfCat( state.root ,  categorySet_Nm )) ) ||
         isFormOfCat( state.root ,  categorySet_Ncm ) ||
         isPenaltyFormOfCat( state.root ,  categorySet_Nm )) &&
       state.root.someSenseIsKindOf( word_Physical_Someth_Etc ) &&
        ( ! ( state.root.someSenseIsKindOf( word_Animal )) )) &&
     testPostTest( state ));
 }


 void act517( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       morphRoot( state ) &&
       isRootOfCat( state.root ,  categorySet_Anyn ) &&
       state.root.someSenseIsKindOf( word_Mental_Somethin_Etc )) &&
     testPostTest( state ));
 }


 void act518( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       state.lex.addSuffixes( wordSet_Ful );
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] {});
      }
 }


 void act519( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       morphRoot( state ) &&
       isRootOfCat( state.root ,  categorySet_Anyn ) &&
       state.root.someSenseIsKindOf( word_Abstract_Someth_Etc )) &&
     testPostTest( state ));
 }


 void act520( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       morphRoot( state ) &&
       isRootOfCat( state.root ,  categorySet_Nm ) &&
       ( ( ! ( isFormOfCat( state.root ,  categorySet_Nc )) ) ||
         isPenaltyFormOfCat( state.root ,  categorySet_Nc )) &&
        ( ! ( isPenaltyFormOfCat( state.root ,  categorySet_Nm )) )) &&
     testPostTest( state ));
 }


 void act521( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Nm )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] { atom_Suffix ,  word_Ful ,  atom_Prob ,  word_60 });
      }
 }


 void act522( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Nc ) &&
             ( ! ( state.root.someSenseIsKindOf( word_Animal )) ) &&
             (state.root.getdict( feature_Guessed ) ==  null )) &&
          catPostTest( state ))
      { state.lex.addIioParent( word_Unit_Of_Measure );
       state.lex.addIkoParent( word_Amount );
       state.lex.addRoot( state.root );
       addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Suffix ,  word_Ful ,  atom_Prob ,  word_40 });
      }
 }


 void act523( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Anyn$V$Adj$Adv )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] { atom_Suffix ,  word_Ful });
      }
 }


 void act524( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       morphRoot( state ) &&
       isRootOfCat( state.root ,  categorySet_Nm$Adj$Prefix )) &&
     testPostTest( state ));
 }


 void act525( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.addIkoParent( word_Animal );
       state.lex.addRoot( state.root );
       addCatSense( state ,  category_Nm ,  state.lex ,  new Value[] { atom_Suffix ,  word_Dactyl });
      }
 }


 void act526( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Nm$Adj$Prefix )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_Nm ,  state.lex ,  new Value[] { atom_Suffix ,  word_Yl ,  atom_Domain ,  word_Chemistry });
      }
 }


 void act528( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       polysyllabic( state.root ) &&
       morphRoot( state ) &&
       isFormOfCat( state.root ,  categorySet_Prefix )) &&
     testPostTest( state ));
 }


 void act529( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.applyFalseRoot( state.root );
       state.lex.addSuffixes( wordSet_Phil );
       state.lex.addPrefixes( new Word[] { state.root });
       state.lex.addRoot( state.lex );
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] {});
      }
 }


 void act530( MorphState  state ) {
   if    (catPreTest( state ) &&
          polysyllabic( state.root ) &&
          catPostTest( state ))
      addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Mass ,  atom_True ,  atom_Mass$Pure ,  atom_True ,  atom_Icode ,  atom_Mass });
 }


 void act531( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.addIkoParent( word_Animal );
       addCatSense( state ,  category_Nm ,  state.lex ,  new Value[] { atom_Suffix ,  word_Dactyl });
      }
 }


 void act532( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      addCatSense( state ,  category_Nm ,  state.lex ,  new Value[] { atom_Domain ,  word_Chemistry });
 }


 void act533( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Anyn )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Suffix ,  word_Dom });
      }
 }


 void act534( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Nn$V$Adj )) &&
          catPostTest( state ))
      { state.lex.addSuffixes( wordSet_Ism );
       state.lex.addRoot( state.root );
       makeRealWord( state ,  state.root );
       addCatSense( state ,  category_Nm ,  state.lex ,  new Value[] { atom_Mass$Pure ,  atom_True ,  atom_Mass ,  atom_True ,  atom_Icode ,  atom_$S });
      }
 }


 void act535( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       needFinalE( state.root ) &&
       morphRoot( state ) &&
       dict.isKnownWord( state.root ) &&
        ( ! ( patternCheck( state.root ,  pattern_E$E )) )) &&
     testPostTest( state ));
 }


 void act536( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Nn$V$Adj )) &&
          catPostTest( state ))
      { state.lex.addSuffixes( wordSet_Ism );
       state.lex.addRoot( state.root );
       makeRealWord( state ,  state.root );
       addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Icode ,  atom_$S });
      }
 }


 void act537( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Anyn$V$Adj )) &&
          catPostTest( state ))
      { state.lex.addSuffixes( wordSet_Ism );
       state.lex.addRoot( state.root );
       makeRealWord( state ,  state.root );
       addCatSense( state ,  category_Nm ,  state.lex ,  new Value[] { atom_Mass$Pure ,  atom_True ,  atom_Mass ,  atom_True ,  atom_Icode ,  atom_$S });
      }
 }


 void act538( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       morphRoot( state ) &&
        ( ! ( patternCheck( state.root ,  pattern_E$E )) )) &&
     testPostTest( state ));
 }


 void act540( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Prefix )) &&
          catPostTest( state ))
      { state.lex.addSuffixes( wordSet_Ism );
       state.lex.addRoot( state.root );
       makeRealWord( state ,  state.root );
       addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Icode ,  atom_$S });
      }
 }


 void act541( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Nn$Prefix )) &&
          catPostTest( state ))
      { state.lex.addSuffixes( wordSet_Ism );
       state.lex.addRoot( state.root );
       makeRealWord( state ,  state.root );
       addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Icode ,  atom_$S });
      }
 }


 void act543( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_V )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Mass ,  atom_True ,  atom_Number ,  atom_Sg ,  atom_Suffix ,  word_Ism });
      }
 }


 void act544( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Nn$V$Adj )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Mass ,  atom_True ,  atom_Suffix ,  word_Ism });
      }
 }


 void act545( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Adj$Nn )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Mass ,  atom_True ,  atom_Suffix ,  word_Ism });
      }
 }


 void act547( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Adj )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Mass ,  atom_True ,  atom_Suffix ,  word_Ism });
      }
 }


 void act548( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Anyn$V$Adj )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Mass ,  atom_True ,  atom_Suffix ,  word_Atism });
      }
 }


 void act549( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Nn$V$Adj )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Mass ,  atom_True ,  atom_Suffix ,  word_Atism });
      }
 }


 void act550( MorphState  state ) {
   if    (catPreTest( state ) &&
          plausibleRoot( state.root ) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Mass ,  atom_True ,  atom_Suffix ,  word_Atism });
      }
 }


 void act551( MorphState  state ) {
   if    (catPreTest( state ) &&
          plausibleRoot( state.root ) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Mass ,  atom_True ,  atom_Suffix ,  word_Ism });
      }
 }


 void act552( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     ( ( state.root.getWordString().length()  >  2 ) &&
       syllabic( state.root )) &&
     testPostTest( state ));
 }


 void act555( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     state.root.numeralp() &&
     testPostTest( state ));
 }


 void act556( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Icode ,  atom_$Apostrophe$S });
 }


 void act557( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            state.root.testIcode( category_N ,  atomSet_$En )) &&
          catPostTest( state ))
      addCatSense( state ,  category_N ,  state.root ,  new Value[] { atom_Number ,  atom_Pl });
 }


 void act559( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            state.root.testIcode( category_N ,  atomSet_$Men )) &&
          catPostTest( state ))
      addCatSense( state ,  category_N ,  state.root ,  new Value[] { atom_Number ,  atom_Pl });
 }


 void act560( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            morphCheck( state.root ,  category_N$V$Adj$Det ) &&
             ( ! ( isFormOfCat( state.root ,  categorySet_Prefix )) )) &&
          catPostTest( state ))
      { state.lex.addIkoParent( word_Person );
       state.lex.addRoot( word_Human );
       state.lex.addPrefixes( new Word[] { state.root });
       state.lex.applyFalseRoot( state.root );
       addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Icode ,  atom_$S });
      }
 }


 void act561( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            morphCheck( state.root ,  category_N$V$Adj$Det )) &&
          catPostTest( state ))
      { state.lex.addIkoParent( word_Woman );
       state.lex.addRoot( word_Woman );
       state.lex.addPrefixes( new Word[] { state.root });
       state.lex.applyFalseRoot( state.root );
       addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Icode ,  atom_$Men });
      }
 }


 void act562( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            morphCheck( state.root ,  category_N$V$Adj$Det )) &&
          catPostTest( state ))
      { state.lex.addIkoParent( word_Man );
       state.lex.addRoot( word_Man );
       state.lex.addPrefixes( new Word[] { state.root });
       state.lex.applyFalseRoot( state.root );
       addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Icode ,  atom_$Men });
      }
 }


 void act563( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            morphCheck( state.root ,  category_N$V$Adj$Det ) &&
             ( ! ( isFormOfCat( state.root ,  categorySet_Prefix )) )) &&
          catPostTest( state ))
      { state.lex.addIkoParent( word_Woman );
       state.lex.addRoot( word_Woman );
       state.lex.addPrefixes( new Word[] { state.root });
       state.lex.applyFalseRoot( state.root );
       addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Icode ,  atom_$Men });
      }
 }


 void act564( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            morphCheck( state.root ,  category_N$V$Adj$Det ) &&
             ( ! ( isFormOfCat( state.root ,  categorySet_Prefix )) )) &&
          catPostTest( state ))
      { state.lex.addIkoParent( word_Man );
       state.lex.addRoot( word_Man );
       state.lex.addPrefixes( new Word[] { state.root });
       state.lex.applyFalseRoot( state.root );
       addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Icode ,  atom_$Men });
      }
 }


 void act565( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            morphCheck( state.root ,  category_N$V$Adj$Det ) &&
             ( ! ( LexiconUtil.isMembOfArray(morphPackLex( state , state.lex.getWordString(),  "S" ), state.root.getForms())) )) &&
          catPostTest( state ))
      { state.lex.addIkoParent( word_Woman );
       state.lex.addRoot( word_Woman );
       state.lex.addPrefixes( new Word[] { state.root });
       state.lex.applyFalseRoot( state.root );
       addCatSense( state ,  category_N , morphPackLex( state , state.root.getWordString(),  "SWOMAN" ),  new Value[] { atom_Number ,  atom_Pl });
      }
 }


 void act566( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            morphCheck( state.root ,  category_N$V$Adj$Det ) &&
             ( ! ( isFormOfCat( state.root ,  categorySet_Prefix )) ) &&
             ( ! ( LexiconUtil.isMembOfArray(morphPackLex( state , state.lex.getWordString(),  "S" ), state.root.getForms())) )) &&
          catPostTest( state ))
      { state.lex.addIkoParent( word_Woman );
       state.lex.addRoot( word_Woman );
       state.lex.addPrefixes( new Word[] { state.root });
       state.lex.applyFalseRoot( state.root );
       addCatSense( state ,  category_N , morphPackLex( state , state.root.getWordString(),  "WOMAN" ),  new Value[] { atom_Number ,  atom_Pl });
      }
 }


 void act567( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            morphCheck( state.root ,  category_N$V$Adj$Det ) &&
             ( ! ( LexiconUtil.isMembOfArray(morphPackLex( state , state.lex.getWordString(),  "S" ), state.root.getForms())) )) &&
          catPostTest( state ))
      { state.lex.addIkoParent( word_Man );
       state.lex.addRoot( word_Man );
       state.lex.addPrefixes( new Word[] { state.root });
       state.lex.applyFalseRoot( state.root );
       addCatSense( state ,  category_N , morphPackLex( state , state.root.getWordString(),  "SMAN" ),  new Value[] { atom_Number ,  atom_Pl });
      }
 }


 void act568( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            morphCheck( state.root ,  category_N$V$Adj$Det ) &&
             ( ! ( isFormOfCat( state.root ,  categorySet_Prefix )) ) &&
             ( ! ( LexiconUtil.isMembOfArray(morphPackLex( state , state.lex.getWordString(),  "S" ), state.root.getForms())) )) &&
          catPostTest( state ))
      { state.lex.addIkoParent( word_Man );
       state.lex.addRoot( word_Man );
       state.lex.addPrefixes( new Word[] { state.root });
       state.lex.applyFalseRoot( state.root );
       addCatSense( state ,  category_N , morphPackLex( state , state.root.getWordString(),  "MAN" ),  new Value[] { atom_Number ,  atom_Pl });
      }
 }


 void act569( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       morphRoot( state ) &&
        ( ! ( isFormOfCat( state.root ,  categorySet_Prefix )) ) &&
        ( ! ( LexiconUtil.isMembOfArray(morphPackLex( state , state.lex.getWordString(),  "S" ), state.root.getForms())) )) &&
     testPostTest( state ));
 }


 void act570( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.applyFalseRoot( state.root );
       state.lex.addIkoParent( word_Substance );
       state.lex.addSuffixes( wordSet_Gen );
       state.lex.addPrefixes( new Word[] { state.root });
       markDict( state ,  state.lex ,  atom_Domain ,  wordSet_Biology ,  true );
       markDict( state ,  state.lex ,  atom_Derived$From , dict.makeList( new Word[] { state.root ,  word_Gen }),  true );
       addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Icode ,  atom_$S });
      }
 }


 void act571( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (morphRoot( state ) &&
        ( ! ( state.lex.isHyphenated()) ) &&
       ( ( ! ( patternCheckLeft( state.lex ,  pattern_A$N$T$I )) ) ||
    		   LexiconUtil.isMembOfArray( state.lex ,  wordSet_Anticipation$An_Etc )) &&
        ( ! ( patternCheckLeft( state.lex ,  pattern_A$N$T$E )) ) &&
        ( ! (patternCheckLeft( state.lex ,  pattern_P$R$E ) &&
        		LexiconUtil.isMembOfArray( state.lex ,  wordSet_Prereconstructi_Etc ))) &&
       ( ( ! ( patternCheckLeft( state.lex ,  pattern_P$R$O )) ) ||
    		   LexiconUtil.isMembOfArray( state.lex ,  wordSet_Probation$Produ_Etc )) &&
        ( ! ( patternCheckLeft( state.lex ,  pattern_S$E$M$I )) ) &&
        ( ! ( patternCheck( state.lex ,  pattern_A$M$B$I$T$I$O$N )) ) &&
        ( ! ( patternCheck( state.lex ,  pattern_A$U$C$T$I$O$N )) ) &&
        ( ! ( patternCheck( state.lex ,  pattern_A$U$D$I$T$I$O$N )) ) &&
        ( ! ( patternCheck( state.lex ,  pattern_C$A$P$T$I$O$N )) ) &&
        ( ! ( patternCheck( state.lex ,  pattern_C$A$U$T$I$O$N )) ) &&
        ( ! ( patternCheck( state.lex ,  pattern_C$O$N$D$I$T$I$O_Etc )) ) &&
        ( ! ( patternCheck( state.lex ,  pattern_C$O$N$F$E$C$T$I_Etc )) ) &&
        ( ! ( patternCheck( state.lex ,  pattern_F$R$A$C$T$I$O$N )) ) &&
        ( ! ( patternCheck( state.lex ,  pattern_F$U$N$C$T$I$O$N )) ) &&
        ( ! ( patternCheck( state.lex ,  pattern_M$E$N$T$I$O$N )) ) &&
        ( ! ( patternCheck( state.lex ,  pattern_M$O$T$I$O$N )) ) &&
        ( ! ( patternCheck( state.lex ,  pattern_M$U$N$I$T$I$O$N )) ) &&
        ( ! ( patternCheck( state.lex ,  pattern_P$A$R$T$I$T$I$O_Etc )) ) &&
        ( ! ( patternCheck( state.lex ,  pattern_P$E$T$I$T$I$O$N )) ) &&
        ( ! ( patternCheck( state.lex ,  pattern_P$O$R$T$I$O$N )) ) &&
        ( ! ( patternCheck( state.lex ,  pattern_P$O$S$I$T$I$O$N )) ) &&
        ( ! ( patternCheck( state.lex ,  pattern_Q$U$E$S$T$I$O$N )) ) &&
        ( ! ( patternCheck( state.lex ,  pattern_R$E$Q$U$I$S$I$T_Etc )) ) &&
        ( ! ( patternCheck( state.lex ,  pattern_S$A$N$C$T$I$O$N )) ) &&
        ( ! ( patternCheck( state.lex ,  pattern_S$T$A$T$I$O$N )) ) &&
        ( ! ( patternCheck( state.lex ,  pattern_V$A$C$A$T$I$O$N )) )) &&
     testPostTest( state ));
 }


 void act573( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_V )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_Nmc ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Suffix ,  word_Tion });
      }
 }


 void act574( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       morphRoot( state ) &&
       notPrefix( state.root ,  wordSet_Un$Non )) &&
     testPostTest( state ));
 }


 void act575( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Adj )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       state.lex.addSuffixes( wordSet_En );
       addCatSense( state ,  category_V ,  state.lex ,  new Value[] { atom_Tns ,  atom_Present ,  atom_Agr ,  atom_Not3sg ,  atom_Untensed ,  atom_True ,  atom_Icode ,  atom_S$Ed });
      }
 }


 void act576( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       morphRoot( state ) &&
       notPrefix( state.root ,  wordSet_Un$Non ) &&
        ( ! ( patternCheck( state.root ,  pattern_E )) )) &&
     testPostTest( state ));
 }


 void act577( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      addCatSense( state ,  category_V ,  state.root ,  new Value[] { atom_Pastpart ,  atom_True });
 }


 void act578( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (polysyllabic( state.root ) &&
       morphRoot( state ) &&
       dict.isKnownWord( state.root ) &&
        ( ! ( state.lex.isHyphenated()) ) &&
       isRootOfCat( state.root ,  categorySet_Nn$V$Adj )) &&
     testPostTest( state ));
 }


 void act579( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.addIkoParent( word_Person );
       state.lex.addSuffixes( wordSet_Ician );
       state.lex.addRoot( state.root );
       addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Icode ,  atom_$S });
      }
 }


 void act580( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (polysyllabic( state.root ) &&
       morphRoot( state ) &&
       dict.isKnownWord( state.root ) &&
        ( ! ( state.lex.isHyphenated()) ) &&
       isRootOfCat( state.root ,  categorySet_Anyn$V$Adj )) &&
     testPostTest( state ));
 }


 void act581( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.addIkoParent( word_Person );
       state.lex.addSuffixes( wordSet_Ian );
       state.lex.addRoot( state.root );
       addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Icode ,  atom_$S });
      }
 }


 void act582( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (polysyllabic( state.root ) &&
       morphRoot( state ) &&
       dict.isKnownWord( state.root ) &&
        ( ! ( state.lex.isHyphenated()) ) &&
       isRootOfCat( state.root ,  categorySet_Nn )) &&
     testPostTest( state ));
 }


 void act583( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       polysyllabic( state.root ) &&
       morphRoot( state ) &&
       dict.isKnownWord( state.root ) &&
        ( ! ( state.lex.isHyphenated()) ) &&
       isRootOfCat( state.root ,  categorySet_Nn$V$Adj )) &&
     testPostTest( state ));
 }


 void act584( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.addIkoParent( word_Person );
       state.lex.addSuffixes( wordSet_Arian );
       state.lex.addRoot( state.root );
       addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Icode ,  atom_$S });
      }
 }


 void act585( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.addIkoParent( word_Person );
       state.lex.addSuffixes( wordSet_An );
       state.lex.addRoot( state.root );
       addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Icode ,  atom_$S });
      }
 }


 void act586( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (morphRoot( state ) &&
       isRootOfCat( state.root ,  categorySet_Prefix ) &&
        (state.root.numericalValue() !=  null )) &&
     testPostTest( state ));
 }


 void act587( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.addIkoParent(dict.makeStructuredConcept(morphPackLex( state , Double.toString( 10  * state.root.numericalValue().doubleValue()),  "-year-old_person" ),  category_N , dict.makeList( new Value[] { word_Person , dict.makeList( new Value[] { word_Age , dict.makeWord(Double.toString( 10  * state.root.numericalValue().doubleValue()))})})));
       state.lex.addIkoParent( word_Person );
       state.lex.addIkoParent(dict.makeStructuredConcept(morphPackLex( state , Double.toString( 10  * state.root.numericalValue().doubleValue()),  "-year-old" ),  category_Adj , dict.makeList( new Value[] { word_Age , dict.makeWord(Double.toString( 10  * state.root.numericalValue().doubleValue()))})));
       markDict( state ,  state.lex ,  atom_Derived$From , dict.makeList( new Word[] { state.root ,  word_Generation ,  word_Ian }),  true );
       state.lex.applyFalseRoot( state.root );
       state.lex.addSuffixes( wordSet_Ian );
       state.lex.addPrefixes( new Word[] { state.root });
       state.lex.setNumericalValue( 10  * state.root.numericalValue().doubleValue());
       addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Icode ,  atom_$S });
      }
 }


 void act589( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (morphRoot( state ) &&
       isRootOfCat( state.root ,  categorySet_Prefix )) &&
     testPostTest( state ));
 }


 void act590( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.addIkoParent( word_Person );
       markDict( state ,  state.lex ,  atom_Derived$From , dict.makeList( new Word[] { state.root ,  word_Generation ,  word_Ian }),  true );
       state.lex.applyFalseRoot( state.root );
       state.lex.addSuffixes( wordSet_Ian );
       state.lex.addPrefixes( new Word[] { state.root });
       addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Icode ,  atom_$S });
      }
 }


 void act591( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       polysyllabic( state.root ) &&
       morphRoot( state ) &&
       dict.isKnownWord( state.root ) &&
        ( ! ( state.lex.isHyphenated()) ) &&
       isRootOfCat( state.root ,  categorySet_Anyn )) &&
     testPostTest( state ));
 }


 void act592( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       needFinalE( state.root ) &&
       morphRoot( state ) &&
       dict.isKnownWord( state.root ) &&
        ( ! ( state.lex.isHyphenated()) ) &&
       isRootOfCat( state.root ,  categorySet_Nn$V$Adj )) &&
     testPostTest( state ));
 }


 void act593( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       morphRoot( state ) &&
       dict.isKnownWord( state.root ) &&
       isRootOfCat( state.root ,  categorySet_Prefix )) &&
     testPostTest( state ));
 }


 void act594( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.addIkoParent( word_Animal );
       state.lex.addSuffixes( wordSet_Arian );
       state.lex.addPrefixes( new Word[] { state.root });
       state.lex.applyFalseRoot( state.root );
       addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Icode ,  atom_$S });
      }
 }


 void act595( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       syllabic( state.root ) &&
       morphRoot( state ) &&
       dict.isKnownWord( state.root ) &&
        ( ! ( state.lex.isHyphenated()) ) &&
       isRootOfCat( state.root ,  categorySet_Nn$V$Adj$Pron )) &&
     testPostTest( state ));
 }


 void act597( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       polysyllabic( state.root ) &&
       morphRoot( state ) &&
        ( ! ( state.lex.isHyphenated()) ) &&
       isRootOfCat( state.root ,  categorySet_Anyn$V$Adj )) &&
     testPostTest( state ));
 }


 void act598( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       syllabic( state.root ) &&
       morphRoot( state ) &&
        ( ! ( state.lex.isHyphenated()) ) &&
       isRootOfCat( state.root ,  categorySet_Anyn$V$Adj )) &&
     testPostTest( state ));
 }


 void act599( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       polysyllabic( state.root ) &&
       morphRoot( state ) &&
        ( ! ( state.lex.isHyphenated()) ) &&
       isRootOfCat( state.root ,  categorySet_Anyn$V$Adj ) &&
       needFinalE( state.root )) &&
     testPostTest( state ));
 }


 void act600( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       polysyllabic( state.root ) &&
       morphRoot( state ) &&
        ( ! ( state.lex.isHyphenated()) ) &&
       isRootOfCat( state.root ,  categorySet_Nn$V$Adj )) &&
     testPostTest( state ));
 }


 void act601( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       polysyllabic( state.root ) &&
       morphRoot( state ) &&
        ( ! ( state.lex.isHyphenated()) ) &&
       dict.isKnownWord( state.root ) &&
       isRootOfCat( state.root ,  categorySet_Anyn$V$Adj )) &&
     testPostTest( state ));
 }


 void act602( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       morphRoot( state ) &&
        ( ! ( state.lex.isHyphenated()) ) &&
       isRootOfCat( state.root ,  categorySet_Anyn$V$Adj ) &&
       dict.isKnownWord( state.root )) &&
     testPostTest( state ));
 }


 void act605( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (polysyllabic( state.root ) &&
       morphRoot( state ) &&
       isRootOfCat( state.root ,  categorySet_Lastname )) &&
     testPostTest( state ));
 }


 void act607( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (polysyllabic( state.root ) &&
       morphRoot( state ) &&
        ( ! ( state.lex.isHyphenated()) ) &&
       notSuffix( state.root ,  wordSet_Er )) &&
     testPostTest( state ));
 }


 void act608( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Anyn )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] { atom_Suffix ,  word_An });
      }
 }


 void act609( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Anyn )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Suffix ,  word_An });
      }
 }


 void act610( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (polysyllabic( state.root ) &&
       morphRoot( state ) &&
        ( ! ( state.lex.isHyphenated()) ) &&
       isRootOfCat( state.root ,  categorySet_Anyn )) &&
     testPostTest( state ));
 }


 void act611( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] { atom_Suffix ,  word_An });
      }
 }


 void act612( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Suffix ,  word_An });
      }
 }


 void act613( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isFormOfCat( state.root ,  categorySet_Malefirstname$L_Etc )) &&
          catPostTest( state ))
      { state.lex.applyFalseRoot( state.root );
       state.lex.addSuffixes( wordSet_Son );
       markDict( state ,  state.lex ,  atom_Derived$From , dict.makeList( new Word[] { state.root ,  word_Son }),  true );
       addCatSense( state ,  category_Lastname ,  state.lex ,  new Value[] {});
      }
 }


 void act614( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isFormOfCat( state.root ,  categorySet_Malefirstname$L_Etc )) &&
          catPostTest( state ))
      { state.lex.applyFalseRoot( state.root );
       state.lex.addSuffixes( wordSet_Sen );
       markDict( state ,  state.lex ,  atom_Derived$From , dict.makeList( new Word[] { state.root ,  word_Sen }),  true );
       addCatSense( state ,  category_Lastname ,  state.lex ,  new Value[] {});
      }
 }


 void act615( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       polysyllabic( state.root ) &&
       morphRoot( state ) &&
       isRootOfCat( state.root ,  categorySet_Adj$Prefix )) &&
     testPostTest( state ));
 }


 void act616( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.applyFalseRoot( state.root );
       state.lex.addIkoParent( word_Animal );
       markDict( state ,  state.lex ,  atom_Derived$From , dict.makeList( new Word[] { state.root ,  word_Don }),  true );
       addCatSense( state ,  category_Nc ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Icode ,  atom_$S });
      }
 }


 void act617( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       polysyllabic( state.root ) &&
       morphRoot( state ) &&
       isFormOfCat( state.root ,  categorySet_Adj$Prefix )) &&
     testPostTest( state ));
 }


 void act618( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.applyFalseRoot( state.root );
       state.lex.addIioParent( word_Chemical );
       state.lex.addSuffixes( wordSet_In );
       state.lex.addPrefixes( new Word[] { state.root });
       markDict( state ,  state.lex ,  atom_Derived$From , dict.makeList( new Word[] { state.root ,  word_In }),  true );
       addCatSense( state ,  category_Nm ,  state.lex ,  new Value[] { atom_Mass$Pure ,  atom_True ,  atom_Mass ,  atom_True ,  atom_Icode ,  atom_$S });
      }
 }


 void act619( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       morphRoot( state ) &&
        ( ! ( patternCheck( state.root ,  pattern_V$E$R$M )) ) &&
       isFormOfCat( state.root ,  categorySet_Prefix$Adj$Anyn )) &&
     testPostTest( state ));
 }


 void act620( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      addCatSense( state ,  category_Unit ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Icode ,  atom_$S });
 }


 void act621( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { if    (state.root.numericalValue() !=  null )
          state.lex.setNumericalValue(state.root.numericalValue());
       markDict( state ,  state.lex ,  atom_Ntakespreps ,  wordSet_Of ,  true );
       state.lex.addIioParent( word_Unit );
       state.lex.addIioParent( word_Unit_Of_Countin_Etc );
       state.lex.addSuffixes( wordSet_Illion );
       state.lex.addPrefixes( new Word[] { state.root });
       addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Icode ,  atom_$S });
      }
 }


 void act622( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       morphRoot( state ) &&
        ( ! ( patternCheck( state.root ,  pattern_V$E$R$M )) )) &&
     testPostTest( state ));
 }


 void act623( MorphState  state ) {
   if    (catPreTest( state ) &&
          polysyllabic( state.root ) &&
          catPostTest( state ))
      { state.lex.addIkoParent( word_Person );
       state.lex.addSuffixes( wordSet_Ian );
       addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Icode ,  atom_$S });
      }
 }


 void act626( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            (state.root.testIcode( category_Adj ,  atomSet_Ier$Iest ) ||
              (isRootOfCat( state.root ,  categorySet_Adj ) &&
                 ( ! ( state.root.testIcode( category_Adj ,  atomSet_Ier$Iest$Er$Est_Etc )) )))) &&
          catPostTest( state ))
      addCatSense( state ,  category_Adj ,  state.root ,  new Value[] { atom_Comparative ,  atom_True });
 }


 void act627( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            (state.root.testIcode( category_Adv ,  atomSet_Ier$Iest ) ||
              (isRootOfCat( state.root ,  categorySet_Adv ) &&
                 ( ! ( state.root.testIcode( category_Adv ,  atomSet_Ier$Iest$Er$Est_Etc$ )) )))) &&
          catPostTest( state ))
      addCatSense( state ,  category_Adv ,  state.root ,  new Value[] { atom_Comparative ,  atom_True });
 }


 void act628( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_V )) &&
          catPostTest( state ))
      { state.lex.addSuffixes( wordSet_Er );
       state.lex.addRoot( state.root );
       addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Icode ,  atom_$S });
      }
 }


 void act629( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Adj )) &&
          catPostTest( state ))
      addCatSense( state ,  category_Adj ,  state.root ,  new Value[] { atom_Comparative ,  atom_True });
 }


 void act630( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Adv )) &&
          catPostTest( state ))
      addCatSense( state ,  category_Adv ,  state.root ,  new Value[] { atom_Comparative ,  atom_True });
 }


 void act631( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       morphRoot( state ) &&
       dict.isKnownWord( state.root ) &&
       plausibleComparativeRoot( state.root )) &&
     testPostTest( state ));
 }


 void act632( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Nn )) &&
          catPostTest( state ))
      { state.lex.addSuffixes( wordSet_Er );
       state.lex.addRoot( state.root );
       addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Icode ,  atom_$S });
      }
 }


 void act634( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       polysyllabic( state.root ) &&
       morphRoot( state ) &&
       dict.isKnownWord( state.root ) &&
       isRootOfCat( state.root ,  categorySet_Nn )) &&
     testPostTest( state ));
 }


 void act635( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.addIkoParent( word_Person );
       addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Prob ,  word_30 ,  atom_From ,  state.root ,  atom_Suffix ,  word_Ier });
      }
 }


 void act636( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            plausibleComparativeRoot( state.root )) &&
          catPostTest( state ))
      addCatSense( state ,  category_Adj ,  state.root ,  new Value[] { atom_Comparative ,  atom_True });
 }


 void act637( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isFormOfCat( state.root ,  categorySet_Adj$Nn$Prefix )) &&
          catPostTest( state ))
      { state.lex.addSuffixes( wordSet_Opter );
       state.lex.addPrefixes( new Word[] { state.root });
       markDict( state ,  state.lex ,  atom_Domain ,  wordSet_Biology ,  true );
       state.lex.addIkoParent(dict.makeStructuredConcept( category_Ncm , dict.makeList( new Value[] {dict.makeList( new Value[] { word_Flyer , dict.makeList( new Value[] { word_Mod ,  state.root })}),  word_Animal })));
       addCatSense( state ,  category_Ncm ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Mass ,  atom_True ,  atom_Icode ,  atom_$S });
      }
 }


 void act638( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.addSuffixes( wordSet_Bacter );
       state.lex.addPrefixes( new Word[] { state.root });
       markDict( state ,  state.lex ,  atom_Domain ,  wordSet_Biology ,  true );
       state.lex.addIkoParent(dict.makeStructuredConcept( category_Ncm , dict.makeList( new Value[] { word_Bacterium , dict.makeList( new Value[] { word_Mod ,  state.root })})));
       addCatSense( state ,  category_Ncm ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Mass ,  atom_True ,  atom_Icode ,  atom_$S });
      }
 }


 void act639( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isFormOfCat( state.root ,  categorySet_Prefix )) &&
          catPostTest( state ))
      { state.lex.addSuffixes( wordSet_Mer );
       state.lex.addPrefixes( new Word[] { state.root });
       markDict( state ,  state.lex ,  atom_Domain ,  wordSet_Chemistry ,  true );
       state.lex.addIkoParent(dict.makeStructuredConcept( category_Ncm , dict.makeList( new Value[] {dict.makeList( new Value[] { word_Molecule , dict.makeList( new Value[] { word_Mod ,  state.root })}),  word_Substance })));
       addCatSense( state ,  category_Ncm ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Mass ,  atom_True ,  atom_Icode ,  atom_$S });
      }
 }


 void act640( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.applyFalseRoot( state.root );
       state.lex.addPrefixes( new Word[] { state.root });
       state.lex.addRoot( word_Owner );
       state.lex.addIkoParent(dict.makeStructuredConcept( category_N , dict.makeList( new Value[] { word_Owner , dict.makeList( new Value[] { word_Of ,  state.root })})));
       addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Icode ,  atom_$S });
      }
 }


 void act641( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.applyFalseRoot( state.root );
       state.lex.addPrefixes( new Word[] { state.root });
       state.lex.addRoot( word_Setter );
       state.lex.addIkoParent(dict.makeStructuredConcept( category_N , dict.makeList( new Value[] { word_Setter , dict.makeList( new Value[] { word_Of ,  state.root })})));
       addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Icode ,  atom_$S });
      }
 }


 void act643( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       morphRoot( state ) &&
       dict.isKnownWord( state.root ) &&
       isRootOfCat( state.root ,  categorySet_Nn )) &&
     testPostTest( state ));
 }


 void act644( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.addSuffixes( wordSet_Er );
       addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Icode ,  atom_$S });
      }
 }


 void act645( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.applyFalseRoot( state.root );
       markDict( state ,  state.lex ,  atom_Entails ,  state.root ,  true );
       state.lex.addPrefixes( new Word[] { state.root });
       state.lex.addRoot( word_Meter );
       state.lex.addIkoParent(dict.makeStructuredConcept( category_N , dict.makeList( new Value[] { word_Meter , dict.makeList( new Value[] { word_Mod ,  state.root })})));
       addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Icode ,  atom_$S });
      }
 }


 void act646( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isFormOfCat( state.root ,  categorySet_Malefirstname$F_Etc )) &&
          catPostTest( state ))
      { state.lex.applyFalseRoot( state.root );
       state.lex.addSuffixes( wordSet_Dotter );
       markDict( state ,  state.lex ,  atom_Derived$From , dict.makeList( new Word[] { state.root ,  word_Dotter }),  true );
       addCatSense( state ,  category_Lastname ,  state.lex ,  new Value[] {});
      }
 }


 void act647( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isFormOfCat( state.root ,  categorySet_Lastname$Name )) &&
          catPostTest( state ))
      { state.lex.applyFalseRoot( state.root );
       state.lex.addSuffixes( wordSet_Heimer );
       markDict( state ,  state.lex ,  atom_Derived$From , dict.makeList( new Word[] { state.root ,  word_Heimer }),  true );
       addCatSense( state ,  category_Lastname ,  state.lex ,  new Value[] {});
      }
 }


 void act648( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.addSuffixes( wordSet_Heimer );
       addCatSense( state ,  category_Lastname ,  state.lex ,  new Value[] {});
      }
 }


 void act649( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.addSuffixes( wordSet_Macher );
       addCatSense( state ,  category_Lastname ,  state.lex ,  new Value[] {});
      }
 }


 void act650( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       morphRoot( state ) &&
        ( ! ( patternCheckLeft( state.root ,  pattern_A$N$A )) ) &&
        ( ! ( patternCheckLeft( state.root ,  pattern_C$O$N )) ) &&
        ( ! ( patternCheckLeft( state.root ,  pattern_D$E )) ) &&
        ( ! ( patternCheckLeft( state.root ,  pattern_D$I )) ) &&
        ( ! ( patternCheckLeft( state.root ,  pattern_D$I$S )) ) &&
        ( ! ( patternCheckLeft( state.root ,  pattern_E$X )) ) &&
        ( ! ( patternCheckLeft( state.root ,  pattern_U$N )) ) &&
        (morphPrefix( state ,  state.root ) !=  null )) &&
     testPostTest( state ));
 }


 void act651( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isKnownFormOfCat( state.root ,  categorySet_Nn )) &&
          catPostTest( state ))
      addCatSense( state ,  category_N ,  state.lex , copyFeatures( state.root ,  category_Nn ));
 }


 void act652( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       morphRoot( state ) &&
        ( ! ( dict.isKnownWord( state.root )) ) &&
       isCompoundCat( state.root ,  category_V ) &&
        ( ! ( isRootOfCat( state.root ,  categorySet_Adj )) ) &&
       isFormOfCat(word1( state.root ),  categorySet_Adv$Adj ) &&
       isRootOfCat(word2( state.root ),  categorySet_Vt )) &&
     testPostTest( state ));
 }


 void act653( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      addCompoundSuffixCatSenses( state ,  category_N ,  state.lex ,  category_N ,  state.root ,  1 ,  word_Ier ,  word_Mod );
 }


 void act654( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      addCompoundSuffixCatSenses( state ,  category_N ,  state.lex ,  category_N ,  state.root ,  0 ,  word_R ,  word_Mod );
 }


 void act655( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       morphRoot( state ) &&
        ( ! ( dict.isKnownWord( state.root )) ) &&
       isCompoundCat( state.root ,  category_V ) &&
        ( ! ( isRootOfCat( state.root ,  categorySet_Adj )) ) &&
       isFormOfCat(word1( state.root ),  categorySet_Adv$Adj ) &&
       isRootOfCat(word2( state.root ),  categorySet_Vt ) &&
        ( ! ( needDoubleLetter(word2( state.root ))) )) &&
     testPostTest( state ));
 }


 void act656( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      addCompoundSuffixCatSenses( state ,  category_N ,  state.lex ,  category_N ,  state.root ,  0 ,  word_Er ,  word_Mod );
 }


 void act657( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      addCompoundSuffixCatSenses( state ,  category_N ,  state.lex ,  category_N ,  state.root ,  -1 ,  word_Er ,  word_Mod );
 }


 void act658( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       morphRoot( state ) &&
        ( ! ( dict.isKnownWord( state.root )) ) &&
       isCompoundCat( state.root ,  category_V ) &&
        ( ! ( isRootOfCat( state.root ,  categorySet_Adj )) ) &&
       isRootOfCat(word1( state.root ),  categorySet_Anyn ) &&
       isRootOfCat(word2( state.root ),  categorySet_Vt )) &&
     testPostTest( state ));
 }


 void act659( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      addCompoundSuffixCatSenses( state ,  category_N ,  state.lex ,  category_N ,  state.root ,  1 ,  word_Ier ,  word_Of );
 }


 void act660( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      addCompoundSuffixCatSenses( state ,  category_N ,  state.lex ,  category_N ,  state.root ,  0 ,  word_R ,  word_Of );
 }


 void act661( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       morphRoot( state ) &&
        ( ! ( dict.isKnownWord( state.root )) ) &&
       isCompoundCat( state.root ,  category_V ) &&
        ( ! ( isRootOfCat( state.root ,  categorySet_Adj )) ) &&
       isRootOfCat(word1( state.root ),  categorySet_Anyn ) &&
       isRootOfCat(word2( state.root ),  categorySet_Vt ) &&
        ( ! ( needDoubleLetter(word2( state.root ))) )) &&
     testPostTest( state ));
 }


 void act662( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      addCompoundSuffixCatSenses( state ,  category_N ,  state.lex ,  category_N ,  state.root ,  0 ,  word_Er ,  word_Of );
 }


 void act663( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      addCompoundSuffixCatSenses( state ,  category_N ,  state.lex ,  category_N ,  state.root ,  -1 ,  word_Er ,  word_Of );
 }


 void act664( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Anyn$V )) &&
          catPostTest( state ))
      { state.lex.addIkoParent( word_Person );
       addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_From ,  state.root ,  atom_Suffix ,  word_Ster });
      }
 }


 void act665( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_V$Nn )) &&
          catPostTest( state ))
      addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_From ,  state.root ,  atom_Suffix ,  word_Er });
 }


 void act666( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            (state.root.testIcode( category_Adj ,  atomSet_$Er$$Est$Er$Est ) ||
              (isRootOfCat( state.root ,  categorySet_Adj ) &&
                plausibleComparativeRoot( state.root ) &&
                state.root.testIcode( category_V ,  atomSet_S$$Ed$S$Ed$$Ed$_Etc )))) &&
          catPostTest( state ))
      addCatSense( state ,  category_Adj ,  state.root ,  new Value[] { atom_Comparative ,  atom_True });
 }


 void act667( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            (state.root.testIcode( category_Adv ,  atomSet_$Er$$Est$Er$Est ) ||
              (isRootOfCat( state.root ,  categorySet_Adv ) &&
                plausibleComparativeRoot( state.root ) &&
                state.root.testIcode( category_V ,  atomSet_S$$Ed$S$Ed$$Ed$_Etc )))) &&
          catPostTest( state ))
      addCatSense( state ,  category_Adv ,  state.root ,  new Value[] { atom_Comparative ,  atom_True });
 }


 void act668( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            (state.root.testIcode( category_V ,  atomSet_S$$Ed$S$Ed$$Ed$_Etc ) ||
              (isRootOfCat( state.root ,  categorySet_Nn ) &&
                state.root.testIcode( category_Adj ,  atomSet_$Er$$Est$Er$Est )))) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Suffix ,  word_Er });
      }
 }


 void act669( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Anyn )) &&
          catPostTest( state ))
      { state.lex.addIkoParent(dict.makeStructuredConcept( category_N , dict.makeList( new Value[] { word_Person , dict.makeList( new Value[] { word_Mod ,  state.root })})));
       { state.lex.addRoot( state.root );
        addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Suffix ,  word_Eer });
       }
      }
 }


 void act670( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Nn )) &&
          catPostTest( state ))
      { state.lex.addIkoParent(dict.makeStructuredConcept( category_N , dict.makeList( new Value[] { word_Person , dict.makeList( new Value[] { word_Mod ,  state.root })})));
       { state.lex.addRoot( state.root );
        addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Suffix ,  word_Eer });
       }
      }
 }


 void act671( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Adj ) &&
            plausibleComparativeRoot( state.root )) &&
          catPostTest( state ))
      addCatSense( state ,  category_Adj ,  state.root ,  new Value[] { atom_Comparative ,  atom_True });
 }


 void act672( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Adv ) &&
            plausibleComparativeRoot( state.root )) &&
          catPostTest( state ))
      addCatSense( state ,  category_Adv ,  state.root ,  new Value[] { atom_Comparative ,  atom_True });
 }


 void act673( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_V$Nn )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Suffix ,  word_Er });
      }
 }


 void act674( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       needFinalE( state.root ) &&
       morphRoot( state ) &&
       isRootOfCat( state.root ,  categorySet_V$Nn )) &&
     testPostTest( state ));
 }


 void act675( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            plausibleComparativeRoot( state.root )) &&
          catPostTest( state ))
      addCatSense( state ,  category_Adv ,  state.root ,  new Value[] { atom_Comparative ,  atom_True });
 }


 void act676( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       morphRoot( state ) &&
       isRootOfCat( state.root ,  categorySet_V$Nn )) &&
     testPostTest( state ));
 }


 void act677( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Suffix ,  word_Er });
      }
 }


 void act678( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       morphRoot( state ) &&
        ( ! ( polysyllabic( state.root )) ) &&
       needFinalE( state.root ) &&
        ( ! ( patternCheck( state.root ,  pattern_I$E )) )) &&
     testPostTest( state ));
 }


 void act679( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            (state.root.testIcode( category_Adj ,  atomSet_Er$Est ) ||
              (isRootOfCat( state.root ,  categorySet_Adj ) &&
                 ( ! ( state.root.testIcode( category_Adj ,  atomSet_Ier$Iest$Er$Est_Etc )) ) &&
                plausibleComparativeRoot( state.root )))) &&
          catPostTest( state ))
      addCatSense( state ,  category_Adj ,  state.root ,  new Value[] { atom_Comparative ,  atom_True });
 }


 void act680( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            (state.root.testIcode( category_Adv ,  atomSet_Er$Est ) ||
              (isRootOfCat( state.root ,  categorySet_Adv ) &&
                 ( ! ( state.root.testIcode( category_Adv ,  atomSet_Ier$Iest$Er$Est_Etc$$ )) ) &&
                plausibleComparativeRoot( state.root )))) &&
          catPostTest( state ))
      addCatSense( state ,  category_Adv ,  state.root ,  new Value[] { atom_Comparative ,  atom_True });
 }


 void act681( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            ((isRootOfCat( state.root ,  categorySet_V$Nn ) &&
                 ( ! ( needDoubleLetter( state.root )) )) ||
              ((state.root.testIcode( category_Adj ,  atomSet_Nonscalar ) ||
                  (isRootOfCat( state.root ,  categorySet_Adj ) &&
                     ( ! ( state.root.testIcode( category_Adj ,  atomSet_Ier$Iest$Er$Est_Etc )) ))) &&
                 ( ! ( plausibleComparativeRoot( state.root )) )))) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Suffix ,  word_Er });
      }
 }


 void act682( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       needFinalE( state.root ) &&
       morphRoot( state ) &&
        ( ! ( patternCheck( state.root ,  pattern_I$E )) )) &&
     testPostTest( state ));
 }


 void act683( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            (state.root.testIcode( category_Adj ,  atomSet_R$St ) ||
              (isRootOfCat( state.root ,  categorySet_Adj ) &&
                 ( ! ( state.root.testIcode( category_Adj ,  atomSet_Ier$Iest$Er$Est_Etc )) ) &&
                plausibleComparativeRoot( state.root )))) &&
          catPostTest( state ))
      addCatSense( state ,  category_Adj ,  state.root ,  new Value[] { atom_Comparative ,  atom_True });
 }


 void act684( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            (state.root.testIcode( category_Adv ,  atomSet_R$St ) ||
              (isRootOfCat( state.root ,  categorySet_Adv ) &&
                 ( ! ( state.root.testIcode( category_Adv ,  atomSet_Ier$Iest$Er$Est_Etc$$ )) ) &&
                plausibleComparativeRoot( state.root )))) &&
          catPostTest( state ))
      addCatSense( state ,  category_Adv ,  state.root ,  new Value[] { atom_Comparative ,  atom_True });
 }


 void act685( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            (isRootOfCat( state.root ,  categorySet_V$Nn ) ||
              ((state.root.testIcode( category_Adj ,  atomSet_Nonscalar ) ||
                  (isRootOfCat( state.root ,  categorySet_Adj ) &&
                     ( ! ( state.root.testIcode( category_Adj ,  atomSet_Ier$Iest$Er$Est_Etc )) ))) &&
                 ( ! ( plausibleComparativeRoot( state.root )) )))) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Suffix ,  word_Er });
      }
 }


 void act686( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            (state.root.testIcode( category_Adj ,  atomSet_Ker$Kest$Er$Est ) ||
              (isRootOfCat( state.root ,  categorySet_Adj ) &&
                 ( ! ( state.root.testIcode( category_Adj ,  atomSet_Ier$Iest$Er$Est_Etc )) ) &&
                plausibleComparativeRoot( state.root )))) &&
          catPostTest( state ))
      addCatSense( state ,  category_Adj ,  state.root ,  new Value[] { atom_Comparative ,  atom_True });
 }


 void act687( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            (state.root.testIcode( category_Adv ,  atomSet_Ker$Kest$Er$Est ) ||
              (isRootOfCat( state.root ,  categorySet_Adv ) &&
                 ( ! ( state.root.testIcode( category_Adv ,  atomSet_Ier$Iest$Er$Est_Etc$$ )) ) &&
                plausibleComparativeRoot( state.root )))) &&
          catPostTest( state ))
      addCatSense( state ,  category_Adv ,  state.root ,  new Value[] { atom_Comparative ,  atom_True });
 }


 void act688( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (morphRoot( state ) &&
       isRootOfCat( state.root ,  categorySet_V$Nn )) &&
     testPostTest( state ));
 }


 void act689( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       polysyllabic( state.root ) &&
       morphRoot( state ) &&
       isRootOfCat( state.root ,  categorySet_V$Nn )) &&
     testPostTest( state ));
 }


 void act690( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Nn )) &&
          catPostTest( state ))
      { state.lex.addIkoParent( word_Person );
       addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Prob ,  word_30 ,  atom_From ,  state.root ,  atom_Suffix ,  word_Ier });
      }
 }


 void act691( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       polysyllabic( state.root ) &&
       morphRoot( state ) &&
        ( ! ( patternCheck( state.root ,  pattern_Any$$$Any )) ) &&
        ( ! ( patternCheck( state.root ,  pattern_E$Y )) )) &&
     testPostTest( state ));
 }


 void act692( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Nm )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Suffix ,  word_Er });
      }
 }


 void act693( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_V )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Suffix ,  word_Er });
      }
 }


 void act695( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Anyn )) &&
          catPostTest( state ))
      { state.lex.addVariantOf( state.root );
       addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Features ,  atom_British });
      }
 }


 void act696( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_V )) &&
          catPostTest( state ))
      { state.lex.addVariantOf( state.root );
       addCatSense( state ,  category_V ,  state.lex ,  new Value[] { atom_Tns ,  atom_Present ,  atom_Agr ,  atom_Not3sg ,  atom_Features ,  atom_British });
      }
 }


 void act697( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Adj )) &&
          catPostTest( state ))
      { state.lex.addVariantOf( state.root );
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] { atom_Features ,  atom_British });
      }
 }


 void act698( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Adv )) &&
          catPostTest( state ))
      { state.lex.addVariantOf( state.root );
       addCatSense( state ,  category_Adv ,  state.lex ,  new Value[] { atom_Features ,  atom_British });
      }
 }


 void act699( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.applyFalseRoot( state.root );
       state.lex.addPrefixes( new Word[] { state.root });
       state.lex.addRoot( word_Color );
       { state.lex.addIkoParent( word_$N$Color );
        state.lex.addRoot( word_Color );
        addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Prefix ,  state.root });
       }
      }
 }


 void act700( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.applyFalseRoot( state.root );
       state.lex.addPrefixes( new Word[] { state.root });
       state.lex.addRoot( word_Color );
       { state.lex.addIkoParent( word_$V$Color );
        state.lex.addRoot( word_Color );
        addCatSense( state ,  category_V ,  state.lex ,  new Value[] { atom_Prefix ,  state.root ,  atom_Penalty ,  word_2 });
       }
      }
 }


 void act701( MorphState  state ) {
   if    (catPreTest( state ) &&
          plausibleRoot( state.root ) &&
          catPostTest( state ))
      { state.lex.applyFalseRoot( state.root );
       state.lex.addPrefixes( new Word[] { state.root });
       state.lex.addRoot( word_Color );
       { state.lex.addIkoParent( word_$Adj$Colored );
        state.lex.addRoot( word_Color );
        addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] { atom_Prefix ,  state.root });
       }
      }
 }


 void act702( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       needFinalE( state.root ) &&
       morphRoot( state ) &&
       state.root.noSuffix()) &&
     testPostTest( state ));
 }


 void act703( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Nn )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] { atom_Suffix ,  word_Ar });
      }
 }


 void act704( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       morphRoot( state ) &&
       state.root.noSuffix()) &&
     testPostTest( state ));
 }


 void act705( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (polysyllabic( state.root ) &&
       plausibleRoot( state.root )) &&
     testPostTest( state ));
 }


 void act706( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Anyn ) &&
            plausibleRoot( state.root )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] { atom_Suffix ,  word_Ar });
      }
 }


 void act707( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Nn ) &&
            plausibleRoot( state.root )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] { atom_Suffix ,  word_Ar });
      }
 }


 void act708( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] { atom_Suffix ,  word_Ar });
      }
 }


 void act709( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Nn )) &&
          catPostTest( state ))
      { state.lex.addIkoParent( state.root );
       state.lex.addRoot( state.root );
       addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Suffix ,  word_Eur });
      }
 }


 void act710( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_V$Nn )) &&
          catPostTest( state ))
      { state.lex.addIkoParent(morphPackLex( state , state.root.getWordString(),  "OR" ));
       state.lex.addRoot( state.root );
       addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Suffix ,  word_Eur });
      }
 }


 void act712( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_V )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Suffix ,  word_Or });
      }
 }


 void act713( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_V )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Suffix ,  word_Or });
      }
 }


 void act714( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_V )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Suffix ,  word_Or });
      }
 }


 void act715( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_V )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Suffix ,  word_Or });
      }
 }


 void act716( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Adj )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Suffix ,  word_Tor });
      }
 }


 void act717( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.addIkoParent( word_Error );
       state.lex.addRoot( word_Error );
       addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Prefix ,  state.root });
      }
 }


 void act718( MorphState  state ) {
   if    (catPreTest( state ) &&
          plausibleRoot( state.root ) &&
          catPostTest( state ))
      { state.lex.applyFalseRoot( state.root );
       state.lex.addIkoParent( word_Manager );
       markDict( state ,  state.lex ,  atom_Entails ,  state.root ,  true );
       state.lex.addRoot( word_Manager );
       addCompoundSense( state.lex , dict.makeList( new Word[] { state.root ,  word_Manager }));
       addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Icode ,  atom_$S });
      }
 }


 void act719( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            mayBeCat( state ,  state.root ,  category_V )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Suffix ,  word_Or });
      }
 }


 void act720( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            mayBeCat( state ,  state.root ,  category_V$Nn )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Suffix ,  word_Er });
      }
 }


 void act721( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            mayBeCat( state ,  state.root ,  category_Adj ) &&
            plausibleComparativeRoot( state.root )) &&
          catPostTest( state ))
      addCatSense( state ,  category_Adj ,  state.root ,  new Value[] { atom_Comparative ,  atom_True });
 }


 void act722( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            mayBeCat( state ,  state.root ,  category_Adv ) &&
            plausibleComparativeRoot( state.root )) &&
          catPostTest( state ))
      addCatSense( state ,  category_Adv ,  state.root ,  new Value[] { atom_Comparative ,  atom_True });
 }


 void act723( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            mayBeCat( state ,  state.root ,  category_V )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Suffix ,  word_Er });
      }
 }


 void act725( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            mayBeCat( state ,  state.root ,  category_N )) &&
          catPostTest( state ))
      { state.lex.addIkoParent(dict.makeStructuredConcept( category_N , dict.makeList( new Value[] { word_Person , dict.makeList( new Value[] { word_Mod ,  state.root })})));
       { state.lex.addRoot( state.root );
        addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Suffix ,  word_Eer });
       }
      }
 }


 void act726( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (morphRoot( state ) &&
        ( ! ( state.root.isHyphenated()) )) &&
     testPostTest( state ));
 }


 void act727( MorphState  state ) {
   if    (catPreTest( state ) &&
          polysyllabic( state.root ) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Suffix ,  word_Er });
      }
 }


 void act728( MorphState  state ) {
   if    (catPreTest( state ) &&
          (polysyllabic( state.root ) &&
            morphRoot( state ) &&
            plausibleComparativeRoot( state.root )) &&
          catPostTest( state ))
      addCatSense( state ,  category_Adj ,  state.root ,  new Value[] { atom_Comparative ,  atom_True });
 }


 void act729( MorphState  state ) {
   if    (catPreTest( state ) &&
          (polysyllabic( state.root ) &&
            morphRoot( state ) &&
            plausibleComparativeRoot( state.root )) &&
          catPostTest( state ))
      addCatSense( state ,  category_Adv ,  state.root ,  new Value[] { atom_Comparative ,  atom_True });
 }


 void act730( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            mayBeCat( state ,  state.root ,  category_V$N )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Suffix ,  word_Er });
      }
 }


 void act731( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (morphRoot( state ) &&
        ( ! ( state.root.isHyphenated()) ) &&
       needFinalE( state.root ) &&
        ( ! ( patternCheck( state.root ,  pattern_I$E )) )) &&
     testPostTest( state ));
 }


 void act732( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            mayBeCat( state ,  state.root ,  category_Nn )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Suffix ,  word_Er });
      }
 }


 void act733( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            mayBeCat( state ,  state.root ,  category_Nn ) &&
             ( ! ( needDoubleLetter( state.root )) )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Suffix ,  word_Er });
      }
 }


 void act734( MorphState  state ) {
   if    (catPreTest( state ) &&
          (plausibleRoot( state.root ) &&
            morphRoot( state ) &&
             ( ! ( isFormOfCat( state.root ,  categorySet_V )) )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Suffix ,  word_Er });
      }
 }


 void act735( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (morphRoot( state ) &&
       mayBeSuperlativeEtc( state.lex )) &&
     testPostTest( state ));
 }


 void act737( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_V )) &&
          catPostTest( state ))
      addCatSense( state ,  category_V ,  state.root ,  new Value[] { atom_Tns ,  atom_Present ,  atom_Agr ,  atom_2sg ,  atom_Archaic ,  atom_True });
 }


 void act738( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isFormOfCat( state.root ,  categorySet_Past )) &&
          catPostTest( state ))
      addCatSense( state ,  category_V , firstPastRoot( state.root ),  new Value[] { atom_Tns ,  atom_Past ,  atom_Agr ,  atom_2sg ,  atom_Archaic ,  atom_True });
 }


 void act739( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_V )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_Nmc ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Suffix ,  word_Ment });
      }
 }


 void act741( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_V )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_Nmc ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Mass ,  atom_True ,  atom_Suffix ,  word_Ment });
      }
 }


 void act742( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Adj ) &&
             ( state.root.getWordString().length()  >  2 )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] { atom_Suffix ,  word_Most });
      }
 }


 void act743( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       polysyllabic( state.root ) &&
       morphRoot( state ) &&
       notPrefix( state.root ,  wordSet_Anti$Over$Pro$U_Etc )) &&
     testPostTest( state ));
 }


 void act744( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Nn$V ) &&
             ( state.root.getWordString().length()  >  2 )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] { atom_Suffix ,  word_Ant });
      }
 }


 void act745( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_V ) &&
             ( state.root.getWordString().length()  >  2 )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Suffix ,  word_Ant });
      }
 }


 void act746( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       polysyllabic( state.root ) &&
        ( state.root.getWordString().length()  >  3 ) &&
       morphRoot( state ) &&
       notPrefix( state.root ,  wordSet_Anti$Over$Pro$U_Etc )) &&
     testPostTest( state ));
 }


 void act747( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Nn$V ) &&
             ( state.root.getWordString().length()  >  3 )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] { atom_Suffix ,  word_Ant });
      }
 }


 void act748( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_V ) &&
             ( state.root.getWordString().length()  >  3 )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Suffix ,  word_Ant });
      }
 }


 void act749( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_V$Adj ) &&
             ( state.root.getWordString().length()  >  2 )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Suffix ,  word_Ant });
      }
 }


 void act751( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       polysyllabic( state.root ) &&
        ( state.root.getWordString().length()  >  6 ) &&
       morphRoot( state ) &&
       notPrefix( state.root ,  wordSet_Anti$Over$Pro$U_Etc )) &&
     testPostTest( state ));
 }


 void act752( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Nn ) &&
             ( state.root.getWordString().length()  >  2 )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] { atom_Suffix ,  word_Ant });
      }
 }


 void act753( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Nn ) &&
             ( state.root.getWordString().length()  >  2 )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Suffix ,  word_Ant });
      }
 }


 void act754( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_V ) &&
             ( state.root.getWordString().length()  >  2 )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] { atom_Suffix ,  word_Ent });
      }
 }


 void act755( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_V ) &&
             ( state.root.getWordString().length()  >  2 )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Suffix ,  word_Ent });
      }
 }


 void act756( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       morphRoot( state ) &&
        ( ! ( patternCheck( state.root ,  pattern_$R_S$ )) )) &&
     testPostTest( state ));
 }


 void act757( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_V ) &&
             ( state.root.getWordString().length()  >  2 )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Suffix ,  word_Ient });
      }
 }


 void act758( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
        ( state.root.getWordString().length()  >  2 )) &&
     testPostTest( state ));
 }


 void act759( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Anyn$Adj$Prep$C_Etc )) &&
          catPostTest( state ))
      { state.lex.addRoot( word_Left );
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] { atom_Prefix ,  state.root });
      }
 }


 void act760( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_V )) &&
          catPostTest( state ))
      { addCompoundSense( state.lex , dict.makeList( new Word[] { state.root ,  word_Left }));
       state.lex.addRoot( state.root );
       state.lex.addSuffixes( wordSet_Left );
       addCatSense( state ,  category_V ,  state.lex ,  new Value[] { atom_Tns ,  atom_Present ,  atom_Agr ,  atom_Not3sg ,  atom_Untensed ,  atom_True ,  atom_Icode ,  atom_S$Ed });
      }
 }


 void act762( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            dict.isKnownWord( state.root ) &&
            isRootOfCat( state.root ,  categorySet_Nsg )) &&
          catPostTest( state ))
      { state.lex.addIkoParent( word_Person );
       state.lex.addRoot( state.root );
       addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Icode ,  atom_$S });
      }
 }


 void act763( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Prefix )) &&
          catPostTest( state ))
      { state.lex.addIkoParent( word_Person );
       state.lex.addPrefixes( new Word[] { state.root });
       state.lex.addSuffixes( wordSet_Naut );
       markDict( state ,  state.lex ,  atom_Derived$From , dict.makeList( new Word[] { state.root ,  word_Naut }),  true );
       addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Icode ,  atom_$S });
      }
 }


 void act764( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Prefix )) &&
          catPostTest( state ))
      { state.lex.addPrefixes( new Word[] { state.root });
       state.lex.addSuffixes( wordSet_Stat );
       markDict( state ,  state.lex ,  atom_Derived$From , dict.makeList( new Word[] { state.root ,  word_Stat }),  true );
       addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Icode ,  atom_$S });
      }
 }


 void act765( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (morphRoot( state ) &&
       dict.isKnownWord( state.root ) &&
       plausibleRoot( state.root ) &&
        ( state.root.getWordString().length()  >  2 ) &&
       needFinalE( state.root ) &&
       isRootOfCat( state.root ,  categorySet_Anyn$V$Adj ) &&
        (state.root.getdict( feature_Guessed ) ==  null )) &&
     testPostTest( state ));
 }


 void act766( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] { atom_Suffix ,  word_Ist });
      }
 }


 void act767( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.addIkoParent( word_Person );
       state.lex.addRoot( state.root );
       addCatSense( state ,  category_Nc ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Suffix ,  word_Ist });
      }
 }


 void act768( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (morphRoot( state ) &&
       dict.isKnownWord( state.root ) &&
       plausibleRoot( state.root ) &&
        ( state.root.getWordString().length()  >  2 ) &&
       isRootOfCat( state.root ,  categorySet_Anyn$Adj$Anyn ) &&
        (state.root.getdict( feature_Guessed ) ==  null )) &&
     testPostTest( state ));
 }


 void act769( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (morphRoot( state ) &&
       dict.isKnownWord( state.root ) &&
       plausibleRoot( state.root ) &&
        ( state.root.getWordString().length()  >  2 ) &&
       isRootOfCat( state.root ,  categorySet_Anyn$V$Adj ) &&
        (state.root.getdict( feature_Guessed ) ==  null )) &&
     testPostTest( state ));
 }


 void act770( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (morphRoot( state ) &&
       dict.isKnownWord( state.root ) &&
       plausibleRoot( state.root ) &&
        ( state.root.getWordString().length()  >  2 ) &&
       isRootOfCat( state.root ,  categorySet_Adj$Anyn ) &&
        (state.root.getdict( feature_Guessed ) ==  null )) &&
     testPostTest( state ));
 }


 void act771( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (morphRoot( state ) &&
       dict.isKnownWord( state.root ) &&
       plausibleRoot( state.root ) &&
       polysyllabic( state.root ) &&
       isRootOfCat( state.root ,  categorySet_Adj$Anyn ) &&
        (state.root.getdict( feature_Guessed ) ==  null )) &&
     testPostTest( state ));
 }


 void act773( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       polysyllabic( state.root ) &&
       morphRoot( state ) &&
       isRootOfCat( state.root ,  categorySet_Adj$Anyn ) &&
        (state.root.getdict( feature_Guessed ) ==  null )) &&
     testPostTest( state ));
 }


 void act774( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (morphRoot( state ) &&
       dict.isKnownWord( state.root ) &&
       plausibleRoot( state.root ) &&
       polysyllabic( state.root ) &&
       isRootOfCat( state.root ,  categorySet_Anyn$Adj$Prefix ) &&
        (state.root.getdict( feature_Guessed ) ==  null )) &&
     testPostTest( state ));
 }


 void act775( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (morphRoot( state ) &&
       dict.isKnownWord( state.root ) &&
       plausibleRoot( state.root ) &&
       polysyllabic( state.root ) &&
       isRootOfCat( state.root ,  categorySet_V ) &&
        (state.root.getdict( feature_Guessed ) ==  null )) &&
     testPostTest( state ));
 }


 void act776( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
        ( state.root.getWordString().length()  >  2 ) &&
       morphRoot( state ) &&
       isRootOfCat( state.root ,  categorySet_Adj$Anyn ) &&
        (state.root.getdict( feature_Guessed ) ==  null )) &&
     testPostTest( state ));
 }


 void act777( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
        ( state.root.getWordString().length()  >  2 ) &&
       morphRoot( state ) &&
        ( ! ( patternCheck( state.root ,  pattern_E$E )) ) &&
       isRootOfCat( state.root ,  categorySet_Adj$Anyn ) &&
        (state.root.getdict( feature_Guessed ) ==  null )) &&
     testPostTest( state ));
 }


 void act778( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
        ( state.root.getWordString().length()  >  2 ) &&
       morphRoot( state ) &&
       isRootOfCat( state.root ,  categorySet_V ) &&
        (state.root.getdict( feature_Guessed ) ==  null )) &&
     testPostTest( state ));
 }


 void act779( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
        ( state.root.getWordString().length()  >  2 ) &&
       morphRoot( state ) &&
        ( ! ( patternCheck( state.root ,  pattern_E$E )) ) &&
       isRootOfCat( state.root ,  categorySet_V ) &&
        (state.root.getdict( feature_Guessed ) ==  null )) &&
     testPostTest( state ));
 }


 void act780( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       morphRoot( state ) &&
       dict.isKnownWord( state.root ) &&
       polysyllabic( state.root ) &&
        ( ! ( patternCheck( state.root ,  pattern_Y$Y )) ) &&
       isRootOfCat( state.root ,  categorySet_V ) &&
        (state.root.getdict( feature_Guessed ) ==  null )) &&
     testPostTest( state ));
 }


 void act781( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       morphRoot( state ) &&
       dict.isKnownWord( state.root ) &&
       polysyllabic( state.root ) &&
        ( ! ( patternCheck( state.root ,  pattern_Y$Y )) ) &&
       isRootOfCat( state.root ,  categorySet_Adj$Anyn ) &&
        (state.root.getdict( feature_Guessed ) ==  null )) &&
     testPostTest( state ));
 }


 void act782( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] { atom_Suffix ,  word_Ist ,  atom_Penalty ,  word_1 });
      }
 }


 void act783( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
        ( state.root.getWordString().length()  >  2 ) &&
       morphRoot( state ) &&
       isRootOfCat( state.root ,  categorySet_Adj$Anyn )) &&
     testPostTest( state ));
 }


 void act784( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       polysyllabic( state.root ) &&
       morphRoot( state ) &&
       isRootOfCat( state.root ,  categorySet_Adj$Anyn )) &&
     testPostTest( state ));
 }


 void act785( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       morphRoot( state ) &&
       isRootOfCat( state.root ,  categorySet_Anyn$Adj$V$Prep_Etc )) &&
     testPostTest( state ));
 }


 void act786( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.applyFalseRoot( state.root );
       state.lex.addPrefixes( new Word[] { state.root });
       state.lex.addRoot( word_List );
       state.lex.addIkoParent( word_List );
       addCatSense( state ,  category_Nc ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Icode ,  atom_$S });
      }
 }


 void act787( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       morphRoot( state ) &&
       morphCheck( state.root ,  category_N )) &&
     testPostTest( state ));
 }


 void act788( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Adj$Anyn )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_Nc ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Suffix ,  word_Let });
      }
 }


 void act789( MorphState  state ) {
   if    (catPreTest( state ) &&
          polysyllabic( state.root ) &&
          catPostTest( state ))
      addCatSense( state ,  category_Nmc ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Mass ,  atom_True ,  atom_Icode ,  atom_$S });
 }


 void act790( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       morphRoot( state ) &&
       mayBeCat( state ,  state.root ,  category_N )) &&
     testPostTest( state ));
 }


 void act791( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       needFinalE( state.root ) &&
       morphRoot( state ) &&
       mayBeCat( state ,  state.root ,  category_N )) &&
     testPostTest( state ));
 }


 void act792( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_Nc ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Suffix ,  word_Ist });
      }
 }


 void act793( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
        ( state.root.getWordString().length()  >  2 ) &&
       morphRoot( state ) &&
       mayBeCat( state ,  state.root ,  category_N$V$Adj )) &&
     testPostTest( state ));
 }


 void act794( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.addRoot( word_List );
       addCatSense( state ,  category_Nc ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Prefix ,  state.root });
      }
 }


 void act795( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
        ( state.root.getWordString().length()  >  2 ) &&
       morphRoot( state ) &&
       mayBeCat( state ,  state.root ,  category_Adj$N )) &&
     testPostTest( state ));
 }


 void act796( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
        ( state.root.getWordString().length()  >  2 ) &&
       morphRoot( state ) &&
        ( ! ( patternCheck( state.root ,  pattern_E$E )) ) &&
       mayBeCat( state ,  state.root ,  category_Adj$N )) &&
     testPostTest( state ));
 }


 void act797( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       polysyllabic( state.root ) &&
       morphRoot( state ) &&
       mayBeCat( state ,  state.root ,  category_Adj$N ) &&
        (state.root.getdict( feature_Guessed ) ==  null )) &&
     testPostTest( state ));
 }


 void act798( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       polysyllabic( state.root ) &&
       morphRoot( state ) &&
       mayBeCat( state ,  state.root ,  category_Adj$N )) &&
     testPostTest( state ));
 }


 void act799( MorphState  state ) {
   if    (catPreTest( state ) &&
          polysyllabic( state.root ) &&
          catPostTest( state ))
      { markDict( state ,  state.lex ,  atom_Features ,  wordSet_Russian ,  true );
       addCatSense( state ,  category_Nm ,  state.lex ,  new Value[] { atom_Mass$Pure ,  atom_True ,  atom_Mass ,  atom_True ,  atom_Icode ,  atom_Nopl });
      }
 }


 void act800( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            dict.isKnownWord( state.root ) &&
            isRootOfCat( state.root ,  categorySet_Anyn )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_Nm ,  state.lex ,  new Value[] { atom_Suffix ,  word_Cy });
      }
 }


 void act801( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Prefix )) &&
          catPostTest( state ))
      { state.lex.applyFalseRoot( state.root );
       state.lex.addSuffixes( wordSet_Morphy );
       state.lex.addPrefixes( new Word[] { state.root });
       state.lex.addRoot( state.lex );
       addCatSense( state ,  category_Nm ,  state.lex ,  new Value[] { atom_Mass$Pure ,  atom_True ,  atom_Mass ,  atom_True ,  atom_Icode ,  atom_$Ies });
      }
 }


 void act802( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Prefix )) &&
          catPostTest( state ))
      { state.lex.applyFalseRoot( state.root );
       state.lex.addIioParent( word_Condition );
       state.lex.addSuffixes( wordSet_Pathy );
       state.lex.addPrefixes( new Word[] { state.root });
       state.lex.addRoot( state.lex );
       addCatSense( state ,  category_Nm ,  state.lex ,  new Value[] { atom_Mass$Pure ,  atom_True ,  atom_Mass ,  atom_True ,  atom_Icode ,  atom_$Ies });
      }
 }


 void act803( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Prefix )) &&
          catPostTest( state ))
      { state.lex.applyFalseRoot( state.root );
       state.lex.addIioParent( word_Condition );
       state.lex.addSuffixes( wordSet_Trophy );
       state.lex.addPrefixes( new Word[] { state.root });
       state.lex.addRoot( state.lex );
       addCatSense( state ,  category_Nm ,  state.lex ,  new Value[] { atom_Mass$Pure ,  atom_True ,  atom_Mass ,  atom_True ,  atom_Icode ,  atom_$Ies });
      }
 }


 void act804( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Anyn )) &&
          catPostTest( state ))
      { state.lex.addSuffixes( wordSet_Y );
       addCatSense( state ,  category_Nm ,  state.lex ,  new Value[] { atom_Mass$Pure ,  atom_True ,  atom_Mass ,  atom_True ,  atom_Icode ,  atom_$Ies });
      }
 }


 void act805( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Prefix )) &&
          catPostTest( state ))
      { state.lex.addSuffixes( wordSet_Phagy );
       state.lex.addPrefixes( new Word[] { state.root });
       markDict( state ,  state.lex ,  atom_Derived$From , dict.makeList( new Word[] { state.root ,  word_Phagy }),  true );
       state.lex.applyFalseRoot( state.root );
       addCatSense( state ,  category_Nm ,  state.lex ,  new Value[] { atom_Mass$Pure ,  atom_True ,  atom_Mass ,  atom_True ,  atom_Icode ,  atom_$Ies });
      }
 }


 void act806( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Prefix )) &&
          catPostTest( state ))
      { state.lex.applyFalseRoot( state.root );
       state.lex.addSuffixes( wordSet_Phony );
       state.lex.addPrefixes( new Word[] { state.root });
       state.lex.addRoot( state.lex );
       addCatSense( state ,  category_Nm ,  state.lex ,  new Value[] { atom_Mass$Pure ,  atom_True ,  atom_Mass ,  atom_True ,  atom_Icode ,  atom_$Ies });
      }
 }


 void act807( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Prefix )) &&
          catPostTest( state ))
      { state.lex.applyFalseRoot( state.root );
       state.lex.addSuffixes( wordSet_Megaly );
       state.lex.addPrefixes( new Word[] { state.root });
       state.lex.addRoot( state.lex );
       addCatSense( state ,  category_Nm ,  state.lex ,  new Value[] { atom_Mass$Pure ,  atom_True ,  atom_Mass ,  atom_True ,  atom_Icode ,  atom_$Ies });
      }
 }


 void act808( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Prefix )) &&
          catPostTest( state ))
      { state.lex.applyFalseRoot( state.root );
       state.lex.addIioParent( word_Condition );
       state.lex.addSuffixes( wordSet_Cephaly );
       state.lex.addPrefixes( new Word[] { state.root });
       state.lex.addRoot( state.lex );
       addCatSense( state ,  category_Nm ,  state.lex ,  new Value[] { atom_Mass$Pure ,  atom_True ,  atom_Mass ,  atom_True ,  atom_Icode ,  atom_$Ies });
      }
 }


 void act809( MorphState  state ) {
   if    (catPreTest( state ) &&
          polysyllabic( state.root ) &&
          catPostTest( state ))
      addCatSense( state ,  category_Nm ,  state.lex ,  new Value[] { atom_Mass$Pure ,  atom_True ,  atom_Mass ,  atom_True ,  atom_Icode ,  atom_$Ies });
 }


 void act810( MorphState  state ) {
   if    (catPreTest( state ) &&
          polysyllabic( state.root ) &&
          catPostTest( state ))
      addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Mass ,  atom_True });
 }


 void act811( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Nm )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] { atom_Suffix ,  word_Y });
      }
 }


 void act812( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Anyn$V$Adj )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_Nm ,  state.lex ,  new Value[] { atom_Suffix ,  word_Ry });
      }
 }


 void act813( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       morphRoot( state ) &&
       dict.isKnownWord( state.root ) &&
       needFinalE( state.root )) &&
     testPostTest( state ));
 }


 void act814( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Anyn$V )) &&
          catPostTest( state ))
      { state.lex.addIkoParent( word_Science );
       state.lex.addSuffixes( wordSet_Ography );
       state.lex.addRoot( state.root );
       addCatSense( state ,  category_Nm ,  state.lex ,  new Value[] { atom_Mass$Pure ,  atom_True ,  atom_Mass ,  atom_True ,  atom_Icode ,  atom_$Ies });
      }
 }


 void act815( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Prefix )) &&
          catPostTest( state ))
      { state.lex.addIkoParent( word_Science );
       state.lex.addSuffixes( wordSet_Ography );
       state.lex.addPrefixes( new Word[] { state.root });
       addCatSense( state ,  category_Nm ,  state.lex ,  new Value[] { atom_Mass$Pure ,  atom_True ,  atom_Mass ,  atom_True ,  atom_Icode ,  atom_$Ies });
      }
 }


 void act816( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Anyn$V )) &&
          catPostTest( state ))
      { state.lex.addIkoParent( word_Science );
       state.lex.addSuffixes( wordSet_Graphy );
       state.lex.addRoot( state.root );
       addCatSense( state ,  category_Nm ,  state.lex ,  new Value[] { atom_Mass$Pure ,  atom_True ,  atom_Mass ,  atom_True ,  atom_Icode ,  atom_$Ies });
      }
 }


 void act817( MorphState  state ) {
   if    (catPreTest( state ) &&
          polysyllabic( state.root ) &&
          catPostTest( state ))
      { state.lex.addIkoParent( word_Science );
       state.lex.addSuffixes( wordSet_Ography );
       state.lex.addRoot( state.root );
       addCatSense( state ,  category_Nm ,  state.lex ,  new Value[] { atom_Mass$Pure ,  atom_True ,  atom_Mass ,  atom_True ,  atom_Icode ,  atom_$Ies });
      }
 }


 void act818( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            mayBeCat( state ,  state.root ,  category_N )) &&
          catPostTest( state ))
      { state.lex.addIkoParent( word_Science );
       state.lex.addSuffixes( wordSet_Graphy );
       state.lex.addRoot( state.root );
       addCatSense( state ,  category_Nm ,  state.lex ,  new Value[] { atom_Mass$Pure ,  atom_True ,  atom_Mass ,  atom_True ,  atom_Icode ,  atom_$Ies });
      }
 }


 void act819( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Anyn$V )) &&
          catPostTest( state ))
      { state.lex.addIkoParent( word_Science );
       state.lex.addSuffixes( wordSet_Ology );
       state.lex.addRoot( state.root );
       addCatSense( state ,  category_Nm ,  state.lex ,  new Value[] { atom_Mass$Pure ,  atom_True ,  atom_Mass ,  atom_True ,  atom_Icode ,  atom_$Ies });
      }
 }


 void act820( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.addIkoParent( word_Science );
       state.lex.addSuffixes( wordSet_Ology );
       state.lex.addRoot( state.lex );
       addCatSense( state ,  category_Nm ,  state.lex ,  new Value[] { atom_Mass$Pure ,  atom_True ,  atom_Mass ,  atom_True ,  atom_Icode ,  atom_$Ies });
      }
 }


 void act821( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isFormOfCat( state.root ,  categorySet_Anyn$V )) &&
          catPostTest( state ))
      { state.lex.addIkoParent( word_Science );
       state.lex.addSuffixes( wordSet_Ology );
       state.lex.addRoot( state.root );
       addCatSense( state ,  category_Nm ,  state.lex ,  new Value[] { atom_Mass$Pure ,  atom_True ,  atom_Mass ,  atom_True ,  atom_Icode ,  atom_$Ies });
      }
 }


 void act822( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Anyn ) &&
             ( ! ( isFormOfCat( state.root ,  categorySet_Npl )) )) &&
          catPostTest( state ))
      { state.lex.applyFalseRoot( state.root );
       state.lex.addIkoParent( word_Science );
       state.lex.addSuffixes( wordSet_Ology );
       state.lex.addRoot( state.lex );
       addCatSense( state ,  category_Nm ,  state.lex ,  new Value[] { atom_Mass$Pure ,  atom_True ,  atom_Mass ,  atom_True ,  atom_Icode ,  atom_$Ies });
      }
 }


 void act823( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Anyn$V )) &&
          catPostTest( state ))
      { state.lex.applyFalseRoot( state.root );
       state.lex.addIkoParent( word_Science );
       state.lex.addSuffixes( wordSet_Ology );
       state.lex.addRoot( state.lex );
       addCatSense( state ,  category_Nm ,  state.lex ,  new Value[] { atom_Mass$Pure ,  atom_True ,  atom_Mass ,  atom_True ,  atom_Icode ,  atom_$Ies });
      }
 }


 void act824( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Adj )) &&
          catPostTest( state ))
      { state.lex.applyFalseRoot( state.root );
       state.lex.addIkoParent( word_Science );
       state.lex.addSuffixes( wordSet_Ology );
       state.lex.addRoot( state.lex );
       addCatSense( state ,  category_Nm ,  state.lex ,  new Value[] { atom_Mass$Pure ,  atom_True ,  atom_Mass ,  atom_True ,  atom_Icode ,  atom_$Ies });
      }
 }


 void act825( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.applyFalseRoot( state.root );
       state.lex.addIkoParent( word_Science );
       state.lex.addSuffixes( wordSet_Ology );
       state.lex.addRoot( state.lex );
       addCatSense( state ,  category_Nm ,  state.lex ,  new Value[] { atom_Mass$Pure ,  atom_True ,  atom_Mass ,  atom_True ,  atom_Icode ,  atom_$Ies });
      }
 }


 void act826( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Prefix )) &&
          catPostTest( state ))
      { state.lex.addIkoParent( word_Science );
       state.lex.addSuffixes( wordSet_Ology );
       state.lex.addPrefixes( new Word[] { state.root });
       addCatSense( state ,  category_Nm ,  state.lex ,  new Value[] { atom_Mass$Pure ,  atom_True ,  atom_Mass ,  atom_True ,  atom_Icode ,  atom_$Ies });
      }
 }


 void act827( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            dict.isKnownWord( state.root ) &&
            isRootOfCat( state.root ,  categorySet_Anyn )) &&
          catPostTest( state ))
      { state.lex.applyFalseRoot( state.root );
       state.lex.addIkoParent( word_Science );
       state.lex.addSuffixes( wordSet_Ology );
       state.lex.addRoot( state.lex );
       addCatSense( state ,  category_Nm ,  state.lex ,  new Value[] { atom_Mass$Pure ,  atom_True ,  atom_Mass ,  atom_True ,  atom_Icode ,  atom_$Ies });
      }
 }


 void act828( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Prefix )) &&
          catPostTest( state ))
      { state.lex.applyFalseRoot( state.root );
       state.lex.addIkoParent( word_Shape );
       state.lex.addSuffixes( wordSet_Ognomy );
       state.lex.addPrefixes( new Word[] { state.root });
       addCatSense( state ,  category_Nm ,  state.lex ,  new Value[] { atom_Mass$Pure ,  atom_True ,  atom_Mass ,  atom_True ,  atom_Icode ,  atom_$Ies });
      }
 }


 void act829( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Prefix )) &&
          catPostTest( state ))
      { state.lex.applyFalseRoot( state.root );
       state.lex.addSuffixes( wordSet_Nomy );
       state.lex.addPrefixes( new Word[] { state.root });
       addCatSense( state ,  category_Nm ,  state.lex ,  new Value[] { atom_Mass$Pure ,  atom_True ,  atom_Mass ,  atom_True ,  atom_Icode ,  atom_$Ies });
      }
 }


 void act830( MorphState  state ) {
   if    (catPreTest( state ) &&
          plausibleRoot( state.root ) &&
          catPostTest( state ))
      { state.lex.applyFalseRoot( state.root );
       addCatSense( state ,  category_Nm ,  state.lex ,  new Value[] { atom_Suffix ,  word_Ognomy });
      }
 }


 void act831( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Prefix )) &&
          catPostTest( state ))
      { state.lex.addIkoParent( word_Operation );
       state.lex.addSuffixes( wordSet_Otomy );
       state.lex.addPrefixes( new Word[] { state.root });
       addCatSense( state ,  category_Nm ,  state.lex ,  new Value[] { atom_Mass$Pure ,  atom_True ,  atom_Mass ,  atom_True ,  atom_Icode ,  atom_$Ies });
      }
 }


 void act832( MorphState  state ) {
   if    (catPreTest( state ) &&
          plausibleRoot( state.root ) &&
          catPostTest( state ))
      { state.lex.applyFalseRoot( state.root );
       addCatSense( state ,  category_Nm ,  state.lex ,  new Value[] { atom_Suffix ,  word_Otomy });
      }
 }


 void act833( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Prefix )) &&
          catPostTest( state ))
      { state.lex.addIkoParent( word_Operation );
       state.lex.addSuffixes( wordSet_Ostomy );
       state.lex.addPrefixes( new Word[] { state.root });
       addCatSense( state ,  category_Nm ,  state.lex ,  new Value[] { atom_Mass$Pure ,  atom_True ,  atom_Mass ,  atom_True ,  atom_Icode ,  atom_$Ies });
      }
 }


 void act834( MorphState  state ) {
   if    (catPreTest( state ) &&
          plausibleRoot( state.root ) &&
          catPostTest( state ))
      { state.lex.applyFalseRoot( state.root );
       addCatSense( state ,  category_Nm ,  state.lex ,  new Value[] { atom_Suffix ,  word_Ostomy });
      }
 }


 void act835( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.addIkoParent( word_Operation );
       state.lex.addSuffixes( wordSet_Ectomy );
       state.lex.addRoot( state.root );
       addCatSense( state ,  category_Nm ,  state.lex ,  new Value[] { atom_Mass$Pure ,  atom_True ,  atom_Mass ,  atom_True ,  atom_Icode ,  atom_$Ies });
      }
 }


 void act836( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       morphRoot( state ) &&
       isRootOfCat( state.root ,  categorySet_Anyn ) &&
       needFinalE( state.root )) &&
     testPostTest( state ));
 }


 void act837( MorphState  state ) {
   if    (catPreTest( state ) &&
          plausibleRoot( state.root ) &&
          catPostTest( state ))
      { state.lex.addSuffixes( wordSet_Ectomy );
       addCatSense( state ,  category_Nm ,  state.lex ,  new Value[] { atom_Mass$Pure ,  atom_True ,  atom_Mass ,  atom_True ,  atom_Icode ,  atom_$Ies });
      }
 }


 void act838( MorphState  state ) {
   if    (catPreTest( state ) &&
          plausibleRoot( state.root ) &&
          catPostTest( state ))
      { state.lex.addSuffixes( wordSet_Tropy );
       addCatSense( state ,  category_Nm ,  state.lex ,  new Value[] { atom_Mass$Pure ,  atom_True ,  atom_Mass ,  atom_True ,  atom_Icode ,  atom_$Ies });
      }
 }


 void act839( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Anyn$V )) &&
          catPostTest( state ))
      { state.lex.addIkoParent( word_Examination );
       state.lex.addSuffixes( wordSet_Oscopy );
       state.lex.addRoot( state.root );
       addCatSense( state ,  category_Nm ,  state.lex ,  new Value[] { atom_Mass$Pure ,  atom_True ,  atom_Mass ,  atom_True ,  atom_Icode ,  atom_$Ies });
      }
 }


 void act840( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Prefix )) &&
          catPostTest( state ))
      { state.lex.addIkoParent( word_Examination );
       state.lex.addSuffixes( wordSet_Oscopy );
       state.lex.addPrefixes( new Word[] { state.root });
       addCatSense( state ,  category_Nm ,  state.lex ,  new Value[] { atom_Mass$Pure ,  atom_True ,  atom_Mass ,  atom_True ,  atom_Icode ,  atom_$Ies });
      }
 }


 void act841( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Anyn$V )) &&
          catPostTest( state ))
      { state.lex.addIkoParent( word_Examination );
       state.lex.addSuffixes( wordSet_Scopy );
       state.lex.addRoot( state.root );
       addCatSense( state ,  category_Nm ,  state.lex ,  new Value[] { atom_Mass$Pure ,  atom_True ,  atom_Mass ,  atom_True ,  atom_Icode ,  atom_$Ies });
      }
 }


 void act842( MorphState  state ) {
   if    (catPreTest( state ) &&
          polysyllabic( state.root ) &&
          catPostTest( state ))
      { state.lex.addIkoParent( word_Examination );
       state.lex.addSuffixes( wordSet_Oscopy );
       state.lex.addRoot( state.root );
       addCatSense( state ,  category_Nm ,  state.lex ,  new Value[] { atom_Mass$Pure ,  atom_True ,  atom_Mass ,  atom_True ,  atom_Icode ,  atom_$Ies });
      }
 }


 void act843( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            mayBeCat( state ,  state.root ,  category_N )) &&
          catPostTest( state ))
      { state.lex.addIkoParent( word_Examination );
       state.lex.addSuffixes( wordSet_Scopy );
       state.lex.addRoot( state.root );
       addCatSense( state ,  category_Nm ,  state.lex ,  new Value[] { atom_Mass$Pure ,  atom_True ,  atom_Mass ,  atom_True ,  atom_Icode ,  atom_$Ies });
      }
 }


 void act844( MorphState  state ) {
   if    (catPreTest( state ) &&
          syllabic( state.root ) &&
          catPostTest( state ))
      { state.lex.addIkoParent( word_Examination );
       state.lex.addSuffixes( wordSet_Oscopy );
       state.lex.addRoot( state.root );
       addCatSense( state ,  category_Nm ,  state.lex ,  new Value[] { atom_Mass$Pure ,  atom_True ,  atom_Mass ,  atom_True ,  atom_Icode ,  atom_$Ies });
      }
 }


 void act845( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Nn$V$Adj )) &&
          catPostTest( state ))
      { state.lex.addSuffixes( wordSet_Gamy );
       state.lex.addRoot( state.root );
       addCatSense( state ,  category_Nm ,  state.lex ,  new Value[] { atom_Mass$Pure ,  atom_True ,  atom_Mass ,  atom_True ,  atom_Icode ,  atom_$Ies });
      }
 }


 void act846( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Nn$V$Adj )) &&
          catPostTest( state ))
      { state.lex.addSuffixes( wordSet_Taxy );
       state.lex.addRoot( state.root );
       addCatSense( state ,  category_Nm ,  state.lex ,  new Value[] { atom_Mass$Pure ,  atom_True ,  atom_Mass ,  atom_True ,  atom_Icode ,  atom_$Ies });
      }
 }


 void act847( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (morphRoot( state ) &&
        ( ! ( LexiconUtil.isMembOfArray( state.root ,  wordSet_De$Non$Re$Un )) )) &&
     testPostTest( state ));
 }


 void act848( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Nn$V$Adj$Prefix )) &&
          catPostTest( state ))
      { state.lex.addSuffixes( wordSet_Gamy );
       state.lex.addPrefixes( new Word[] { state.root });
       markDict( state ,  state.lex ,  atom_Derived$From , dict.makeList( new Word[] { state.root ,  word_Gamy }),  true );
       addCatSense( state ,  category_Nm ,  state.lex ,  new Value[] { atom_Mass$Pure ,  atom_True ,  atom_Mass ,  atom_True ,  atom_Icode ,  atom_$Ies });
      }
 }


 void act849( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Nn$V$Adj$Prefix )) &&
          catPostTest( state ))
      { state.lex.addSuffixes( wordSet_Taxy );
       state.lex.addPrefixes( new Word[] { state.root });
       markDict( state ,  state.lex ,  atom_Derived$From , dict.makeList( new Word[] { state.root ,  word_Taxy }),  true );
       addCatSense( state ,  category_Nm ,  state.lex ,  new Value[] { atom_Mass$Pure ,  atom_True ,  atom_Mass ,  atom_True ,  atom_Icode ,  atom_$Ies });
      }
 }


 void act850( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Prefix )) &&
          catPostTest( state ))
      { state.lex.addSuffixes( wordSet_Ogony );
       state.lex.addPrefixes( new Word[] { state.root });
       addCatSense( state ,  category_Nm ,  state.lex ,  new Value[] { atom_Mass$Pure ,  atom_True ,  atom_Mass ,  atom_True ,  atom_Icode ,  atom_$Ies });
      }
 }


 void act851( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Prefix )) &&
          catPostTest( state ))
      { state.lex.addSuffixes( wordSet_Ography );
       state.lex.addPrefixes( new Word[] { state.root });
       addCatSense( state ,  category_Nm ,  state.lex ,  new Value[] { atom_Mass$Pure ,  atom_True ,  atom_Mass ,  atom_True ,  atom_Icode ,  atom_$Ies });
      }
 }


 void act852( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Prefix )) &&
          catPostTest( state ))
      { state.lex.addSuffixes( wordSet_Graphy );
       state.lex.addPrefixes( new Word[] { state.root });
       addCatSense( state ,  category_Nm ,  state.lex ,  new Value[] { atom_Mass$Pure ,  atom_True ,  atom_Mass ,  atom_True ,  atom_Icode ,  atom_$Ies });
      }
 }


 void act853( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Prefix )) &&
          catPostTest( state ))
      { state.lex.addIkoParent( word_Science );
       state.lex.addSuffixes( wordSet_Ogeny );
       state.lex.addPrefixes( new Word[] { state.root });
       addCatSense( state ,  category_Nm ,  state.lex ,  new Value[] { atom_Mass$Pure ,  atom_True ,  atom_Mass ,  atom_True ,  atom_Icode ,  atom_$Ies });
      }
 }


 void act854( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Anyn$V )) &&
          catPostTest( state ))
      { state.lex.addIkoParent( word_Science );
       state.lex.addSuffixes( wordSet_Ogeny );
       state.lex.addRoot( state.root );
       addCatSense( state ,  category_Nm ,  state.lex ,  new Value[] { atom_Mass$Pure ,  atom_True ,  atom_Mass ,  atom_True ,  atom_Icode ,  atom_$Ies });
      }
 }


 void act855( MorphState  state ) {
   if    (catPreTest( state ) &&
          plausibleRoot( state.root ) &&
          catPostTest( state ))
      { state.lex.applyFalseRoot( state.root );
       addCatSense( state ,  category_Nm ,  state.lex ,  new Value[] { atom_Suffix ,  word_Ogeny });
      }
 }


 void act856( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Prefix )) &&
          catPostTest( state ))
      { state.lex.addIkoParent( word_Worship );
       state.lex.addSuffixes( wordSet_Olatry );
       state.lex.addPrefixes( new Word[] { state.root });
       addCatSense( state ,  category_Nm ,  state.lex ,  new Value[] { atom_Mass$Pure ,  atom_True ,  atom_Mass ,  atom_True ,  atom_Icode ,  atom_$Ies });
      }
 }


 void act857( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Anyn$V )) &&
          catPostTest( state ))
      { state.lex.addIkoParent( word_Worship );
       state.lex.addSuffixes( wordSet_Olatry );
       state.lex.addRoot( state.root );
       addCatSense( state ,  category_Nm ,  state.lex ,  new Value[] { atom_Mass$Pure ,  atom_True ,  atom_Mass ,  atom_True ,  atom_Icode ,  atom_$Ies });
      }
 }


 void act858( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Adj$Prefix )) &&
          catPostTest( state ))
      { state.lex.addIkoParent( word_Marital_Practic_Etc );
       state.lex.addSuffixes( wordSet_Andry );
       state.lex.addRoot( state.root );
       addCatSense( state ,  category_Nm ,  state.lex ,  new Value[] { atom_Mass$Pure ,  atom_True ,  atom_Mass ,  atom_True ,  atom_Icode ,  atom_$Ies });
      }
 }


 void act859( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isFormOfCat( state.root ,  categorySet_Nn )) &&
          catPostTest( state ))
      { state.lex.addIkoParent( word_Measurement );
       state.lex.addSuffixes( wordSet_Scopy );
       state.lex.addRoot( state.root );
       addCatSense( state ,  category_Nm ,  state.lex ,  new Value[] { atom_Mass$Pure ,  atom_True ,  atom_Mass ,  atom_True ,  atom_Icode ,  atom_Nopl });
      }
 }


 void act860( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Anyn$V )) &&
          catPostTest( state ))
      { state.lex.addIkoParent( word_Measurement );
       state.lex.addSuffixes( wordSet_Metry );
       state.lex.addRoot( state.root );
       addCatSense( state ,  category_Nm ,  state.lex ,  new Value[] { atom_Mass$Pure ,  atom_True ,  atom_Mass ,  atom_True ,  atom_Icode ,  atom_$Ies });
      }
 }


 void act861( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Prefix )) &&
          catPostTest( state ))
      { state.lex.addIkoParent( word_Measurement );
       state.lex.addSuffixes( wordSet_Metry );
       state.lex.addPrefixes( new Word[] { state.root });
       addCatSense( state ,  category_Nm ,  state.lex ,  new Value[] { atom_Mass$Pure ,  atom_True ,  atom_Mass ,  atom_True ,  atom_Icode ,  atom_$Ies });
      }
 }


 void act862( MorphState  state ) {
   if    (catPreTest( state ) &&
          polysyllabic( state.root ) &&
          catPostTest( state ))
      { state.lex.addIkoParent( word_Measurement );
       state.lex.addSuffixes( wordSet_Metry );
       state.lex.addRoot( state.root );
       addCatSense( state ,  category_Nm ,  state.lex ,  new Value[] { atom_Mass$Pure ,  atom_True ,  atom_Mass ,  atom_True ,  atom_Icode ,  atom_$Ies });
      }
 }


 void act863( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            mayBeCat( state ,  state.root ,  category_N )) &&
          catPostTest( state ))
      { state.lex.addIkoParent( word_Measurement );
       state.lex.addSuffixes( wordSet_Metry );
       state.lex.addRoot( state.root );
       addCatSense( state ,  category_Nm ,  state.lex ,  new Value[] { atom_Mass$Pure ,  atom_True ,  atom_Mass ,  atom_True ,  atom_Icode ,  atom_$Ies });
      }
 }


 void act864( MorphState  state ) {
   if    (catPreTest( state ) &&
          syllabic( state.root ) &&
          catPostTest( state ))
      { state.lex.addIkoParent( word_Measurement );
       state.lex.addSuffixes( wordSet_Metry );
       state.lex.addRoot( state.root );
       addCatSense( state ,  category_Nm ,  state.lex ,  new Value[] { atom_Mass$Pure ,  atom_True ,  atom_Mass ,  atom_True ,  atom_Icode ,  atom_$Ies });
      }
 }


 void act865( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            dict.isKnownWord( state.root ) &&
            isRootOfCat( state.root ,  categorySet_Adj )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_Adv ,  state.lex ,  new Value[] { atom_Suffix ,  word_Ly });
      }
 }


 void act866( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            dict.isKnownWord( state.root ) &&
            isRootOfCat( state.root ,  categorySet_Nn ) &&
            isNonpenaltyFormOfCat( state.root ,  categorySet_Nn )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] { atom_Suffix ,  word_Ly });
      }
 }


 void act867( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Nn ) &&
            notPrefix( state.root ,  wordSet_Anti$Over$Pro$U_Etc )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] { atom_Suffix ,  word_Y });
      }
 }


 void act868( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Nn ) &&
            notPrefix( state.root ,  wordSet_Anti$Over$Pro$U_Etc$ )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_Nm ,  state.lex ,  new Value[] { atom_Suffix ,  word_Ery });
      }
 }


 void act869( MorphState  state ) {
   if    (catPreTest( state ) &&
          (plausibleRoot( state.root ) &&
            morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Adj$Anyn ) &&
             (state.root.getdict( feature_Compound$Of ) ==  null ) &&
            state.root.noPrefix()) &&
          catPostTest( state ))
      { state.lex.addSuffixes( wordSet_Ify );
       state.lex.addRoot( state.root );
       addCatSense( state ,  category_V ,  state.lex ,  new Value[] { atom_Tns ,  atom_Present ,  atom_Agr ,  atom_Not3sg ,  atom_Untensed ,  atom_True ,  atom_Icode ,  atom_Ies$Ied });
      }
 }


 void act871( MorphState  state ) {
   if    (catPreTest( state ) &&
          (plausibleRoot( state.root ) &&
            needFinalE( state.root ) &&
            morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Adj$Anyn ) &&
             (state.root.getdict( feature_Compound$Of ) ==  null ) &&
            state.root.noPrefix()) &&
          catPostTest( state ))
      { state.lex.addSuffixes( wordSet_Ify );
       state.lex.addRoot( state.root );
       addCatSense( state ,  category_V ,  state.lex ,  new Value[] { atom_Tns ,  atom_Present ,  atom_Agr ,  atom_Not3sg ,  atom_Untensed ,  atom_True ,  atom_Icode ,  atom_Ies$Ied });
      }
 }


 void act872( MorphState  state ) {
   if    (catPreTest( state ) &&
          (plausibleRoot( state.root ) &&
            morphRoot( state ) &&
            dict.isKnownWord( state.root ) &&
            isRootOfCat( state.root ,  categorySet_Adj$Anyn ) &&
             (state.root.getdict( feature_Compound$Of ) ==  null ) &&
            state.root.noPrefix()) &&
          catPostTest( state ))
      { state.lex.addSuffixes( wordSet_Ify );
       state.lex.addRoot( state.root );
       addCatSense( state ,  category_V ,  state.lex ,  new Value[] { atom_Tns ,  atom_Present ,  atom_Agr ,  atom_Not3sg ,  atom_Untensed ,  atom_True ,  atom_Icode ,  atom_Ies$Ied });
      }
 }


 void act873( MorphState  state ) {
   if    (catPreTest( state ) &&
          (plausibleRoot( state.root ) &&
            morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Adj$Prefix ) &&
             (state.root.getdict( feature_Compound$Of ) ==  null ) &&
            state.root.noPrefix()) &&
          catPostTest( state ))
      { state.lex.addSuffixes( wordSet_Ify );
       state.lex.addPrefixes( new Word[] { state.root });
       addCatSense( state ,  category_V ,  state.lex ,  new Value[] { atom_Tns ,  atom_Present ,  atom_Agr ,  atom_Not3sg ,  atom_Untensed ,  atom_True ,  atom_Icode ,  atom_Ies$Ied });
      }
 }


 void act874( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Nn$V )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] { atom_Suffix ,  word_Y });
      }
 }


 void act875( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            dict.isKnownWord( state.root ) &&
            isRootOfCat( state.root ,  categorySet_Adj )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_Adv ,  state.lex ,  new Value[] { atom_Suffix ,  word_Ly });
      }
 }


 void act876( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Adj )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_Adv ,  state.lex ,  new Value[] { atom_Suffix ,  word_Ly });
      }
 }


 void act877( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            dict.isKnownWord( state.root ) &&
            isRootOfCat( state.root ,  categorySet_Adj ) &&
            notPrefix( state.root ,  wordSet_Un$Non$Over$Und_Etc )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_Adv ,  state.lex ,  new Value[] { atom_Suffix ,  word_Ly });
      }
 }


 void act878( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            dict.isKnownWord( state.root ) &&
            isRootOfCat( state.root ,  categorySet_Nn ) &&
             ( ! ( isFormOfCat( state.root ,  categorySet_Prespart )) ) &&
             ( ! ( state.root.hasSuffix( wordSet_Able$Al$Ant$Ar$_Etc )) ) &&
            isNonpenaltyFormOfCat( state.root ,  categorySet_Nn )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] { atom_Suffix ,  word_Ly });
      }
 }


 void act879( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Adj ) &&
            notPrefix( state.root ,  wordSet_Un$Non$Over$Und_Etc )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_Adv ,  state.lex ,  new Value[] { atom_Suffix ,  word_Ly });
      }
 }


 void act880( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Nn ) &&
             ( ! ( isFormOfCat( state.root ,  categorySet_Prespart )) ) &&
             ( ! ( state.root.hasSuffix( wordSet_Able$Al$Ant$Ar$_Etc )) ) &&
            isNonpenaltyFormOfCat( state.root ,  categorySet_Nn )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] { atom_Suffix ,  word_Ly });
      }
 }


 void act881( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Nn ) &&
            isNonpenaltyFormOfCat( state.root ,  categorySet_Nn )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] { atom_Suffix ,  word_Ly });
      }
 }


 void act882( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
             ( ! ( isRootOfCat( state.root ,  categorySet_Adj )) ) &&
            isRootOfCat( state.root ,  categorySet_Nn )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] { atom_Suffix ,  word_Ly });
      }
 }


 void act883( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            morphCheck( state.root ,  category_Adj ,  atom_Known )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_Adv ,  state.lex ,  new Value[] { atom_Suffix ,  word_Ly });
      }
 }


 void act884( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            morphCheck( state.root ,  category_Adj ,  atom_Known ) &&
             ( ! ( state.root.isHyphenated()) ) &&
            notPrefix( state.root ,  wordSet_Un$Non$Over$Und_Etc )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_Adv ,  state.lex ,  new Value[] { atom_Suffix ,  word_Ly });
      }
 }


 void act885( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       morphRoot( state ) &&
       notPrefix( state.root ,  wordSet_Un$Non$Over$Und_Etc )) &&
     testPostTest( state ));
 }


 void act886( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       morphRoot( state ) &&
       isRootOfCat( state.root ,  categorySet_Adj )) &&
     testPostTest( state ));
 }


 void act887( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_Adv ,  state.lex ,  new Value[] { atom_Suffix ,  word_Ly });
      }
 }


 void act888( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Anyn$V )) &&
          catPostTest( state ))
      { state.lex.addRoot(morphPackLex( state , state.root.getWordString(),  "ABLE" ));
       addCatSense( state ,  category_Adv ,  state.lex ,  new Value[] { atom_Suffix ,  word_Ly });
      }
 }


 void act889( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Adj )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Mass ,  atom_True ,  atom_Suffix ,  word_Ity });
      }
 }


 void act890( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_V )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Mass ,  atom_True ,  atom_Suffix ,  word_Ability });
      }
 }


 void act891( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Adj$Anyn )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Mass ,  atom_True ,  atom_Suffix ,  word_Ity });
      }
 }


 void act892( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Adj$Anyn )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Mass ,  atom_True ,  atom_Suffix ,  word_Icity });
      }
 }


 void act893( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Adj )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Mass ,  atom_True ,  atom_Suffix ,  word_Ality });
      }
 }


 void act894( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Anyn$V )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Mass ,  atom_True ,  atom_Suffix ,  word_Ity });
      }
 }


 void act896( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (morphRoot( state ) &&
       dict.isKnownWord( state.root ) &&
       plausibleRoot( state.root )) &&
     testPostTest( state ));
 }


 void act897( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Anyn$V$Adj )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Mass ,  atom_True ,  atom_Suffix ,  word_Ility });
      }
 }


 void act898( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Anyn$V$Adj )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Mass ,  atom_True ,  atom_Suffix ,  word_Ity });
      }
 }


 void act899( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            dict.isKnownWord( state.root ) &&
            isRootOfCat( state.root ,  categorySet_Nn$V )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] { atom_Suffix ,  word_Y });
      }
 }


 void act900( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       morphRoot( state ) &&
        ( ! ( patternCheck( state.root ,  pattern_Y )) ) &&
       notPrefix( state.root ,  wordSet_Anti$Over$Pro$U_Etc$ )) &&
     testPostTest( state ));
 }


 void act901( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       morphRoot( state ) &&
       notPrefix( state.root ,  wordSet_Anti$Over$Pro$U_Etc$ )) &&
     testPostTest( state ));
 }


 void act902( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      addCatSense( state ,  category_Nm ,  state.lex ,  new Value[] { atom_Mass$Pure ,  atom_True ,  atom_Mass ,  atom_True ,  atom_Icode ,  atom_$Ies });
 }


 void act903( MorphState  state ) {
   if    (catPreTest( state ) &&
          plausibleRoot( state.root ) &&
          catPostTest( state ))
      { state.lex.applyFalseRoot( state.root );
       state.lex.addIkoParents( wordSet_Berry$$N$Plant$_Etc );
       state.lex.addPrefixes( new Word[] { state.root });
       state.lex.addRoot( word_Berry );
       addCatSense( state ,  category_Nm ,  state.lex ,  new Value[] { atom_Mass$Pure ,  atom_True ,  atom_Mass ,  atom_True ,  atom_Icode ,  atom_$Ies });
      }
 }


 void act904( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            dict.isKnownWord( state.root ) &&
            isRootOfCat( state.root ,  categorySet_Nn )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] { atom_Suffix ,  word_Y });
      }
 }


 void act905( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Firstname )) &&
          catPostTest( state ))
      { state.lex.addVariantOf( state.root );
       state.lex.addIioParent( word_Nickname );
       addCatSense( state ,  category_Firstname ,  state.lex ,  new Value[] {});
      }
 }


 void act906( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            dict.isKnownWord( state.root ) &&
            isRootOfCat( state.root ,  categorySet_Nn$V ) &&
            notPrefix( state.root ,  wordSet_Anti$Over$Pro$U_Etc$ )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] { atom_Suffix ,  word_Y });
      }
 }


 void act907( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            dict.isKnownWord( state.root ) &&
            isRootOfCat( state.root ,  categorySet_Anyn ) &&
             ( ! ( isRootOfCat( state.root ,  categorySet_Adj )) )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] { atom_Suffix ,  word_Y });
      }
 }


 void act908( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Anyn )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_Nm ,  state.lex ,  new Value[] { atom_Suffix ,  word_Cy });
      }
 }


 void act909( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Adj$Anyn )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_Nm ,  state.lex ,  new Value[] { atom_Suffix ,  word_Cy });
      }
 }


 void act910( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_V )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_Nm ,  state.lex ,  new Value[] { atom_Suffix ,  word_Ency });
      }
 }


 void act911( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Adj$V$Anyn )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_Nm ,  state.lex ,  new Value[] { atom_Suffix ,  word_Cy });
      }
 }


 void act913( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Adj$V )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_Nm ,  state.lex ,  new Value[] { atom_Suffix ,  word_Cy });
      }
 }


 void act914( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Nn$V )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_Nm ,  state.lex ,  new Value[] { atom_Suffix ,  word_Ery });
      }
 }


 void act915( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       morphRoot( state ) &&
       state.root.noPrefix() &&
       needFinalE( state.root )) &&
     testPostTest( state ));
 }


 void act916( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Adj$Anyn )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] { atom_Suffix ,  word_Ary });
      }
 }


 void act917( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       morphRoot( state ) &&
       state.root.noPrefix()) &&
     testPostTest( state ));
 }


 void act918( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Anyn )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] { atom_Suffix ,  word_Ary });
      }
 }


 void act919( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       morphRoot( state ) &&
       state.root.noPrefix() &&
        ( ! ( patternCheck( state.root ,  pattern_A )) ) &&
        ( ! ( patternCheck( state.root ,  pattern_C$T )) )) &&
     testPostTest( state ));
 }


 void act920( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Nn$V ) &&
            notPrefix( state.root ,  wordSet_Anti$Over$Pro$U_Etc$ )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_Nm ,  state.lex ,  new Value[] { atom_Suffix ,  word_Ry });
      }
 }


 void act921( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            dict.isKnownWord( state.root ) &&
            isRootOfCat( state.root ,  categorySet_Nn )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_Nm ,  state.lex ,  new Value[] { atom_Suffix ,  word_Metry });
      }
 }


 void act922( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Nn )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_Nm ,  state.lex ,  new Value[] { atom_Suffix ,  word_Y });
      }
 }


 void act923( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Nn )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_Nm ,  state.lex ,  new Value[] { atom_Suffix ,  word_Metry });
      }
 }


 void act924( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Nn )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] { atom_Suffix ,  word_Y });
      }
 }


 void act925( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       morphRoot( state ) &&
        ( ! ( patternCheck( state.root ,  pattern_A$E$R )) )) &&
     testPostTest( state ));
 }


 void act926( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       morphRoot( state ) &&
        ( ! ( polysyllabic( state.root )) )) &&
     testPostTest( state ));
 }


 void act927( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Adj$Anyn )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] { atom_Suffix ,  word_Sy });
      }
 }


 void act928( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Firstname ) &&
             ( ! ( polysyllabic( state.root )) )) &&
          catPostTest( state ))
      { state.lex.addVariantOf( state.root );
       state.lex.addIioParent( word_Nickname );
       addCatSense( state ,  category_Firstname ,  state.lex ,  new Value[] {});
      }
 }


 void act929( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            dict.isKnownWord( state.root ) &&
            isRootOfCat( state.root ,  categorySet_Anyn ) &&
            isFormOfCat( state.root ,  categorySet_Nn ) &&
            notPrefix( state.root ,  wordSet_Anti$Over$Pro$U_Etc$ )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] { atom_Suffix ,  word_Y });
      }
 }


 void act930( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            dict.isKnownWord( state.root ) &&
            isRootOfCat( state.root ,  categorySet_Adj ) &&
             ( ! ( isRootOfCat( state.root ,  categorySet_Anyn )) ) &&
            state.root.noSuffix() &&
            notPrefix( state.root ,  wordSet_Anti$Over$Pro$U_Etc$ ) &&
             ( ! ( state.root.isHyphenated()) )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_Nm ,  state.lex ,  new Value[] { atom_Suffix ,  word_Y });
      }
 }


 void act931( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       morphRoot( state ) &&
        ( ! ( patternCheck( state.root ,  pattern_Y )) )) &&
     testPostTest( state ));
 }


 void act932( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            dict.isKnownWord( state.root ) &&
            isRootOfCat( state.root ,  categorySet_Adj ) &&
             ( ! ( isRootOfCat( state.root ,  categorySet_Anyn )) ) &&
            state.root.noSuffix() &&
            notPrefix( state.root ,  wordSet_Anti$Over$Pro$U_Etc$ ) &&
             ( ! ( state.root.isHyphenated()) )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_Nc ,  state.lex ,  new Value[] { atom_Suffix ,  word_Y });
      }
 }


 void act933( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            dict.isKnownWord( state.root ) &&
            isRootOfCat( state.root ,  categorySet_Anyn ) &&
            isFormOfCat( state.root ,  categorySet_Nn )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] { atom_Suffix ,  word_Y });
      }
 }


 void act934( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_V )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] { atom_Suffix ,  word_Ory });
      }
 }


 void act935( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_V )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] { atom_Suffix ,  word_Atory });
      }
 }


 void act936( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            dict.isKnownWord( state.root ) &&
            isRootOfCat( state.root ,  categorySet_V )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_Nm ,  state.lex ,  new Value[] { atom_Suffix ,  word_Y });
      }
 }


 void act937( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            dict.isKnownWord( state.root ) &&
            isRootOfCat( state.root ,  categorySet_V ) &&
            notPrefix( state.root ,  wordSet_Anti$Over$Pro$U_Etc$ )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_Nm ,  state.lex ,  new Value[] { atom_Suffix ,  word_Y });
      }
 }


 void act938( MorphState  state ) {
   if    (catPreTest( state ) &&
          plausibleRoot( state.root ) &&
          catPostTest( state ))
      { state.lex.addSuffixes( wordSet_Ify );
       addCatSense( state ,  category_V ,  state.lex ,  new Value[] { atom_Tns ,  atom_Present ,  atom_Agr ,  atom_Not3sg ,  atom_Untensed ,  atom_True ,  atom_Icode ,  atom_Ies$Ied });
      }
 }


 void act939( MorphState  state ) {
   if    (catPreTest( state ) &&
          plausibleRoot( state.root ) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       state.lex.addSuffixes( wordSet_Ply );
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] {});
      }
 }


 void act940( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Mass ,  atom_True });
 }


 void act941( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            mayBeCat( state ,  state.root ,  category_Adj )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_Adv ,  state.lex ,  new Value[] { atom_Suffix ,  word_Ly });
      }
 }


 void act942( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            morphCheck( state.root ,  category_Adj )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_Adv ,  state.lex ,  new Value[] { atom_Suffix ,  word_Ly });
      }
 }


 void act943( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            mayBeCat( state ,  state.root ,  category_V$Adj$N )) &&
          catPostTest( state ))
      { state.lex.applyFalseRoot( state.root );
       state.lex.addIkoParent( word_$N$Fly );
       state.lex.addPrefixes( new Word[] { state.root });
       state.lex.addRoot( word_$N$Fly );
       addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Icode ,  atom_$Ies });
      }
 }


 void act944( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.applyFalseRoot( state.root );
       state.lex.addIkoParent( word_Family );
       state.lex.addPrefixes( new Word[] { state.root });
       state.lex.addRoot( word_Family );
       addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Icode ,  atom_$Ies });
      }
 }


 void act945( MorphState  state ) {
   if    (catPreTest( state ) &&
          plausibleRoot( state.root ) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_Adv ,  state.lex ,  new Value[] { atom_Suffix ,  word_Ly });
      }
 }


 void act946( MorphState  state ) {
   if    (catPreTest( state ) &&
          polysyllabic( state.root ) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_Adv ,  state.lex ,  new Value[] { atom_Suffix ,  word_Ly });
      }
 }


 void act947( MorphState  state ) {
   if    (catPreTest( state ) &&
          plausibleRoot( state.root ) &&
          catPostTest( state ))
      { addPenalty( state.lex ,  category_Adj ,  1 );
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] {});
      }
 }


 void act948( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            mayBeCat( state ,  state.root ,  category_Adj )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Mass ,  atom_True ,  atom_Suffix ,  word_Ity });
      }
 }


 void act949( MorphState  state ) {
   if    (catPreTest( state ) &&
          plausibleRoot( state.root ) &&
          catPostTest( state ))
      addCatSense( state ,  category_Nm ,  state.lex ,  new Value[] { atom_Mass$Pure ,  atom_True ,  atom_Mass ,  atom_True ,  atom_Icode ,  atom_$Ies });
 }


 void act950( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            mayBeCat( state ,  state.root ,  category_N )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] { atom_Suffix ,  word_Ary });
      }
 }


 void act951( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Adj )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_Nm ,  state.lex ,  new Value[] { atom_Suffix ,  word_Cy });
      }
 }


 void act952( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            mayBeCat( state ,  state.root ,  category_V )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_Nm ,  state.lex ,  new Value[] { atom_Suffix ,  word_Ency });
      }
 }


 void act953( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            mayBeCat( state ,  state.root ,  category_V )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_Nm ,  state.lex ,  new Value[] { atom_Suffix ,  word_Ancy });
      }
 }


 void act955( MorphState  state ) {
   if    (catPreTest( state ) &&
          polysyllabic( state.root ) &&
          catPostTest( state ))
      { state.lex.addIkoParent( word_Science );
       addCatSense( state ,  category_Nm ,  state.lex ,  new Value[] { atom_Mass$Pure ,  atom_True ,  atom_Mass ,  atom_True ,  atom_Icode ,  atom_$Ies });
      }
 }


 void act956( MorphState  state ) {
   if    (catPreTest( state ) &&
          polysyllabic( state.root ) &&
          catPostTest( state ))
      { state.lex.addIkoParent( word_Science );
       state.lex.addSuffixes( wordSet_Graphy );
       state.lex.addRoot( state.root );
       addCatSense( state ,  category_Nm ,  state.lex ,  new Value[] { atom_Mass$Pure ,  atom_True ,  atom_Mass ,  atom_True ,  atom_Icode ,  atom_$Ies });
      }
 }


 void act957( MorphState  state ) {
   if    (catPreTest( state ) &&
          syllabic( state.root ) &&
          catPostTest( state ))
      { state.lex.addIkoParent( word_Examination );
       state.lex.addPrefixes( new Word[] { state.root });
       state.lex.addRoot( word_$N$Oscopy$Exami_Etc );
       addCatSense( state ,  category_Nm ,  state.lex ,  new Value[] { atom_Mass$Pure ,  atom_True ,  atom_Mass ,  atom_True ,  atom_Icode ,  atom_$Ies });
      }
 }


 void act958( MorphState  state ) {
   if    (catPreTest( state ) &&
          polysyllabic( state.root ) &&
          catPostTest( state ))
      addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] { atom_Scalar ,  atom_True ,  atom_Icode ,  atom_Ier$Iest });
 }


 void act959( MorphState  state ) {
   if    (catPreTest( state ) &&
          (polysyllabic( state.root ) &&
            morphRoot( state ) &&
             ( ! ( patternCheckLeft( state.root ,  pattern_A$N$T$I )) ) &&
             ( ! ( patternCheckLeft( state.root ,  pattern_P$R$O )) )) &&
          catPostTest( state ))
      addCatSense( state ,  category_Nm ,  state.lex ,  new Value[] { atom_Mass$Pure ,  atom_True ,  atom_Mass ,  atom_True ,  atom_Icode ,  atom_$Ies });
 }


 void act960( MorphState  state ) {
   if    (catPreTest( state ) &&
          polysyllabic( state.root ) &&
          catPostTest( state ))
      { state.lex.addSuffixes( wordSet_Ity );
       addCatSense( state ,  category_Nm ,  state.lex ,  new Value[] { atom_Mass$Pure ,  atom_True ,  atom_Mass ,  atom_True ,  atom_Icode ,  atom_$Ies });
      }
 }


 void act961( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            mayBeCat( state ,  state.root ,  category_N )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Suffix ,  word_Y });
      }
 }


 void act962( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            mayBeCat( state ,  state.root ,  category_Adj )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] { atom_Suffix ,  word_Y });
      }
 }


 void act963( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Icode ,  atom_$Ies });
 }


 void act964( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { markDict( state ,  state.lex ,  atom_Guessed ,  wordSet_T ,  false );
       addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Icode ,  atom_$Ies });
      }
 }


 void act965( MorphState  state ) {
   if    (catPreTest( state ) &&
           sp_guessVerbFlag  &&
          catPostTest( state ))
      { addPenalty( state.lex ,  category_V ,  1 );
       addPenalty( state.lex ,  category_Adj ,  1 );
       addCatSense( state ,  category_V ,  state.lex ,  new Value[] { atom_Tns ,  atom_Present ,  atom_Agr ,  atom_Not3sg ,  atom_Untensed ,  atom_True ,  atom_Icode ,  atom_Ies$Ied });
      }
 }


 void act966( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Nn )) &&
          catPostTest( state ))
      { state.lex.addIkoParent(morphPackLex( state ,  "RELATED_TO_" , state.root.getWordString()));
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] {});
      }
 }


 void act968( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       polysyllabic( state.root ) &&
       morphRoot( state ) &&
       isRootOfCat( state.root ,  categorySet_Nn ) &&
       notPrefix( state.root ,  wordSet_A$An$Dis$In$Im$_Etc )) &&
     testPostTest( state ));
 }


 void act969( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      addCatSense( state ,  category_Adj ,  state.lex , makeSuffixDef( state.lex ,  state.root ,  word_Antic ));
 }


 void act970( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       polysyllabic( state.root ) &&
       morphRoot( state ) &&
       dict.isKnownWord( state.root ) &&
       isRootOfCat( state.root ,  categorySet_Nn ) &&
       notPrefix( state.root ,  wordSet_A$An$Dis$In$Im$_Etc )) &&
     testPostTest( state ));
 }


 void act971( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      addCatSense( state ,  category_Adj ,  state.lex , makeSuffixDef( state.lex ,  state.root ,  word_Etic ));
 }


 void act972( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       morphRoot( state ) &&
       isRootOfCat( state.root ,  categorySet_Nn ) &&
       notPrefix( state.root ,  wordSet_A$An$Dis$In$Im$_Etc )) &&
     testPostTest( state ));
 }


 void act973( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.addIkoParent( word_Acetic );
       state.lex.addSuffixes( wordSet_Acetic );
       state.lex.addRoot( state.root );
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] {});
      }
 }


 void act974( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       morphRoot( state ) &&
       dict.isKnownWord( state.root ) &&
       isRootOfCat( state.root ,  categorySet_Nn ) &&
       notPrefix( state.root ,  wordSet_A$An$Dis$In$Im$_Etc )) &&
     testPostTest( state ));
 }


 void act975( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       morphRoot( state ) &&
       notPrefix( state.root ,  wordSet_A$An$Dis$In$Im$_Etc )) &&
     testPostTest( state ));
 }


 void act976( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      addCatSense( state ,  category_Adj ,  state.lex , makeSuffixDef( state.lex ,  state.root ,  word_Atic ));
 }


 void act977( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      addCatSense( state ,  category_N ,  state.lex , makeSuffixDef( state.lex ,  state.root ,  word_Atic ));
 }


 void act978( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       morphRoot( state ) &&
       isRootOfCat( state.root ,  categorySet_Nn ) &&
       needFinalE( state.root ) &&
       notPrefix( state.root ,  wordSet_A$An$Dis$In$Im$_Etc )) &&
     testPostTest( state ));
 }


 void act979( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (morphRoot( state ) &&
       dict.isKnownWord( state.root ) &&
       isRootOfCat( state.root ,  categorySet_Nn ) &&
       notPrefix( state.root ,  wordSet_A$An$Dis$In$Im$_Etc )) &&
     testPostTest( state ));
 }


 void act981( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      addCatSense( state ,  category_Adj ,  state.lex , makeSuffixDef( state.lex ,  state.root ,  state.suffix ));
 }


 void act982( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
        ( state.root.getWordString().length()  >  2 ) &&
       morphRoot( state ) &&
       isRootOfCat( state.root ,  categorySet_Nn$Adj$V ) &&
       notPrefix( state.root ,  wordSet_A$An$Dis$In$Im$_Etc )) &&
     testPostTest( state ));
 }


 void act983( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      addCatSense( state ,  category_Adj ,  state.lex , makeSuffixDef( state.lex ,  state.root ,  word_Istic ));
 }


 void act984( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
        ( state.root.getWordString().length()  >  2 ) &&
       needFinalE( state.root ) &&
       morphRoot( state ) &&
       isRootOfCat( state.root ,  categorySet_Nn$Adj$V ) &&
       notPrefix( state.root ,  wordSet_A$An$Dis$In$Im$_Etc )) &&
     testPostTest( state ));
 }


 void act985( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
        ( state.root.getWordString().length()  >  2 ) &&
       morphRoot( state ) &&
       dict.isKnownWord( state.root ) &&
       isRootOfCat( state.root ,  categorySet_Nn$Adj$V ) &&
       notPrefix( state.root ,  wordSet_A$An$Dis$In$Im$_Etc )) &&
     testPostTest( state ));
 }


 void act986( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      addCatSense( state ,  category_Adj ,  state.lex , makeSuffixDef( state.lex ,  state.root ,  word_Otic ));
 }


 void act987( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       morphRoot( state ) &&
       dict.isKnownWord( state.root ) &&
       isRootOfCat( state.root ,  categorySet_Nn ) &&
        ( ! ( isFormOfCat( state.root ,  categorySet_Np )) ) &&
       notPrefix( state.root ,  wordSet_A$An$Dis$In$Im$_Etc )) &&
     testPostTest( state ));
 }


 void act988( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       morphRoot( state ) &&
       dict.isKnownWord( state.root ) &&
       isRootOfCat( state.root ,  categorySet_Prefix ) &&
       notPrefix( state.root ,  wordSet_A$An$Dis$In$Im$_Etc )) &&
     testPostTest( state ));
 }


 void act989( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.addSuffixes( wordSet_Otic );
       state.lex.addPrefixes( new Word[] { state.root });
       markDict( state ,  state.lex ,  atom_Derived$From , dict.makeList( new Word[] { state.root ,  word_Otic }),  true );
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] {});
      }
 }


 void act990( MorphState  state ) {
   if    (catPreTest( state ) &&
          (plausibleRoot( state.root ) &&
            morphRoot( state ) &&
            dict.isKnownWord( state.root ) &&
            polysyllabic( state.root ) &&
            isRootOfCat( state.root ,  categorySet_Nn ) &&
            notPrefix( state.root ,  wordSet_A$An$Dis$In$Im$_Etc )) &&
          catPostTest( state ))
      addCatSense( state ,  category_Adj ,  state.lex , makeSuffixDef( state.lex ,  state.root ,  state.suffix ));
 }


 void act991( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       morphRoot( state ) &&
       dict.isKnownWord( state.root ) &&
       polysyllabic( state.root ) &&
       isRootOfCat( state.root ,  categorySet_Nn ) &&
       needFinalE( state.root ) &&
       notPrefix( state.root ,  wordSet_A$An$Dis$In$Im$_Etc )) &&
     testPostTest( state ));
 }


 void act992( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       morphRoot( state ) &&
       dict.isKnownWord( state.root ) &&
       polysyllabic( state.root ) &&
       isRootOfCat( state.root ,  categorySet_Prefix ) &&
       notPrefix( state.root ,  wordSet_A$An$Dis$In$Im$_Etc )) &&
     testPostTest( state ));
 }


 void act993( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       morphRoot( state ) &&
       dict.isKnownWord( state.root ) &&
       polysyllabic( state.root ) &&
       isRootOfCat( state.root ,  categorySet_Nn ) &&
       notPrefix( state.root ,  wordSet_A$An$Dis$In$Im$_Etc )) &&
     testPostTest( state ));
 }


 void act994( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       morphRoot( state ) &&
       isRootOfCat( state.root ,  categorySet_Anyn ) &&
       notPrefix( state.root ,  wordSet_A$An$Dis$In$Im$_Etc )) &&
     testPostTest( state ));
 }


 void act995( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       morphRoot( state ) &&
       isRootOfCat( state.root ,  categorySet_Nn ) &&
       polysyllabic( state.root ) &&
       notPrefix( state.root ,  wordSet_A$An$Dis$In$Im$_Etc )) &&
     testPostTest( state ));
 }


 void act996( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (polysyllabic( state.root ) &&
       plausibleRoot( state.root ) &&
       morphRoot( state ) &&
       dict.isKnownWord( state.root ) &&
       isRootOfCat( state.root ,  categorySet_Nn ) &&
       notPrefix( state.root ,  wordSet_A$An$Dis$In$Im$_Etc )) &&
     testPostTest( state ));
 }


 void act997( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (polysyllabic( state.root ) &&
       plausibleRoot( state.root ) &&
       morphRoot( state ) &&
       dict.isKnownWord( state.root ) &&
       isRootOfCat( state.root ,  categorySet_Nn ) &&
       notPrefix( state.root ,  wordSet_In$Im$Non$Un )) &&
     testPostTest( state ));
 }


 void act998( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (polysyllabic( state.root ) &&
       plausibleRoot( state.root ) &&
       morphRoot( state ) &&
       isRootOfCat( state.root ,  categorySet_Anyn ) &&
       notPrefix( state.root ,  wordSet_A$An$Dis$In$Im$_Etc )) &&
     testPostTest( state ));
 }


 void act999( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (polysyllabic( state.root ) &&
       plausibleRoot( state.root ) &&
       morphRoot( state ) &&
       isRootOfCat( state.root ,  categorySet_Nn ) &&
       notPrefix( state.root ,  wordSet_A$An$Dis$In$Im$_Etc )) &&
     testPostTest( state ));
 }


 void act1000( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       morphRoot( state ) &&
       isRootOfCat( state.root ,  categorySet_V ) &&
       notPrefix( state.root ,  wordSet_A$An$Dis$In$Im$_Etc )) &&
     testPostTest( state ));
 }


 void act1002( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       morphRoot( state ) &&
       isRootOfCat( state.root ,  categorySet_Anyn$V$Adj )) &&
     testPostTest( state ));
 }


 void act1003( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.addIkoParent( word_Person );
       state.lex.addSuffixes( wordSet_Iac );
       state.lex.addRoot( state.root );
       addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Icode ,  atom_$S });
      }
 }


 void act1004( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       morphRoot( state ) &&
       isRootOfCat( state.root ,  categorySet_Anyn$V$Adj ) &&
       needFinalE( state.root )) &&
     testPostTest( state ));
 }


 void act1005( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       morphRoot( state ) &&
       isRootOfCat( state.root ,  categorySet_Nn$V$Adj )) &&
     testPostTest( state ));
 }


 void act1006( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       morphRoot( state ) &&
       isRootOfCat( state.root ,  categorySet_Prefix ) &&
       notPrefix( state.root ,  wordSet_A$An$Dis$In$Im$_Etc )) &&
     testPostTest( state ));
 }


 void act1007( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.addIkoParent(dict.makeStructuredConcept(morphPackLex( state ,  "with_" , state.root.getWordString(),  "_scope" ),  category_Adj , dict.makeList( new Value[] { word_Modifier , dict.makeList( wordSequence_Relation$With ), dict.makeList( new Value[] { word_Object , dict.makeList( new Value[] { word_Scope , dict.makeList( new Value[] { word_Mod ,  state.root })})})})));
       addCatSense( state ,  category_Adj ,  state.lex , makeSuffixDef( state.lex ,  state.root ,  word_Scopic ));
      }
 }


 void act1008( MorphState  state ) {
   if    (catPreTest( state ) &&
          (plausibleRoot( state.root ) &&
            polysyllabic( state.root )) &&
          catPostTest( state ))
      { state.lex.addSuffixes( new Word[] { state.suffix });
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] {});
      }
 }


 void act1009( MorphState  state ) {
   if    (catPreTest( state ) &&
          (plausibleRoot( state.root ) &&
            morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Prefix$Adj )) &&
          catPostTest( state ))
      { state.lex.addSuffixes( wordSet_Tropic );
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] {});
      }
 }


 void act1010( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Anyn )) &&
          catPostTest( state ))
      addCatSense( state ,  category_Adj ,  state.lex , makeSuffixDef( state.lex ,  state.root ,  state.suffix ));
 }


 void act1011( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isFormOfCat( state.root ,  categorySet_Prefix )) &&
          catPostTest( state ))
      addCatSense( state ,  category_Adj ,  state.lex , makeSuffixDef( state.lex , morphPackLex( state , state.root.getWordString(),  "LOGY" ),  state.suffix ));
 }


 void act1012( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.addSuffixes( wordSet_Zoic );
       state.lex.addIioParent( word_$N$Era$Time_Per_Etc );
       state.lex.addIkoParent(morphPackLex(state, "in_", state.lex.getWordString(), "_era").makeSenseName( category_Adj ));
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] {});
      }
 }


 void act1013( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Icode ,  atom_Unique });
 }


 void act1014( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { markDict( state ,  state.lex ,  atom_Guessed ,  wordSet_T ,  false );
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] {});
      }
 }


 void act1015( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.addIkoParent( word_Person );
       addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Icode ,  atom_$S });
      }
 }


 void act1016( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            mayBeCat( state ,  state.root ,  category_N )) &&
          catPostTest( state ))
      addCatSense( state ,  category_N ,  state.root ,  new Value[] { atom_Poss ,  atom_True });
 }


 void act1018( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       morphRoot( state ) &&
        ( ! ( state.root.isHyphenated()) ) &&
       state.root.noPrefix()) &&
     testPostTest( state ));
 }


 void act1019( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            state.root.testIcode( category_Nn ,  atomSet_$Ata )) &&
          catPostTest( state ))
      addCatSense( state ,  category_N ,  state.root ,  new Value[] { atom_Number ,  atom_Pl });
 }


 void act1021( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            state.root.testIcode( category_N ,  atomSet_$A )) &&
          catPostTest( state ))
      addCatSense( state ,  category_N ,  state.root ,  new Value[] { atom_Number ,  atom_Pl });
 }


 void act1022( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (morphRoot( state ) &&
       dict.isKnownWord( state.root ) &&
       plausibleRoot( state.root ) &&
        ( state.root.getWordString().length()  >  2 ) &&
       isRootOfCat( state.root ,  categorySet_Anyn ) &&
        (state.root.getdict( feature_Guessed ) ==  null )) &&
     testPostTest( state ));
 }


 void act1024( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.addIkoParent( word_Person );
       state.lex.addRoot( state.root );
       addCatSense( state ,  category_Nc ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Suffix ,  state.suffix });
      }
 }


 void act1025( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
        ( state.root.getWordString().length()  >  2 ) &&
       morphRoot( state ) &&
        ( ! ( state.root.isHyphenated()) ) &&
       state.root.noPrefix()) &&
     testPostTest( state ));
 }


 void act1026( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       morphRoot( state ) &&
        ( ! ( state.root.isHyphenated()) )) &&
     testPostTest( state ));
 }


 void act1027( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            state.root.testIcode( category_N ,  atomSet_$I )) &&
          catPostTest( state ))
      addCatSense( state ,  category_N ,  state.root ,  new Value[] { atom_Number ,  atom_Pl });
 }


 void act1028( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
        ( state.root.getWordString().length()  >  2 ) &&
       morphRoot( state ) &&
        ( ! ( state.root.isHyphenated()) )) &&
     testPostTest( state ));
 }


 void act1029( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       polysyllabic( state.root ) &&
       morphRoot( state ) &&
        ( ! ( state.lex.isHyphenated()) ) &&
       isRootOfCat( state.root ,  categorySet_Country$Npr )) &&
     testPostTest( state ));
 }


 void act1030( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.addIkoParent( word_Person );
       state.lex.addSuffixes( wordSet_I );
       state.lex.addRoots(state.root.makeSenseNamesIfNeeded( categorySet_Country$Npr ));
       addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Icode ,  atom_$S });
      }
 }


 void act1031( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Nn )) &&
          catPostTest( state ))
      addCatSense( state ,  category_N ,  state.root ,  new Value[] { atom_Number ,  atom_Pl });
 }


 void act1032( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
        ( state.root.getWordString().length()  >  4 ) &&
       morphRoot( state ) &&
        ( ! ( state.root.isHyphenated()) ) &&
       state.root.noPrefix()) &&
     testPostTest( state ));
 }


 void act1033( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       polysyllabic( state.root ) &&
       morphRoot( state ) &&
        ( ! ( state.root.isHyphenated()) ) &&
       state.root.noPrefix() &&
        ( state.root.getWordString().length()  >  4 ) &&
        ( ! (isRootOfCat( state.root ,  categorySet_Anyn ) &&
        		LexiconUtil.intersectp(getRightConstituents( state.root ),  wordSet_Alum$Bum$Bunkum_Etc ))) &&
        ( ! ( isChemicalConstituent( state.root )) )) &&
     testPostTest( state ));
 }


 void act1034( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       polysyllabic( state.root ) &&
       morphRoot( state ) &&
        ( ! ( state.root.isHyphenated()) ) &&
       state.root.noPrefix() &&
        ( state.root.getWordString().length()  >  4 ) &&
        ( ! ( patternCheck( state.root ,  pattern_T$I$O$N )) )) &&
     testPostTest( state ));
 }


 void act1035( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       polysyllabic( state.root ) &&
        ( state.root.getWordString().length()  >  4 ) &&
       morphRoot( state ) &&
        ( ! ( state.root.isHyphenated()) ) &&
       state.root.noPrefix()) &&
     testPostTest( state ));
 }


 void act1036( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_V )) &&
          catPostTest( state ))
      addCatSense( state ,  category_V ,  state.root ,  new Value[] { atom_Tns ,  atom_Present ,  atom_Agr ,  atom_3sg ,  atom_Archaic ,  atom_True });
 }


 void act1037( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
             ( ! ( polysyllabic( state.root )) )) &&
          catPostTest( state ))
      { markDict( state ,  state.lex ,  atom_Guessed ,  wordSet_T ,  false );
       addCatSense( state ,  category_V ,  state.root ,  new Value[] { atom_Tns ,  atom_Present ,  atom_Agr ,  atom_3sg ,  atom_Archaic ,  atom_True });
      }
 }


 void act1038( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { markDict( state ,  state.lex ,  atom_Guessed ,  wordSet_T ,  false );
       addCatSense( state ,  category_V ,  state.root ,  new Value[] { atom_Tns ,  atom_Present ,  atom_Agr ,  atom_3sg ,  atom_Archaic ,  atom_True });
      }
 }


 void act1039( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Adj$Anyn )) &&
          catPostTest( state ))
      { state.lex.applyFalseRoot( state.root );
       state.lex.addIkoParent( word_Fish );
       state.lex.addPrefixes( new Word[] { state.root });
       state.lex.addRoot( word_Fish );
       addCatSense( state ,  category_Nmsp ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg$Pl ,  atom_Mass ,  atom_True ,  atom_Icode ,  atom_$Es });
      }
 }


 void act1041( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            (isRootOfCat( state.root ,  categorySet_Adj$Anyn ) ||
              (isRootOfCat( state.root ,  categorySet_V ) &&
                 (state.root.getPrefixes() ==  null )))) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] { atom_Suffix ,  state.suffix });
      }
 }


 void act1042( MorphState  state ) {
   if    (catPreTest( state ) &&
          (plausibleRoot( state.root ) &&
            morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Anyn )) &&
          catPostTest( state ))
      { state.lex.applyFalseRoot( state.root );
       state.lex.addIioParent( word_Skill );
       state.lex.addSuffixes( wordSet_Ship );
       state.lex.addRoot(morphPackLex( state , state.root.getWordString(),  "SMAN" ));
       addCatSense( state ,  category_Nm ,  state.lex ,  new Value[] { atom_Mass$Pure ,  atom_True ,  atom_Mass ,  atom_True ,  atom_Icode ,  atom_$S });
      }
 }


 void act1043( MorphState  state ) {
   if    (catPreTest( state ) &&
          (plausibleRoot( state.root ) &&
            morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Anyn )) &&
          catPostTest( state ))
      { state.lex.applyFalseRoot( state.root );
       state.lex.addIioParent( word_Skill );
       state.lex.addSuffixes( wordSet_Ship );
       state.lex.addRoot(morphPackLex( state , state.root.getWordString(),  "MAN" ));
       addCatSense( state ,  category_Nm ,  state.lex ,  new Value[] { atom_Mass$Pure ,  atom_True ,  atom_Mass ,  atom_True ,  atom_Icode ,  atom_$S });
      }
 }


 void act1044( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Nn )) &&
          catPostTest( state ))
      { state.lex.addIioParent( word_Role );
       state.lex.addSuffixes( wordSet_Ship );
       state.lex.addRoot( state.root );
       addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Icode ,  atom_$S });
      }
 }


 void act1045( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       morphRoot( state ) &&
        ( ! ( patternCheck( state.root ,  pattern_E )) ) &&
       isRootOfCat( state.root ,  categorySet_Anyn )) &&
     testPostTest( state ));
 }


 void act1046( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       morphRoot( state ) &&
       isRootOfCat( state.root ,  categorySet_Anyn$V )) &&
     testPostTest( state ));
 }


 void act1047( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.addIkoParent( word_Proof );
       state.lex.addRoot( word_Proof );
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] { atom_Prefix ,  state.root });
      }
 }


 void act1048( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { markDict( state ,  state.lex ,  atom_Features ,  wordSet_Trans$Passive ,  true );
       state.lex.addRoot( state.root );
       state.lex.addSuffixes( wordSet_Proof );
       addCatSense( state ,  category_V ,  state.lex ,  new Value[] { atom_Tns ,  atom_Present ,  atom_Agr ,  atom_Not3sg ,  atom_Untensed ,  atom_True ,  atom_Icode ,  atom_S$Ed });
      }
 }


 void act1049( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { markDict( state ,  state.lex ,  atom_Guessed ,  wordSet_T ,  false );
       { state.lex.addIkoParent( word_Proof );
        state.lex.addRoot( word_Proof );
        addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] { atom_Prefix ,  state.root });
       }
      }
 }


 void act1050( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (morphRoot( state ) &&
        ( ! ( isFormOfCat( state.root ,  categorySet_Prefix )) )) &&
     testPostTest( state ));
 }


 void act1051( MorphState  state ) {
   if    (catPreTest( state ) &&
          (plausibleRoot( state.root ) &&
            morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Anyn$V$Adj$Adv )) &&
          catPostTest( state ))
      { addCompoundSense( state.lex , dict.makeList( new Word[] { state.root ,  word_Speak }));
       state.lex.addSuffixes( wordSet_Speak );
       state.lex.addRoot( state.root );
       state.lex.addIkoParent( word_Technical_Langu_Etc );
       state.lex.addIkoParent( word_Talk );
       state.lex.addIkoParent( word_Jargon );
       addCatSense( state ,  category_Nm ,  state.lex ,  new Value[] { atom_Mass$Pure ,  atom_True ,  atom_Mass ,  atom_True ,  atom_Icode ,  atom_Nopl });
      }
 }


 void act1052( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Prefix )) &&
          catPostTest( state ))
      { state.lex.applyFalseRoot( state.root );
       state.lex.addPrefixes( new Word[] { state.root });
       state.lex.addSuffixes( wordSet_Ia );
       addCatSense( state ,  category_Nm ,  state.lex ,  new Value[] { atom_Mass$Pure ,  atom_True ,  atom_Mass ,  atom_True ,  atom_Icode ,  atom_$S });
      }
 }


 void act1053( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Adj )) &&
          catPostTest( state ))
      { state.lex.addSuffixes( wordSet_Ia );
       addCatSense( state ,  category_Nm ,  state.lex ,  new Value[] { atom_Mass$Pure ,  atom_True ,  atom_Mass ,  atom_True ,  atom_Icode ,  atom_$S });
      }
 }


 void act1054( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.applyFalseRoot( state.root );
       state.lex.addIkoParent( word_Animal );
       state.lex.addSuffixes( wordSet_Zoa );
       state.lex.addPrefixes( new Word[] { state.root });
       addCompoundSense( state.lex , dict.makeList( new Word[] { state.root ,  word_Zoa }));
       addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Icode ,  atom_$S });
      }
 }


 void act1055( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Anyn )) &&
          catPostTest( state ))
      { state.lex.addIkoParent( state.root );
       state.lex.addIkoParent( word_Female );
       state.lex.addIkoParent( word_Person );
       state.lex.addSuffixes( wordSet_Trix );
       state.lex.addRoot( state.root );
       addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Icode ,  atom_$Ces });
      }
 }


 void act1056( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_V )) &&
          catPostTest( state ))
      { state.lex.addIkoParent( word_Female );
       state.lex.addIkoParent( word_Person );
       state.lex.addSuffixes( wordSet_Trix );
       state.lex.addRoot( state.root );
       addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Icode ,  atom_$Ces });
      }
 }


 void act1057( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Prefix )) &&
          catPostTest( state ))
      { state.lex.applyFalseRoot( state.root );
       state.lex.addIkoParent( word_Animal );
       state.lex.addSuffixes( wordSet_Branch );
       state.lex.addPrefixes( new Word[] { state.root });
       addCompoundSense( state.lex , dict.makeList( new Word[] { state.root ,  word_Branch }));
       addCatSense( state ,  category_Nc ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Icode ,  atom_$Es });
      }
 }


 void act1058( MorphState  state ) {
   if    (catPreTest( state ) &&
          polysyllabic( state.root ) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg$Pl ,  atom_Suffix ,  state.suffix });
      }
 }


 void act1059( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Mass ,  atom_True ,  atom_Mass$Pure ,  atom_True ,  atom_Icode ,  atom_Mass });
 }


 void act1060( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.addIkoParent( word_Fish );
       state.lex.addRoot( word_Fish );
       addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Prefix ,  state.root });
      }
 }


 void act1061( MorphState  state ) {
   if    (catPreTest( state ) &&
          plausibleRoot( state.root ) &&
          catPostTest( state ))
      addCatSense( state ,  category_Adj ,  state.lex , makeSuffixDef( state.lex ,  state.root ,  state.suffix ));
 }


 void act1062( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            mayBeCat( state ,  state.root ,  category_V )) &&
          catPostTest( state ))
      addCatSense( state ,  category_V ,  state.root ,  new Value[] { atom_Tns ,  atom_Present ,  atom_Agr ,  atom_3sg ,  atom_Archaic ,  atom_True });
 }


 void act1063( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (morphRoot( state ) &&
       (isFormOfCat( state.root ,  categorySet_Integer ) ||
         isKnownInstanceOf( state.root ,  word_Unit_Of_Countin_Etc ) ||
         isKnownKindOf( state.root ,  word_Multiple ))) &&
     testPostTest( state ));
 }


 void act1064( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      addCatSense( state ,  category_Ord ,  state.lex ,  new Value[] {});
 }


 void act1065( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { { addPenalty( state.lex ,  category_N ,  1 );
        addPenalty( state.lex ,  category_Adv ,  2 );
       }
       state.lex.addIioParent( word_Ordinal );
       state.lex.setNumericalValue(state.root.numericalValue());
       state.lex.addSuffixes( wordSet_Th );
       state.lex.addRoot( state.root );
       addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Icode ,  atom_$S });
      }
 }


 void act1066( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.addIkoParent(dict.makeStructuredConcept(morphPackLex( state ,  "in_" , state.lex.getWordString(),  "_position" ),  category_Adv , dict.makeList( new Value[] { word_In , dict.makeList( new Value[] { state.lex ,  word_Position })})));
       addCatSense( state ,  category_Adv ,  state.lex ,  new Value[] {});
      }
 }


 void act1067( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (morphRoot( state ) &&
       morphCheck( state.root ,  category_N ) &&
        (makeRealWord( state ,  state.root ) !=  null ) &&
       isKnownInstanceOf( state.root ,  word_Unit_Of_Countin_Etc )) &&
     testPostTest( state ));
 }


 void act1068( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.addIkoParent(dict.makeStructuredConcept(morphPackLex( state ,  "in_" , state.lex.getWordString(),  "_position" ),  category_Adv , dict.makeList( new Value[] { word_In , dict.makeList( new Value[] { state.lex ,  word_Position })})));
       addCatSense( state ,  category_Adv ,  state.lex ,  new Value[] {});
      }
 }


 void act1069( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (morphRoot( state ) &&
       dict.isKnownWord( state.root ) &&
        ( state.root.getWordString().length()  >  3 ) &&
       isFormOfCat( state.root ,  categorySet_V$Adj )) &&
     testPostTest( state ));
 }


 void act1070( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.addSuffixes( wordSet_Th );
       state.lex.addRoot( state.root );
       addCatSense( state ,  category_Nm ,  state.lex ,  new Value[] { atom_Mass$Pure ,  atom_True ,  atom_Mass ,  atom_True ,  atom_Icode ,  atom_$S });
      }
 }


 void act1071( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       morphRoot( state ) &&
        ( ! ( patternCheck( state.root ,  pattern_I )) ) &&
       (isRootOfCat( state.root ,  categorySet_City$Country ) ||
         (isRootOfCat( state.root ,  categorySet_Npr ) &&
           state.root.isInstanceOf( word_Country )))) &&
     testPostTest( state ));
 }


 void act1072( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.addIkoParent( word_Person );
       state.lex.addIkoParent(morphPackLex( state ,  "person_from_" , state.root.getWordString()));
       state.lex.addSuffixes( wordSet_I );
       markDict( state ,  state.lex ,  atom_Has$Root , dict.makeAtom( "root" ),  true );
       addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg });
      }
 }


 void act1073( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       morphRoot( state ) &&
        ( ! ( patternCheck( state.root ,  pattern_I )) ) &&
       isRootOfCat( state.root ,  categorySet_Nn ) &&
        ( ! ( (state.root.getdict( feature_Guessed ) !=  null ) ||
            (state.root.getRoot() !=  null ) ||
            (state.root.getSuffixes() !=  null ) ||
            (state.root.getdict( feature_Compound$Of ) !=  null ) ||
           state.root.testIcode( category_N ,  atomSet_$Apostrophe$S$$_Etc )))) &&
     testPostTest( state ));
 }


 void act1074( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { markDict( state ,  state.lex ,  atom_Guessed ,  wordSet_T ,  false );
       addCatSense( state ,  category_N ,  state.root ,  new Value[] { atom_Number ,  atom_Pl ,  atom_Prob ,  word_60 });
      }
 }


 void act1075( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { markDict( state ,  state.lex ,  atom_Guessed ,  wordSet_T ,  false );
       addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Number ,  atom_Pl ,  atom_Prob ,  word_50 });
      }
 }


 void act1076( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg });
 }


 void act1077( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (morphRoot( state ) &&
       dict.isKnownWord( state.root ) &&
       isFormOfCat( state.root ,  categorySet_Adj )) &&
     testPostTest( state ));
 }


 void act1078( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.addIkoParent( state.root );
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] {});
      }
 }


 void act1080( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Icode ,  atom_$I });
 }


 void act1081( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_V$Adj )) &&
          catPostTest( state ))
      { state.lex.addSuffixes( wordSet_Tion );
       state.lex.addRoot( state.root );
       addCatSense( state ,  category_Nmc ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Mass ,  atom_True ,  atom_Icode ,  atom_$S });
      }
 }


 void act1082( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_V )) &&
          catPostTest( state ))
      { state.lex.addSuffixes( wordSet_Tion );
       state.lex.addRoot( state.root );
       addCatSense( state ,  category_Nmc ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Mass ,  atom_True ,  atom_Icode ,  atom_$S });
      }
 }


 void act1083( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_V )) &&
          catPostTest( state ))
      { state.lex.addSuffixes( wordSet_Ation );
       state.lex.addRoot( state.root );
       addCatSense( state ,  category_Nmc ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Mass ,  atom_True ,  atom_Icode ,  atom_$S });
      }
 }


 void act1084( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isCompoundCat( state.lex ,  category_N )) &&
          catPostTest( state ))
      addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Icode ,  atom_$S });
 }


 void act1085( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isCompoundCat( state.lex ,  category_V )) &&
          catPostTest( state ))
      addCatSense( state ,  category_V ,  state.lex ,  new Value[] { atom_Tns ,  atom_Present ,  atom_Agr ,  atom_Not3sg ,  atom_Untensed ,  atom_True ,  atom_Icode ,  atom_S$Ed });
 }


 void act1086( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Adj$V )) &&
          catPostTest( state ))
      { state.lex.addSuffixes( wordSet_Tion );
       state.lex.addRoot( state.root );
       addCatSense( state ,  category_Nmc ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Mass ,  atom_True ,  atom_Icode ,  atom_$S });
      }
 }


 void act1087( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Adj$V )) &&
          catPostTest( state ))
      { state.lex.addSuffixes( wordSet_Ation );
       state.lex.addRoot( state.root );
       addCatSense( state ,  category_Nmc ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Mass ,  atom_True ,  atom_Icode ,  atom_$S });
      }
 }


 void act1088( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_V )) &&
          catPostTest( state ))
      { state.lex.addSuffixes( wordSet_Ation );
       state.lex.addRoot(state.root.makeSenseName( category_V ));
       addCatSense( state ,  category_Nmc ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Mass ,  atom_True ,  atom_Icode ,  atom_$S });
      }
 }


 void act1089( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_V$Adj$Anyn )) &&
          catPostTest( state ))
      { state.lex.addSuffixes( wordSet_Ation );
       state.lex.addRoot( state.root );
       addCatSense( state ,  category_Nmc ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Mass ,  atom_True ,  atom_Icode ,  atom_$S });
      }
 }


 void act1090( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            mayBeCat( state ,  state.root ,  category_V )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_Nmc ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Mass ,  atom_True ,  atom_Suffix ,  word_Ication });
      }
 }


 void act1091( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            mayBeCat( state ,  state.root ,  category_V$Adj )) &&
          catPostTest( state ))
      { state.lex.addSuffixes( wordSet_Tion );
       state.lex.addRoot( state.root );
       addCatSense( state ,  category_Nmc ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Mass ,  atom_True ,  atom_Icode ,  atom_$S });
      }
 }


 void act1092( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            mayBeCat( state ,  state.root ,  category_V$Adj )) &&
          catPostTest( state ))
      { state.lex.addSuffixes( wordSet_Ation );
       state.lex.addRoot( state.root );
       addCatSense( state ,  category_Nmc ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Mass ,  atom_True ,  atom_Icode ,  atom_$S });
      }
 }


 void act1094( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Adj ) &&
            (state.root.testIcode( category_Adj ,  atomSet_Ier$Iest ) ||
               ( ! ( state.root.testIcode( category_Adj ,  atomSet_Ier$Iest$Er$Est_Etc )) ))) &&
          catPostTest( state ))
      addCatSense( state ,  category_Adj ,  state.root ,  new Value[] { atom_Superlative ,  atom_True });
 }


 void act1095( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Adv ) &&
            (state.root.testIcode( category_Adv ,  atomSet_Ier$Iest ) ||
               ( ! ( state.root.testIcode( category_Adv ,  atomSet_Ier$Iest$Er$Est_Etc$ )) ))) &&
          catPostTest( state ))
      addCatSense( state ,  category_Adv ,  state.root ,  new Value[] { atom_Superlative ,  atom_True });
 }


 void act1096( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_V )) &&
          catPostTest( state ))
      addCatSense( state ,  category_V ,  state.root ,  new Value[] { atom_Tns ,  atom_Present ,  atom_Agr ,  atom_2sg ,  atom_Archaic ,  atom_True ,  atom_Penalty ,  word_2 });
 }


 void act1097( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isFormOfCat( state.root ,  categorySet_Past )) &&
          catPostTest( state ))
      addCatSense( state ,  category_V , firstPastRoot( state.root ),  new Value[] { atom_Tns ,  atom_Past ,  atom_Agr ,  atom_2sg ,  atom_Archaic ,  atom_True ,  atom_Penalty ,  word_2 });
 }


 void act1098( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Adj )) &&
          catPostTest( state ))
      addCatSense( state ,  category_Adj ,  state.root ,  new Value[] { atom_Superlative ,  atom_True });
 }


 void act1099( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Adv )) &&
          catPostTest( state ))
      addCatSense( state ,  category_Adv ,  state.root ,  new Value[] { atom_Superlative ,  atom_True });
 }


 void act1100( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Adj ) &&
            (state.root.testIcode( category_Adj ,  atomSet_$Er$$Est$Er$Est ) ||
               ( ! ( state.root.testIcode( category_Adj ,  atomSet_Ier$Iest$Er$Est_Etc )) ))) &&
          catPostTest( state ))
      addCatSense( state ,  category_Adj ,  state.root ,  new Value[] { atom_Superlative ,  atom_True });
 }


 void act1101( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Adv ) &&
            (state.root.testIcode( category_Adv ,  atomSet_$Er$$Est$Er$Est ) ||
               ( ! ( state.root.testIcode( category_Adv ,  atomSet_Ier$Iest$Er$Est_Etc$ )) ))) &&
          catPostTest( state ))
      addCatSense( state ,  category_Adv ,  state.root ,  new Value[] { atom_Superlative ,  atom_True });
 }


 void act1102( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Adj ) &&
            (state.root.testIcode( category_Adj ,  atomSet_R$St ) ||
               ( ! ( state.root.testIcode( category_Adj ,  atomSet_Ier$Iest$Er$Est_Etc )) ))) &&
          catPostTest( state ))
      addCatSense( state ,  category_Adj ,  state.root ,  new Value[] { atom_Superlative ,  atom_True });
 }


 void act1103( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Adv ) &&
            (state.root.testIcode( category_Adv ,  atomSet_R$St ) ||
               ( ! ( state.root.testIcode( category_Adv ,  atomSet_Ier$Iest$Er$Est_Etc$ )) ))) &&
          catPostTest( state ))
      addCatSense( state ,  category_Adv ,  state.root ,  new Value[] { atom_Superlative ,  atom_True });
 }


 void act1104( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Adj ) &&
            (state.root.testIcode( category_Adj ,  atomSet_Er$Est ) ||
               ( ! ( state.root.testIcode( category_Adj ,  atomSet_Ier$Iest$Er$Est_Etc )) ))) &&
          catPostTest( state ))
      addCatSense( state ,  category_Adj ,  state.root ,  new Value[] { atom_Superlative ,  atom_True });
 }


 void act1105( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Adv ) &&
            (state.root.testIcode( category_Adv ,  atomSet_Er$Est ) ||
               ( ! ( state.root.testIcode( category_Adv ,  atomSet_Ier$Iest$Er$Est_Etc$ )) ))) &&
          catPostTest( state ))
      addCatSense( state ,  category_Adv ,  state.root ,  new Value[] { atom_Superlative ,  atom_True });
 }


 void act1106( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Adj ) &&
            (state.root.testIcode( category_Adj ,  atomSet_Ker$Kest$Er$Est ) ||
               ( ! ( state.root.testIcode( category_Adj ,  atomSet_Ier$Iest$Er$Est_Etc )) ))) &&
          catPostTest( state ))
      addCatSense( state ,  category_Adj ,  state.root ,  new Value[] { atom_Superlative ,  atom_True });
 }


 void act1107( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Adv ) &&
            (state.root.testIcode( category_Adv ,  atomSet_Ker$Kest$Er$Est ) ||
               ( ! ( state.root.testIcode( category_Adv ,  atomSet_Ier$Iest$Er$Est_Etc$ )) ))) &&
          catPostTest( state ))
      addCatSense( state ,  category_Adv ,  state.root ,  new Value[] { atom_Superlative ,  atom_True });
 }


 void act1108( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      addCatSense( state ,  category_Adj ,  state.root ,  new Value[] { atom_Superlative ,  atom_True });
 }


 void act1109( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      addCatSense( state ,  category_Adv ,  state.root ,  new Value[] { atom_Superlative ,  atom_True });
 }


 void act1110( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       morphRoot( state ) &&
       (isRootOfCat( state.root ,  categorySet_V ) ||
         isFormOfCat( state.root ,  categorySet_Past ))) &&
     testPostTest( state ));
 }


 void act1111( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            mayBeCat( state ,  state.root ,  category_Adj )) &&
          catPostTest( state ))
      addCatSense( state ,  category_Adj ,  state.root ,  new Value[] { atom_Superlative ,  atom_True });
 }


 void act1112( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            mayBeCat( state ,  state.root ,  category_Adv )) &&
          catPostTest( state ))
      addCatSense( state ,  category_Adv ,  state.root ,  new Value[] { atom_Superlative ,  atom_True });
 }


 void act1113( MorphState  state ) {
   if    (catPreTest( state ) &&
          polysyllabic( state.root ) &&
          catPostTest( state ))
      addCatSense( state ,  category_Adj ,  state.root ,  new Value[] { atom_Superlative ,  atom_True });
 }


 void act1114( MorphState  state ) {
   if    (catPreTest( state ) &&
          polysyllabic( state.root ) &&
          catPostTest( state ))
      addCatSense( state ,  category_Adv ,  state.root ,  new Value[] { atom_Superlative ,  atom_True });
 }


 void act1115( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Adv )) &&
          catPostTest( state ))
      addCatSense( state ,  category_Adj ,  state.root ,  new Value[] { atom_Superlative ,  atom_True });
 }


 void act1116( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       morphRoot( state ) &&
       dict.isKnownWord( state.root ) &&
       isRootOfCat( state.root ,  categorySet_Nn )) &&
     testPostTest( state ));
 }


 void act1117( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.addSuffixes( wordSet_Iform );
       state.lex.addRoot( state.root );
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] {});
      }
 }


 void act1119( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       needFinalE( state.root ) &&
       morphRoot( state ) &&
       dict.isKnownWord( state.root ) &&
       isRootOfCat( state.root ,  categorySet_Nn )) &&
     testPostTest( state ));
 }


 void act1122( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.addSuffixes( wordSet_Iform );
       state.lex.addPrefixes( new Word[] { state.root });
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] {});
      }
 }


 void act1123( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       morphRoot( state ) &&
       dict.isKnownWord( state.root ) &&
       isRootOfCat( state.root ,  categorySet_Adj )) &&
     testPostTest( state ));
 }


 void act1125( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       morphRoot( state ) &&
       dict.isKnownWord( state.root ) &&
       isFormOfCat( state.root ,  categorySet_Prefix ) &&
        ( ! ( LexiconUtil.isMembOfArray( state.root ,  wordSet_Anti$Bi$Centi$D_Etc )) )) &&
     testPostTest( state ));
 }


 void act1126( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       morphRoot( state ) &&
       dict.isKnownWord( state.root ) &&
       isRootOfCat( state.root ,  categorySet_Nn$V$Adj )) &&
     testPostTest( state ));
 }


 void act1127( MorphState  state ) {
   if    (catPreTest( state ) &&
          plausibleRoot( state.root ) &&
          catPostTest( state ))
      { state.lex.addSuffixes( wordSet_Iform );
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] {});
      }
 }


 void act1128( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (needFinalE( state.root ) &&
       morphRoot( state ) &&
       state.root.isKindOf( word_Bodypart )) &&
     testPostTest( state ));
 }


 void act1129( MorphState  state ) {
   if    (catPreTest( state ) &&
          (syllabic( state.root ) &&
            morphRoot( state ) &&
            isFormOfCat( state.root ,  categorySet_Nn )) &&
          catPostTest( state ))
      { state.lex.addIioParent( word_Condition );
       state.lex.addSuffixes( wordSet_Itis );
       state.lex.addRoot( state.root );
       addCatSense( state ,  category_Nm ,  state.lex ,  new Value[] { atom_Mass$Pure ,  atom_True ,  atom_Mass ,  atom_True ,  atom_Icode ,  atom_$Des });
      }
 }


 void act1130( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (morphRoot( state ) &&
       state.root.isKindOf( word_Bodypart )) &&
     testPostTest( state ));
 }


 void act1135( MorphState  state ) {
   if    (catPreTest( state ) &&
          (syllabic( state.root ) &&
            morphRoot( state ) &&
            isFormOfCat( state.root ,  categorySet_Adj )) &&
          catPostTest( state ))
      { state.lex.addIioParent( word_Condition );
       state.lex.addSuffixes( wordSet_Itis );
       state.lex.addRoot( state.root );
       addCatSense( state ,  category_Nm ,  state.lex ,  new Value[] { atom_Mass$Pure ,  atom_True ,  atom_Mass ,  atom_True ,  atom_Icode ,  atom_$Des });
      }
 }


 void act1136( MorphState  state ) {
   if    (catPreTest( state ) &&
          (syllabic( state.root ) &&
            morphRoot( state ) &&
            isFormOfCat( state.root ,  categorySet_Prefix )) &&
          catPostTest( state ))
      { state.lex.addIioParent( word_Condition );
       state.lex.addSuffixes( wordSet_Itis );
       state.lex.addPrefixes( new Word[] { state.root });
       addCatSense( state ,  category_Nm ,  state.lex ,  new Value[] { atom_Mass$Pure ,  atom_True ,  atom_Mass ,  atom_True ,  atom_Icode ,  atom_$Des });
      }
 }


 void act1137( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
      sp_wordListCheckFlag  &&
     testPostTest( state ));
 }


 void act1138( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
             (wordListCheck( state.lex ,  category_N ) !=  null )) &&
          catPostTest( state ))
      addCatSense( state ,  category_N ,  state.lex , makeNoun( state.lex ));
 }


 void act1139( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
             (wordListCheck( state.lex ,  category_V ) !=  null )) &&
          catPostTest( state ))
      addCatSense( state ,  category_V ,  state.lex , makeVerb( state.lex ));
 }


 void act1140( MorphState  state ) {
   if    (catPreTest( state ) &&
           sp_guessVerbFlag  &&
          catPostTest( state ))
      { addPenalty( state.lex ,  category_V ,  1 );
       addCatSense( state ,  category_V ,  state.lex ,  new Value[] { atom_Tns ,  atom_Present ,  atom_Agr ,  atom_Not3sg ,  atom_Untensed ,  atom_True ,  atom_Icode ,  atom_S$D });
      }
 }


 void act1141( MorphState  state ) {
   if    (catPreTest( state ) &&
           sp_guessVerbFlag  &&
          catPostTest( state ))
      { addPenalty( state.lex ,  category_V ,  1 );
       addCatSense( state ,  category_V ,  state.lex ,  new Value[] { atom_Tns ,  atom_Present ,  atom_Agr ,  atom_Not3sg ,  atom_Untensed ,  atom_True ,  atom_Icode ,  atom_Es$Ed });
      }
 }


 void act1142( MorphState  state ) {
   if    (catPreTest( state ) &&
           sp_guessVerbFlag  &&
          catPostTest( state ))
      { addPenalty( state.lex ,  category_V ,  1 );
       addCatSense( state ,  category_V ,  state.lex ,  new Value[] { atom_Tns ,  atom_Present ,  atom_Agr ,  atom_Not3sg ,  atom_Untensed ,  atom_True ,  atom_Icode ,  atom_S$Ed });
      }
 }


 void act1143( MorphState  state ) {
   if    (catPreTest( state ) &&
           sp_guessVerbFlag  &&
          catPostTest( state ))
      { addPenalty( state.lex ,  category_V ,  1 );
       addCatSense( state ,  category_V ,  state.lex ,  new Value[] { atom_Tns ,  atom_Present ,  atom_Agr ,  atom_Not3sg ,  atom_Untensed ,  atom_True ,  atom_Icode ,  atom_S$$Ed });
      }
 }


 void act1144( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] { atom_Scalar ,  atom_True ,  atom_Icode ,  atom_More$Most });
 }


 void act1145( MorphState  state ) {
   if    (catPreTest( state ) &&
           sp_guessVerbFlag  &&
          catPostTest( state ))
      { addPenalty( state.lex ,  category_V ,  1 );
       addCatSense( state ,  category_V ,  state.lex ,  new Value[] { atom_Tns ,  atom_Present ,  atom_Agr ,  atom_Not3sg ,  atom_Untensed ,  atom_True ,  atom_Icode ,  atom_S$Ked });
      }
 }


 void act1146( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { markDict( state ,  state.lex ,  atom_Guessed ,  wordSet_T ,  false );
       addCatSense( state ,  category_Npr ,  state.lex ,  new Value[] {});
      }
 }


 void act1148( MorphState  state ) {
   if    (catPreTest( state ) &&
          ( sp_recognizeInitialPlusLastnameFlag  &&
            morphRoot( state ) &&
            dict.isKnownWord( state.root ) &&
            isFormOfCat( state.root ,  categorySet_Lastname ) &&
             ( state.root.getWordString().length()  >  2 )) &&
          catPostTest( state ))
      addCatSense( state ,  category_Name ,  state.lex , initialPlusLastnameVal( state.lex ,  state.root ));
 }


 void act1167( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       morphRoot( state ) &&
        ( ! ( state.root.isHyphenated()) ) &&
       notSuffix( state.root ,  wordSet_An$Ism$Ist$Ity$_Etc )) &&
     testPostTest( state ));
 }


 void act1169( MorphState  state ) {
   if    (catPreTest( state ) &&
          (plausibleRoot( state.root ) &&
            morphRoot( state ) &&
             ( ! ( isFormOfCat( state.root ,  categorySet_V )) ) &&
            state.root.noSuffix() &&
            isFormOfCat( state.root ,  categorySet_Adj$Anyn )) &&
          catPostTest( state ))
      addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] { atom_From ,  state.root.makeSenseNamesIfNeeded(categorySet_Adj$N)[0] ,  atom_Prefix ,  state.prefix });
 }


 void act1172( MorphState  state ) {
   if    (catPreTest( state ) &&
          (plausibleRoot( state.root ) &&
            morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Adj )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root.makeSenseNamesIfNeeded(categorySet_Adj)[0] );
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] { atom_Prefix ,  state.prefix });
      }
 }


 void act1173( MorphState  state ) {
   if    (catPreTest( state ) &&
          (plausibleRoot( state.root ) &&
            morphRoot( state ) &&
            isFormOfCat( state.root ,  categorySet_Nn )) &&
          catPostTest( state ))
      {  Category  tempCategory1017 ;
       if    (isFormOfCat( state.root ,  categorySet_Nm ))
           tempCategory1017  =  category_Nm ;

       else   tempCategory1017  =  category_N ;
       addCatSense( state ,  category_N ,  state.lex , formsWithPrefix( state.root ,  tempCategory1017 ,  state.prefix ));
      }
 }


 void act1175( MorphState  state ) {
   if    (catPreTest( state ) &&
          (plausibleRoot( state.root ) &&
            morphRoot( state ) &&
            isFormOfCat( state.root ,  categorySet_Prespart )) &&
          catPostTest( state ))
      addCatSense( state ,  category_Nm ,  state.lex ,  new Value[] { atom_Mass$Pure ,  atom_True ,  atom_Mass ,  atom_True ,  atom_Icode ,  atom_$S });
 }


 void act1176( MorphState  state ) {
   if    (catPreTest( state ) &&
          (plausibleRoot( state.root ) &&
            morphRoot( state ) &&
            isFormOfCat( state.root ,  categorySet_Prespart$Pastpa_Etc )) &&
          catPostTest( state ))
      addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] {});
 }


 void act1177( MorphState  state ) {
   if    (catPreTest( state ) &&
          (plausibleRoot( state.root ) &&
            morphRoot( state ) &&
            isFormOfCat( state.root ,  categorySet_V )) &&
          catPostTest( state ))
      { state.lex.addPrefixes( new Word[] { state.prefix });
       state.lex.addRoots(state.root.makeSenseNamesIfNeeded( categorySet_V ));
       addCatSense( state ,  category_V ,  state.lex , formsWithPrefix( state.root ,  category_V ,  state.prefix ));
      }
 }


 void act1178( MorphState  state ) {
   if    (catPreTest( state ) &&
          (plausibleRoot( state.root ) &&
            morphRoot( state ) &&
             ( ! ( isFormOfCat( state.root ,  categorySet_Prespart )) ) &&
            isFormOfCat( state.root ,  categorySet_Nn )) &&
          catPostTest( state ))
      {  Category  tempCategory1019 ;
       if    (isFormOfCat( state.root ,  categorySet_Nm ))
           tempCategory1019  =  category_Nm ;

       else   tempCategory1019  =  category_N ;
       addCatSense( state ,  category_N ,  state.lex , formsWithPrefix( state.root ,  tempCategory1019 ,  state.prefix ));
      }
 }


 void act1179( MorphState  state ) {
   if    (catPreTest( state ) &&
          (plausibleRoot( state.root ) &&
            morphRoot( state ) &&
             ( ! ( isFormOfCat( state.root ,  categorySet_Prespart$Pastpa_Etc )) ) &&
            isRootOfCat( state.root ,  categorySet_Adj )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root.makeSenseNamesIfNeeded(categorySet_Adj)[0] );
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] { atom_Prefix ,  state.prefix });
      }
 }


 void act1180( MorphState  state ) {
   if    (catPreTest( state ) &&
          (plausibleRoot( state.root ) &&
            morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Adv )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root.makeSenseNamesIfNeeded(categorySet_Adv)[0] );
       addCatSense( state ,  category_Adv ,  state.lex ,  new Value[] { atom_Prefix ,  state.prefix });
      }
 }


 void act1182( MorphState  state ) {
   if    (catPreTest( state ) &&
          (plausibleRoot( state.root ) &&
            morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Adj$Anyn )) &&
          catPostTest( state ))
      addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] { atom_From ,  state.root.makeSenseNamesIfNeeded(categorySet_Adj$N)[0] ,  atom_Prefix ,  state.prefix });
 }


 void act1184( MorphState  state ) {
   if    (catPreTest( state ) &&
          (plausibleRoot( state.root ) &&
            morphRoot( state ) &&
            isFormOfCat( state.root ,  categorySet_Adj$Anyn )) &&
          catPostTest( state ))
      addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] { atom_From ,  state.root.makeSenseNamesIfNeeded(categorySet_Adj$N)[0] ,  atom_Prefix ,  state.prefix });
 }


 void act1186( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       morphRoot( state ) &&
        ( ! ( state.root.isHyphenated()) ) &&
       notSuffix( state.root ,  wordSet_Ism$Ist$Ity$Tio_Etc )) &&
     testPostTest( state ));
 }


 void act1190( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     ( ( state.prefix  !=  null ) &&
       plausibleRoot( state.root )) &&
     testPostTest( state ));
 }


 void act1191( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isFormOfCat( state.root ,  categorySet_Prespart )) &&
          catPostTest( state ))
      addCatSense( state ,  category_Nm ,  state.lex ,  new Value[] { atom_Mass$Pure ,  atom_True ,  atom_Mass ,  atom_True ,  atom_Icode ,  atom_$S });
 }


 void act1192( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isFormOfCat( state.root ,  categorySet_Prespart$Pastpa_Etc )) &&
          catPostTest( state ))
      addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] {});
 }


 void act1193( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isFormOfCat( state.root ,  categorySet_V )) &&
          catPostTest( state ))
      { state.lex.addPrefixes( new Word[] { state.prefix });
       state.lex.addRoots(state.root.makeSenseNamesIfNeeded( categorySet_V ));
       addCatSense( state ,  category_V ,  state.lex , formsWithPrefix( state.root ,  category_V ,  state.prefix ));
      }
 }


 void act1194( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
             ( ! ( isFormOfCat( state.root ,  categorySet_Prespart )) ) &&
            isFormOfCat( state.root ,  categorySet_Nn )) &&
          catPostTest( state ))
      {  Category  tempCategory1021 ;
       if    (isFormOfCat( state.root ,  categorySet_Nm ))
           tempCategory1021  =  category_Nm ;

       else   tempCategory1021  =  category_N ;
       addCatSense( state ,  category_N ,  state.lex , formsWithPrefix( state.root ,  tempCategory1021 ,  state.prefix ));
      }
 }


 void act1195( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
             ( ! ( isFormOfCat( state.root ,  categorySet_Prespart$Pastpa_Etc )) ) &&
            isRootOfCat( state.root ,  categorySet_Adj$Nn )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root.makeSenseNamesIfNeeded(categorySet_Adj$N)[0] );
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] { atom_Prefix ,  state.prefix });
      }
 }


 void act1196( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Adv )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root.makeSenseNamesIfNeeded(categorySet_Adv)[0] );
       addCatSense( state ,  category_Adv ,  state.lex ,  new Value[] { atom_Prefix ,  state.prefix });
      }
 }


 void act1197( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       morphRoot( state ) &&
        ( ! ( state.root.isHyphenated()) ) &&
       dict.isKnownWord( state.root ) &&
       isRootOfCat( state.root ,  categorySet_Vi ) &&
       notSuffix( state.root ,  wordSet_An$Ism$Ist$Ity$_Etc ) &&
       state.root.noPrefix() &&
        ( ! ( quickcheck( state.root ,  categorySet_Special$Qword$D_Etc )) ) &&
        ( ! (isRootOfCat( state.root ,  categorySet_Adj$Anyn ) &&
           isPenaltyFormOfCat( state.root ,  categorySet_V ))) &&
        (state.root.getdict( feature_Abbrev ) ==  null )) &&
     testPostTest( state ));
 }


 void act1199( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.addIkoParent(getInflectedForm( state.root ,  atom_Prespart ));
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] { atom_From ,  state.root.makeSenseNamesIfNeeded(categorySet_Vi)[0] ,  atom_Prefix ,  state.prefix });
      }
 }


 void act1200( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.addIkoParent(getInflectedForm( state.root ,  atom_Prespart ));
       addCatSense( state ,  category_Adv ,  state.lex ,  new Value[] { atom_From ,  state.root.makeSenseNamesIfNeeded(categorySet_Vi)[0] ,  atom_Prefix ,  state.prefix });
      }
 }


 void act1201( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      addCatSense( state ,  category_V ,  state.lex , formsWithPrefix( state.root ,  category_Vi ,  state.prefix ));
 }


 void act1202( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       morphRoot( state ) &&
        ( ! ( state.root.isHyphenated()) ) &&
       dict.isKnownWord( state.root ) &&
       isFormOfCat( state.root ,  categorySet_Vi ) &&
       isFormOfCat( state.root ,  categorySet_Prespart$Pastpa_Etc ) &&
        (state.root.getdict( feature_Abbrev ) ==  null )) &&
     testPostTest( state ));
 }


 void act1203( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.addIkoParent( state.root.makeSenseNamesIfNeeded(categorySet_Adj)[0] );
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] { atom_From ,  state.root.makeSenseNamesIfNeeded(categorySet_V)[0] ,  atom_Prefix ,  state.prefix });
      }
 }


 void act1204( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.addIkoParent( state.root.makeSenseNamesIfNeeded(categorySet_Adv)[0] );
       addCatSense( state ,  category_Adv ,  state.lex ,  new Value[] { atom_From ,  state.root.makeSenseNamesIfNeeded(categorySet_V)[0] ,  atom_Prefix ,  state.prefix });
      }
 }


 void act1205( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      addCatSense( state ,  category_V ,  state.lex , formsWithPrefix( state.root ,  category_V ,  state.prefix ));
 }


 void act1206( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       morphRoot( state ) &&
        ( ! ( state.root.isHyphenated()) ) &&
       dict.isKnownWord( state.root ) &&
       isRootOfCat( state.root ,  categorySet_Nn ) &&
       notSuffix( state.root ,  wordSet_An$Ism$Ist$Ity$_Etc ) &&
       state.root.noPrefix() &&
        ( ! ( polysyllabic( state.root )) ) &&
        ( ! ( quickcheck( state.root ,  categorySet_Special$Qword$D_Etc$ )) ) &&
        (state.root.getdict( feature_Abbrev ) ==  null )) &&
     testPostTest( state ));
 }


 void act1207( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.addIkoParent(dict.makeStructuredConcept( category_Adj , dict.makeList( new Value[] { word_Mod ,  state.root })));
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] { atom_From ,  state.root.makeSenseNamesIfNeeded(categorySet_N)[0] ,  atom_Prefix ,  state.prefix });
      }
 }


 void act1208( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.addIkoParent(dict.makeStructuredConcept( category_Adv , dict.makeList( new Value[] { word_Mod ,  state.root })));
       addCatSense( state ,  category_Adv ,  state.lex ,  new Value[] { atom_From ,  state.root.makeSenseNamesIfNeeded(categorySet_N)[0] ,  atom_Prefix ,  state.prefix });
      }
 }


 void act1209( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       morphRoot( state ) &&
        ( ! ( state.root.isHyphenated()) ) &&
       state.root.noPrefix() &&
       (dict.isKnownWord( state.root ) ||
         state.root.hasSuffix( wordSet_Ic$Atic$Al$Ar$O_Etc )) &&
        ( ! ( quickcheck( state.root ,  categorySet_Special$Qword$D_Etc )) ) &&
        (state.root.getdict( feature_Abbrev ) ==  null )) &&
     testPostTest( state ));
 }


 void act1210( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Adj ) &&
             ( ! ( isFormOfCat( state.root ,  categorySet_Prespart$Pastpa_Etc )) ) &&
             ( ! (isRootOfCat( state.root ,  categorySet_Anyn ) &&
                isPenaltyFormOfCat( state.root ,  categorySet_Adj )))) &&
          catPostTest( state ))
      { state.lex.addIkoParent(morphPackLex( state ,  "not_" , state.root.getWordString()));
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] { atom_From ,  state.root.makeSenseNamesIfNeeded(categorySet_Adj)[0] ,  atom_Prefix ,  state.prefix });
      }
 }


 void act1212( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       morphRoot( state ) &&
        ( ! ( state.root.isHyphenated()) ) &&
       (dict.isKnownWord( state.root ) ||
         state.root.hasSuffix( wordSet_Ic$Atic$Al$Ar$O_Etc )) &&
        ( ! ( quickcheck( state.root ,  categorySet_Special$Qword$D_Etc )) ) &&
        (state.root.getdict( feature_Abbrev ) ==  null )) &&
     testPostTest( state ));
 }


 void act1214( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Adj )) &&
          catPostTest( state ))
      { state.lex.addIkoParent(morphPackLex( state ,  "not_" , state.root.getWordString()));
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] { atom_From ,  state.root.makeSenseNamesIfNeeded(categorySet_Adj)[0] ,  atom_Prefix ,  state.prefix });
      }
 }


 void act1215( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Nn ) &&
             ( ! ( isFormOfCat( state.root ,  categorySet_Nm )) ) &&
            (dict.isKnownWord( state.root ) ||
              state.root.hasSuffix( wordSet_Ic$Atic ))) &&
          catPostTest( state ))
      addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_From ,  state.root.makeSenseNamesIfNeeded(categorySet_N)[0] ,  atom_Prefix ,  state.prefix });
 }


 void act1216( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Nm ) &&
             ( ! ( isFormOfCat( state.root ,  categorySet_Nc )) ) &&
            (dict.isKnownWord( state.root ) ||
              state.root.hasSuffix( wordSet_Ic$Atic ))) &&
          catPostTest( state ))
      addCatSense( state ,  category_Nm ,  state.lex ,  new Value[] { atom_From ,  state.root.makeSenseNamesIfNeeded(categorySet_Nm)[0] ,  atom_Prefix ,  state.prefix });
 }


 void act1217( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Nm ) &&
            isRootOfCat( state.root ,  categorySet_Nc ) &&
            (dict.isKnownWord( state.root ) ||
              state.root.hasSuffix( wordSet_Ic$Atic ))) &&
          catPostTest( state ))
      addCatSense( state ,  category_Nmc ,  state.lex ,  new Value[] { atom_From ,  state.root.makeSenseNamesIfNeeded(categorySet_N)[0] ,  atom_Prefix ,  state.prefix });
 }


 void act1219( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Adj )) &&
          catPostTest( state ))
      { state.lex.addIkoParent(morphPackLex( state ,  "away_from_" , state.root.getWordString()));
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] { atom_From ,  state.root.makeSenseNamesIfNeeded(categorySet_Adj)[0] ,  atom_Prefix ,  state.prefix });
      }
 }


 void act1220( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Unit )) &&
          catPostTest( state ))
      { addUnitInfo( state.lex ,  state.root );
       addCatSense( state ,  category_Unit ,  state.lex , formsWithPrefix( state.root ,  category_Unit ,  state.prefix ));
      }
 }


 void act1221( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       morphRoot( state ) &&
        ( ! ( state.root.isHyphenated()) ) &&
       notSuffix( state.root ,  wordSet_An$Ism$Ist$Ity$_Etc ) &&
       state.root.noPrefix()) &&
     testPostTest( state ));
 }


 void act1223( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isFormOfCat( state.root ,  categorySet_V )) &&
          catPostTest( state ))
      addCatSense( state ,  category_V ,  state.lex , formsWithPrefix( state.root ,  category_V ,  state.prefix ,  null , state.lex.getWordString().substring( 0 ,  2 )));
 }


 void act1224( MorphState  state ) {
   if    (catPreTest( state ) &&
          (plausibleRoot( state.root ) &&
            morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Adj ) &&
            (state.root.hasSuffix( wordSet_Ic$Atic$Al$Ar$O_Etc ) ||
              patternCheck( state.root ,  pattern_I$C ) ||
              patternCheck( state.root ,  pattern_A$$L_R$ ) ||
              patternCheck( state.root ,  pattern_O$S$E ) ||
              patternCheck( state.root ,  pattern_O$U$S )) &&
             ( ! ( isFormOfCat( state.root ,  categorySet_Prespart$Pastpa_Etc )) ) &&
             ( ! ( quickcheck( state.root ,  categorySet_Special$Qword$D_Etc )) ) &&
             (state.root.getdict( feature_Abbrev ) ==  null )) &&
          catPostTest( state ))
      addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] { atom_From ,  state.root.makeSenseNamesIfNeeded(categorySet_Adj)[0] ,  atom_Prefix ,  state.prefix });
 }


 void act1225( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Vi ) &&
             ( ! ( isFormOfCat( state.root ,  categorySet_Prespart$Pastpa_Etc )) ) &&
             ( ! ( quickcheck( state.root ,  categorySet_Special$Qword$D_Etc$ )) ) &&
             ( ! ( isPenaltyFormOfCat( state.root ,  categorySet_V )) ) &&
             (state.root.getdict( feature_Abbrev ) ==  null )) &&
          catPostTest( state ))
      { state.lex.addIkoParent(getInflectedForm( state.root ,  atom_Prespart ));
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] { atom_From ,  state.root.makeSenseNamesIfNeeded(categorySet_Vi)[0] ,  atom_Prefix ,  state.prefix });
      }
 }


 void act1226( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       morphRoot( state ) &&
        ( ! ( state.root.isHyphenated()) ) &&
       dict.isKnownWord( state.root ) &&
       isFormOfCat( state.root ,  categorySet_V ) &&
       notSuffix( state.root ,  wordSet_Ism$Ist$Ity$Tio_Etc ) &&
       state.root.noPrefix() &&
        (state.root.getdict( feature_Guessed ) ==  null ) &&
        ( ! ( LexiconUtil.intersectp(state.root.getRoots( category_V ),  wordSet_Ache )) )) &&
     testPostTest( state ));
 }


 void act1228( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.addPrefixes( new Word[] { state.prefix });
       state.lex.addRoots(state.root.makeSenseNamesIfNeeded( categorySet_V ));
       addCatSense( state ,  category_V ,  state.lex , formsWithPrefix( state.root ,  category_V ,  state.prefix ));
      }
 }


 void act1229( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       morphRoot( state ) &&
        ( ! ( state.root.isHyphenated()) ) &&
       dict.isKnownWord( state.root ) &&
        ( ! ( isFormOfCat( state.root ,  categorySet_V )) ) &&
       isRootOfCat( state.root ,  categorySet_Nn ) &&
       state.root.noPrefix() &&
       notSuffix( state.root ,  wordSet_Ism$Ist$Ity$Tio_Etc ) &&
        (state.root.getdict( feature_Guessed ) ==  null )) &&
     testPostTest( state ));
 }


 void act1230( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Adj$Anyn )) &&
          catPostTest( state ))
      addCatSense( state ,  category_V ,  state.lex ,  new Value[] { atom_From ,  state.root.makeSenseNamesIfNeeded(categorySet_Adj$N)[0] ,  atom_Prefix ,  state.prefix });
 }


 void act1231( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       morphRoot( state ) &&
        ( ! ( state.root.isHyphenated()) ) &&
       dict.isKnownWord( state.root ) &&
        (state.root.getdict( feature_Guessed ) ==  null )) &&
     testPostTest( state ));
 }


 void act1233( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       morphRoot( state ) &&
        ( ! ( state.root.isHyphenated()) ) &&
       dict.isKnownWord( state.root ) &&
        ( ! ( isFormOfCat( state.root ,  categorySet_Prep )) ) &&
       state.root.noPrefix() &&
       ( ( ! ( suffixedVerbP( state.root )) ) ||
         isRootOfCat( state.root ,  categorySet_Adj )) &&
        (state.root.getdict( feature_Guessed ) ==  null )) &&
     testPostTest( state ));
 }


 void act1235( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Adj$Nn$Suffix )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root.makeSenseNamesIfNeeded(categorySet_Adj$N$Suffix)[0] );
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] { atom_Prefix ,  state.prefix });
      }
 }


 void act1236( MorphState  state ) {
   if    (catPreTest( state ) &&
          (plausibleRoot( state.root ) &&
            morphRoot( state ) &&
            isFormOfCat( state.root ,  categorySet_Nn )) &&
          catPostTest( state ))
      addCatSense( state ,  category_N ,  state.lex , formsWithPrefix( state.root ,  category_N ,  state.prefix ));
 }


 void act1238( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isFormOfCat( state.root ,  categorySet_Prespart$Pastpa_Etc$ )) &&
          catPostTest( state ))
      addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] {});
 }


 void act1239( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isFormOfCat( state.root ,  categorySet_Prespart$Pastpa_Etc )) &&
          catPostTest( state ))
      addCatSense( state ,  category_Adv ,  state.lex ,  new Value[] {});
 }


 void act1240( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isFormOfCat( state.root ,  categorySet_V )) &&
          catPostTest( state ))
      { state.lex.addIkoParent(dict.makeStructuredConcept( category_V , dict.makeList( new Value[] { state.root , dict.makeList( new Value[] { word_Modified_By ,  state.prefix })})));
       state.lex.addPrefixes( new Word[] { state.prefix });
       state.lex.addRoots(state.root.makeSenseNamesIfNeeded( categorySet_V ));
       addCatSense( state ,  category_V ,  state.lex , formsWithPrefix( state.root ,  category_V ,  state.prefix ));
      }
 }


 void act1241( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isFormOfCat( state.root ,  categorySet_Nn ) &&
             ( ! ( isFormOfCat( state.root ,  categorySet_Prespart )) )) &&
          catPostTest( state ))
      {  Word[]  tempWordSet1023 ;
       if    (isKnownKindOf( state.root ,  word_Fish_Bodypart ))
           tempWordSet1023  =  wordSet_Fish ;

       else  if   (isKnownKindOf( state.root ,  word_Bird_Bodypart ))
           tempWordSet1023  =  wordSet_Bird ;

       else  if   (isKnownKindOf( state.root ,  word_Bodypart ))
          if    (isFormOfCat( state.root ,  categorySet_Suffix ))
              tempWordSet1023  =  wordSet_Bodypart ;

          else   tempWordSet1023  =  wordSet_Animal ;

       else   tempWordSet1023  =  new Word[] {dict.makeStructuredConcept( category_N , dict.makeList( new Value[] { state.root , dict.makeList( new Value[] { word_Modified_By ,  state.prefix })}))};
       state.lex.addIkoParents( tempWordSet1023 );
       state.lex.addPrefixes( new Word[] { state.prefix });
       state.lex.addRoots(state.root.makeSenseNamesIfNeeded( categorySet_N ));
       addCatSense( state ,  category_N ,  state.lex , formsWithPrefix( state.root ,  category_N ,  state.prefix ));
      }
 }


 void act1242( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       morphRoot( state ) &&
        ( ! ( state.root.isHyphenated()) ) &&
       (isFormOfCat( state.root ,  categorySet_Prespart$Pastpa_Etc ) ||
         (isFormOfCat( state.root ,  categorySet_Anyn ) &&
           isKnownKindOf( state.root ,  word_Bodypart )))) &&
     testPostTest( state ));
 }


 void act1244( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { if   (isKnownKindOf( state.root ,  word_Bodypart ))
          state.lex.addIkoParent(morphPackLex( state ,  "with_bare_" , state.root.getWordString()));
       if    (isFormOfCat( state.root ,  categorySet_Pastpart ))
          {  Word[]  tempWordSet1025  = state.root.getInflectionRoots();
           if     ( tempWordSet1025  !=  null )
              for ( int  i  =  0 ;  i  <  tempWordSet1025.length ;  i++ ) {
                  Word  x  =  tempWordSet1025[i] ;
                 { if    (isKnownKindOf( x ,  word_Bodypart ))
                      state.lex.addIkoParent(morphPackLex( state ,  "with_bare_" , x.getWordString()));
                 }
              }
          }
       state.lex.addPrefixes( new Word[] { state.prefix });
       state.lex.addRoot( state.root );
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] {});
      }
 }


 void act1250( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       morphRoot( state ) &&
        ( ! ( state.root.isHyphenated()) ) &&
        ( ! ( isFormOfCat( state.root ,  categorySet_Prespart )) )) &&
     testPostTest( state ));
 }


 void act1252( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       morphRoot( state ) &&
        ( ! ( state.root.isHyphenated()) ) &&
       isFormOfCat( state.root ,  categorySet_Anyn$V$Adj ) &&
        ( ! ( state.root.hasPrefix( wordSet_A$Co$De$In$No$U_Etc )) )) &&
     testPostTest( state ));
 }


 void act1255( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       morphRoot( state ) &&
        ( ! ( state.root.isHyphenated()) ) &&
        ( ! ( isFormOfCat( state.root ,  categorySet_V )) ) &&
       state.root.noSuffix()) &&
     testPostTest( state ));
 }


 void act1257( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Anyn )) &&
          catPostTest( state ))
      addCatSense( state ,  category_V ,  state.lex ,  new Value[] { atom_From ,  state.root.makeSenseNamesIfNeeded(categorySet_N)[0] ,  atom_Prefix ,  state.prefix ,  atom_Tns ,  atom_Present ,  atom_Agr ,  atom_Not3sg ,  atom_Untensed ,  atom_True });
 }


 void act1258( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     ( ( state.prefix  !=  null ) &&
       plausibleRoot( state.root ) &&
       morphRoot( state ) &&
       isFormOfCat( state.root ,  categorySet_V )) &&
     testPostTest( state ));
 }


 void act1260( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isFormOfCat( state.root ,  categorySet_Anyn )) &&
          catPostTest( state ))
      addCatSense( state ,  category_N ,  state.lex , formsWithPrefix( state.root ,  category_N ,  state.prefix ));
 }


 void act1262( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Nn ) &&
             ( ! ( isFormOfCat( state.root ,  categorySet_Prespart )) )) &&
          catPostTest( state ))
      { state.lex.addIkoParent(dict.makeStructuredConcept( category_V , dict.makeList( new Value[] { word_Separate , dict.makeList( new Value[] { state.root }),  word_From })));
       state.lex.addRoot( state.root.makeSenseNamesIfNeeded(categorySet_N)[0] );
       addCatSense( state ,  category_V ,  state.lex ,  new Value[] { atom_Tns ,  atom_Present ,  atom_Agr ,  atom_Not3sg ,  atom_Prefix ,  state.prefix });
      }
 }


 void act1263( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       morphRoot( state ) &&
        ( ! ( state.root.isHyphenated()) ) &&
       (dict.isKnownWord( state.root ) ||
         state.root.hasSuffix( wordSet_Ic$Atic$Al$Ar$O_Etc ))) &&
     testPostTest( state ));
 }


 void act1265( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       morphRoot( state ) &&
        ( ! ( state.root.isHyphenated()) ) &&
       state.root.noSuffix()) &&
     testPostTest( state ));
 }


 void act1268( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       morphRoot( state ) &&
        ( ! ( state.root.isHyphenated()) ) &&
       (state.root.hasSuffix( wordSet_E$Ve$En ) ||
         (state.root.noSuffix() &&
           state.root.noPrefix()))) &&
     testPostTest( state ));
 }


 void act1270( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Nn )) &&
          catPostTest( state ))
      { state.lex.addIkoParent( word_$Adv$Down );
       state.lex.addRoot( state.root );
       addCatSense( state ,  category_Adv ,  state.lex ,  new Value[] { atom_Prefix ,  state.prefix });
      }
 }


 void act1271( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       morphRoot( state ) &&
        ( ! ( state.root.isHyphenated()) ) &&
       isFormOfCat( state.root ,  categorySet_V ) &&
       state.root.noSuffix() &&
        ( ! ( suffixedVerbP( state.root )) )) &&
     testPostTest( state ));
 }


 void act1273( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isFormOfCat( state.root ,  categorySet_Pastpart$Prespa_Etc )) &&
          catPostTest( state ))
      addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] {});
 }


 void act1274( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.addIkoParents(state.root.makeSenseNamesIfNeeded( categorySet_V ));
       addCatSense( state ,  category_V ,  state.lex , formsWithPrefix( state.root ,  category_V ,  word_En ,  null ));
      }
 }


 void act1275( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Adj$Nn ) &&
             ( ! ( isFormOfCat( state.root ,  categorySet_V )) ) &&
            state.root.noSuffix() &&
            state.root.noPrefix()) &&
          catPostTest( state ))
      { state.lex.addIkoParent( word_$Vt$Change );
       addCatSense( state ,  category_V ,  state.lex ,  new Value[] { atom_From ,  state.root.makeSenseNamesIfNeeded(categorySet_Adj$N)[0] ,  atom_Prefix ,  state.prefix });
      }
 }


 void act1277( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.addIkoParent( state.root );
       addCatSense( state ,  category_V ,  state.lex , formsWithPrefix( state.root ,  category_V ,  word_En ,  null ,  "EM" ));
      }
 }


 void act1278( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Adj$Nn ) &&
             ( ! ( isFormOfCat( state.root ,  categorySet_V )) ) &&
            state.root.noSuffix() &&
            state.root.noPrefix()) &&
          catPostTest( state ))
      { state.lex.addIkoParent( word_$Vt$Change );
       addCatSense( state ,  category_V ,  state.lex ,  new Value[] { atom_From ,  state.root ,  atom_Prefix ,  state.prefix });
      }
 }


 void act1279( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     ( ( state.lex.getWordString().length()  >  4 ) &&
       patternCheck( state.lex ,  pattern_E$N )) &&
     testPostTest( state ));
 }


 void act1281( MorphState  state ) {
   if    (catPreTest( state ) &&
          (plausibleRoot( state.root ) &&
            morphRoot( state ) &&
             ( ! ( polysyllabic( state.root )) ) &&
            isRootOfCat( state.root ,  categorySet_Adj )) &&
          catPostTest( state ))
      { state.lex.addIkoParent(morphPackLex( state ,  "make_" , state.root.getWordString()));
       state.lex.addIkoParent( word_$Vt$Change );
       state.lex.addRoots(state.root.makeSenseNamesIfNeeded( categorySet_Adj ));
       state.lex.addPrefixes( wordSet_En );
       state.lex.addSuffixes( wordSet_En );
       addCatSense( state ,  category_V ,  state.lex ,  new Value[] { atom_Tns ,  atom_Present ,  atom_Agr ,  atom_Not3sg ,  atom_Untensed ,  atom_True ,  atom_Icode ,  atom_S$Ed });
      }
 }


 void act1282( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     ( ( state.lex.getWordString().length()  >  4 ) &&
       patternCheck( state.lex ,  pattern_E$N ) &&
       morphRoot( state ) &&
        ( ! ( patternCheck( state.root ,  pattern_E )) )) &&
     testPostTest( state ));
 }


 void act1284( MorphState  state ) {
   if    (catPreTest( state ) &&
          (plausibleRoot( state.root ) &&
            morphRoot( state ) &&
             ( ! ( polysyllabic( state.root )) ) &&
            isRootOfCat( state.root ,  categorySet_Adj )) &&
          catPostTest( state ))
      { state.lex.addIkoParent(morphPackLex( state ,  "make_" , state.root.getWordString()));
       state.lex.addIkoParent( word_$Vt$Change );
       state.lex.addRoots(state.root.makeSenseNamesIfNeeded( categorySet_Adj ));
       state.lex.addPrefixes( wordSet_Em );
       state.lex.addSuffixes( wordSet_En );
       addCatSense( state ,  category_V ,  state.lex ,  new Value[] { atom_Tns ,  atom_Present ,  atom_Agr ,  atom_Not3sg ,  atom_Untensed ,  atom_True ,  atom_Icode ,  atom_S$Ed });
      }
 }


 void act1285( MorphState  state ) {
   if    (catPreTest( state ) &&
          (plausibleRoot( state.root ) &&
            morphRoot( state ) &&
             ( ! ( polysyllabic( state.root )) ) &&
            isRootOfCat( state.root ,  categorySet_Anyn )) &&
          catPostTest( state ))
      { state.lex.addIkoParent(morphPackLex( state ,  "give_" , state.root.getWordString()));
       state.lex.addIkoParent( word_$Vt$Change );
       state.lex.addRoots(state.root.makeSenseNamesIfNeeded( categorySet_N ));
       state.lex.addPrefixes( wordSet_En );
       state.lex.addSuffixes( wordSet_En );
       addCatSense( state ,  category_V ,  state.lex ,  new Value[] { atom_Tns ,  atom_Present ,  atom_Agr ,  atom_Not3sg ,  atom_Untensed ,  atom_True ,  atom_Icode ,  atom_S$Ed });
      }
 }


 void act1286( MorphState  state ) {
   if    (catPreTest( state ) &&
          (plausibleRoot( state.root ) &&
            morphRoot( state ) &&
             ( ! ( polysyllabic( state.root )) ) &&
            isRootOfCat( state.root ,  categorySet_Anyn )) &&
          catPostTest( state ))
      { state.lex.addIkoParent(morphPackLex( state ,  "give_" , state.root.getWordString()));
       state.lex.addIkoParent( word_$Vt$Change );
       state.lex.addRoots(state.root.makeSenseNamesIfNeeded( categorySet_N ));
       state.lex.addPrefixes( wordSet_Em );
       state.lex.addSuffixes( wordSet_En );
       addCatSense( state ,  category_V ,  state.lex ,  new Value[] { atom_Tns ,  atom_Present ,  atom_Agr ,  atom_Not3sg ,  atom_Untensed ,  atom_True ,  atom_Icode ,  atom_S$Ed });
      }
 }


 void act1287( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       morphRoot( state ) &&
        ( ! ( state.root.isHyphenated()) ) &&
       state.root.noSuffix() &&
       state.root.noPrefix()) &&
     testPostTest( state ));
 }


 void act1290( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Adj )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root.makeSenseNamesIfNeeded(categorySet_Adj)[0] );
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] { atom_Prefix ,  state.prefix });
      }
 }


 void act1291( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Anyn )) &&
          catPostTest( state ))
      addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] { atom_From ,  state.root.makeSenseNamesIfNeeded(categorySet_N)[0] ,  atom_Prefix ,  state.prefix ,  atom_Prob ,  word_50 });
 }


 void act1293( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Adj )) &&
          catPostTest( state ))
      addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] { atom_From ,  state.root.makeSenseNamesIfNeeded(categorySet_Adj)[0] ,  atom_Prefix ,  state.prefix });
 }


 void act1294( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Nn )) &&
          catPostTest( state ))
      addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_From ,  state.root.makeSenseNamesIfNeeded(categorySet_N)[0] ,  atom_Prefix ,  state.prefix });
 }


 void act1295( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            mayBeCat( state ,  state.root ,  category_Adj )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root.makeSenseNamesIfNeeded(categorySet_Adj)[0] );
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] { atom_Prefix ,  state.prefix });
      }
 }


 void act1298( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Prep )) &&
          catPostTest( state ))
      { markDict( state ,  state.lex ,  atom_From ,  state.root.makeSenseNamesIfNeeded(categorySet_Prep)[0] ,  true );
       state.lex.addIkoParent( state.prefix );
       state.lex.addPrefixes( new Word[] { state.prefix });
       addCompoundSense( state.lex , dict.makeList( new Word[] { state.prefix ,  state.root }));
       state.lex.addIkoParent(morphPackLex( state , state.root.getWordString(),  "_" , state.prefix.getWordString()));
       { state.lex.addRoot( state.root );
        addCatSense( state ,  category_Adv ,  state.lex ,  new Value[] { atom_Prefix ,  state.prefix });
       }
      }
 }


 void act1303( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isFormOfCat( state.root ,  categorySet_V )) &&
          catPostTest( state ))
      { state.lex.addPrefixes( new Word[] { state.prefix });
       state.lex.addRoots(state.root.makeSenseNamesIfNeeded( categorySet_V ));
       addCatSense( state ,  category_V ,  state.lex , formsWithPrefix( state.root ,  category_V ,  state.prefix ,  null ,  "hypo" ,  "hyper" ));
      }
 }


 void act1304( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
             ( ! ( isFormOfCat( state.root ,  categorySet_Prespart )) ) &&
            isFormOfCat( state.root ,  categorySet_Nn )) &&
          catPostTest( state ))
      {  Category  tempCategory1026 ;
       if    (isFormOfCat( state.root ,  categorySet_Nm ))
           tempCategory1026  =  category_Nm ;

       else   tempCategory1026  =  category_N ;
       addCatSense( state ,  category_N ,  state.lex , formsWithPrefix( state.root ,  tempCategory1026 ,  state.prefix ,  null ,  "hypo" ,  "hyper" ));
      }
 }


 void act1305( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
             ( ! ( isFormOfCat( state.root ,  categorySet_Prespart$Pastpa_Etc )) ) &&
            isRootOfCat( state.root ,  categorySet_Adj )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root.makeSenseNamesIfNeeded(categorySet_Adj)[0] );
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] { atom_Prefix ,  state.prefix });
      }
 }


 void act1307( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Adv )) &&
          catPostTest( state ))
      { state.lex.addIkoParent(morphPackLex( state ,  "not_" , state.root.getWordString()));
       addCatSense( state ,  category_Adv ,  state.lex ,  new Value[] { atom_From ,  state.root.makeSenseNamesIfNeeded(categorySet_Adv)[0] ,  atom_Prefix ,  state.prefix });
      }
 }


 void act1309( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Adj ) &&
             ( ! ( isFormOfCat( state.root ,  categorySet_Pastpart$Prespa_Etc )) )) &&
          catPostTest( state ))
      { state.lex.addIkoParent(morphPackLex( state ,  "not_" , state.root.getWordString()));
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] { atom_From ,  state.root.makeSenseNamesIfNeeded(categorySet_Adj)[0] ,  atom_Prefix ,  state.prefix });
      }
 }


 void act1310( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       morphRoot( state ) &&
        ( ! ( state.root.isHyphenated()) ) &&
       isFormOfCat( state.root ,  categorySet_V ) &&
       notSuffix( state.root ,  wordSet_Ism$Ist$Ity$Tio_Etc ) &&
        ( ! ( suffixedVerbP( state.root )) )) &&
     testPostTest( state ));
 }


 void act1311( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.addIkoParents(state.root.makeSenseNamesIfNeeded( categorySet_V ));
       addCatSense( state ,  category_V ,  state.lex , formsWithPrefix( state.root ,  category_V ,  word_En ,  null ,  "IM" ));
      }
 }


 void act1312( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
             ( ! ( isFormOfCat( state.root ,  categorySet_V )) ) &&
            isRootOfCat( state.root ,  categorySet_Adj$Nn ) &&
            notSuffix( state.root ,  wordSet_Ism$Ist$Ity$Tio_Etc ) &&
            state.root.noPrefix()) &&
          catPostTest( state ))
      { state.lex.addIkoParent( word_$Vt$Change );
       addCatSense( state ,  category_V ,  state.lex ,  new Value[] { atom_From ,  state.root.makeSenseNamesIfNeeded(categorySet_V)[0] ,  atom_Prefix ,  state.prefix });
      }
 }


 void act1315( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       morphRoot( state ) &&
        ( ! ( state.root.isHyphenated()) ) &&
        ( ! ( isFormOfCat( state.root ,  categorySet_Pastpart$Prespa_Etc )) ) &&
       notSuffix( state.root ,  wordSet_Ism$Ist$Ity$Tio_Etc ) &&
       notPrefix( state.root ,  wordSet_Ter )) &&
     testPostTest( state ));
 }


 void act1317( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       morphRoot( state ) &&
        ( ! ( state.root.isHyphenated()) ) &&
        ( ! ( suffixedVerbP( state.root )) ) &&
       notPrefix( state.root ,  wordSet_Ter ) &&
       notSuffix( state.root ,  wordSet_Ism$Ist$Ity$Tio_Etc )) &&
     testPostTest( state ));
 }


 void act1318( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isFormOfCat( state.root ,  categorySet_Nn ) &&
            notPrefix( state.root ,  wordSet_Ter ) &&
            patternCheck( state.root ,  pattern_C$I$T$Y )) &&
          catPostTest( state ))
      addCatSense( state ,  category_N ,  state.lex , formsWithPrefix( state.root ,  category_N ,  state.prefix ));
 }


 void act1322( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Adj )) &&
          catPostTest( state ))
      { state.lex.addIkoParent(morphPackLex( state ,  "uniformly_" , state.root.getWordString()));
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] { atom_From ,  state.root.makeSenseNamesIfNeeded(categorySet_Adj)[0] ,  atom_Prefix ,  state.prefix });
      }
 }


 void act1323( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isFormOfCat( state.root ,  categorySet_Nn )) &&
          catPostTest( state ))
      addCatSense( state ,  category_N ,  state.lex , formsWithPrefix( state.root ,  category_N ,  state.prefix ));
 }


 void act1325( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isFormOfCat( state.root ,  categorySet_Malefirstname$L_Etc )) &&
          catPostTest( state ))
      { state.lex.applyFalseRoot( state.root );
       state.lex.addPrefixes( new Word[] { state.prefix });
       markDict( state ,  state.lex ,  atom_Derived$From , dict.makeList( new Word[] { state.prefix ,  state.root }),  true );
       addCatSense( state ,  category_Lastname ,  state.lex ,  new Value[] {});
      }
 }


 void act1327( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
             ( ! ( patternCheck( state.root ,  pattern_E$S$Q$U$E )) )) &&
          catPostTest( state ))
      { state.lex.applyFalseRoot( state.root );
       state.lex.addPrefixes( new Word[] { state.prefix });
       markDict( state ,  state.lex ,  atom_Derived$From , dict.makeList( new Word[] { state.prefix ,  state.root }),  true );
       addCatSense( state ,  category_Lastname ,  state.lex ,  new Value[] {});
      }
 }


 void act1328( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       morphRoot( state ) &&
        ( ! ( state.root.isHyphenated()) ) &&
       state.root.noPrefix() &&
       notSuffix( state.root ,  wordSet_Ism$Ist$Ity$Tio_Etc )) &&
     testPostTest( state ));
 }


 void act1330( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isFormOfCat( state.root ,  categorySet_Adj$Nn ) &&
            polysyllabic( state.root )) &&
          catPostTest( state ))
      {  Category  tempCategory1028 ;
       if    (isFormOfCat( state.root ,  categorySet_Nm ))
           tempCategory1028  =  category_Nm ;

       else   tempCategory1028  =  category_N ;
       addCatSense( state ,  category_N ,  state.lex , formsWithPrefix( state.root ,  tempCategory1028 ,  state.prefix ));
      }
 }


 void act1331( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isFormOfCat( state.root ,  categorySet_Adj ) &&
            polysyllabic( state.root )) &&
          catPostTest( state ))
      addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] {});
 }


 void act1333( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       morphRoot( state ) &&
        ( ! ( state.root.isHyphenated()) ) &&
       notSuffix( state.root ,  wordSet_Ism$Ist$Ity$Tio_Etc$ )) &&
     testPostTest( state ));
 }


 void act1335( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Adv$Anyn )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root.makeSenseNamesIfNeeded(categorySet_Adv$N)[0] );
       addCatSense( state ,  category_Adv ,  state.lex ,  new Value[] { atom_Prefix ,  state.prefix });
      }
 }


 void act1340( MorphState  state ) {
   if    (catPreTest( state ) &&
          (plausibleRoot( state.root ) &&
            morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Adj$Nn )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root.makeSenseNamesIfNeeded(categorySet_Adj$N)[0] );
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] { atom_Prefix ,  state.prefix });
      }
 }


 void act1345( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            (isFormOfCat( state.root ,  categorySet_Adj ) ||
              isRootOfCat( state.root ,  categorySet_Anyn ) ||
              ( ( ! ( isFormOfCat( state.root ,  categorySet_Adv )) ) &&
                morphCheck( state.root ,  category_Adj ) &&
                 (makeRealWord( state ,  state.root ) !=  null )))) &&
          catPostTest( state ))
      { state.lex.addIkoParent(dict.makeStructuredConcept( category_Adj , dict.makeList( new Value[] { word_Not ,  state.root })));
       state.lex.addIkoParent(morphPackLex( state ,  "UN" , state.root.getWordString()));
       state.lex.addPrefixes( new Word[] { state.prefix });
       state.lex.addRoots(state.root.makeSenseNamesIfNeeded( categorySet_Adj$N$Adv ));
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] {});
      }
 }


 void act1346( MorphState  state ) {
   if    (catPreTest( state ) &&
          (plausibleRoot( state.root ) &&
            morphRoot( state ) &&
            isFormOfCat( state.root ,  categorySet_Nn )) &&
          catPostTest( state ))
      addCatSense( state ,  category_N ,  state.lex , formsWithPrefix( state.root ,  category_N ,  state.prefix ));
 }


 void act1347( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isFormOfCat( state.root ,  categorySet_Adv )) &&
          catPostTest( state ))
      { state.lex.addIkoParent(dict.makeStructuredConcept( category_Adv , dict.makeList( new Value[] { word_Not ,  state.root })));
       state.lex.addPrefixes( new Word[] { state.prefix });
       state.lex.addRoots(state.root.makeSenseNamesIfNeeded( categorySet_Adv ));
       addCatSense( state ,  category_Adv ,  state.lex ,  new Value[] {});
      }
 }


 void act1348( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       morphRoot( state ) &&
        ( ! ( state.root.isHyphenated()) ) &&
       dict.isKnownWord( state.root )) &&
     testPostTest( state ));
 }


 void act1350( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Nn$V$Adj )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root.makeSenseNamesIfNeeded(categorySet_N$V$Adj)[0] );
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] { atom_Prefix ,  state.prefix });
      }
 }


 void act1351( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Nn$V$Adj )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root.makeSenseNamesIfNeeded(categorySet_N$V$Adj)[0] );
       addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Prefix ,  state.prefix });
      }
 }


 void act1354( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Nn )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root.makeSenseNamesIfNeeded(categorySet_N)[0] );
       addCatSense( state ,  category_Adv ,  state.lex ,  new Value[] { atom_Prefix ,  state.prefix });
      }
 }


 void act1355( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isFormOfCat( state.root ,  categorySet_V )) &&
          catPostTest( state ))
      addCatSense( state ,  category_V ,  state.lex , formsWithPrefix( state.root ,  category_V ,  state.prefix ,  new Value[] { atom_Kindof ,  state.root }));
 }


 void act1356( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isFormOfCat( state.root ,  categorySet_Nn ) &&
             ( ! ( isFormOfCat( state.root ,  categorySet_Prespart )) )) &&
          catPostTest( state ))
      addCatSense( state ,  category_N ,  state.lex , formsWithPrefix( state.root ,  category_N ,  state.prefix ));
 }


 void act1357( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Adj$Nn ) &&
             ( ! ( isFormOfCat( state.root ,  categorySet_Prespart$Pastpa_Etc )) )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root.makeSenseNamesIfNeeded(categorySet_Adj$N)[0] );
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] { atom_Prefix ,  state.prefix });
      }
 }


 void act1361( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isFormOfCat( state.root ,  categorySet_Nn )) &&
          catPostTest( state ))
      addCatSense( state ,  category_N ,  state.lex , formsWithPrefix( state.root ,  category_N ,  state.prefix ,  new Value[] { atom_Kindof ,  state.root }));
 }


 void act1362( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       morphRoot( state ) &&
        ( ! ( state.root.isHyphenated()) ) &&
       isFormOfCat( state.root ,  categorySet_V ) &&
       (state.root.hasSuffix( wordSet_E$Ve$En ) ||
         (state.root.noSuffix() &&
           state.root.noPrefix()))) &&
     testPostTest( state ));
 }


 void act1364( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      addCatSense( state ,  category_Vt ,  state.lex , formsWithPrefix( state.root ,  category_V ,  state.prefix ,  new Value[] { atom_Kindof ,  word_Surpass }));
 }


 void act1365( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Adj$Anyn )) &&
          catPostTest( state ))
      { state.lex.addIkoParent( word_Surpass );
       state.lex.addRoot( state.root.makeSenseNamesIfNeeded(categorySet_Adj$N)[0] );
       addCatSense( state ,  category_Vt ,  state.lex ,  new Value[] { atom_Prefix ,  state.prefix ,  atom_Prob ,  word_50 });
      }
 }


 void act1366( MorphState  state ) {
   if    (testPreTest( state ))
      {  boolean  tempboolean1030 ;
       if    (plausibleRoot( state.root ) &&
              morphRoot( state ) &&
               ( ! ( state.root.isHyphenated()) ) &&
              isFormOfCat( state.root ,  categorySet_V ) &&
              notSuffix( state.root ,  wordSet_Ism$Ist$Ity$Tio_Etc$$ ))
          {  boolean  tempboolean1031 ;
           if    (state.root.hasSuffix( wordSet_Al ) &&
                  isRootOfCat( state.root ,  categorySet_Nm ))
              {  Word[]  tempWordSet1032  = state.root.getDirectRoots();
                tempboolean1031  =  false ;
               if     ( tempWordSet1032  !=  null )
                  for ( int  i  =  0 ;  i  <  tempWordSet1032.length ;  i++ ) {
                      Word  base  =  tempWordSet1032[i] ;
                     { if    (isRootOfCat( base ,  categorySet_V ))
                          {  tempboolean1031  =  true ;
                            break ;
                          }
                     }
                  }
              }

           else   tempboolean1031  =  false ;
            tempboolean1030  =  ( !  tempboolean1031 );
          }

       else   tempboolean1030  =  false ;
       if    ( tempboolean1030 )
           state.testval  = testPostTest( state );

       else   state.testval  =  false ;
      }

   else   state.testval  =  false ;
 }


 void act1368( MorphState  state ) {
   if    (testPreTest( state ))
      {  boolean  tempboolean1033 ;
       if    (plausibleRoot( state.root ) &&
              morphRoot( state ) &&
               ( ! ( state.root.isHyphenated()) ) &&
              isFormOfCat( state.root ,  categorySet_Nn$Adj$Adv ) &&
               ( ! ( isFormOfCat( state.root ,  categorySet_V )) ) &&
              notSuffix( state.root ,  wordSet_Ism$Ist$Ity$Tio_Etc$$ ))
          {  boolean  tempboolean1034 ;
           if    (state.root.hasSuffix( wordSet_Al ) &&
                  isRootOfCat( state.root ,  categorySet_Nm ))
              {  Word[]  tempWordSet1035  = state.root.getDirectRoots();
                tempboolean1034  =  false ;
               if     ( tempWordSet1035  !=  null )
                  for ( int  i  =  0 ;  i  <  tempWordSet1035.length ;  i++ ) {
                      Word  base  =  tempWordSet1035[i] ;
                     { if    (isRootOfCat( base ,  categorySet_V ))
                          {  tempboolean1034  =  true ;
                            break ;
                          }
                     }
                  }
              }

           else   tempboolean1034  =  false ;
            tempboolean1033  =  ( !  tempboolean1034 );
          }

       else   tempboolean1033  =  false ;
       if    ( tempboolean1033 )
           state.testval  = testPostTest( state );

       else   state.testval  =  false ;
      }

   else   state.testval  =  false ;
 }


 void act1369( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isNonpenaltyFormOfCat( state.root ,  categorySet_Nn )) &&
          catPostTest( state ))
      { state.lex.addIkoParent( word_Exceed );
       state.lex.addRoot( state.root.makeSenseNamesIfNeeded(categorySet_N)[0] );
       addCatSense( state ,  category_V ,  state.lex ,  new Value[] { atom_Prefix ,  state.prefix });
      }
 }


 void act1370( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isFormOfCat( state.root ,  categorySet_Nn )) &&
          catPostTest( state ))
      { state.lex.addIkoParent( state.root );
       state.lex.addRoot( state.root.makeSenseNamesIfNeeded(categorySet_N)[0] );
       addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Prefix ,  state.prefix });
      }
 }


 void act1371( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isFormOfCat( state.root ,  categorySet_Adj )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root.makeSenseNamesIfNeeded(categorySet_Adj)[0] );
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] { atom_Prefix ,  state.prefix });
      }
 }


 void act1372( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isFormOfCat( state.root ,  categorySet_Adv )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root.makeSenseNamesIfNeeded(categorySet_Adv)[0] );
       addCatSense( state ,  category_Adv ,  state.lex ,  new Value[] { atom_Prefix ,  state.prefix });
      }
 }


 void act1382( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Adv$Nn )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root );
       addCatSense( state ,  category_Adv ,  state.lex ,  new Value[] { atom_Prob ,  word_50 ,  atom_Prefix ,  state.prefix });
      }
 }


 void act1385( MorphState  state ) {
   if    (testPreTest( state ))
      {  boolean  tempboolean1036 ;
       if    (plausibleRoot( state.root ) &&
              morphRoot( state ) &&
               ( ! ( state.root.isHyphenated()) ) &&
              isFormOfCat( state.root ,  categorySet_Adj$Adv$Nn$V ) &&
              notSuffix( state.root ,  wordSet_Ness ))
          {  boolean  tempboolean1037 ;
           if    (state.root.hasSuffix( wordSet_Al ) &&
                  isRootOfCat( state.root ,  categorySet_Nm ))
              {  Word[]  tempWordSet1038  = state.root.getDirectRoots();
                tempboolean1037  =  false ;
               if     ( tempWordSet1038  !=  null )
                  for ( int  i  =  0 ;  i  <  tempWordSet1038.length ;  i++ ) {
                      Word  base  =  tempWordSet1038[i] ;
                     { if    (isRootOfCat( base ,  categorySet_V ))
                          {  tempboolean1037  =  true ;
                            break ;
                          }
                     }
                  }
              }

           else   tempboolean1037  =  false ;
            tempboolean1036  =  ( !  tempboolean1037 );
          }

       else   tempboolean1036  =  false ;
       if    ( tempboolean1036 )
           state.testval  = testPostTest( state );

       else   state.testval  =  false ;
      }

   else   state.testval  =  false ;
 }


 void act1387( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
             ( ! ( isFormOfCat( state.root ,  categorySet_Prespart$Pastpa_Etc )) ) &&
            (isRootOfCat( state.root ,  categorySet_Adj$Nn ) ||
              (isFormOfCat( state.root ,  categorySet_Name ) &&
                 ( ! ( isFormOfCat( state.root ,  categorySet_V )) )))) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root.makeSenseNamesIfNeeded(categorySet_Adj$N)[0] );
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] { atom_Prefix ,  state.prefix });
      }
 }


 void act1388( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Adv$Nn )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root.makeSenseNamesIfNeeded(categorySet_Adv$N)[0] );
       addCatSense( state ,  category_Adv ,  state.lex ,  new Value[] { atom_Prob ,  word_50 ,  atom_Prefix ,  state.prefix });
      }
 }


 void act1389( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       morphRoot( state ) &&
        ( ! ( state.root.isHyphenated()) ) &&
       isFormOfCat( state.root ,  categorySet_Adj$Anyn )) &&
     testPostTest( state ));
 }


 void act1391( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Nn ) &&
            state.root.hasSuffix( wordSet_Ism$Ist$Ity$Tio_Etc )) &&
          catPostTest( state ))
      { state.lex.addIkoParent( state.root );
       addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_From ,  state.root ,  atom_Prefix ,  state.prefix });
      }
 }


 void act1392( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Adj$Anyn )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root.makeSenseNamesIfNeeded(categorySet_Adj$N)[0] );
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] { atom_Prefix ,  state.prefix });
      }
 }


 void act1393( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       morphRoot( state ) &&
        ( ! ( state.root.isHyphenated()) ) &&
        ( ! ( state.root.isHyphenated()) ) &&
       isFormOfCat( state.root ,  categorySet_V ) &&
       (notSuffix( state.root ,  wordSet_Ism$Ist$Ity$Tio_Etc ) ||
         state.root.hasSuffix( wordSet_Ise$Ize$Ate$En$_Etc ) ||
         patternCheck( state.root ,  pattern_I$$S_Z$$E ) ||
         patternCheck( state.root ,  pattern_A$T$E ) ||
         patternCheck( state.root ,  pattern_E$N ))) &&
     testPostTest( state ));
 }


 void act1395( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.addIkoParent(dict.makeStructuredConcept( category_V , dict.makeList( new Value[] { state.root ,  word_$V$Redo ,  word_$V$Repeat })));
       state.lex.addVariantOf(dict.makeStructuredConcept( category_V , dict.makeList( new Value[] {(Value)(morphPackLex( state , state.prefix.getWordString(), state.root.getWordString()))})));
       state.lex.addPrefixes( new Word[] { state.prefix });
       state.lex.addRoots(state.root.makeSenseNamesIfNeeded( categorySet_V ));
       addCatSense( state ,  category_V ,  state.lex , formsWithPrefix( state.root ,  category_V ,  word_Re$ ,  new Value[] { atom_Kindof , state.root.makeSenseName( category_V )}));
      }
 }


 void act1396( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
             ( ! ( isFormOfCat( state.root ,  categorySet_Prespart )) ) &&
            isNonpenaltyFormOfCat( state.root ,  categorySet_Nn ) &&
            isFormOfCat( state.root ,  categorySet_Nn )) &&
          catPostTest( state ))
      addCatSense( state ,  category_N ,  state.lex , formsWithPrefix( state.root ,  category_N ,  state.prefix ));
 }


 void act1397( MorphState  state ) {
   if    (testPreTest( state ))
      {  boolean  tempboolean1039 ;
       if    (plausibleRoot( state.root ) &&
              morphRoot( state ) &&
               ( ! ( state.root.isHyphenated()) ) &&
               ( ! ( state.root.isHyphenated()) ) &&
              isFormOfCat( state.root ,  categorySet_V ) &&
              (notSuffix( state.root ,  wordSet_Ism$Ist$Ity$Tio_Etc ) ||
                state.root.hasSuffix( wordSet_Ise$Ize$Ate$En$_Etc ) ||
                patternCheck( state.root ,  pattern_I$$S_Z$$E ) ||
                patternCheck( state.root ,  pattern_A$T$E ) ||
                patternCheck( state.root ,  pattern_E$N )))
          {  boolean  tempboolean1040 ;
           if    (state.root.hasSuffix( wordSet_Al ) &&
                  isRootOfCat( state.root ,  categorySet_Nm ))
              {  Word[]  tempWordSet1041  = state.root.getDirectRoots();
                tempboolean1040  =  false ;
               if     ( tempWordSet1041  !=  null )
                  for ( int  i  =  0 ;  i  <  tempWordSet1041.length ;  i++ ) {
                      Word  base  =  tempWordSet1041[i] ;
                     { if    (isRootOfCat( base ,  categorySet_V ))
                          {  tempboolean1040  =  true ;
                            break ;
                          }
                     }
                  }
              }

           else   tempboolean1040  =  false ;
            tempboolean1039  =  ( !  tempboolean1040 );
          }

       else   tempboolean1039  =  false ;
       if    ( tempboolean1039 )
           state.testval  = testPostTest( state );

       else   state.testval  =  false ;
      }

   else   state.testval  =  false ;
 }


 void act1398( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.addIkoParents(LexiconUtil.concatArrays(state.root.makeSenseNamesIfNeeded( categorySet_V ),  new Word[] { word_$V$Redo ,  word_$V$Repeat }));
       state.lex.addPrefixes( new Word[] { state.prefix });
       state.lex.addRoots(state.root.makeSenseNamesIfNeeded( categorySet_V ));
       addCatSense( state ,  category_V ,  state.lex , formsWithPrefix( state.root ,  category_V ,  state.prefix ,  new Value[] { atom_Kindof , state.root.makeSenseName( category_V )}));
      }
 }


 void act1399( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
             ( ! ( isFormOfCat( state.root ,  categorySet_Prespart )) ) &&
            isFormOfCat( state.root ,  categorySet_Nn ) &&
             ( ! ( isPenaltyFormOfCat( state.root ,  categorySet_Nn ,  2 )) )) &&
          catPostTest( state ))
      addCatSense( state ,  category_N ,  state.lex , formsWithPrefix( state.root ,  category_N ,  state.prefix ));
 }


 void act1400( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       morphRoot( state ) &&
        ( ! ( state.root.isHyphenated()) ) &&
        ( ! ( state.root.isHyphenated()) ) &&
        ( ! ( isFormOfCat( state.root ,  categorySet_V )) ) &&
       notSuffix( state.root ,  wordSet_Ism$Ist$Ity$Tio_Etc )) &&
     testPostTest( state ));
 }


 void act1401( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Nn$Adj ) &&
             ( ! ( isFormOfCat( state.root ,  categorySet_V )) )) &&
          catPostTest( state ))
      { state.lex.addIkoParent(dict.makeStructuredConcept( category_V , dict.makeList( wordSet_$V$Redo$$V$Repe_Etc )));
       state.lex.addVariantOf(dict.makeStructuredConcept( category_V , dict.makeList( new Value[] {(Value)(morphPackLex( state , state.prefix.getWordString(), state.root.getWordString()))})));
       state.lex.addPrefixes( new Word[] { state.prefix });
       state.lex.addRoots(state.root.makeSenseNamesIfNeeded( categorySet_N$Adj ));
       { state.lex.addIkoParent( word_$V$Redo );
        state.lex.addRoot( state.root.makeSenseNamesIfNeeded(categorySet_N$Adj)[0] );
        addCatSense( state ,  category_V ,  state.lex ,  new Value[] { atom_Prefix ,  state.prefix });
       }
      }
 }


 void act1402( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Nn$Adj ) &&
             ( ! ( isFormOfCat( state.root ,  categorySet_V )) )) &&
          catPostTest( state ))
      { state.lex.addIkoParent(dict.makeStructuredConcept( category_V , dict.makeList( wordSet_$V$Redo$$V$Repe_Etc )));
       state.lex.addPrefixes( new Word[] { state.prefix });
       state.lex.addRoots(state.root.makeSenseNamesIfNeeded( categorySet_N$Adj ));
       { state.lex.addIkoParent( word_$V$Redo );
        state.lex.addRoot( state.root );
        addCatSense( state ,  category_V ,  state.lex ,  new Value[] { atom_Prefix ,  state.prefix });
       }
      }
 }


 void act1404( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Adv )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root.makeSenseNamesIfNeeded(categorySet_Adv)[0] );
       addCatSense( state ,  category_Adv ,  state.lex ,  new Value[] { atom_Prob ,  word_50 ,  atom_Prefix ,  state.prefix });
      }
 }


 void act1405( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Adj )) &&
          catPostTest( state ))
      { state.lex.addIkoParent( state.root.makeSenseNamesIfNeeded(categorySet_Adj)[0] );
       state.lex.addRoot( state.root.makeSenseNamesIfNeeded(categorySet_Adj)[0] );
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] { atom_Prefix ,  state.prefix });
      }
 }


 void act1406( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isFormOfCat( state.root ,  categorySet_V )) &&
          catPostTest( state ))
      addCatSense( state ,  category_V ,  state.lex , formsWithPrefix( state.root ,  category_V ,  word_Semi ,  dictStruct_$Prob_50$ ));
 }


 void act1407( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       morphRoot( state ) &&
        ( ! ( state.root.isHyphenated()) ) &&
       isFormOfCat( state.root ,  categorySet_Nn ) &&
       isKnownKindOf( state.root ,  word_$N$Relative$Per_Etc )) &&
     testPostTest( state ));
 }


 void act1409( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.addIkoParent(dict.makeStructuredConcept( category_N , dict.makeList( new Value[] { word_Half ,  state.root })));
       state.lex.addPrefixes( new Word[] { state.prefix });
       state.lex.addRoots(state.root.makeSenseNamesIfNeeded( categorySet_N ));
       addCatSense( state ,  category_N ,  state.lex , formsWithPrefix( state.root ,  category_N ,  state.prefix ));
      }
 }


 void act1413( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       morphRoot( state ) &&
        ( ! ( state.root.isHyphenated()) ) &&
       (state.root.noSuffix() ||
         state.root.hasSuffix( wordSet_Ar ) ||
         patternCheck( state.root ,  pattern_I$$S_Z$$E ) ||
         patternCheck( state.root ,  pattern_A$T$E ))) &&
     testPostTest( state ));
 }


 void act1415( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
             ( ! ( isFormOfCat( state.root ,  categorySet_Prespart$Pastpa_Etc )) ) &&
            isRootOfCat( state.root ,  categorySet_Npr )) &&
          catPostTest( state ))
      { state.lex.addRoot(state.root.makeSenseName( category_Npr ));
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] { atom_Prefix ,  state.prefix });
      }
 }


 void act1420( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       morphRoot( state ) &&
        ( ! ( state.root.isHyphenated()) ) &&
       isFormOfCat( state.root ,  categorySet_Prespart$Pastpa_Etc )) &&
     testPostTest( state ));
 }


 void act1422( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.addIkoParent(dict.makeStructuredConcept( category_Adj , dict.makeList( new Value[] { word_Not ,  state.root })));
       state.lex.addPrefixes( new Word[] { state.prefix });
       state.lex.addRoot( state.root );
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] {});
      }
 }


 void act1423( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isFormOfCat( state.root ,  categorySet_Pastpart )) &&
          catPostTest( state ))
      { state.lex.addIkoParent(dict.makeStructuredConcept( category_Adv , dict.makeList( new Value[] { word_Not ,  state.root })));
       state.lex.addPrefixes( new Word[] { state.prefix });
       state.lex.addRoot( state.root );
       addCatSense( state ,  category_Adv ,  state.lex ,  new Value[] {});
      }
 }


 void act1424( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       morphRoot( state ) &&
       isUndoableVerb( state.root )) &&
     testPostTest( state ));
 }


 void act1425( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       morphRoot( state ) &&
        ( ! ( state.root.isHyphenated()) ) &&
       isNonpenaltyFormOfCat( state.root ,  categorySet_V ) &&
        ( ! ( isFormOfCat( state.root ,  categorySet_Prespart$Pastpa_Etc )) )) &&
     testPostTest( state ));
 }


 void act1426( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Adj )) &&
          catPostTest( state ))
      { state.lex.addIkoParent(dict.makeStructuredConcept( category_Adj , dict.makeList( new Value[] { word_Not ,  state.root })));
       state.lex.addPrefixes( new Word[] { state.prefix });
       state.lex.addRoots(state.root.makeSenseNamesIfNeeded( categorySet_Adj ));
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] {});
      }
 }


 void act1427( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Adv )) &&
          catPostTest( state ))
      { state.lex.addIkoParent(dict.makeStructuredConcept( category_Adv , dict.makeList( new Value[] { word_Not ,  state.root })));
       addCatSense( state ,  category_Adv ,  state.lex ,  new Value[] { atom_From ,  state.root.makeSenseNamesIfNeeded(categorySet_Adv)[0] ,  atom_Prefix ,  state.prefix });
      }
 }


 void act1428( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       morphRoot( state ) &&
        ( ! ( state.root.isHyphenated()) ) &&
        ( ! ( isFormOfCat( state.root ,  categorySet_Prespart$Pastpa_Etc )) )) &&
     testPostTest( state ));
 }


 void act1429( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       morphRoot( state ) &&
        ( ! ( state.root.isHyphenated()) ) &&
       dict.isKnownWord( state.root ) &&
       notSuffix( state.root ,  wordSet_Ness ) &&
       state.root.noPrefix()) &&
     testPostTest( state ));
 }


 void act1430( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Nn ) &&
             ( ! ( isFormOfCat( state.root ,  categorySet_Adj$V )) ) &&
            state.root.noSuffix()) &&
          catPostTest( state ))
      { state.lex.addIkoParent(dict.makeStructuredConcept( category_V , dict.makeList( new Value[] { word_$V$Separate , dict.makeList( new Value[] { word_From ,  state.root })})));
       addCatSense( state ,  category_V ,  state.lex ,  new Value[] { atom_From ,  state.root.makeSenseNamesIfNeeded(categorySet_N)[0] ,  atom_Prefix ,  state.prefix ,  atom_Tns ,  atom_Present ,  atom_Agr ,  atom_Not3sg ,  atom_Untensed ,  atom_True });
      }
 }


 void act1431( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       morphRoot( state ) &&
        ( ! ( state.root.isHyphenated()) ) &&
        ( ! ( isFormOfCat( state.root ,  categorySet_Prespart )) ) &&
       notSuffix( state.root ,  wordSet_Ness )) &&
     testPostTest( state ));
 }


 void act1432( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isFormOfCat( state.root ,  categorySet_Nm )) &&
          catPostTest( state ))
      { state.lex.addIkoParent(dict.makeStructuredConcept( category_Nm , dict.makeList( new Value[] { word_Non ,  state.root })));
       addCatSense( state ,  category_Nm ,  state.lex ,  new Value[] { atom_From ,  state.root.makeSenseNamesIfNeeded(categorySet_N)[0] ,  atom_Prefix ,  state.prefix });
      }
 }


 void act1433( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       morphRoot( state ) &&
        ( ! ( state.root.isHyphenated()) ) &&
       dict.isKnownWord( state.root ) &&
        ( ! ( isFormOfCat( state.root ,  categorySet_Prespart )) ) &&
       notSuffix( state.root ,  wordSet_Ness )) &&
     testPostTest( state ));
 }


 void act1434( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isFormOfCat( state.root ,  categorySet_Nn )) &&
          catPostTest( state ))
      { state.lex.addIkoParent(dict.makeStructuredConcept( category_Nc , dict.makeList( new Value[] { word_Non ,  state.root })));
       addCatSense( state ,  category_Nc ,  state.lex ,  new Value[] { atom_From ,  state.root.makeSenseNamesIfNeeded(categorySet_N)[0] ,  atom_Prefix ,  state.prefix });
      }
 }


 void act1436( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            ((morphCheck( state.root ,  category_Adj ) &&
                 (makeRealWord( state ,  state.root ) !=  null )) ||
              isRootOfCat( state.root ,  categorySet_Nn ))) &&
          catPostTest( state ))
      { state.lex.addIkoParent( state.root );
       { state.lex.addRoot( state.root.makeSenseNamesIfNeeded(categorySet_Adj$N)[0] );
        addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] { atom_Prefix ,  state.prefix });
       }
      }
 }


 void act1437( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Nn )) &&
          catPostTest( state ))
      { state.lex.addRoot( state.root.makeSenseNamesIfNeeded(categorySet_N)[0] );
       addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Prefix ,  state.prefix });
      }
 }


 void act1438( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (plausibleRoot( state.root ) &&
       morphRoot( state ) &&
        ( ! ( state.root.isHyphenated()) ) &&
       notSuffix( state.root ,  wordSet_Ism$Ist$Ity$Tio_Etc$$$ ) &&
       state.root.noPrefix()) &&
     testPostTest( state ));
 }


 void act1440( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat( state.root ,  categorySet_Nn )) &&
          catPostTest( state ))
      { state.lex.addIkoParent( word_$Adv$Up );
       state.lex.addRoot( state.root.makeSenseNamesIfNeeded(categorySet_N)[0] );
       addCatSense( state ,  category_Adv ,  state.lex ,  new Value[] { atom_Prefix ,  state.prefix });
      }
 }


 void act1442( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (morphRoot( state ) &&
        ( ! ( patternCheckLeft( state.root ,  pattern_T$Y )) )) &&
     testPostTest( state ));
 }


 void act1443( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isFormOfCat( state.root ,  categorySet_Malefirstname$L_Etc )) &&
          catPostTest( state ))
      { state.lex.applyFalseRoot( state.root );
       state.lex.addPrefixes( wordSet_Fitz );
       markDict( state ,  state.lex ,  atom_Derived$From , dict.makeList( new Word[] { word_Fitz ,  state.root }),  true );
       addCatSense( state ,  category_Lastname ,  state.lex ,  new Value[] {});
      }
 }


 void act1444( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.addPrefixes( wordSet_Fitz );
       addCatSense( state ,  category_Lastname ,  state.lex ,  new Value[] {});
      }
 }


 void act1446( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (morphRoot( state ) &&
       dict.isKnownWord( state.root )) &&
     testPostTest( state ));
 }


 void act1451( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (morphRoot( state ) &&
       notSuffix( state.root ,  wordSet_Ism$Ist$Ity$Tio_Etc$ )) &&
     testPostTest( state ));
 }


 void act1453( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (morphRoot( state ) &&
       lexicalPrefixTest( state ,  state.lex )) &&
     testPostTest( state ));
 }


 void act1455( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isFormOfCat(word2( state.lex ),  categorySet_Prespart )) &&
          catPostTest( state ))
      addCatSense( state ,  category_Nm ,  state.lex ,  new Value[] { atom_Mass$Pure ,  atom_True ,  atom_Mass ,  atom_True ,  atom_Icode ,  atom_$S });
 }


 void act1456( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isFormOfCat(word2( state.lex ),  categorySet_Prespart$Pastpa_Etc )) &&
          catPostTest( state ))
      addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] {});
 }


 void act1457( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isFormOfCat(word2( state.lex ),  categorySet_V )) &&
          catPostTest( state ))
      { state.lex.addPrefixes( new Word[] { state.prefix });
       state.lex.addRoots(word2(state.lex).makeSenseNamesIfNeeded( categorySet_V ));
       addCatSense( state ,  category_V ,  state.lex , formsWithPrefix(word2( state.lex ),  category_V ,  state.prefix ));
      }
 }


 void act1458( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
             ( ! ( isFormOfCat(word2( state.lex ),  categorySet_Prespart )) ) &&
            isFormOfCat(word2( state.lex ),  categorySet_Nn )) &&
          catPostTest( state ))
      {  Category  tempCategory1042 ;
       if    (isFormOfCat(word2( state.lex ),  categorySet_Nm ))
           tempCategory1042  =  category_Nm ;

       else   tempCategory1042  =  category_N ;
       addCatSense( state ,  category_N ,  state.lex , formsWithPrefix(word2( state.lex ),  tempCategory1042 ,  state.prefix ));
      }
 }


 void act1459( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
             ( ! ( isFormOfCat(word2( state.lex ),  categorySet_Prespart$Pastpa_Etc )) ) &&
            isRootOfCat(word2( state.lex ),  categorySet_Adj )) &&
          catPostTest( state ))
      { state.lex.addRoot( word2(state.lex).makeSenseNamesIfNeeded(categorySet_Adj)[0] );
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] { atom_Prefix ,  state.prefix });
      }
 }


 void act1460( MorphState  state ) {
   if    (catPreTest( state ) &&
          (morphRoot( state ) &&
            isRootOfCat(word2( state.lex ),  categorySet_Adv )) &&
          catPostTest( state ))
      { state.lex.addRoot( word2(state.lex).makeSenseNamesIfNeeded(categorySet_Adv)[0] );
       addCatSense( state ,  category_Adv ,  state.lex ,  new Value[] { atom_Prefix ,  state.prefix });
      }
 }


 void act1461( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      addCatSense( state ,  category_Integer , dict.makeWord(state.word2.numericalValue().intValue() + state.word1.numericalValue().intValue()),  null );
 }


 void act1462( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     ( ( state.connector  !=  null ) &&
       state.connector.equals( "-" )) &&
     testPostTest( state ));
 }


 void act1463( MorphState  state ) {
   if    (catPreTest( state ) &&
          ( ( ! ( state.word1.numeralp()) ) &&
             ( ! ( romanNumeralP( state.word1 )) ) &&
             ( ! ( state.word2.numeralp()) ) &&
             ( ! ( romanNumeralP( state.word2 )) )) &&
          catPostTest( state ))
      { addCompoundSense( state.lex , dict.makeList( new Word[] { state.word1 ,  state.word2 }));
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] {});
      }
 }


 void act1464( MorphState  state ) {
   if    (catPreTest( state ) &&
          ( ( state.connector  !=  null ) &&
            state.connector.equals( "-" ) &&
             ( state.word1  ==  state.word2 ) &&
             ( state.word1.getWordString().length()  >  2 ) &&
             ( ! ( polysyllabic( state.word1 )) ) &&
             ( ! ( state.word1.looksLike( category_Adv )) ) &&
            ( ( ! ( isFormOfCat( state.word1 ,  categorySet_Npl )) ) ||
              isRootOfCat( state.word1 ,  categorySet_Nn )) &&
            ( ( ! ( isFormOfCat( state.word1 ,  categorySet_Prespart$Pastpa_Etc )) ) ||
              isRootOfCat( state.word1 ,  categorySet_V ))) &&
          catPostTest( state ))
      { addCompoundSense( state.lex , dict.makeList( new Word[] { state.word1 ,  state.word2 }));
       addCatSense( state ,  category_N ,  state.lex , getStandardFeatures( state.lex ,  category_N , nounInflectCode( state.lex )));
      }
 }


 void act1465( MorphState  state ) {
   if    (catPreTest( state ) &&
          ( ( state.connector  !=  null ) &&
            state.connector.equals( "-" ) &&
             ( state.word1  ==  state.word2 ) &&
             ( state.word1.getWordString().length()  >  2 ) &&
            polysyllabic( state.word1 ) &&
            ( ( ! ( isFormOfCat( state.word1 ,  categorySet_Npl )) ) ||
              isRootOfCat( state.word1 ,  categorySet_Anyn )) &&
            ( ( ! ( isFormOfCat( state.word1 ,  categorySet_Prespart$Pastpa_Etc )) ) ||
              isRootOfCat( state.word1 ,  categorySet_V ))) &&
          catPostTest( state ))
      { addCompoundSense( state.lex , dict.makeList( new Word[] { state.word1 ,  state.word2 }));
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] {});
      }
 }


 void act1466( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     ( ( state.connector  !=  null ) &&
       state.connector.equals( "-" ) &&
       state.word1.looksLike( category_Prep ) &&
        ( ! ( isFormOfCat( state.word1 ,  categorySet_Prefix )) ) &&
        ( ! ( LexiconUtil.isMembOfArray( state.word1 ,  wordSet_A$Ad$Ar$De$En$E_Etc )) ) &&
       state.word2.noSuffix()) &&
     testPostTest( state ));
 }


 void act1467( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { addCompoundSense( state.lex , dict.makeList( new Word[] { state.word1 ,  state.word2 }));
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] {});
      }
 }


 void act1468( MorphState  state ) {
   if    (catPreTest( state ) &&
          (isFormOfCat( state.word1 ,  categorySet_Adj ) &&
            isFormOfCat( state.word2 ,  categorySet_Nn ) &&
             ( ! ( state.word2.isHyphenated()) )) &&
          catPostTest( state ))
      { addCompoundSense( state.lex , dict.makeList( new Word[] { state.word1 ,  state.word2 }));
       addCatSense( state ,  category_N ,  state.lex , getStandardFeatures( state.lex ,  category_N , nounInflectCode( state.lex )));
      }
 }


 void act1469( MorphState  state ) {
   if    (catPreTest( state ) &&
          ( ( state.connector  !=  null ) &&
            state.connector.equals( "-" ) &&
             ( state.word1  ==  word_To )) &&
          catPostTest( state ))
      { addCompoundSense( state.lex , dict.makeList( new Word[] { state.word1 ,  state.word2 }));
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] {});
      }
 }


 void act1470( MorphState  state ) {
    boolean  tempboolean1044 ;
   if    (catPreTest( state ))
      {  boolean  tempboolean1045 ;
       if    ( ( state.connector  !=  null ) &&
              state.connector.equals( "-" ) &&
              isFormOfCat( state.word1 ,  categorySet_Pastpart ))
           tempboolean1045  = LexiconUtil.isMembOfArray( state.word2 ,  wordSet_For );

       else   tempboolean1045  =  false ;
       if    ( tempboolean1045 )
           tempboolean1044  = catPostTest( state );

       else   tempboolean1044  =  false ;
      }

   else   tempboolean1044  =  false ;
   if    ( tempboolean1044 )
      { addCompoundSense( state.lex , dict.makeList( new Word[] { state.word1 ,  state.word2 }));
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] {});
      }
 }


 void act1471( MorphState  state ) {
   if    (catPreTest( state ) &&
          ( ( state.connector  !=  null ) &&
            state.connector.equals( "-" ) &&
            LexiconUtil.isMembOfArray( state.word1 ,  wordSet_Be$Have )) &&
          catPostTest( state ))
      { addCompoundSense( state.lex , dict.makeList( new Word[] { state.word1 ,  state.word2 }));
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] {});
      }
 }


 void act1472( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     ( ( state.connector  !=  null ) &&
       state.connector.equals( "-" ) &&
        ( state.word2  ==  word_Type )) &&
     testPostTest( state ));
 }


 void act1473( MorphState  state ) {
   if    (catPreTest( state ) &&
          isFormOfCat( state.word1 ,  categorySet_Npr$Adj ) &&
          catPostTest( state ))
      { state.lex.addIkoParent(dict.makeStructuredConcept( category_Adj , dict.makeList( new Value[] { word_Modified_By ,  state.word1 })));
       addCompoundSense( state.lex , dict.makeList( new Word[] { state.word1 ,  state.word2 }));
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] {});
      }
 }


 void act1474( MorphState  state ) {
   if    (catPreTest( state ) &&
          isFormOfCat( state.word1 ,  categorySet_Nn ) &&
          catPostTest( state ))
      { state.lex.addIkoParent(dict.makeStructuredConcept( category_N , dict.makeList( new Value[] { state.word2 , dict.makeList( new Value[] { word_Of ,  state.word1 })})));
       markDict( state ,  state.lex ,  atom_Entails ,  state.word1 ,  true );
       state.lex.addPrefixes( new Word[] { state.word1 });
       state.lex.addRoot( state.word2 );
       addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Icode ,  atom_$S });
      }
 }


 void act1475( MorphState  state ) {
   if    (catPreTest( state ) &&
          ( ( state.connector  !=  null ) &&
            state.connector.equals( "-" ) &&
            hyphenAdj( state.word2 ) &&
            LexiconUtil.isMembOfArray(state.word2.firstWord(),  wordSet_And$Or ) &&
            isRootOfCat(state.word2.restWords().firstWord(),  categorySet_V ) &&
             (state.word2.restWords().restWords() ==  null )) &&
          catPostTest( state ))
      { addCompoundSense( state.lex , (List)(addToRightCompoundEntries( state.word1 ,  state.word2 )));
       state.lex.addIkoParent(dict.makeStructuredConcept( category_Adj , dict.makeList( new Value[] { state.word1 , (Value)(state.word2.restWords().firstWord())})));
       state.lex.addRoot(dict.makeStructuredConcept( category_Adj , dict.makeList( new Value[] { state.word1 , (Value)(state.word2.restWords().firstWord())})));
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] {});
      }
 }


 void act1476( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (((   ( state.connector  ==  null ) &&
            ( ! ( sp_rulePrefixes.contains(state.word1.getWordString())) ) &&
           plausibleRoot( state.word2 )) ||
         ( ( state.connector  !=  null ) &&
           state.connector.equals( "-" ) &&
            ( ! ( sp_adjPrefixes.contains(state.word1.getWordString())) ))) &&
        ( ! ( state.word2.numeralp()) ) &&
        ( ! ( hyphenAdj( state.word2 )) ) &&
        ( ! (isPenaltyFormOfCat( state.word2 ,  categorySet_V ) &&
           isFormOfCat( state.word2 ,  categorySet_Adv ) &&
           isFormOfCat( state.word1 ,  categorySet_V )))) &&
     testPostTest( state ));
 }


 void act1477( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.addIkoParent(dict.makeStructuredConcept( category_V , dict.makeList( new Value[] { state.word2 , dict.makeList( new Value[] { word_Modified_By ,  state.word1 })})));
       state.lex.addPrefixes( new Word[] { state.word1 });
       state.lex.addRoot( state.word2 );
       addCompoundSense( state.lex , dict.makeList( new Word[] { state.word1 ,  state.word2 }));
       addCompoundCatSenses( state ,  category_V ,  state.word1 ,  state.word2 ,  category_V ,  state.connector );
      }
 }


 void act1478( MorphState  state ) {
   if    (catPreTest( state ) &&
          (isFormOfCat( state.word2 ,  categorySet_Prespart$Pastpa_Etc ) ||
            (isFormOfCat( state.word2 ,  categorySet_Adj ) &&
               ( ! ( LexiconUtil.isMembOfArray( state.word1 ,  wordSet_De$Re )) ))) &&
          catPostTest( state ))
      addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] {});
 }


 void act1479( MorphState  state ) {
   if    (catPreTest( state ) &&
          ((isFormOfCat( state.word2 ,  categorySet_Prespart ) ||
              (isFormOfCat( state.word2 ,  categorySet_Nm ) &&
                 ( ! ( LexiconUtil.isMembOfArray( state.word1 ,  wordSet_De$Re )) ))) &&
             ( ! ( isFormOfCat( state.word2 ,  categorySet_Nc )) )) &&
          catPostTest( state ))
      { state.lex.addIkoParent(dict.makeStructuredConcept( category_Nm , dict.makeList( new Value[] { state.word2 , dict.makeList( new Value[] { word_Modified_By ,  state.word1 })})));
       state.lex.addPrefixes( new Word[] { state.word1 });
       state.lex.addRoot( state.word2 );
       addCatSense( state ,  category_Nm ,  state.word2 , getStandardFeatures( state.word2 ,  category_Nm , nounInflectCode( state.word2 )));
      }
 }


 void act1480( MorphState  state ) {
   if    (catPreTest( state ) &&
          (isFormOfCat( state.word2 ,  categorySet_Nc ) &&
             ( ! ( isFormOfCat( state.word2 ,  categorySet_Prespart$Nm )) )) &&
          catPostTest( state ))
      { state.lex.addIkoParent(dict.makeStructuredConcept( category_Nc , dict.makeList( new Value[] { state.word2 , dict.makeList( new Value[] { word_Modified_By ,  state.word1 })})));
       state.lex.addPrefixes( new Word[] { state.word1 });
       state.lex.addRoot( state.word2 );
       addCatSense( state ,  category_Nc ,  state.word2 , getStandardFeatures( state.word2 ,  category_Nc , nounInflectCode( state.word2 )));
      }
 }


 void act1481( MorphState  state ) {
   if    (catPreTest( state ) &&
          ((isFormOfCat( state.word2 ,  categorySet_Prespart ) ||
              (isFormOfCat( state.word2 ,  categorySet_Nm ) &&
                 ( ! ( LexiconUtil.isMembOfArray( state.word1 ,  wordSet_De$Re )) ))) &&
            isFormOfCat( state.word2 ,  categorySet_Nc )) &&
          catPostTest( state ))
      { state.lex.addIkoParent(dict.makeStructuredConcept( category_Ncm , dict.makeList( new Value[] { state.word2 , dict.makeList( new Value[] { word_Modified_By ,  state.word1 })})));
       state.lex.addPrefixes( new Word[] { state.word1 });
       state.lex.addRoot( state.word2 );
       addCatSense( state ,  category_Ncm ,  state.word2 , getStandardFeatures( state.word2 ,  category_Ncm , nounInflectCode( state.word2 )));
      }
 }


 void act1482( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     ((  ( state.connector  !=  null ) ||
          ( ! ( sp_rulePrefixes.contains(state.word1.getWordString())) )) &&
        ( ! ( LexiconUtil.isMembOfArray( state.word1 ,  wordSet_De$Re )) )) &&
     testPostTest( state ));
 }


 void act1483( MorphState  state ) {
   if    (catPreTest( state ) &&
          (isRootOfCat( state.word2 ,  categorySet_Adj ) ||
            (sp_adjFormingPrefixes.contains(state.word1.getWordString()) &&
              isRootOfCat( state.word2 ,  categorySet_Anyn ))) &&
          catPostTest( state ))
      {  List  tempList1046 ;
        List  tempList1047 ;
       if    (state.word2.isHyphenated())
          {  List  tempList1048 ;
           if     ((  tempList1048  = (List)(addToRightCompoundEntries( state.word1 ,  state.word2 )) ) !=  null )
               tempList1047  =  tempList1048 ;

           else   tempList1047  =  null ;
          }

       else   tempList1047  =  null ;
       if     ( tempList1047  !=  null )
           tempList1046  =  tempList1047 ;

       else   tempList1046  = dict.makeList( new Value[] {dict.makeList( new Value[] { state.word1 ,  state.word2 })});
       addCompoundSense( state.lex ,  tempList1046 );
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] {});
      }
 }


 void act1484( MorphState  state ) {
   if    (catPreTest( state ) &&
          (isFormOfCat( state.word2 ,  categorySet_Anyn ) &&
             ( ! (isPenaltyFormOfCat( state.word2 ,  categorySet_Anyn ,  2 ) &&
                isNonpenaltyFormOfCat( state.word2 ,  categorySet_Adj$V ))) &&
             (state.word2.getdict( feature_Guessed ) ==  null ) &&
             ( ! ( state.word2.isHyphenated()) )) &&
          catPostTest( state ))
      { state.lex.addPrefixes( new Word[] { state.word1 });
       state.lex.addRoot( state.word2 );
       addCompoundSense( state.lex , dict.makeList( new Word[] { state.word1 ,  state.word2 }));
       addCompoundCatSenses( state ,  category_N ,  state.word1 ,  state.word2 ,  category_N ,  state.connector );
      }
 }


 void act1485( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (LexiconUtil.isMembOfArray( state.word1 ,  wordSet_Self )) &&
     testPostTest( state ));
 }


 void act1486( MorphState  state ) {
   if    (catPreTest( state ) &&
          (isFormOfCat( state.word2 ,  categorySet_Anyn ) &&
             ( ! ( isFormOfCat( state.word2 ,  categorySet_Prespart )) ) &&
             ( ! (isPenaltyFormOfCat( state.word2 ,  categorySet_Anyn ,  2 ) &&
                isNonpenaltyFormOfCat( state.word2 ,  categorySet_Adj$V ))) &&
             (state.word2.getdict( feature_Guessed ) ==  null ) &&
             ( ! ( state.word2.isHyphenated()) )) &&
          catPostTest( state ))
      { state.lex.addPrefixes( new Word[] { state.word1 });
       state.lex.addRoot( state.word2 );
       addCompoundSense( state.lex , dict.makeList( new Word[] { state.word1 ,  state.word2 }));
       addCompoundCatSenses( state ,  category_N ,  state.word1 ,  state.word2 ,  category_N ,  state.connector );
      }
 }


 void act1487( MorphState  state ) {
   if    (catPreTest( state ) &&
          ( ( state.connector  !=  null ) &&
            state.connector.equals( "-" ) &&
            (isFormOfCat( state.word1 ,  categorySet_Integer ) ||
            		LexiconUtil.isMembOfArray( state.word1 ,  wordSet_All$Many$So$Too )) &&
            notSuffix( state.word2 ,  wordSet_Er ) &&
             ( ! ( isFormOfCat( state.word2 ,  categorySet_Comparative )) )) &&
          catPostTest( state ))
      { addCompoundSense( state.lex , dict.makeList( new Word[] { state.word1 ,  state.word2 }));
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] {});
      }
 }


 void act1488( MorphState  state ) {
   if    (catPreTest( state ) &&
          ( ( ! ( state.word2.isHyphenated()) ) &&
            isFormOfCat( state.word2 ,  categorySet_Anyn ) &&
            state.word2.hasSuffix( wordSet_Er )) &&
          catPostTest( state ))
      { state.lex.addPrefixes( new Word[] { state.word1 });
       state.lex.addRoot( state.word2 );
       addCompoundSense( state.lex , dict.makeList( new Word[] { state.word1 ,  state.word2 }));
       addCatSense( state ,  category_N ,  state.word2 , getStandardFeatures( state.word2 ,  category_N , nounInflectCode( state.word2 )));
      }
 }


 void act1489( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     ( ( state.connector  !=  null ) &&
       state.connector.equals( "-" ) &&
       LexiconUtil.isMembOfArray( state.word1 ,  wordSet_East$North$Sout_Etc ) &&
       isKnownInstanceOf( state.word2 ,  word_Compass_Directi_Etc )) &&
     testPostTest( state ));
 }


 void act1490( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     ( ( state.connector  !=  null ) &&
       state.connector.equals( "-" ) &&
       LexiconUtil.isMembOfArray( state.word1 ,  wordSet_East$North$Sout_Etc ) &&
       ((LexiconUtil.isMembOfArray( state.word1 ,  wordSet_North$South ) &&
    		   LexiconUtil.isMembOfArray( state.word2 ,  wordSet_East$West )) ||
    		   LexiconUtil.isMembOfArray( state.word1 , state.word2.getFirstDecomposition())) &&
       isKnownInstanceOf( state.word2 ,  word_Compass_Directi_Etc )) &&
     testPostTest( state ));
 }


 void act1491( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.addIioParent( word_Compass_Directi_Etc );
       addCatSense( state ,  category_Adj$Pred ,  state.lex ,  new Value[] {});
      }
 }


 void act1492( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      addCatSense( state ,  category_Adv$Pred ,  state.lex ,  new Value[] {});
 }


 void act1493( MorphState  state ) {
   if    (catPreTest( state ) &&
          ( ( state.connector  !=  null ) &&
            state.connector.equals( "-" ) &&
             ( state.word2  ==  word_To$Be )) &&
          catPostTest( state ))
      { state.lex.addIkoParent(dict.makeStructuredConcept( category_N , dict.makeList( new Value[] { word_Future ,  state.word1 })));
       state.lex.addSuffixes( wordSet_To$Be );
       state.lex.addRoot( state.word1 );
       addCompoundSense( state.lex , dict.makeList( new Word[] { state.word1 ,  word_To$Be }));
       addCatSense( state ,  category_N ,  state.lex , getStandardFeatures( state.lex ,  category_N , nounInflectCode( state.lex )));
      }
 }


 void act1494( MorphState  state ) {
   if    (catPreTest( state ) &&
          ( ( state.connector  !=  null ) &&
            state.connector.equals( "-" ) &&
            hyphenAdj( state.word2 ) &&
            LexiconUtil.isMembOfArray(state.word2.firstWord(),  wordSet_And$Or ) &&
            isRootOfCat(state.word2.restWords().firstWord(),  categorySet_Adj ) &&
             (state.word2.restWords().restWords() ==  null )) &&
          catPostTest( state ))
      { state.lex.addIkoParent(dict.makeStructuredConcept( category_Adj , dict.makeList( new Value[] { state.word1 , (Value)(state.word2.restWords().firstWord())})));
       state.lex.addRoot(dict.makeStructuredConcept( category_Adj , dict.makeList( new Value[] { state.word1 , (Value)(state.word2.restWords().firstWord())})));
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] {});
      }
 }


 void act1495( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     ( ( state.connector  !=  null ) &&
       state.connector.equals( "-" ) &&
       hyphenAdj( state.word2 ) &&
       isFormOfCat(state.word2.firstWord(),  categorySet_Prep ) &&
       LexiconUtil.isMembOfArray(state.word2.firstWord(),  wordSet_To ) &&
       isFormOfCat(state.word2.restWords(),  categorySet_Anyn )) &&
     testPostTest( state ));
 }


 void act1496( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.addIkoParent( state.word2 );
       state.lex.addSuffixes( new Word[] { state.word2 });
       state.lex.addRoot( state.word1 );
       addCompoundSense( state.lex , dict.makeList( new Word[] { state.word1 ,  word_To , state.word2.restWords()}));
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] {});
      }
 }


 void act1497( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     ( ( state.connector  !=  null ) &&
       state.connector.equals( "-" ) &&
       hyphenAdj( state.word2 ) &&
       isFormOfCat(state.word2.firstWord(),  categorySet_Prep ) &&
       LexiconUtil.isMembOfArray(state.word2.firstWord(),  wordSet_To ) &&
       isFormOfCat(state.word2.restWords(),  categorySet_Anyn$V$Adj )) &&
     testPostTest( state ));
 }


 void act1498( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.addIkoParent( state.word1 );
       state.lex.addSuffixes( new Word[] { state.word2 });
       state.lex.addRoot( state.word1 );
       addCompoundSense( state.lex , dict.makeList( new Word[] { state.word1 ,  word_To , state.word2.restWords()}));
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] {});
      }
 }


 void act1499( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     ( ( state.connector  !=  null ) &&
       state.connector.equals( "-" ) &&
       hyphenAdj( state.word2 ) &&
       isFormOfCat(state.word2.firstWord(),  categorySet_Prep ) &&
       isRootOfCat( state.word1 ,  categorySet_Anyn )) &&
     testPostTest( state ));
 }


 void act1500( MorphState  state ) {
   if    (catPreTest( state ) &&
          ( ( ! ( LexiconUtil.isMembOfArray(state.word2.firstWord(),  wordSet_To )) ) &&
             ( ! ( ( state.word1  ==  word_Out ) &&
                 (state.word2.firstWord() ==  word_Of )))) &&
          catPostTest( state ))
      { state.lex.addIkoParent( state.word1 );
       state.lex.addSuffixes( new Word[] { state.word2 });
       state.lex.addRoot( state.word1 );
       addCompoundSense( state.lex , dict.makeList( new Word[] { state.word1 ,  state.word2 }));
       markDict( state ,  state.lex ,  atom_Inflects$At ,  word_1 ,  false );
       addCatSense( state ,  category_N ,  state.word1 , getStandardFeatures( state.word1 ,  category_N , nounInflectCode( state.word1 )));
      }
 }


 void act1501( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     ( ( state.connector  !=  null ) &&
       state.connector.equals( "-" ) &&
        (state.word1.getInflectionRoots() !=  null ) &&
       hyphenAdj( state.word2 ) &&
       isFormOfCat(state.word2.firstWord(),  categorySet_Prep )) &&
     testPostTest( state ));
 }


 void act1502( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.addIkoParent( state.word1 );
       addCatSense( state ,  category_N , morphPackLex( state , firstInflectionRoot(state.word1).getWordString(),  state.connector , state.word2.getWordString()),  new Value[] { atom_Number ,  atom_Pl });
      }
 }


 void act1503( MorphState  state ) {
   if    (catPreTest( state ) &&
          ( ( state.connector  !=  null ) &&
            state.connector.equals( "-" ) &&
            hyphenAdj( state.word2 ) &&
            LexiconUtil.isMembOfArray(state.word2.firstWord(),  wordSet_And$Or ) &&
            isRootOfCat(state.word2.restWords().firstWord(),  categorySet_Vt ) &&
             (state.word2.restWords().restWords() ==  null )) &&
          catPostTest( state ))
      { state.lex.addIkoParent(dict.makeStructuredConcept( category_Adj , dict.makeList( new Value[] {nodeSequenceFirst(morphInflect( state.word1 ,  atom_Able$Rule )), nodeSequenceFirst(morphInflect(state.word2.restWords().firstWord(),  atom_Able$Rule ))})));
       state.lex.addRoot(dict.makeStructuredConcept( category_Adj , dict.makeList( new Value[] { state.word1 , (Value)(state.word2.restWords().firstWord())})));
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] {});
      }
 }


 void act1504( MorphState  state ) {
   if    (catPreTest( state ) &&
          ( ( state.connector  !=  null ) &&
            state.connector.equals( "-" ) &&
            hyphenAdj( state.word2 ) &&
            LexiconUtil.isMembOfArray(state.word2.firstWord(),  wordSet_And$Or ) &&
            isRootOfCat(state.word2.restWords().firstWord(),  categorySet_Anyn ) &&
             (state.word2.restWords().restWords() ==  null )) &&
          catPostTest( state ))
      { state.lex.addIkoParent(dict.makeStructuredConcept( category_Adj , dict.makeList( new Value[] {(Value)(morphPackLex( state ,  "RELATED_TO_" , state.word1.getWordString())), (Value)(morphPackLex( state ,  "RELATED_TO_" , state.word2.restWords().firstWord().getWordString()))})));
       state.lex.addRoot(dict.makeStructuredConcept( category_Adj , dict.makeList( new Value[] { state.word1 , (Value)(state.word2.restWords().firstWord())})));
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] {});
      }
 }


 void act1505( MorphState  state ) {
    boolean  tempboolean1049 ;
   if    (catPreTest( state ))
      {  boolean  tempboolean1050 ;
        tempboolean1050  = LexiconUtil.isMembOfArray( state.word2 ,  wordSet_Who$What$When$W_Etc );
       if    ( tempboolean1050 )
           tempboolean1049  = catPostTest( state );

       else   tempboolean1049  =  false ;
      }

   else   tempboolean1049  =  false ;
   if    ( tempboolean1049 )
      { state.lex.addPrefixes( new Word[] { state.word1 });
       state.lex.addRoot( state.word2 );
       addCatSense( state ,  category_Adv ,  state.lex ,  new Value[] {});
      }
 }


 void act1506( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.addPrefixes( new Word[] { state.word1 });
       state.lex.addRoot( state.word2 );
       state.lex.addIkoParent( state.word1 );
       state.lex.addIkoParent( state.word2 );
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] {});
      }
 }


 void act1507( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.addPrefixes( new Word[] { state.word1 });
       state.lex.addRoot( state.word2 );
       state.lex.addIkoParent( state.word1 );
       state.lex.addIkoParent( state.word2 );
       addCatSense( state ,  category_Adv ,  state.lex ,  new Value[] {});
      }
 }


 void act1508( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (((   ( state.connector  ==  null ) &&
            ( ! ( sp_rulePrefixes.contains(state.word1.getWordString())) ) &&
           plausibleRoot( state.word2 )) ||
         ( ( state.connector  !=  null ) &&
        		 LexiconUtil.stringInArrayP( state.connector ,  stringArray_$$_ ))) &&
        sp_skipVerbForHyphenatedParticiples  &&
        ( ! ( hyphenAdj( state.word2 )) ) &&
        ( ! (isPenaltyFormOfCat( state.word2 ,  categorySet_V ) &&
           isNonpenaltyFormOfCat( state.word2 ,  categorySet_Adv ) &&
           isFormOfCat( state.word2 ,  categorySet_Prep ) &&
           isFormOfCat( state.word1 ,  categorySet_V ))) &&
        ( ! ( hasKnownCompoundRoot( state.word1 ,  "-" ,  state.word2 ,  category_V )) )) &&
     testPostTest( state ));
 }


 void act1509( MorphState  state ) {
   if    (catPreTest( state ) &&
          (isNonpenaltyFormOfCat( state.word2 ,  categorySet_Anyn ) &&
             ( ! (( sp_makeGerundFlag  &&
                  isFormOfCat( state.word2 ,  categorySet_Prespart )) ||
                isFormOfCat( state.word2 ,  categorySet_Nm )))) &&
          catPostTest( state ))
      { if    ( ! ( isPenaltyFormOfCat( state.word2 ,  categorySet_Anyn$Adj )) )
          state.lex.addIkoParent(dict.makeStructuredConcept( category_Nc , dict.makeList( new Value[] { state.word2 , dict.makeList( new Value[] { word_Modified_By ,  state.word1 })})));
       markDict( state ,  state.lex ,  atom_Entails ,  state.word1 ,  true );
       state.lex.addPrefixes( new Word[] { state.word1 });
       state.lex.addRoot( state.word2 );
       addCompoundSense( state.lex , dict.makeList( new Word[] { state.word1 ,  state.word2 }));
       addCatSense( state ,  category_Nc ,  state.word2 , getStandardFeatures( state.word2 ,  category_Nc , nounInflectCode( state.word2 )));
      }
 }


 void act1510( MorphState  state ) {
   if    (catPreTest( state ) &&
          ((  ( state.connector  ==  null ) ||
              state.connector.equals( "" )) &&
            isNonpenaltyFormOfCat( state.word1 ,  categorySet_V ) &&
            isRootOfCat( state.word1 ,  categorySet_V ) &&
             ( ! ( isNonpenaltyFormOfCat( state.word2 ,  categorySet_Anyn )) ) &&
             ( ! (( sp_makeGerundFlag  &&
                  isFormOfCat( state.word2 ,  categorySet_Prespart )) ||
                isFormOfCat( state.word2 ,  categorySet_Pastpart ) ||
                isFormOfCat( state.word2 ,  categorySet_Nm )))) &&
          catPostTest( state ))
      { addCompoundSense( state.lex , dict.makeList( new Word[] { state.word1 ,  state.word2 }));
       addCatSense( state ,  category_Nc ,  state.word2 , getStandardFeatures( state.word2 ,  category_Nc , nounInflectCode( state.word2 )));
      }
 }


 void act1511( MorphState  state ) {
   if    (catPreTest( state ) &&
           ( ! (isFormOfCat( state.word2 ,  categorySet_Anyn ) &&
              ( ( ! ( isFormOfCat( state.word2 ,  categorySet_Adj )) ) ||
                 (state.word2.getCatPenalty( category_Adj ) > state.word2.getCatPenalty( category_N )) ||
                 ( ! ( isRootOfCat( state.word2 ,  categorySet_Adj )) )))) &&
          catPostTest( state ))
      { if    ( ! ( isPenaltyFormOfCat( state.word2 ,  categorySet_Anyn$Adj )) )
          state.lex.addIkoParent(dict.makeStructuredConcept( category_Adj , dict.makeList( new Value[] { state.word2 , dict.makeList( new Value[] { word_Modified_By ,  state.word1 })})));
       markDict( state ,  state.lex ,  atom_Entails ,  state.word1 ,  true );
       state.lex.addPrefixes( new Word[] { state.word1 });
       state.lex.addRoot( state.word2 );
       addCompoundSense( state.lex , dict.makeList( new Word[] { state.word1 ,  state.word2 }));
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] {});
      }
 }


 void act1512( MorphState  state ) {
   if    (catPreTest( state ) &&
          ((  sp_makeGerundFlag  &&
              isFormOfCat( state.word2 ,  categorySet_Prespart )) ||
            ( sp_makeGerundFlag  &&
              isFormOfCat( state.word1 ,  categorySet_Prespart ) &&
              isFormOfCat( state.word2 ,  categorySet_Adj$Adv )) ||
            isFormOfCat( state.word2 ,  categorySet_Nm )) &&
          catPostTest( state ))
      { if   (isFormOfCat( state.word2 ,  categorySet_Nc ))
          { if    ( ! ( isPenaltyFormOfCat( state.word2 ,  categorySet_Anyn$Adj )) )
              state.lex.addIkoParent(dict.makeStructuredConcept( category_Nmc , dict.makeList( new Value[] { state.word2 , dict.makeList( new Value[] { word_Modified_By ,  state.word1 })})));
           markDict( state ,  state.lex ,  atom_Entails ,  state.word1 ,  true );
           state.lex.addPrefixes( new Word[] { state.word1 });
           state.lex.addRoot( state.word2 );
          }
       addCompoundSense( state.lex , dict.makeList( new Word[] { state.word1 ,  state.word2 }));
       addCatSense( state ,  category_Nmc ,  state.word2 , getStandardFeatures( state.word2 ,  category_Nmc , nounInflectCode( state.word2 )));
      }
 }


 void act1513( MorphState  state ) {
   if    (catPreTest( state ) &&
          (isFormOfCat( state.word1 ,  categorySet_Prespart ) &&
            isFormOfCat( state.word2 ,  categorySet_Adv )) &&
          catPostTest( state ))
      { addCompoundSense( state.lex , dict.makeList( new Word[] { state.word1 ,  state.word2 }));
       addCatSense( state ,  category_Adv ,  state.lex ,  new Value[] {});
      }
 }


 void act1514( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (((   ( state.connector  ==  null ) &&
           isFormOfCat( state.word1 ,  categorySet_Nn$Adj ) &&
            ( ! ( sp_rulePrefixes.contains(state.word1.getWordString())) ) &&
           plausibleRoot( state.word2 )) ||
         ( ( state.connector  !=  null ) &&
           state.connector.equals( "-" ))) &&
       isRootOfCat( state.word1 ,  categorySet_Adj$Anyn ) &&
        ( ! ( state.word2.numeralp()) ) &&
        ( ! ( state.word1.isHyphenated()) ) &&
        ( ! ( state.word2.isHyphenated()) ) &&
        ( ! ( LexiconUtil.isMembOfArray( state.word2 ,  wordSet_Man$Is$Are$Am$W_Etc )) ) &&
        ( ! ( LexiconUtil.isMembOfArray( state.word1 ,  wordSet_As$Bare )) ) &&
        ( ! (isPenaltyFormOfCat( state.word2 ,  categorySet_V ) &&
           isFormOfCat( state.word2 ,  categorySet_Adv ) &&
           isFormOfCat( state.word1 ,  categorySet_V ))) &&
        ( ! ( isFormOfCat( state.word2 ,  categorySet_Prespart )) ) &&
       ( ( ! ( isFormOfCat( state.word2 ,  categorySet_Pastpart )) ) ||
          ( ! ( isFormOfCat( state.word2 ,  categorySet_Past )) ) ||
         isIrregularVerbForm( state.word2 )) &&
        ( ! ( ( state.connector  !=  null ) &&
           state.connector.equals( "-" ) &&
           isNonpenaltyFormOfCat( state.word2 ,  categorySet_Nn$Adj ) &&
           isPenaltyFormOfCat( state.word2 ,  categorySet_V ) &&
           isRootOfCat( state.word2 ,  categorySet_V )))) &&
     testPostTest( state ));
 }


 void act1515( MorphState  state ) {
   if    (catPreTest( state ) &&
           ( ! (( ( state.connector  !=  null ) &&
                isNonpenaltyFormOfCat( state.word2 ,  categorySet_Adj$Anyn ) &&
                isPenaltyFormOfCat( state.word2 ,  categorySet_V ) &&
                isRootOfCat( state.word2 ,  categorySet_V )) ||
              ( ( state.connector  ==  null ) &&
            		  LexiconUtil.isMembOfArray( state.word2 ,  wordSet_See$Saw )))) &&
          catPostTest( state ))
      { state.lex.addIkoParent(dict.makeStructuredConcept( category_V , dict.makeList( new Value[] { state.word2 , dict.makeList( new Value[] { word_Modified_By ,  state.word1 })})));
       state.lex.addPrefixes( new Word[] { state.word1 });
       state.lex.addRoot( state.word2 );
       addCompoundSense( state.lex , dict.makeList( new Word[] { state.word1 ,  state.word2 }));
       addCompoundCatSenses( state ,  category_V ,  state.word1 ,  state.word2 ,  category_V ,  state.connector );
      }
 }


 void act1516( MorphState  state ) {
   if    (catPreTest( state ) &&
          ( ( state.connector  !=  null ) &&
            isFormOfCat( state.word2 ,  categorySet_Prespart$Pastpa_Etc$ )) &&
          catPostTest( state ))
      addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] {});
 }


 void act1517( MorphState  state ) {
   if    (catPreTest( state ) &&
          (isFormOfCat( state.word2 ,  categorySet_Prespart$Nm ) &&
             ( ! ( isFormOfCat( state.word2 ,  categorySet_Nc )) )) &&
          catPostTest( state ))
      { state.lex.addIkoParent(dict.makeStructuredConcept( category_Nm , dict.makeList( new Value[] { state.word2 , dict.makeList( new Value[] { word_Modified_By ,  state.word1 })})));
       markDict( state ,  state.lex ,  atom_Entails ,  state.word1 ,  true );
       state.lex.addPrefixes( new Word[] { state.word1 });
       state.lex.addRoot( state.word2 );
       addCompoundCatSenses( state ,  category_Nm ,  state.word1 ,  state.word2 ,  category_N ,  state.connector );
      }
 }


 void act1518( MorphState  state ) {
   if    (catPreTest( state ) &&
          (isFormOfCat( state.word2 ,  categorySet_Nc ) &&
             ( ! ( isFormOfCat( state.word2 ,  categorySet_Prespart$Nm )) )) &&
          catPostTest( state ))
      {  Word[]  tempWordSet1051 ;
       if    (isKnownKindOf( state.word2 ,  word_Fish_Bodypart ))
           tempWordSet1051  =  wordSet_$N$Fish ;

       else  if   (isKnownKindOf( state.word2 ,  word_Bird_Bodypart ))
           tempWordSet1051  =  wordSet_$N$Bird ;

       else  if   (isKnownKindOf( state.word2 ,  word_Part_Of_Plant ))
           tempWordSet1051  =  wordSet_$Nc$Plant$Veget_Etc ;

       else  if   (isKnownKindOf( state.word2 ,  word_Bodypart ))
          if    (isFormOfCat( state.word1 ,  categorySet_Prefix ) ||
                 isFormOfCat( state.word2 ,  categorySet_Suffix ))
              tempWordSet1051  =  wordSet_Bodypart ;

          else  if   (isKnownKindOf( state.word1 ,  word_Animal ))
             if    (patternCheck( state.word1 ,  pattern_S ) &&
                    mustBePluralNoun( state.word1 ))
                 tempWordSet1051  =  wordSet_$Nc$Plant$Veget_Etc ;

             else   tempWordSet1051  =  new Word[] { state.word2 };

          else   tempWordSet1051  =  wordSet_$N$Animal ;

       else   tempWordSet1051  =  new Word[] {dict.makeStructuredConcept( category_Nc , dict.makeList( new Value[] { state.word2 , dict.makeList( new Value[] { word_Modified_By ,  state.word1 })}))};
       state.lex.addIkoParents( tempWordSet1051 );
       markDict( state ,  state.lex ,  atom_Entails ,  state.word1 ,  true );
       state.lex.addPrefixes( new Word[] { state.word1 });
       state.lex.addRoot( state.word2 );
       addCompoundCatSenses( state ,  category_Nc ,  state.word1 ,  state.word2 ,  category_N ,  state.connector );
      }
 }


 void act1519( MorphState  state ) {
   if    (catPreTest( state ) &&
          (isFormOfCat( state.word2 ,  categorySet_Prespart$Nm ) &&
            isFormOfCat( state.word2 ,  categorySet_Nc )) &&
          catPostTest( state ))
      { state.lex.addIkoParent(dict.makeStructuredConcept( category_Ncm , dict.makeList( new Value[] { state.word2 , dict.makeList( new Value[] { word_Modified_By ,  state.word1 })})));
       markDict( state ,  state.lex ,  atom_Entails ,  state.word1 ,  true );
       state.lex.addPrefixes( new Word[] { state.word1 });
       state.lex.addRoot( state.word2 );
       addCompoundCatSenses( state ,  category_Ncm ,  state.word1 ,  state.word2 ,  category_N ,  state.connector );
      }
 }


 void act1520( MorphState  state ) {
   if    (catPreTest( state ) &&
          ( ( state.connector  !=  null ) &&
            state.connector.equals( "-" ) &&
             ( ! ( hasHyphenatedRootVerb( state.word1 ,  state.connector ,  state.word2 )) )) &&
          catPostTest( state ))
      { addCompoundSense( state.lex , dict.makeList( new Word[] { state.word1 ,  state.word2 }));
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] {});
      }
 }


 void act1521( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     ( ( state.connector  !=  null ) &&
       state.connector.equals( "-" ) &&
       (state.word2.numeralp() ||
          ( state.word2.getWordString().length()  ==  1 ) ||
         (isFormOfCat( state.word2 ,  categorySet_Npr$Number ) &&
            ( ! ( isFormOfCat( state.word2 ,  categorySet_Name )) )))) &&
     testPostTest( state ));
 }


 void act1522( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.addIkoParent(dict.makeStructuredConcept( category_N , dict.makeList( new Value[] { state.word1 , dict.makeList( new Value[] { word_Modified_By ,  state.word2 })})));
       state.lex.addSuffixes( new Word[] { state.word2 });
       state.lex.addRoot( state.word1 );
       addCompoundSense( state.lex , dict.makeList( new Word[] { state.word1 ,  state.word2 }));
       addCatSense( state ,  category_N ,  state.lex , getStandardFeatures( state.lex ,  category_N , nounInflectCode( state.lex )));
      }
 }


 void act1523( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     ( ( state.connector  !=  null ) &&
    		 LexiconUtil.stringInArrayP( state.connector ,  stringArray_$$_ ) &&
        ( ! ( isFormOfCat( state.word2 ,  categorySet_Anyn$V$Adj )) )) &&
     testPostTest( state ));
 }


 void act1524( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { addCompoundSense( state.lex , dict.makeList( new Word[] { state.word1 ,  state.word2 }));
       addCatSense( state ,  category_Prep ,  state.lex ,  new Value[] {});
      }
 }


 void act1525( MorphState  state ) {
   if    (catPreTest( state ) &&
          ( ( state.connector  !=  null ) &&
        		  LexiconUtil.stringInArrayP( state.connector ,  stringArray_$$_ )) &&
          catPostTest( state ))
      { state.lex.addIkoParent( state.word1 );
       markDict( state ,  state.lex ,  atom_Inflects$At ,  word_1 ,  false );
       addCatSense( state ,  category_Nm ,  state.word1 , getStandardFeatures( state.word1 ,  category_Nm , nounInflectCode( state.word1 )));
      }
 }


 void act1526( MorphState  state ) {
   if    (catPreTest( state ) &&
          ( ( state.connector  !=  null ) &&
        		  LexiconUtil.stringInArrayP( state.connector ,  stringArray_$$_ ) &&
            state.word2.looksLike( category_V ) &&
            isNonpenaltyFormOfCat( state.word1 ,  categorySet_Adv )) &&
          catPostTest( state ))
      { state.lex.addIkoParent(dict.makeStructuredConcept( category_V , dict.makeList( new Value[] { state.word2 , dict.makeList( new Value[] { word_Modified_By ,  state.word1 })})));
       markDict( state ,  state.lex ,  atom_Entails ,  state.word1 ,  true );
       state.lex.addPrefixes( new Word[] { state.word1 });
       state.lex.addRoot( state.word2 );
       addCompoundSense( state.lex , dict.makeList( new Word[] { state.word1 ,  state.word2 }));
       addCompoundCatSenses( state ,  category_V ,  state.word1 ,  state.word2 ,  category_V ,  state.connector );
      }
 }


 void act1527( MorphState  state ) {
   if    (catPreTest( state ) &&
          ( ( state.connector  ==  null ) &&
            isRootOfCat( state.word1 ,  categorySet_V ) &&
            isNonpenaltyFormOfCat( state.word2 ,  categorySet_Adv ) &&
             ( ! ( patternCheck( state.word2 ,  pattern_L$Y )) ) &&
             ( ! ( isNonpenaltyFormOfCat( state.word2 ,  categorySet_Anyn )) )) &&
          catPostTest( state ))
      { markDict( state ,  state.lex ,  atom_Entails , dict.makeStructuredConcept( category_N , dict.makeList( new Value[] { state.word1 ,  state.word2 })),  true );
       state.lex.addSuffixes( new Word[] { state.word2 });
       state.lex.addRoot( state.word1 );
       addCompoundSense( state.lex , dict.makeList( new Word[] { state.word1 ,  state.word2 }));
       addCatSense( state ,  category_N ,  state.lex , getStandardFeatures( state.lex ,  category_N , nounInflectCode( state.lex )));
      }
 }


 void act1528( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     ( ( state.connector  !=  null ) &&
       state.connector.equals( "-" ) &&
       isFormOfCat( state.word1 ,  categorySet_V ) &&
       isNonpenaltyFormOfCat( state.word2 ,  categorySet_Adv ) &&
        ( ! ( patternCheck( state.word2 ,  pattern_L$Y )) ) &&
        ( ! ( isNonpenaltyFormOfCat( state.word2 ,  categorySet_Anyn )) )) &&
     testPostTest( state ));
 }


 void act1529( MorphState  state ) {
   if    (catPreTest( state ) &&
          (isRootOfCat( state.word1 ,  categorySet_V ) ||
            isFormOfCat( state.word1 ,  categorySet_Prespart$Pastpa_Etc )) &&
          catPostTest( state ))
      addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] {});
 }


 void act1530( MorphState  state ) {
   if    (catPreTest( state ) &&
          isFormOfCat( state.word1 ,  categorySet_Prespart ) &&
          catPostTest( state ))
      addCatSense( state ,  category_Nm ,  state.lex ,  new Value[] { atom_Mass$Pure ,  atom_True ,  atom_Mass ,  atom_True ,  atom_Icode ,  atom_$S });
 }


 void act1531( MorphState  state ) {
   if    (catPreTest( state ) &&
          isRootOfCat( state.word1 ,  categorySet_V ) &&
          catPostTest( state ))
      addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Icode ,  atom_$S });
 }


 void act1532( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { markDict( state ,  state.lex ,  atom_Entails , dict.makeStructuredConcept( category_V , dict.makeList( new Value[] { state.word1 ,  state.word2 })),  true );
       state.lex.addSuffixes( new Word[] { state.word2 });
       state.lex.addRoot( state.word1 );
       markDict( state ,  state.lex ,  atom_Inflects$At ,  word_1 ,  false );
       addCompoundSense( state.lex , dict.makeList( new Word[] { state.word1 ,  state.word2 }));
       addCompSufCatSenses( state ,  category_V ,  state.word1 ,  state.word2 ,  category_V ,  state.connector );
      }
 }


 void act1533( MorphState  state ) {
   if    (catPreTest( state ) &&
          ( ( state.connector  !=  null ) &&
            state.connector.equals( "-" )) &&
          catPostTest( state ))
      { state.lex.addPrefixes( new Word[] { state.word1 });
       state.lex.addRoot( state.word2 );
       addCatSense( state ,  category_Adv ,  state.lex ,  new Value[] {});
      }
 }


 void act1534( MorphState  state ) {
   if    (catPreTest( state ) &&
          (isFormOfCat( state.word2 ,  categorySet_Anyn$V$Adj ) ||
            (isRootOfCat( state.word1 ,  categorySet_V ) &&
              isFormOfCat( state.word2 ,  categorySet_Adv ))) &&
          catPostTest( state ))
      { if   (isFormOfCat( state.word2 ,  categorySet_Adj$Anyn ) &&
               ( ! (isFormOfCat( state.word2 ,  categorySet_Adv$Prep ) &&
                  isPenaltyFormOfCat( state.word2 ,  categorySet_Adj$Anyn ))))
          { state.lex.addIkoParent(dict.makeStructuredConcept( category_Adj , dict.makeList( new Value[] { state.word2 , dict.makeList( new Value[] { word_Modified_By ,  state.word1 })})));
           state.lex.addPrefixes( new Word[] { state.word1 });
           state.lex.addRoot( state.word2 );
          }
       addCompoundSense( state.lex , dict.makeList( new Word[] { state.word1 ,  state.word2 }));
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] {});
      }
 }


 void act1535( MorphState  state ) {
   if    (catPreTest( state ) &&
          isFormOfCat( state.word2 ,  categorySet_Adv ) &&
          catPostTest( state ))
      { addCompoundSense( state.lex , dict.makeList( new Word[] { state.word1 ,  state.word2 }));
       addCatSense( state ,  category_Adv ,  state.lex ,  new Value[] {});
      }
 }


 void act1536( MorphState  state ) {
   if    (catPreTest( state ) &&
          ((isRootOfCat( state.word1 ,  categorySet_V ) &&
              isRootOfCat( state.word2 ,  categorySet_Adv )) ||
            (isFormOfCat( state.word2 ,  categorySet_Anyn ) &&
               ( ! (isFormOfCat( state.word2 ,  categorySet_Adv$Prep ) &&
                  isPenaltyFormOfCat( state.word2 ,  categorySet_Anyn ))))) &&
          catPostTest( state ))
      addCatSense( state ,  category_N ,  state.lex , getStandardFeatures( state.lex ,  category_N , nounInflectCode( state.lex )));
 }


 void act1537( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (isRootOfCat( state.word1 ,  categorySet_Anyn$V$Adj$Adv$_Etc ) &&
        ( ! (sp_rulePrefixes.contains(state.word1.getWordString())))) &&
     testPostTest( state ));
 }


 void act1538( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      addCompoundCatSenses( state ,  category_V ,  state.word1 ,  state.word2 ,  category_V ,  state.connector );
 }


 void act1539( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.addIkoParent(dict.makeStructuredConcept( category_Nm , dict.makeList( new Value[] { state.word2 , dict.makeList( new Value[] { word_Modified_By ,  state.word1 })})));
       markDict( state ,  state.lex ,  atom_Entails ,  state.word1 ,  true );
       state.lex.addPrefixes( new Word[] { state.word1 });
       state.lex.addRoot( state.word2 );
       addCompoundSense( state.lex , dict.makeList( new Word[] { state.word1 ,  state.word2 }));
       addCatSense( state ,  category_Nm ,  state.lex , getStandardFeatures( state.lex ,  category_Nm , nounInflectCode( state.lex )));
      }
 }


 void act1540( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (isRootOfCat( state.word1 ,  categorySet_Nn$V$Adj$Prefix_Etc ) &&
        ( ! ( isFormOfCat( state.word1 ,  categorySet_Pastpart )) ) &&
        ( ! ( LexiconUtil.isMembOfArray( state.word1 ,  wordSet_Bare )) ) &&
        ( ! ( state.word1.isHyphenated()) ) &&
        ( ! ( state.word2.isHyphenated()) ) &&
        ( ! (sp_rulePrefixes.contains(state.word1.getWordString())))) &&
     testPostTest( state ));
 }


 void act1541( MorphState  state ) {
   if    (catPreTest( state ) &&
          ( (getVRoots( state.word2 ) ==  null ) &&
             ( ! ( LexiconUtil.isMembOfArray( state.word2 ,  wordSet_Man )) )) &&
          catPostTest( state ))
      { state.lex.addIkoParent(dict.makeStructuredConcept( category_V , dict.makeList( new Value[] { state.word2 , dict.makeList( new Value[] { word_Modified_By ,  state.word1 })})));
       markDict( state ,  state.lex ,  atom_Entails ,  state.word1 ,  true );
       state.lex.addPrefixes( new Word[] { state.word1 });
       state.lex.addRoot( state.word2 );
       addCompoundSense( state.lex , dict.makeList( new Word[] { state.word1 ,  state.word2 }));
       addCompoundCatSenses( state ,  category_V ,  state.word1 ,  state.word2 ,  category_V ,  state.connector );
      }
 }


 void act1542( MorphState  state ) {
   if    (catPreTest( state ) &&
          (isFormOfCat( state.word2 ,  categorySet_Anyn ) &&
             (state.word2.getInflectionRoots() ==  null ) &&
             ( ! (isPenaltyFormOfCat( state.word2 ,  categorySet_Anyn ,  2 ) &&
                 ( ! ( isFormOfCat( state.word1 ,  categorySet_Prefix )) ) &&
                 ( ! ( isFormOfCat( state.word2 ,  categorySet_Suffix )) ) &&
                isNonpenaltyFormOfCat( state.word2 ,  categorySet_Adj$V ))) &&
             ( ! ( isFormOfCat( state.word1 ,  categorySet_Pastpart )) ) &&
            (isFormOfCat( state.word1 ,  categorySet_Anyn ) ||
              isRootOfCat( state.word1 ,  categorySet_V$Adj$Prefix ))) &&
          catPostTest( state ))
      {  Word[]  tempWordSet1055 ;
       if    (isKnownKindOf( state.word2 ,  word_Fish_Bodypart ))
           tempWordSet1055  =  wordSet_$N$Fish ;

       else  if   (isKnownKindOf( state.word2 ,  word_Bird_Bodypart ))
           tempWordSet1055  =  wordSet_$N$Bird ;

       else  if   (isKnownKindOf( state.word2 ,  word_Part_Of_Plant ))
           tempWordSet1055  =  wordSet_$Nc$Plant$Veget_Etc ;

       else  if   (isKnownKindOf( state.word2 ,  word_Bodypart ))
          if    (isFormOfCat( state.word1 ,  categorySet_Prefix ) ||
                 isFormOfCat( state.word2 ,  categorySet_Suffix ))
              tempWordSet1055  =  wordSet_Bodypart ;

          else  if   (isKnownKindOf( state.word1 ,  word_Animal ))
             if    (patternCheck( state.word1 ,  pattern_S ) &&
                    mustBePluralNoun( state.word1 ))
                 tempWordSet1055  =  wordSet_$Nc$Plant$Veget_Etc ;

             else   tempWordSet1055  =  new Word[] { state.word2 };

          else   tempWordSet1055  =  wordSet_$N$Animal ;

       else   tempWordSet1055  =  new Word[] {dict.makeStructuredConcept( category_N , dict.makeList( new Value[] { state.word2 , dict.makeList( new Value[] { word_Modified_By ,  state.word1 })}))};
       state.lex.addIkoParents( tempWordSet1055 );
       markDict( state ,  state.lex ,  atom_Entails ,  state.word1 ,  true );
       state.lex.addPrefixes( new Word[] { state.word1 });
       state.lex.addRoot( state.word2 );
       addCompoundSense( state.lex , dict.makeList( new Word[] { state.word1 ,  state.word2 }));
       addCompoundCatSenses( state ,  category_N ,  state.word1 ,  state.word2 ,  category_N ,  state.connector );
      }
 }


 void act1543( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (isRootOfCat( state.word1 ,  categorySet_Nn$V$Adj$Prefix_Etc ) &&
        ( ! ( isFormOfCat( state.word1 ,  categorySet_Pastpart )) ) &&
        ( ! ( LexiconUtil.isMembOfArray( state.word1 ,  wordSet_Bare )) ) &&
        ( ! ( state.word1.isHyphenated()) ) &&
        ( ! ( state.word2.isHyphenated()) ) &&
        ( ! (sp_rulePrefixes.contains(state.word1.getWordString()))) &&
        ( ! ( isFormOfCat( state.word2 ,  categorySet_Pastpart$Prespa_Etc )) )) &&
     testPostTest( state ));
 }


 void act1544( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.addPrefixes( new Word[] { state.word1 });
       state.lex.addRoot( state.word2 );
       addCompoundSense( state.lex , dict.makeList( new Word[] { state.word1 ,  state.word2 }));
       addCompoundCatSenses( state ,  category_V ,  state.word1 ,  state.word2 ,  category_V ,  state.connector );
      }
 }


 void act1545( MorphState  state ) {
   if    (catPreTest( state ) &&
          isFormOfCat( state.word2 ,  categorySet_Prespart$Pastpa_Etc$$ ) &&
          catPostTest( state ))
      addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] {});
 }


 void act1546( MorphState  state ) {
   if    (catPreTest( state ) &&
          (isFormOfCat( state.word2 ,  categorySet_Anyn$Prespart ) &&
             ( ! (isPenaltyFormOfCat( state.word2 ,  categorySet_Anyn ,  2 ) &&
                 ( ! ( isFormOfCat( state.word1 ,  categorySet_Prefix )) ) &&
                 ( ! ( isFormOfCat( state.word2 ,  categorySet_Suffix )) ) &&
                isNonpenaltyFormOfCat( state.word2 ,  categorySet_Adj$V ))) &&
             ( ! ( isFormOfCat( state.word1 ,  categorySet_Pastpart )) ) &&
            (isFormOfCat( state.word1 ,  categorySet_Anyn ) ||
              isRootOfCat( state.word1 ,  categorySet_V$Adj$Prefix ))) &&
          catPostTest( state ))
      {  Word[]  tempWordSet1059 ;
       if    (isKnownKindOf( state.word2 ,  word_Fish_Bodypart ))
           tempWordSet1059  =  wordSet_$N$Fish ;

       else  if   (isKnownKindOf( state.word2 ,  word_Bird_Bodypart ))
           tempWordSet1059  =  wordSet_$N$Bird ;

       else  if   (isKnownKindOf( state.word2 ,  word_Part_Of_Plant ))
           tempWordSet1059  =  wordSet_$Nc$Plant$Veget_Etc ;

       else  if   (isKnownKindOf( state.word2 ,  word_Bodypart ))
          if    (isFormOfCat( state.word1 ,  categorySet_Prefix ) ||
                 isFormOfCat( state.word2 ,  categorySet_Suffix ))
              tempWordSet1059  =  wordSet_Bodypart ;

          else  if   (isKnownKindOf( state.word1 ,  word_Animal ))
             if    (patternCheck( state.word1 ,  pattern_S ) &&
                    mustBePluralNoun( state.word1 ))
                 tempWordSet1059  =  wordSet_$Nc$Plant$Veget_Etc ;

             else   tempWordSet1059  =  new Word[] { state.word2 };

          else   tempWordSet1059  =  wordSet_$N$Animal ;

       else   tempWordSet1059  =  new Word[] {dict.makeStructuredConcept( category_N , dict.makeList( new Value[] { state.word2 , dict.makeList( new Value[] { word_Modified_By ,  state.word1 })}))};
       state.lex.addIkoParents( tempWordSet1059 );
       markDict( state ,  state.lex ,  atom_Entails ,  state.word1 ,  true );
       state.lex.addPrefixes( new Word[] { state.word1 });
       state.lex.addRoot( state.word2 );
       addCompoundSense( state.lex , dict.makeList( new Word[] { state.word1 ,  state.word2 }));
       addCompoundCatSenses( state ,  category_N ,  state.word1 ,  state.word2 ,  category_N ,  state.connector );
      }
 }


 void act1547( MorphState  state ) {
   if    (catPreTest( state ) &&
          (state.word2.looksLike( category_Adj ) &&
             ( ! ( isFormOfCat( state.word2 ,  categorySet_Comparative$Sup_Etc )) ) &&
             ( ! ( isFormOfCat( state.word2 ,  categorySet_Suffix )) )) &&
          catPostTest( state ))
      { state.lex.addIkoParent(dict.makeStructuredConcept( category_Adj , dict.makeList( new Value[] { state.word2 , dict.makeList( new Value[] { word_Modified_By ,  state.word1 })})));
       markDict( state ,  state.lex ,  atom_Entails ,  state.word1 ,  true );
       state.lex.addPrefixes( new Word[] { state.word1 });
       state.lex.addRoot( state.word2 );
       addCompoundSense( state.lex , dict.makeList( new Word[] { state.word1 ,  state.word2 }));
       addCompoundCatSenses( state ,  category_Adj ,  state.word1 ,  state.word2 ,  category_Adj ,  state.connector );
      }
 }


 void act1548( MorphState  state ) {
   if    (catPreTest( state ) &&
          (isRootOfCat( state.word2 ,  categorySet_Nn ) &&
             (state.word2.getInflectionRoots() ==  null ) &&
             (state.word2.getdict( feature_Guessed ) ==  null ) &&
             ( ! (isPenaltyFormOfCat( state.word2 ,  categorySet_Anyn ,  2 ) &&
                 ( ! ( isFormOfCat( state.word1 ,  categorySet_Prefix )) ) &&
                 ( ! ( isFormOfCat( state.word2 ,  categorySet_Suffix )) ) &&
                isNonpenaltyFormOfCat( state.word2 ,  categorySet_Adj$V ))) &&
            isRootOfCat( state.word1 ,  categorySet_Nn$V$Adj$Prefix_Etc ) &&
            ( ( ! ( isFormOfCat( state.word1 ,  categorySet_Prefix )) ) ||
              notSuffix( state.word2 ,  wordSet_Ism$Ist$Ity$Tio_Etc$$$ )) &&
             ( ! ( isFormOfCat( state.word1 ,  categorySet_Pastpart )) ) &&
             ( ! (sp_rulePrefixes.contains(state.word1.getWordString()))) &&
            (isFormOfCat( state.word1 ,  categorySet_Anyn ) ||
              isRootOfCat( state.word1 ,  categorySet_V$Adj$Prefix ))) &&
          catPostTest( state ))
      {  Word[]  tempWordSet1063 ;
       if    (isKnownKindOf( state.word2 ,  word_Fish_Bodypart ))
           tempWordSet1063  =  wordSet_$N$Fish ;

       else  if   (isKnownKindOf( state.word2 ,  word_Bird_Bodypart ))
           tempWordSet1063  =  wordSet_$N$Bird ;

       else  if   (isKnownKindOf( state.word2 ,  word_Part_Of_Plant ))
           tempWordSet1063  =  wordSet_$Nc$Plant$Veget_Etc ;

       else  if   (isKnownKindOf( state.word2 ,  word_Bodypart ))
          if    (isFormOfCat( state.word1 ,  categorySet_Prefix ) ||
                 isFormOfCat( state.word2 ,  categorySet_Suffix ))
              tempWordSet1063  =  wordSet_Bodypart ;

          else  if   (isKnownKindOf( state.word1 ,  word_Animal ))
             if    (patternCheck( state.word1 ,  pattern_S ) &&
                    mustBePluralNoun( state.word1 ))
                 tempWordSet1063  =  wordSet_$Nc$Plant$Veget_Etc ;

             else   tempWordSet1063  =  new Word[] { state.word2 };

          else   tempWordSet1063  =  wordSet_$N$Animal ;

       else   tempWordSet1063  =  new Word[] {dict.makeStructuredConcept( category_N , dict.makeList( new Value[] { state.word2 , dict.makeList( new Value[] { word_Modified_By ,  state.word1 })}))};
        List  tempList1067 ;
        List  tempList1068 ;
       if    (state.word1.isHyphenated())
          {  List  tempList1069 ;
           if     ((  tempList1069  = (List)(addToLeftCompoundEntries( state.word1 ,  state.word2 )) ) !=  null )
               tempList1068  =  tempList1069 ;

           else   tempList1068  =  null ;
          }

       else   tempList1068  =  null ;
       if     ( tempList1068  !=  null )
           tempList1067  =  tempList1068 ;

       else   tempList1067  = dict.makeList( new Value[] {dict.makeList( new Value[] { state.word1 ,  state.word2 })});
       state.lex.addIkoParents( tempWordSet1063 );
       markDict( state ,  state.lex ,  atom_Entails ,  state.word1 ,  true );
       state.lex.addPrefixes( new Word[] { state.word1 });
       state.lex.addRoot( state.word2 );
       addCompoundSense( state.lex ,  tempList1067 );
       addCompoundCatSenses( state ,  category_N ,  state.word1 ,  state.word2 ,  category_N ,  state.connector );
      }
 }


 void act1549( MorphState  state ) {
   if    (catPreTest( state ) &&
          ( ( ! (isPenaltyFormOfCat( state.word2 ,  categorySet_Anyn ,  2 ) &&
                isNonpenaltyFormOfCat( state.word2 ,  categorySet_Adj$V ))) &&
             (state.word2.getdict( feature_Guessed ) ==  null ) &&
            isRootOfCat( state.word1 ,  categorySet_Nn$V$Adj$Prefix_Etc ) &&
            ( ( ! ( isFormOfCat( state.word1 ,  categorySet_Prefix )) ) ||
              notSuffix( state.word2 ,  wordSet_Ism$Ist$Ity$Tio_Etc$$$ )) &&
             ( ! ( isFormOfCat( state.word1 ,  categorySet_Pastpart )) ) &&
             ( ! (sp_rulePrefixes.contains(state.word1.getWordString()))) &&
            (isFormOfCat( state.word1 ,  categorySet_Anyn ) ||
              isRootOfCat( state.word1 ,  categorySet_V$Adj$Prefix ))) &&
          catPostTest( state ))
      {  List  tempList1070 ;
        List  tempList1071 ;
       if    (state.word1.isHyphenated())
          {  List  tempList1072 ;
           if     ((  tempList1072  = (List)(addToLeftCompoundEntries( state.word1 ,  state.word2 )) ) !=  null )
               tempList1071  =  tempList1072 ;

           else   tempList1071  =  null ;
          }

       else   tempList1071  =  null ;
       if     ( tempList1071  !=  null )
           tempList1070  =  tempList1071 ;

       else   tempList1070  = dict.makeList( new Value[] {dict.makeList( new Value[] { state.word1 ,  state.word2 })});
       markDict( state ,  state.lex ,  atom_Entails ,  state.word1 ,  true );
       state.lex.addPrefixes( new Word[] { state.word1 });
       state.lex.addRoot( state.word2 );
       addCompoundSense( state.lex ,  tempList1070 );
       addCompoundCatSenses( state ,  category_N ,  state.word1 ,  state.word2 ,  category_N ,  state.connector );
      }
 }


 void act1550( MorphState  state ) {
   if    (testPreTest( state ))
      {  boolean  tempboolean1073 ;
       if    ( sp_tryCompoundParticiples )
          {  String  tempString1074 ;
           if     ( state.connector  !=  null )
               tempString1074  =  state.connector ;

           else   tempString1074  =  "" ;
            Word  apparentroot  = morphPackLex( state , state.word1.getWordString(),  tempString1074 , firstPastpartRoot(state.word2).getSenseWord().getWordString());
            tempboolean1073  = ( ( apparentroot  !=  word ) &&
             isRootOfCat( apparentroot ,  categorySet_V ));
          }

       else   tempboolean1073  =  false ;
       if    ( tempboolean1073 )
           state.testval  = testPostTest( state );

       else   state.testval  =  false ;
      }

   else   state.testval  =  false ;
 }


 void act1551( MorphState  state ) {
   if    (catPreTest( state ) &&
          ( ( state.connector  !=  null ) &&
            state.connector.equals( "-" )) &&
          catPostTest( state ))
      { state.lex.addIkoParent(dict.makeStructuredConcept( category_Adj , dict.makeList( new Value[] { state.word2 , dict.makeList( new Value[] { word_Modified_By ,  state.word1 })})));
       markDict( state ,  state.lex ,  atom_Entails ,  state.word1 ,  true );
       state.lex.addPrefixes( new Word[] { state.word1 });
       state.lex.addRoot( state.word2 );
       addCompoundSense( state.lex , dict.makeList( new Word[] { state.word1 ,  state.word2 }));
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] {});
      }
 }


 void act1552( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.addIkoParent(dict.makeStructuredConcept( category_Adj , dict.makeList( new Value[] { state.word2 , dict.makeList( new Value[] { word_Modified_By ,  state.word1 })})));
       markDict( state ,  state.lex ,  atom_Entails ,  state.word1 ,  true );
       state.lex.addPrefixes( new Word[] { state.word1 });
       state.lex.addRoot( state.word2 );
       addCompoundSense( state.lex , dict.makeList( new Word[] { state.word1 ,  state.word2 }));
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] {});
      }
 }


 void act1553( MorphState  state ) {
    boolean  tempboolean1075 ;
   if    (catPreTest( state ))
      {  boolean  tempboolean1076 ;
       if    ( sp_tryCompoundParticiples )
          {  String  tempString1077 ;
           if     ( state.connector  !=  null )
               tempString1077  =  state.connector ;

           else   tempString1077  =  "" ;
            Word  apparentroot  = morphPackLex( state , state.word1.getWordString(),  tempString1077 , firstPastpartRoot(state.word2).getSenseWord().getWordString());
           if    ( ( apparentroot  !=  state.lex ) &&
                  isRootOfCat( apparentroot ,  categorySet_Anyn ) &&
                   ( ! ( isRootOfCat( apparentroot ,  categorySet_V )) ))
              { state.lex.addIkoParent(dict.makeStructuredConcept( category_Adj , dict.makeList( new Value[] { word_With , dict.makeList( new Value[] { apparentroot })})));
               state.lex.addRoot( apparentroot );
                tempboolean1076  =  true ;
              }

           else   tempboolean1076  =  false ;
          }

       else   tempboolean1076  =  false ;
       if    ( tempboolean1076 )
           tempboolean1075  = catPostTest( state );

       else   tempboolean1075  =  false ;
      }

   else   tempboolean1075  =  false ;
   if    ( tempboolean1075 )
      { state.lex.addIkoParent( state.word2 );
       markDict( state ,  state.lex ,  atom_Entails ,  state.word1 ,  true );
       state.lex.addPrefixes( new Word[] { state.word1 });
       state.lex.addRoot( state.word2 );
       addCompoundSense( state.lex , dict.makeList( new Word[] { state.word1 ,  state.word2 }));
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] {});
      }
 }


 void act1554( MorphState  state ) {
   if    (catPreTest( state ) &&
          ( sp_tryCompoundParticiples  &&
            isNonpenaltyFormOfCat( state.word1 ,  categorySet_Anyn ) &&
             ( ! ( isRootOfCat( state.word1 ,  categorySet_Adj )) )) &&
          catPostTest( state ))
      { state.lex.addIkoParent(dict.makeStructuredConcept( category_Adj , dict.makeList( new Value[] { state.word2 , dict.makeList( new Value[] { word_Modified_By ,  state.word1 })})));
       state.lex.addPrefixes( new Word[] { state.word1 });
       state.lex.addRoot( state.word2 );
       addCompoundSense( state.lex , dict.makeList( new Word[] { state.word1 ,  state.word2 }));
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] {});
      }
 }


 void act1555( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
      ( ! ( isFormOfCat( state.word1 ,  categorySet_Prefix )) ) &&
     testPostTest( state ));
 }


 void act1556( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.addIkoParent( state.word2 );
       markDict( state ,  state.lex ,  atom_Entails ,  state.word1 ,  true );
       state.lex.addPrefixes( new Word[] { state.word1 });
       state.lex.addRoot( state.word2 );
       addCompoundSense( state.lex , dict.makeList( new Word[] { state.word1 ,  state.word2 }));
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] {});
      }
 }


 void act1557( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     ( ( ! ( isFormOfCat( state.word1 ,  categorySet_Prefix )) ) &&
        ( ! ( sp_rulePrefixes.contains(state.word1.getWordString())) )) &&
     testPostTest( state ));
 }


 void act1558( MorphState  state ) {
   if    (catPreTest( state ) &&
          ( sp_tryCompoundParticiples  &&
            isRootOfCat( state.word1 ,  categorySet_Adv )) &&
          catPostTest( state ))
      { state.lex.addIkoParent(dict.makeStructuredConcept( category_Adj , dict.makeList( new Value[] { state.word2 , dict.makeList( new Value[] { word_Modified_By ,  state.word1 })})));
       markDict( state ,  state.lex ,  atom_Entails ,  state.word1 ,  true );
       state.lex.addPrefixes( new Word[] { state.word1 });
       state.lex.addRoot( state.word2 );
       addCompoundSense( state.lex , dict.makeList( new Word[] { state.word1 ,  state.word2 }));
       addCatSense( state ,  category_Adj ,  state.lex ,  new Value[] {});
      }
 }


 void act1559( MorphState  state ) {
   if    (catPreTest( state ) &&
           (getVRoots( state.word2 ) ==  null ) &&
          catPostTest( state ))
      { state.lex.addIkoParent(dict.makeStructuredConcept( category_V , dict.makeList( new Value[] { state.word2 , dict.makeList( new Value[] { word_Modified_By ,  state.word1 })})));
       markDict( state ,  state.lex ,  atom_Entails ,  state.word1 ,  true );
       state.lex.addPrefixes( new Word[] { state.word1 });
       state.lex.addRoot( state.word2 );
       addCompoundSense( state.lex , dict.makeList( new Word[] { state.word1 ,  state.word2 }));
       addCompoundCatSenses( state ,  category_V ,  state.word1 ,  state.word2 ,  category_V ,  state.connector );
      }
 }


 void act1560( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { markDict( state ,  state.lex ,  atom_Entails ,  state.word1 ,  true );
       state.lex.addPrefixes( new Word[] { state.word1 });
       state.lex.addRoot( state.word2 );
       addCompoundSense( state.lex , dict.makeList( new Word[] { state.word1 ,  state.word2 }));
       addCompoundCatSenses( state ,  category_V ,  state.word1 ,  state.word2 ,  category_V ,  state.connector );
      }
 }


 void act1561( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (dict.isKnownWord( state.word1 ) &&
       dict.isKnownWord( state.word2 )) &&
     testPostTest( state ));
 }


 void act1562( MorphState  state ) {
   if    (catPreTest( state ) &&
          (isFormOfCat( state.word1 ,  categorySet_Femalefirstname ) ||
            isFormOfCat( state.word2 ,  categorySet_Femalefirstname )) &&
          catPostTest( state ))
      { state.lex.addPrefixes( new Word[] { state.word1 });
       state.lex.addRoot( state.word2 );
       addCompoundSense( state.lex , dict.makeList( new Word[] { state.word1 ,  state.word2 }));
       addCatSense( state ,  category_Femalefirstname ,  state.lex ,  new Value[] {});
      }
 }


 void act1563( MorphState  state ) {
   if    (catPreTest( state ) &&
          (isFormOfCat( state.word1 ,  categorySet_Malefirstname ) ||
            isFormOfCat( state.word2 ,  categorySet_Malefirstname )) &&
          catPostTest( state ))
      { state.lex.addPrefixes( new Word[] { state.word1 });
       state.lex.addRoot( state.word2 );
       addCompoundSense( state.lex , dict.makeList( new Word[] { state.word1 ,  state.word2 }));
       addCatSense( state ,  category_Malefirstname ,  state.lex ,  new Value[] {});
      }
 }


 void act1564( MorphState  state ) {
   if    (catPreTest( state ) &&
           ( ! (isFormOfCat( state.word1 ,  categorySet_Femalefirstname ) ||
              isFormOfCat( state.word2 ,  categorySet_Femalefirstname ) ||
              isFormOfCat( state.word1 ,  categorySet_Malefirstname ) ||
              isFormOfCat( state.word2 ,  categorySet_Malefirstname ))) &&
          catPostTest( state ))
      { state.lex.addPrefixes( new Word[] { state.word1 });
       state.lex.addRoot( state.word2 );
       addCompoundSense( state.lex , dict.makeList( new Word[] { state.word1 ,  state.word2 }));
       addCatSense( state ,  category_Firstname ,  state.lex ,  new Value[] {});
      }
 }


 void act1565( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     ( ( state.connector  !=  null ) &&
       state.connector.equals( "-" ) &&
        false ) &&
     testPostTest( state ));
 }


 void act1566( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.addSuffixes( new Word[] { state.word2 });
       state.lex.addPrefixes( new Word[] { state.word1 });
       addCompoundSense( state.lex , dict.makeList( new Word[] { state.word1 ,  state.word2 }));
       addCatSense( state ,  category_N ,  state.lex , getStandardFeatures( state.lex ,  category_N , nounInflectCode( state.lex )));
      }
 }


 void act1567( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { addCompoundSense( state.lex , dict.makeList( new Word[] { state.word1 ,  state.word2 }));
       addCatSense( state ,  category_Prefix ,  state.lex ,  new Value[] {});
      }
 }


 void act1568( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (state.root.numeralp() &&
       morphRoot( state ) &&
        (( state.root.numericalValue().intValue() %  10  ) ==  2 ) &&
        (( state.root.numericalValue().intValue() %  100  ) !=  12 )) &&
     testPostTest( state ));
 }


 void act1569( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.setNumericalValue(state.root.numericalValue());
       { state.lex.addIioParent( word_Fraction );
        addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Penalty ,  word_1 });
       }
      }
 }


 void act1570( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (state.root.numeralp() &&
       morphRoot( state ) &&
        (( state.root.numericalValue().intValue() %  10  ) ==  1 ) &&
        (( state.root.numericalValue().intValue() %  100  ) !=  11 )) &&
     testPostTest( state ));
 }


 void act1571( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.addIioParent( word_Ordinal );
       state.lex.setNumericalValue(state.root.numericalValue());
       addCatSense( state ,  category_Ord ,  state.lex ,  new Value[] {});
      }
 }


 void act1572( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.addIioParent( word_Fraction );
       addCatSense( state ,  category_N ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg ,  atom_Penalty ,  word_1 });
      }
 }


 void act1573( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.addIkoParent(dict.makeStructuredConcept( category_Adv , dict.makeList( new Value[] { word_In , dict.makeList( new Value[] { state.lex ,  word_Position })})));
       addCatSense( state ,  category_Adv ,  state.lex ,  new Value[] { atom_Penalty ,  word_2 });
      }
 }


 void act1574( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (state.root.numeralp() &&
       morphRoot( state ) &&
        (( state.root.numericalValue().intValue() %  10  ) ==  3 ) &&
        (( state.root.numericalValue().intValue() %  100  ) !=  13 )) &&
     testPostTest( state ));
 }


 void act1575( MorphState  state ) {
   if    (catPreTest( state ) &&
          (state.root.numeralp() &&
            morphRoot( state ) &&
             (( state.root.numericalValue().intValue() %  10  ) ==  2 ) &&
             (( state.root.numericalValue().intValue() %  100  ) !=  12 )) &&
          catPostTest( state ))
      { state.lex.setNumericalValue(state.root.numericalValue());
       addCatSense( state ,  category_N , morphPackLex( state , state.root.getWordString(),  "NDTH" ),  new Value[] { atom_Number ,  atom_Pl });
      }
 }


 void act1576( MorphState  state ) {
   if    (catPreTest( state ) &&
          (state.root.numeralp()) &&
          catPostTest( state ))
      { state.lex.setNumericalValue(state.root.numericalValue());
       addCatSense( state ,  category_N , morphPackLex( state , state.root.getWordString(),  "TH" ),  new Value[] { atom_Number ,  atom_Pl });
      }
 }


 void act1577( MorphState  state ) {
   if    (catPreTest( state ) &&
          (state.root.numeralp() &&
            morphRoot( state ) &&
             (( state.root.numericalValue().intValue() %  10  ) ==  1 ) &&
             (( state.root.numericalValue().intValue() %  100  ) !=  11 )) &&
          catPostTest( state ))
      { state.lex.setNumericalValue(state.root.numericalValue());
       addCatSense( state ,  category_N , morphPackLex( state , state.root.getWordString(),  "ST" ),  new Value[] { atom_Number ,  atom_Pl });
      }
 }


 void act1578( MorphState  state ) {
   if    (catPreTest( state ) &&
          (state.root.numeralp() &&
            morphRoot( state ) &&
             (( state.root.numericalValue().intValue() %  10  ) ==  2 ) &&
             (( state.root.numericalValue().intValue() %  100  ) !=  12 )) &&
          catPostTest( state ))
      { state.lex.setNumericalValue(state.root.numericalValue());
       addCatSense( state ,  category_N , morphPackLex( state , state.root.getWordString(),  "ND" ),  new Value[] { atom_Number ,  atom_Pl });
      }
 }


 void act1579( MorphState  state ) {
   if    (catPreTest( state ) &&
          (state.root.numeralp() &&
            morphRoot( state ) &&
             (( state.root.numericalValue().intValue() %  10  ) ==  3 ) &&
             (( state.root.numericalValue().intValue() %  100  ) !=  13 )) &&
          catPostTest( state ))
      { state.lex.setNumericalValue(state.root.numericalValue());
       addCatSense( state ,  category_N , morphPackLex( state , state.root.getWordString(),  "RD" ),  new Value[] { atom_Number ,  atom_Pl });
      }
 }


 void act1580( MorphState  state ) {
   if    (testPreTest( state ))
      {  boolean  tempboolean1078 ;
       if    (morphRoot( state ) &&
              isFormOfCat( state.root ,  categorySet_Number ))
          {  Number  denominator  = state.root.getNumericalFirstVal( atom_Denominator );
            tempboolean1078  = (denominator.equals((Integer) denominator ) &&
              (( denominator.intValue() %  10  ) ==  2 ));
          }

       else   tempboolean1078  =  false ;
       if    ( tempboolean1078 )
           state.testval  = testPostTest( state );

       else   state.testval  =  false ;
      }

   else   state.testval  =  false ;
 }


 void act1581( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.setNumericalValue(state.root.numericalValue());
       state.lex.addSuffixes( wordSet_Ndth );
       { state.lex.addIioParent( word_Fraction );
        addCatSense( state ,  category_Number ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg });
       }
      }
 }


 void act1582( MorphState  state ) {
   if    (testPreTest( state ))
      {  boolean  tempboolean1079 ;
       if    (morphRoot( state ) &&
              isFormOfCat( state.root ,  categorySet_Number ))
          {  Number  denominator  = state.root.getNumericalFirstVal( atom_Denominator );
            tempboolean1079  = (denominator.equals((Integer) denominator ));
          }

       else   tempboolean1079  =  false ;
       if    ( tempboolean1079 )
           state.testval  = testPostTest( state );

       else   state.testval  =  false ;
      }

   else   state.testval  =  false ;
 }


 void act1583( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.setNumericalValue(state.root.numericalValue());
       state.lex.addSuffixes( wordSet_Th );
       { state.lex.addIioParent( word_Fraction );
        addCatSense( state ,  category_Number ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg });
       }
      }
 }


 void act1584( MorphState  state ) {
   if    (testPreTest( state ))
      {  boolean  tempboolean1080 ;
       if    (morphRoot( state ) &&
              isFormOfCat( state.root ,  categorySet_Number ))
          {  Number  denominator  = state.root.getNumericalFirstVal( atom_Denominator );
            tempboolean1080  = (denominator.equals((Integer) denominator ) &&
              (( denominator.intValue() %  10  ) ==  1 ));
          }

       else   tempboolean1080  =  false ;
       if    ( tempboolean1080 )
           state.testval  = testPostTest( state );

       else   state.testval  =  false ;
      }

   else   state.testval  =  false ;
 }


 void act1585( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.setNumericalValue(state.root.numericalValue());
       state.lex.addSuffixes( wordSet_St );
       { state.lex.addIioParent( word_Fraction );
        addCatSense( state ,  category_Number ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg });
       }
      }
 }


 void act1586( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.setNumericalValue(state.root.numericalValue());
       state.lex.addSuffixes( wordSet_Nd );
       { state.lex.addIioParent( word_Fraction );
        addCatSense( state ,  category_Number ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg });
       }
      }
 }


 void act1587( MorphState  state ) {
   if    (testPreTest( state ))
      {  boolean  tempboolean1081 ;
       if    (morphRoot( state ) &&
              isFormOfCat( state.root ,  categorySet_Number ))
          {  Number  denominator  = state.root.getNumericalFirstVal( atom_Denominator );
            tempboolean1081  = (denominator.equals((Integer) denominator ) &&
              (( denominator.intValue() %  10  ) ==  3 ));
          }

       else   tempboolean1081  =  false ;
       if    ( tempboolean1081 )
           state.testval  = testPostTest( state );

       else   state.testval  =  false ;
      }

   else   state.testval  =  false ;
 }


 void act1588( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.setNumericalValue(state.root.numericalValue());
       state.lex.addSuffixes( wordSet_Rd );
       { state.lex.addIioParent( word_Fraction );
        addCatSense( state ,  category_Number ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg });
       }
      }
 }


 void act1589( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.setNumericalValue(state.root.numericalValue());
       state.lex.addSuffixes( wordSet_Ndths );
       { state.lex.addIioParent( word_Fraction );
        addCatSense( state ,  category_Number ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg });
       }
      }
 }


 void act1590( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.setNumericalValue(state.root.numericalValue());
       state.lex.addSuffixes( wordSet_Ths );
       { state.lex.addIioParent( word_Fraction );
        addCatSense( state ,  category_Number ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg });
       }
      }
 }


 void act1591( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.setNumericalValue(state.root.numericalValue());
       state.lex.addSuffixes( wordSet_Sts );
       { state.lex.addIioParent( word_Fraction );
        addCatSense( state ,  category_Number ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg });
       }
      }
 }


 void act1592( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.setNumericalValue(state.root.numericalValue());
       state.lex.addSuffixes( wordSet_Nds );
       { state.lex.addIioParent( word_Fraction );
        addCatSense( state ,  category_Number ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg });
       }
      }
 }


 void act1593( MorphState  state ) {
   if    (catPreTest( state ) &&
          catPostTest( state ))
      { state.lex.setNumericalValue(state.root.numericalValue());
       state.lex.addSuffixes( wordSet_Rds );
       { state.lex.addIioParent( word_Fraction );
        addCatSense( state ,  category_Number ,  state.lex ,  new Value[] { atom_Number ,  atom_Sg });
       }
      }
 }


 void act1594( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (morphRoot( state ) &&
       state.root.testIcode( category_N ,  atomSet_$S )) &&
     testPostTest( state ));
 }


 void act1596( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (morphRoot( state ) &&
       state.root.testIcode( category_N ,  atomSet_$Es )) &&
     testPostTest( state ));
 }


 void act1597( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (morphRoot( state ) &&
       state.root.testIcode( category_N ,  atomSet_$Apostrophe$S )) &&
     testPostTest( state ));
 }


 void act1599( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (morphRoot( state ) &&
       state.root.testIcode( category_N ,  atomSet_$Ves )) &&
     testPostTest( state ));
 }


 void act1601( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (morphRoot( state ) &&
       state.root.testIcode( category_N ,  atomSet_$Ces )) &&
     testPostTest( state ));
 }


 void act1603( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (morphRoot( state ) &&
       state.root.testIcode( category_N ,  atomSet_$$Es )) &&
     testPostTest( state ));
 }


 void act1605( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (morphRoot( state ) &&
       state.root.testIcode( category_N ,  atomSet_$Ies )) &&
     testPostTest( state ));
 }


 void act1607( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (morphRoot( state ) &&
       state.root.testIcode( category_N ,  atomSet_Nopl$Unique )) &&
     testPostTest( state ));
 }


 void act1608( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (morphRoot( state ) &&
       state.root.testIcode( category_N ,  atomSet_$En )) &&
     testPostTest( state ));
 }


 void act1609( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (morphRoot( state ) &&
       state.root.testIcode( category_N ,  atomSet_$Men )) &&
     testPostTest( state ));
 }


 void act1610( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (morphRoot( state ) &&
       state.root.testIcode( category_N ,  atomSet_$I )) &&
     testPostTest( state ));
 }


 void act1611( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (morphRoot( state ) &&
       state.root.testIcode( category_N ,  atomSet_$A )) &&
     testPostTest( state ));
 }


 void act1612( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (morphRoot( state ) &&
       state.root.testIcode( category_N ,  atomSet_Is$Es )) &&
     testPostTest( state ));
 }


 void act1613( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (morphRoot( state ) &&
       ( ( state.lex.getWordString().length()  <  3 ) ||
          ( ! ( Character.isLetter(state.lex.getWordString().charAt( state.lex.getWordString().length()  -  1 ))) ))) &&
     testPostTest( state ));
 }


 void act1614( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (morphRoot( state ) &&
       finalStress( state.root )) &&
     testPostTest( state ));
 }


 void act1615( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (morphRoot( state ) &&
       lastCharCapitalizedP( state )) &&
     testPostTest( state ));
 }


 void act1616( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (morphRoot( state ) &&
       isFormOfCat( state.lex ,  categorySet_Npr$Lastname$Fi_Etc )) &&
     testPostTest( state ));
 }


 void act1617( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     ( sp_inflectManMenFlag  &&
       morphRoot( state ) &&
       isRootOfCat( state.lex ,  categorySet_Anyn ) &&
       state.lex.hasRoot( word_Man )) &&
     testPostTest( state ));
 }


 void act1619( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
      sp_inflectManMenFlag  &&
     testPostTest( state ));
 }


 void act1621( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (morphRoot( state ) &&
        ( ! ( Character.isLetter(state.lex.getWordString().charAt( state.lex.getWordString().length()  -  1 ))) )) &&
     testPostTest( state ));
 }


 void act1622( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (morphRoot( state ) &&
       state.root.testIcode( category_V ,  atomSet_S$D$S$Ed$S$Ked$_Etc )) &&
     testPostTest( state ));
 }


 void act1623( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (morphRoot( state ) &&
       state.root.testIcode( category_V ,  atomSet_Es$Ed$Es$$Ed$Es_Etc$$$ )) &&
     testPostTest( state ));
 }


 void act1624( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (morphRoot( state ) &&
       state.root.testIcode( category_V ,  atomSet_$Es$$Ed )) &&
     testPostTest( state ));
 }


 void act1625( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (morphRoot( state ) &&
       state.root.testIcode( category_V ,  atomSet_Ies$Ied )) &&
     testPostTest( state ));
 }


 void act1626( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (morphRoot( state ) &&
       state.root.testIcode( category_V ,  atomSet_S$D )) &&
     testPostTest( state ));
 }


 void act1627( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (morphRoot( state ) &&
       state.root.testIcode( category_V ,  atomSet_S$Ked )) &&
     testPostTest( state ));
 }


 void act1629( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (morphRoot( state ) &&
       state.root.testIcode( category_V ,  atomSet_S$Ed$Es$Ed )) &&
     testPostTest( state ));
 }


 void act1631( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (morphRoot( state ) &&
       state.root.testIcode( category_V ,  atomSet_S$$Ed$Es$$Ed$$E_Etc$$ )) &&
     testPostTest( state ));
 }


 void act1633( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (morphRoot( state ) &&
       state.root.testIcode( category_V ,  atomSet_S$Ed$$Ed$Es$Ed$_Etc )) &&
     testPostTest( state ));
 }


 void act1635( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (morphRoot( state ) &&
        (state.root.getdict( feature_Compound$Of ) !=  null ) &&
       word2(state.root).testIcode( category_V ,  atomSet_S$$Ed$Es$$Ed$$E_Etc$$ )) &&
     testPostTest( state ));
 }


 void act1636( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (morphRoot( state ) &&
        (state.root.getPrefixes() ==  null )) &&
     testPostTest( state ));
 }


 void act1639( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (morphRoot( state ) &&
       state.lex.testIcode( category_V ,  atomSet_S$D ) &&
        ( ! ( isRootOfCat( state.root ,  categorySet_V )) )) &&
     testPostTest( state ));
 }


 void act1640( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (morphRoot( state ) &&
        ( ! ( isRootOfCat( state.root ,  categorySet_V$Anyn$Adj )) )) &&
     testPostTest( state ));
 }


 void act1642( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (morphRoot( state ) &&
       state.root.testIcode( category_V ,  atomSet_Es$Ed$S$Ed )) &&
     testPostTest( state ));
 }


 void act1643( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (morphRoot( state ) &&
       state.root.testIcode( category_V ,  atomSet_$Es$$Ed$Es$$Ed$_Etc )) &&
     testPostTest( state ));
 }


 void act1648( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (morphRoot( state ) &&
       state.root.testIcode( category_Adj ,  atomSet_R$St )) &&
     testPostTest( state ));
 }


 void act1649( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (morphRoot( state ) &&
       state.root.testIcode( category_Adj ,  atomSet_Ker$Kest )) &&
     testPostTest( state ));
 }


 void act1650( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (morphRoot( state ) &&
       state.root.testIcode( category_Adj ,  atomSet_Er$Est ) &&
        ( ! ( patternCheck( state.root ,  pattern_E )) )) &&
     testPostTest( state ));
 }


 void act1651( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (morphRoot( state ) &&
       state.root.testIcode( category_Adj ,  atomSet_$Er$$Est )) &&
     testPostTest( state ));
 }


 void act1652( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (morphRoot( state ) &&
       state.root.testIcode( category_Adj ,  atomSet_Ier$Iest )) &&
     testPostTest( state ));
 }


 void act1668( MorphState  state ) {
    state.testval  = (testPreTest( state ) &&
     (polysyllabic( state.root ) &&
       morphRoot( state ) &&
        (state.root.getPrefixes() ==  null )) &&
     testPostTest( state ));
 }

 /* (IN-PACKAGE USER) */

 boolean needFinalE( Word  word ) {
  /* need-final-e (word) tests a word that ends in e to see if the e
  could have been a silent e dropped before adding a suffix */
    boolean  tempboolean1001 ;
   {  tempboolean1001  =  false ;
    if     ( sp_needsFinalE  !=  null )
       for ( int  i  =  0 ;  i  <  sp_needsFinalE.length ;  i++ ) {
           BoolRule  brl  =  sp_needsFinalE[i] ;
          { if    (patternCheck( word ,  brl.pattern ))
                return   brl.boolv ;
          }
       }
     return   tempboolean1001 ;
   }
 }


 boolean needDoubleLetter( Word  word ) {
  /* need-double-letter (word) tests a word that ends in
  a consonant to see if it requires a doubled final
  letter before adding -ing -ed -er -est endings */
   if    (syllabic( word ) &&
           ( ! ( polysyllabic( word )) ))
      {  boolean  tempboolean1002 ;
        tempboolean1002  =  false ;
       if     ( sp_needsDoubleLetter  !=  null )
          for ( int  i  =  0 ;  i  <  sp_needsDoubleLetter.length ;  i++ ) {
              BoolRule  brl  =  sp_needsDoubleLetter[i] ;
             { if    (patternCheck( word ,  brl.pattern ))
                   return   brl.boolv ;
             }
          }
        return   tempboolean1002 ;
      }

   else   return   false ;
 }


 boolean isNonnameRootOfCat( Word  word ,  Category  cat ) {
  /* is-nonname-root-of-cat (word cat) tests whether
  word is a root in category cat other than by virtue
  of cat being n and word being a name. */
   if     ( ! ( category_N.subsumesCategory( cat )) )
       return  isRootOfCat( word ,  cat );

   else  if   (cat.equals( categorySet_Nc ))
       return  isRootOfCat( word ,  categorySet_Nnc );

   else  if   (cat.equals( categorySet_Nm ))
       return  isRootOfCat( word ,  categorySet_Nm );

   else   return  (isRootOfCat( word ,  cat ) &&
               isRootOfCat( word ,  categorySet_Nn ));
 }


 boolean plausibleComparativeRoot( Word  comproot ) {
  /* plausible-comparative-root (comproot) is a function
  used in morphological rules to check if a
  word looks plausible as a morphological
  root or a comparative or superlative adjective. */
    return  ( ( ! ( comproot.testIcode( category_Adj ,  atomSet_Nonscalar )) ) &&
            ( ! ( comproot.isHyphenated()) ));
 }


 boolean hyphenAdj( Word  word ) {
  /* hyphenadj (word) tests if word looks like a hypenated adjective modifier */
   {  boolean  hyphenflag  =  false ;
     boolean  letterflag  =  false ;
     boolean  punctflag  =  false ;
     char  chr ;
     String  wordstring  = word.getWordString();
    if     (wordstring.length() >  0 )
       for ( int  i  =  0 ;  i  < wordstring.length() -  1 ;  i++ ) {
           chr  = wordstring.charAt( i );
          if     ( chr  ==  '-' )
              hyphenflag  =  true ;

          else  if   (Character.isDigit( chr ))
             { /* empty statement here */ }

          else  if   (LexiconUtil.charInArrayP( chr ,  sp_punctuationChars ) &&
                  ( ! ( LexiconUtil.charInArrayP( chr ,  sp_internalHyphenChars )) ))
              punctflag  =  true ;

          else   letterflag  =  true ;
       }
     return  ( hyphenflag  &&
             letterflag  &&
             (wordstring.charAt( 0 ) !=  '-' ) &&
             (wordstring.charAt(( wordstring.length() -  1  )) !=  '-' ) &&
             ( !  punctflag ));
   }
 }

/* Originated pmartin 8 may 2001
 * this file started as a collection of stubs to make compilation of
 * morph code proceed until real conversion or construction of these
 * methods.
 *
 * Many have been filled in to varying degrees, and some have been moved to
 * MorphEngFns.java.
 *
 * waw 2005-0125 added skipChemName tests to isChemicalConstituent and chemicalNameTest
 * and changed calls to isFormOfCat and isNonnameFormOfCat in chemicalNameTest
 * waw 2004-0509 changed sp_chemPrefixes to chemPrefixes and sp_chemicalSuffixes
 * and corrected Lexicon.isMembOfArray calls to .contains to agree with new hashtable
 * waw & pm 2004-0804 merged two divergent versions
 * pmartin 7apr04 changed many hashtables to HashSets, moved isUndoableVerb
 *  to MorphEngFns, used HashSet to speed up isChemicalConstituent
 * waw 03-29-04 moved isKnownFormOfCat etc. to MorphEngine
 * waw 03-28-04 moved all but root-looping & chemical stuff to MorphEngFrame
 * waw 03-26-04 moved isKnownFormOfCat etc. to MorphEngFrame and added
 *   isKnownRootOfCat to the list (in MorphEngFrame).
 * pmartin 25 Jun 02 for moving Value out of Lexicon...
 *   and changing the sig of AddCatSense calls
 * pmartin 13aug01 bug fix to stop root looping in isChemicalConstituent 
 *
 */

// just the methods go here .. vars are in other "fake....jav" files


// The following method was in support of a temporary patch that is no
// longer used.  It's only use at the present is to run legacy Morph_en
// version 54, which had that patch.

 public void addRootRootWithAdjPrefix(Word lex, Word root){
     // used to avoid null root of root crash

      lex.applyFalseRoot(root); // tweaked pm 25mar04
//      lex.markDict( atom_False$Root, root, true);
      Word[] rootPrefixes = root.getPrefixes();
      lex.addPrefixes(rootPrefixes);
      Word modname  = LexiconUtil.firstVal(rootPrefixes).normalizeIfNumber();
      Word rootRoot = root.getRoot();
      if (rootRoot != null){
	  lex.addRoot(rootRoot);
	  if (modname != null) {
	      Word struct = dict.packLex("with_", modname.getWordString(),
			 "-", rootRoot.getWordString());
              lex.addIkoParent(dict.makeStructuredConcept(
			   struct,  category_Adj ,
			   dict.makeList( new Value[] {
			       word_With ,
				   dict.makeList( new Value[] {rootRoot,
			  	      dict.makeList( new Value[]
					  { word_Mod ,  modname })})})));

	  }
      }
  }
	  
// The following chemical stuff will eventually be moved to MorphEngFns

  /**
   * Applies the chemical name tests to the indicated word.
   */

  protected void doChemicalNameTest(Word testWord, MorphState state) {
    if (!skipChemName && chemicalNameTest(testWord)) {
      testWord.addInflectionCode(nounInflectCode(testWord));
      addCatSense(state, cat_nm, testWord, null);
    }
    return;
  }


public boolean isChemicalConstituent(Word cword){
    if (skipChemName) return false; // added by hand 01-25-05 waw
    return  isChemicalConstituent(cword, new HashSet());
}

public  boolean isChemicalConstituent( Word  word ,  HashSet passed ) {
  /* is-chemical-constituent (word &optional passed) tests 
  whether word is a chemical or a possible constituent
  of a chemical name. */
 
   if (traceFlag){
       if ((passed != null) && (passed.size() > 0)){
	   System.out.print("\n");
	   for (int i=0; i<passed.size(); i++) System.out.print("-");
       }
       System.out.print("isChemicalConstituent trying " + word);
   }

   if ((word.getWordString().length()  <=  2 ) ||
       passed.contains(word) ||
       nonChemicalConstituents.contains(word.getWordString())){
       if (traceFlag) System.out.println(" false0 for " + word);
       return false;
   }
    if ((LexiconUtil.isInList(word_Chemistry , 
			  (List)(word.getdict(feature_Domain)))) ||
	(LexiconUtil.intersectp(majorChemicalWords, word.getIioParents())) ||
	(LexiconUtil.intersectp(wholeChemicalWords, word.getIkoParents()) ) ||
	(LexiconUtil.valueArrayIntersectp(word.getdict(feature_Sense$Kinds), 
			       majorChemicalWords) ) ||
	(word.isKindOf(word_Chemical)) ){
	if (traceFlag) System.out.println(" true1 for " + word);
	return true;
    }

	/* note that it is important to use the no-morph options in 
	   the calls to isKindof and getAllRoots since otherwise, 
	   a purely hypothetical consideration of "noncla" in nonclass 
	   was doing a morph of "nonclum" that was being treated as 
	   a permanent known word.
	*/
    
    passed.add(word);

    Word[] wroots = word.getAllRoots();
    if (wroots != null)
	for (int i=0; i<wroots.length; i++) 
	    if (isChemicalConstituent(wroots[i] ,passed)){
		       if (traceFlag) System.out.println(" true2 for " + word);
		       return true;
	    }

    Word[] subs = word.getSubsenses();
    if (subs != null)
	for (int i=0; i<subs.length; i++) 
	    if (isChemicalConstituent(subs[i], passed)){
		if (traceFlag) System.out.println(" true3 for " + word);
		return true;
	    }

    if (traceFlag) System.out.println(" false4 for " + word);
    return   false ;
 }


public boolean chemicalNameTest(Word wd){
    /* tests  whether word is a run-together compound chemical name
       that is made from the concatenation of known words and prefixes.
       It makes the appropriate lexicon entry for word from those
       of the constituent words.
    */
    if (skipChemName) return false; // added by hand 01-25-05 waw
    String wdstr = wd.getWordString();
    int wdstrlen = wdstr.length();
    if ((wdstrlen < 5) ||       // longer than 4 chars
	(wdstr.indexOf("_") >= 0))     // no underbars allowed
	return false;

    for (int i=0; i<sp_barredChemicalEndings.length; i++)
	if (wdstr.endsWith(sp_barredChemicalEndings[i]))
	    return false;

    int rpos = wdstrlen;
    int wsize;
    Vector wordseq = new Vector();
    Vector wordpos = new Vector();
    Vector chemflags = new Vector();
    boolean chemflag = false;
    boolean thisChemFlag;
    int ipos = wdstrlen - sp_minimumCompoundLength;
    while (ipos>0) {
	Word word1 = dict.knownOrScratchWord(wdstr.substring(0,ipos));
	Word word2 = dict.getWord(wdstr.substring(ipos, rpos));
	if (traceFlag){ 
	    System.out.print("chemicalNameTest trying w1=" +
			     word1.getWordString() + " + w2= " + word2);
	    wsize = wordseq.size();
	    if (wsize > 0){
		System.out.print(" with ");
		for (int i = wsize-1; i>=0; i--) 
		    System.out.print(
		       ((Word)wordseq.elementAt(i)).getWordString() + " ");
	    }
	    System.out.println(" ");
	}
	if ((word2 != null) &&  //must be known
	    //   !(Lexicon.isMembOfArray(word2,sp_nonChemicalConstituents)) &&
	    !(nonChemicalConstituents.contains(word2.getWordString())) &&
	    !(leftCompoundExceptions.contains(word1.getWordString())) &&
	    //"non" at beginning ok only if applied to subseq pref or adj
	    // -- e.g., *nongold, *hyperacid, *hypoacid
	    ((wordseq.size() > 0) || 
	     !(chemPrefixes.contains(word1.getWordString()))) &&
//	     !(Lexicon.isMembOfArray(word1, chemPrefixes))) &&
	    (word1.syllabic()) &&
	    ((ipos >= sp_minimumCompoundLength) ||
	     // automatically go short for affixes
	     (isFormOfCat( word1 , category_Prefix$Suffix))) &&
	    (word2.syllabic()) &&
	    (dict.isKnownWord(word2)) &&
	    ((isFormOfCat( word2 , category_Suffix)) || 
	     // allow "en" in "methenamine"
	     ((wordseq.size() > 0) &&
	      (isFormOfCat( word2 , category_Prefix))) ||
	     // only prefixes if something is to the right
	     !(rightCompoundExceptions.contains(word2.getWordString()))) &&
	    (isNonnameFormOfCat( word2 , category_N$Adj$Prefix$Suffix)) &&
	    ((wordseq.size() > 0) || 
	     // either it's not the rightmost word
	     (isFormOfCat( word2 , category_Nm)) || 
	     //or is rightmost then it must be chem
	     (chemicalSuffixes.contains(word2.getWordString()))) &&
//	     (Lexicon.isMembOfArray(word2, sp_chemicalSuffixes))) && 
	    //or an allowed suffix
	    (!(sp_strongChemTestFlag) ||

	     word2.isInstanceOf(word_ChemNamePart))){

	    thisChemFlag = false;
	    if (isChemicalConstituent(word2)){
		if (traceFlag) System.out.println(word2 + " isChemConst");
		thisChemFlag = true;
		chemflag = true;
	    }
	    chemflags.addElement(new Boolean(thisChemFlag));
	    wordseq.addElement(word2);
	    wordpos.addElement(new Integer(rpos));


	    if (
		//(!Lexicon.isMembOfArray(word1, sp_nonChemicalConstituents)) &&
		!(nonChemicalConstituents.contains(word1.getWordString())) &&
		(dict.isKnownWord(word1)) &&
		(isNonnameFormOfCat( word1 , category_N$Adj$Prefix$Suffix)) &&
		// reject plurals and comparatives
		(isRootOfCat(word1 , category_N$Adj$Prefix$Suffix)) &&
		((chemflag) ||
		 (isChemicalConstituent(word1)))) {

		wordseq.addElement(word1);
		int wordseqlen = wordseq.size();
		Word[] phraseVal = new Word[wordseqlen];
		Value[] deriv = new Value[wordseqlen+1];
		deriv[0] = atom_ChemicalNameTest;
		Word temp;
		for (int i=0; i<wordseqlen; i++){
		    temp = (Word)wordseq.elementAt(wordseqlen-1-i);
		    phraseVal[i] = temp;
		    deriv[i+1] = temp;
		}
		wd.addtodictprop(feature_Derivation, dict.makeList(deriv));
		wd.addIkoParent(word_Chemical);
		wd.addCompoundOf(phraseVal);
		wd.addtodictprop(feature_Domain, word_Chemistry);
		if (phraseVal[0] == word_Ate){
		    wd.addWordCategory(category_Vt, 0);
		    wd.addInflectionCodes(atomSet_S$D$$S);
		}
                wd.addWordCategory(category_Nm, 0);
                wd.addInflectionCode(nounInflectCode(wd));
	        return true;
	    }else{
		rpos = ipos;
		ipos = rpos - 1;
	    }
	}else if (ipos > 1){
	    ipos --;
	}else if (wordseq.size() > 0){
	    int lastWordSeq = wordseq.size()-1;
	    rpos = ((Integer)wordpos.elementAt(lastWordSeq)).intValue();
	    wordpos.removeElementAt(lastWordSeq);
	    Word word0 = (Word)wordseq.elementAt(lastWordSeq);
	    wordseq.removeElementAt(lastWordSeq);		
	    ipos = rpos - 1 - word0.getWordString().length();
	    thisChemFlag = 
	    ((Boolean)chemflags.elementAt(lastWordSeq)).booleanValue();
	    chemflags.removeElementAt(lastWordSeq);
	    if ((chemflag) && (thisChemFlag)){ 
		// reset chemflag since it may have been set by removed word
		chemflag = false;
		for (int i=0; i<lastWordSeq; i++)
		    if (((Boolean)chemflags.elementAt(i)).booleanValue()){ 
		     chemflag = true;
		     break;
}
	    }
	}else return false;
    }
    return false;
  }



protected void act7(MorphState state) {
doOnly(sBlock, ":s-block", state);
}

protected void act8(MorphState state) {
doOnly(dBlock, ":d-block", state);
}

protected void act9(MorphState state) {
doOnly(eBlock, ":e-block", state);
}

protected void act10(MorphState state) {
doOnly(gBlock, ":g-block", state);
}

protected void act11(MorphState state) {
doOnly(lBlock, ":l-block", state);
}

protected void act12(MorphState state) {
doOnly(mBlock, ":m-block", state);
}

protected void act13(MorphState state) {
doOnly(nBlock, ":n-block", state);
}

protected void act14(MorphState state) {
doOnly(rBlock, ":r-block", state);
}

protected void act15(MorphState state) {
doOnly(tBlock, ":t-block", state);
}

protected void act16(MorphState state) {
doOnly(yBlock, ":y-block", state);
}

protected void act17(MorphState state) {
doOnly(cBlock, ":c-block", state);
}

protected void act18(MorphState state) {
doOnly(miscBlock, ":misc-block", state);
}

protected void act19(MorphState state) {
killRight(3, state);
}

protected void act20(MorphState state) {
addRight("x", state);
}

protected void act22(MorphState state) {
addRight("s", state);
}

protected void act24(MorphState state) {
killRight(1, state);
}

protected void act25(MorphState state) {
state.suffix = word_s;
}

protected void act28(MorphState state) {
addRight("f", state);
}

protected void act30(MorphState state) {
addRight("fe", state);
}

protected void act31(MorphState state) {
addRight("y", state);
}

protected void act33(MorphState state) {
state.suffix = word_ics;
}

protected void act37(MorphState state) {
addRight("o", state);
}

protected void act50(MorphState state) {
killRight(2, state);
}

protected void act54(MorphState state) {
addRight("is", state);
}

protected void act57(MorphState state) {
killRight(5, state);
}

protected void act58(MorphState state) {
state.suffix = word_ness;
}

protected void act61(MorphState state) {
killRight(4, state);
}

protected void act65(MorphState state) {
state.suffix = word_less;
}

protected void act68(MorphState state) {
addRight("e", state);
}

protected void act69(MorphState state) {
addRight("or", state);
}

protected void act70(MorphState state) {
state.suffix = word_ess;
}

protected void act72(MorphState state) {
addRight("er", state);
}

protected void act74(MorphState state) {
state.suffix = word_ress;
}

protected void act102(MorphState state) {
killRight(6, state);
}

protected void act103(MorphState state) {
state.suffix = word_itious;
}

protected void act106(MorphState state) {
state.suffix = word_ous;
}

protected void act107(MorphState state) {
addRight("n", state);
}

protected void act108(MorphState state) {
addRight("ity", state);
}

protected void act111(MorphState state) {
killRight(8, state);
}

protected void act113(MorphState state) {
killRight(7, state);
}

protected void act116(MorphState state) {
addRight("um", state);
}

protected void act117(MorphState state) {
addRight("a", state);
}

protected void act118(MorphState state) {
addRight("ic", state);
}

protected void act120(MorphState state) {
addRight("al", state);
}

protected void act121(MorphState state) {
addRight("ent", state);
}

protected void act126(MorphState state) {
state.suffix = word_aneous;
}

protected void act127(MorphState state) {
state.suffix = word_aceous;
}

protected void act132(MorphState state) {
addRight("on", state);
}

protected void act136(MorphState state) {
doTry(itisBlock, ":itis-block", state);
}

protected void act138(MorphState state) {
state.suffix = word_wards;
}

protected void act150(MorphState state) {
addRight("", state);
}

protected void act158(MorphState state) {
doOnly(defaultRule, ":default-rule", state);
}

protected void act187(MorphState state) {
state.suffix = word_ed;
}

protected void act194(MorphState state) {
addRight("us", state);
}

protected void act199(MorphState state) {
state.suffix = word_id;
}

protected void act225(MorphState state) {
addRight("en", state);
}

protected void act227(MorphState state) {
state.suffix = word_fold;
}

protected void act263(MorphState state) {
state.suffix = word_ward;
}

protected void act273(MorphState state) {
state.suffix = word_wise;
}

protected void act282(MorphState state) {
addRight("ive", state);
}

protected void act285(MorphState state) {
addRight("in", state);
}

protected void act287(MorphState state) {
addRight("ism", state);
}

protected void act290(MorphState state) {
addRight("i", state);
}

protected void act291(MorphState state) {
addRight("ia", state);
}

protected void act292(MorphState state) {
addRight("sis", state);
}

protected void act294(MorphState state) {
addRight("yze", state);
}

protected void act297(MorphState state) {
addRight("ize", state);
}

protected void act307(MorphState state) {
state.suffix = word_esque;
}

protected void act309(MorphState state) {
state.suffix = word_some;
}

protected void act312(MorphState state) {
state.suffix = word_ive;
}

protected void act313(MorphState state) {
state.suffix = word_ative;
}

protected void act314(MorphState state) {
addRight("eive", state);
}

protected void act315(MorphState state) {
state.suffix = word_tive;
}

protected void act316(MorphState state) {
addRight("b", state);
}

protected void act317(MorphState state) {
addRight("be", state);
}

protected void act318(MorphState state) {
addRight("de", state);
}

protected void act331(MorphState state) {
addRight("ion", state);
}

protected void act332(MorphState state) {
addRight("ance", state);
}

protected void act333(MorphState state) {
state.suffix = word_ule;
}

protected void act337(MorphState state) {
state.suffix = word_able;
}

protected void act341(MorphState state) {
addRight("ate", state);
}

protected void act342(MorphState state) {
addRight("t", state);
}

protected void act344(MorphState state) {
addRight("d", state);
}

protected void act373(MorphState state) {
addRight("l", state);
}

protected void act378(MorphState state) {
state.suffix = word_ure;
}

protected void act383(MorphState state) {
state.suffix = word_re;
}

protected void act386(MorphState state) {
state.suffix = word_age;
}

protected void act388(MorphState state) {
state.suffix = word_ence;
}

protected void act390(MorphState state) {
state.suffix = word_ance;
}

protected void act398(MorphState state) {
state.suffix = word_ee;
}

protected void act408(MorphState state) {
addRight("ous", state);
}

protected void act409(MorphState state) {
state.suffix = word_ose;
}

protected void act421(MorphState state) {
}

protected void act428(MorphState state) {
state.suffix = word_like;
}

protected void act450(MorphState state) {
addRight("ie", state);
}

protected void act451(MorphState state) {
state.suffix = word_ing;
}

protected void act468(MorphState state) {
state.suffix = word_ling;
}

protected void act484(MorphState state) {
addRight("ce", state);
}

protected void act527(MorphState state) {
addRight("ane", state);
}

protected void act539(MorphState state) {
addRight("le", state);
}

protected void act542(MorphState state) {
addRight("ze", state);
}

protected void act546(MorphState state) {
addRight("c", state);
}

protected void act553(MorphState state) {
killRight(0, state);
}

protected void act554(MorphState state) {
doTry(iformBlock, ":iform-block", state);
}

protected void act558(MorphState state) {
addRight("an", state);
}

protected void act572(MorphState state) {
doTry(tionBlock, ":tion-block", state);
}

protected void act588(MorphState state) {
killRight(9, state);
}

protected void act596(MorphState state) {
addRight("ation", state);
}

protected void act603(MorphState state) {
addRight("w", state);
}

protected void act604(MorphState state) {
state.suffix = word_ian;
}

protected void act606(MorphState state) {
addRight("we", state);
}

protected void act624(MorphState state) {
addRight("ey", state);
}

protected void act625(MorphState state) {
state.suffix = word_er;
}

protected void act633(MorphState state) {
state.suffix = word_ier;
}

protected void act642(MorphState state) {
addRight("ry", state);
}

protected void act694(MorphState state) {
addRight("r", state);
}

protected void act711(MorphState state) {
state.suffix = word_or;
}

protected void act724(MorphState state) {
state.suffix = word_eer;
}

protected void act736(MorphState state) {
doTry(estBlock, ":est-block", state);
}

protected void act740(MorphState state) {
state.suffix = word_ment;
}

protected void act750(MorphState state) {
addRight("tion", state);
}

protected void act761(MorphState state) {
addRight("ics", state);
}

protected void act772(MorphState state) {
addRight("m", state);
}

protected void act870(MorphState state) {
addRight("id", state);
}

protected void act895(MorphState state) {
addRight("al", state);
}

protected void act912(MorphState state) {
addRight("te", state);
}

protected void act954(MorphState state) {
addRight("acy", state);
}

protected void act967(MorphState state) {
addRight("cy", state);
}

protected void act980(MorphState state) {
state.suffix = word_ic;
}

protected void act1001(MorphState state) {
addRight("ian", state);
}

protected void act1017(MorphState state) {
state.suffix = word_ata;
}

protected void act1020(MorphState state) {
state.suffix = word_a;
}

protected void act1023(MorphState state) {
state.suffix = word_ista;
}

protected void act1040(MorphState state) {
state.suffix = word_ish;
}

protected void act1079(MorphState state) {
addRight("se", state);
}

protected void act1093(MorphState state) {
state.suffix = word_est;
}

protected void act1118(MorphState state) {
addRight("ex", state);
}

protected void act1120(MorphState state) {
addRight("ium", state);
}

protected void act1121(MorphState state) {
addRight("os", state);
}

protected void act1124(MorphState state) {
addRight("ary", state);
}

protected void act1131(MorphState state) {
addRight("oid", state);
}

protected void act1132(MorphState state) {
addRight("es", state);
}

protected void act1133(MorphState state) {
addRight("eum", state);
}

protected void act1134(MorphState state) {
addRight("ea", state);
}

protected void act1147(MorphState state) {
killLeft(1, state);
}

protected void act1149(MorphState state) {
doTry(aPrefixes, ":a-prefixes", state);
}

protected void act1150(MorphState state) {
doTry(bPrefixes, ":b-prefixes", state);
}

protected void act1151(MorphState state) {
doTry(cPrefixes, ":c-prefixes", state);
}

protected void act1152(MorphState state) {
doTry(dPrefixes, ":d-prefixes", state);
}

protected void act1153(MorphState state) {
doTry(ePrefixes, ":e-prefixes", state);
}

protected void act1154(MorphState state) {
doTry(hPrefixes, ":h-prefixes", state);
}

protected void act1155(MorphState state) {
doTry(iPrefixes, ":i-prefixes", state);
}

protected void act1156(MorphState state) {
doTry(mPrefixes, ":m-prefixes", state);
}

protected void act1157(MorphState state) {
doTry(nPrefixes, ":n-prefixes", state);
}

protected void act1158(MorphState state) {
doTry(oPrefixes, ":o-prefixes", state);
}

protected void act1159(MorphState state) {
doTry(pPrefixes, ":p-prefixes", state);
}

protected void act1160(MorphState state) {
doTry(rPrefixes, ":r-prefixes", state);
}

protected void act1161(MorphState state) {
doTry(sPrefixes, ":s-prefixes", state);
}

protected void act1162(MorphState state) {
doTry(tPrefixes, ":t-prefixes", state);
}

protected void act1163(MorphState state) {
doTry(uPrefixes, ":u-prefixes", state);
}

protected void act1164(MorphState state) {
doTry(miscPrefixes, ":misc-prefixes", state);
}

protected void act1165(MorphState state) {
doTry(lexicalPrefixRules, ":lexical-prefix-rules", state);
}

protected void act1166(MorphState state) {
killLeft(3, state);
}

protected void act1168(MorphState state) {
state.prefix = word_all;
}

protected void act1170(MorphState state) {
killLeft(4, state);
}

protected void act1171(MorphState state) {
state.prefix = word_allo;
}

protected void act1174(MorphState state) {
state.prefix = word_aero;
}

protected void act1181(MorphState state) {
state.prefix = word_ante;
}

protected void act1183(MorphState state) {
state.prefix = word_anti;
}

protected void act1185(MorphState state) {
state.prefix = word_ana;
}

protected void act1187(MorphState state) {
state.prefix = word_auto;
}

protected void act1188(MorphState state) {
killLeft(5, state);
}

protected void act1189(MorphState state) {
state.prefix = word_adeno;
}

protected void act1198(MorphState state) {
state.prefix = word_a;
}

protected void act1211(MorphState state) {
killLeft(2, state);
}

protected void act1213(MorphState state) {
state.prefix = word_an;
}

protected void act1218(MorphState state) {
state.prefix = word_ab;
}

protected void act1222(MorphState state) {
state.prefix = word_ad;
}

protected void act1227(MorphState state) {
state.prefix = word_be;
}

protected void act1232(MorphState state) {
state.prefix = word_bio;
}

protected void act1234(MorphState state) {
state.prefix = word_bi;
}

protected void act1237(MorphState state) {
state.prefix = word_back;
}

protected void act1243(MorphState state) {
state.prefix = word_bare;
}

protected void act1245(MorphState state) {
state.prefix = word_chemo;
}

protected void act1246(MorphState state) {
killLeft(7, state);
}

protected void act1247(MorphState state) {
state.prefix = word_counter;
}

protected void act1248(MorphState state) {
killLeft(6, state);
}

protected void act1249(MorphState state) {
state.prefix = word_contra;
}

protected void act1251(MorphState state) {
state.prefix = word_coco;
}

protected void act1253(MorphState state) {
state.prefix = word_co;
}

protected void act1254(MorphState state) {
state.prefix = word_demi;
}

protected void act1256(MorphState state) {
state.prefix = word_de;
}

protected void act1259(MorphState state) {
state.prefix = word_disco;
}

protected void act1261(MorphState state) {
state.prefix = word_dis;
}

protected void act1264(MorphState state) {
state.prefix = word_dia;
}

protected void act1266(MorphState state) {
state.prefix = word_dino;
}

protected void act1267(MorphState state) {
state.prefix = word_di;
}

protected void act1269(MorphState state) {
state.prefix = word_down;
}

protected void act1272(MorphState state) {
state.prefix = word_en;
}

protected void act1276(MorphState state) {
state.prefix = word_em;
}

protected void act1280(MorphState state) {
killRight(1, state);
}

protected void act1283(MorphState state) {
killRight(2, state);
}

protected void act1288(MorphState state) {
state.prefix = word_ex;
}

protected void act1289(MorphState state) {
state.prefix = word_extra;
}

protected void act1292(MorphState state) {
addLeft("in", state);
}

protected void act1296(MorphState state) {
state.prefix = word_hemi;
}

protected void act1297(MorphState state) {
state.prefix = word_here;
}

protected void act1299(MorphState state) {
state.prefix = word_hyper;
}

protected void act1300(MorphState state) {
state.prefix = word_hypno;
}

protected void act1301(MorphState state) {
state.prefix = word_hypo;
}

protected void act1302(MorphState state) {
addLeft("hyper", state);
}

protected void act1306(MorphState state) {
state.prefix = word_il;
}

protected void act1308(MorphState state) {
state.prefix = word_im;
}

protected void act1313(MorphState state) {
state.prefix = word_inter;
}

protected void act1314(MorphState state) {
state.prefix = word_intra;
}

protected void act1316(MorphState state) {
state.prefix = word_in;
}

protected void act1319(MorphState state) {
state.prefix = word_ir;
}

protected void act1320(MorphState state) {
state.prefix = word_inner;
}

protected void act1321(MorphState state) {
state.prefix = word_iso;
}

protected void act1324(MorphState state) {
state.prefix = word_mac;
}

protected void act1326(MorphState state) {
state.prefix = word_mc;
}

protected void act1329(MorphState state) {
state.prefix = word_mal;
}

protected void act1332(MorphState state) {
state.prefix = word_maxi;
}

protected void act1334(MorphState state) {
state.prefix = word_mid;
}

protected void act1336(MorphState state) {
state.prefix = word_mini;
}

protected void act1337(MorphState state) {
state.prefix = word_meso;
}

protected void act1338(MorphState state) {
state.prefix = word_mono;
}

protected void act1339(MorphState state) {
state.prefix = word_multi;
}

protected void act1341(MorphState state) {
state.prefix = word_mis;
}

protected void act1342(MorphState state) {
state.prefix = word_neo;
}

protected void act1343(MorphState state) {
state.prefix = word_neuro;
}

protected void act1344(MorphState state) {
state.prefix = word_non;
}

protected void act1349(MorphState state) {
state.prefix = word_no;
}

protected void act1352(MorphState state) {
state.prefix = word_octo;
}

protected void act1353(MorphState state) {
state.prefix = word_off;
}

protected void act1358(MorphState state) {
state.prefix = word_on;
}

protected void act1359(MorphState state) {
state.prefix = word_ortho;
}

protected void act1360(MorphState state) {
state.prefix = word_outer;
}

protected void act1363(MorphState state) {
state.prefix = word_out;
}

protected void act1367(MorphState state) {
state.prefix = word_over;
}

protected void act1373(MorphState state) {
state.prefix = word_oxy;
}

protected void act1374(MorphState state) {
state.prefix = word_o;
}

protected void act1375(MorphState state) {
state.prefix = word_paleo;
}

protected void act1376(MorphState state) {
state.prefix = word_pseudo;
}

protected void act1377(MorphState state) {
state.prefix = word_pan;
}

protected void act1378(MorphState state) {
state.prefix = word_para;
}

protected void act1379(MorphState state) {
state.prefix = word_petro;
}

protected void act1380(MorphState state) {
state.prefix = word_poly;
}

protected void act1381(MorphState state) {
state.prefix = word_post;
}

protected void act1383(MorphState state) {
state.prefix = word_photo;
}

protected void act1384(MorphState state) {
state.prefix = word_pyro;
}

protected void act1386(MorphState state) {
state.prefix = word_pre;
}

protected void act1390(MorphState state) {
state.prefix = word_pro;
}

protected void act1394(MorphState state) {
state.prefix = word_re;
}

protected void act1403(MorphState state) {
state.prefix = word_semi;
}

protected void act1408(MorphState state) {
state.prefix = word_step;
}

protected void act1410(MorphState state) {
state.prefix = word_sub;
}

protected void act1411(MorphState state) {
state.prefix = word_super;
}

protected void act1412(MorphState state) {
state.prefix = word_supra;
}

protected void act1414(MorphState state) {
state.prefix = word_trans;
}

protected void act1416(MorphState state) {
state.prefix = word_tri;
}

protected void act1417(MorphState state) {
state.prefix = word_there;
}

protected void act1418(MorphState state) {
state.prefix = word_ultra;
}

protected void act1419(MorphState state) {
state.prefix = word_under;
}

protected void act1421(MorphState state) {
state.prefix = word_un;
}

protected void act1435(MorphState state) {
state.prefix = word_uni;
}

protected void act1439(MorphState state) {
state.prefix = word_up;
}

protected void act1441(MorphState state) {
state.prefix = word_fore;
}

protected void act1445(MorphState state) {
state.prefix = word_gastro;
}

protected void act1447(MorphState state) {
state.prefix = word_geo;
}

protected void act1448(MorphState state) {
state.prefix = word_litho;
}

protected void act1449(MorphState state) {
state.prefix = word_quasi;
}

protected void act1450(MorphState state) {
state.prefix = word_quadri;
}

protected void act1452(MorphState state) {
state.prefix = word_vari;
}

protected void act1454(MorphState state) {
state.prefix = word1(state.lex);
}

protected void act1595(MorphState state) {
}

protected void act1598(MorphState state) {
addRight("'s", state);
}

protected void act1600(MorphState state) {
addRight("ves", state);
}

protected void act1602(MorphState state) {
addRight("ces", state);
}

protected void act1604(MorphState state) {
addRight("&es", state);
}

protected void act1606(MorphState state) {
addRight("ies", state);
}

protected void act1618(MorphState state) {
addRight("men", state);
}

protected void act1620(MorphState state) {
addRight("s-in-law", state);
}

protected void act1628(MorphState state) {
addRight("ked", state);
}

protected void act1630(MorphState state) {
addRight("ed", state);
}

protected void act1632(MorphState state) {
addRight("&ed", state);
}

protected void act1634(MorphState state) {
addRight("ied", state);
}

protected void act1637(MorphState state) {
addRight("ing", state);
}

protected void act1638(MorphState state) {
addRight("ying", state);
}

protected void act1641(MorphState state) {
addRight("king", state);
}

protected void act1644(MorphState state) {
addRight("&ing", state);
}

protected void act1645(MorphState state) {
addRight("ker", state);
}

protected void act1646(MorphState state) {
addRight("&er", state);
}

protected void act1647(MorphState state) {
addRight("ier", state);
}

protected void act1653(MorphState state) {
addRight("est", state);
}

protected void act1654(MorphState state) {
addRight("st", state);
}

protected void act1655(MorphState state) {
addRight("kest", state);
}

protected void act1656(MorphState state) {
addRight("&est", state);
}

protected void act1657(MorphState state) {
addRight("iest", state);
}

protected void act1658(MorphState state) {
addRight("ly", state);
}

protected void act1659(MorphState state) {
addRight("ily", state);
}

protected void act1660(MorphState state) {
addRight("-ly", state);
}

protected void act1661(MorphState state) {
addRight("kly", state);
}

protected void act1662(MorphState state) {
addRight("ness", state);
}

protected void act1663(MorphState state) {
addRight("iness", state);
}

protected void act1664(MorphState state) {
addRight("able", state);
}

protected void act1665(MorphState state) {
addRight("yable", state);
}

protected void act1666(MorphState state) {
addRight("kable", state);
}

protected void act1667(MorphState state) {
addRight("&able", state);
}

protected void doNumberedAction (int clauseNumber, MorphState state) {
 switch (clauseNumber) {
 case 1 : act1(state);
  break;
 case 2 : act2(state);
  break;
 case 3 : act3(state);
  break;
 case 4 : act4(state);
  break;
 case 5 : act5(state);
  break;
 case 6 : act6(state);
  break;
 case 7 : act7(state);
  break;
 case 8 : act8(state);
  break;
 case 9 : act9(state);
  break;
 case 10 : act10(state);
  break;
 case 11 : act11(state);
  break;
 case 12 : act12(state);
  break;
 case 13 : act13(state);
  break;
 case 14 : act14(state);
  break;
 case 15 : act15(state);
  break;
 case 16 : act16(state);
  break;
 case 17 : act17(state);
  break;
 case 18 : act18(state);
  break;
 case 19 : act19(state);
  break;
 case 20 : act20(state);
  break;
 case 21 : act21(state);
  break;
 case 22 : act22(state);
  break;
 case 23 : act23(state);
  break;
 case 24 : act24(state);
  break;
 case 25 : act25(state);
  break;
 case 26 : act26(state);
  break;
 case 27 : act27(state);
  break;
 case 28 : act28(state);
  break;
 case 29 : act29(state);
  break;
 case 30 : act30(state);
  break;
 case 31 : act31(state);
  break;
 case 32 : act32(state);
  break;
 case 33 : act33(state);
  break;
 case 34 : act34(state);
  break;
 case 35 : act35(state);
  break;
 case 36 : act36(state);
  break;
 case 37 : act37(state);
  break;
 case 38 : act38(state);
  break;
 case 39 : act39(state);
  break;
 case 40 : act40(state);
  break;
 case 41 : act41(state);
  break;
 case 42 : act42(state);
  break;
 case 43 : act43(state);
  break;
 case 44 : act44(state);
  break;
 case 45 : act45(state);
  break;
 case 46 : act46(state);
  break;
 case 47 : act47(state);
  break;
 case 48 : act48(state);
  break;
 case 49 : act49(state);
  break;
 case 50 : act50(state);
  break;
 case 51 : act51(state);
  break;
 case 52 : act52(state);
  break;
 case 53 : act53(state);
  break;
 case 54 : act54(state);
  break;
 case 55 : act55(state);
  break;
 case 56 : act56(state);
  break;
 case 57 : act57(state);
  break;
 case 58 : act58(state);
  break;
 case 59 : act59(state);
  break;
 case 60 : act60(state);
  break;
 case 61 : act61(state);
  break;
 case 62 : act62(state);
  break;
 case 63 : act63(state);
  break;
 case 64 : act64(state);
  break;
 case 65 : act65(state);
  break;
 case 66 : act66(state);
  break;
 case 67 : act67(state);
  break;
 case 68 : act68(state);
  break;
 case 69 : act69(state);
  break;
 case 70 : act70(state);
  break;
 case 71 : act71(state);
  break;
 case 72 : act72(state);
  break;
 case 73 : act73(state);
  break;
 case 74 : act74(state);
  break;
 case 75 : act75(state);
  break;
 case 76 : act76(state);
  break;
 case 77 : act77(state);
  break;
 case 78 : act78(state);
  break;
 case 79 : act79(state);
  break;
 case 80 : act80(state);
  break;
 case 81 : act81(state);
  break;
 case 82 : act82(state);
  break;
 case 83 : act83(state);
  break;
 case 84 : act84(state);
  break;
 case 85 : act85(state);
  break;
 case 86 : act86(state);
  break;
 case 87 : act87(state);
  break;
 case 88 : act88(state);
  break;
 case 89 : act89(state);
  break;
 case 90 : act90(state);
  break;
 case 91 : act91(state);
  break;
 case 92 : act92(state);
  break;
 case 93 : act93(state);
  break;
 case 94 : act94(state);
  break;
 case 95 : act95(state);
  break;
 case 96 : act96(state);
  break;
 case 97 : act97(state);
  break;
 case 98 : act98(state);
  break;
 case 99 : act99(state);
  break;
 case 100 : act100(state);
  break;
 case 101 : act101(state);
  break;
 case 102 : act102(state);
  break;
 case 103 : act103(state);
  break;
 case 104 : act104(state);
  break;
 case 105 : act105(state);
  break;
 case 106 : act106(state);
  break;
 case 107 : act107(state);
  break;
 case 108 : act108(state);
  break;
 case 109 : act109(state);
  break;
 case 110 : act110(state);
  break;
 case 111 : act111(state);
  break;
 case 112 : act112(state);
  break;
 case 113 : act113(state);
  break;
 case 114 : act114(state);
  break;
 case 115 : act115(state);
  break;
 case 116 : act116(state);
  break;
 case 117 : act117(state);
  break;
 case 118 : act118(state);
  break;
 case 119 : act119(state);
  break;
 case 120 : act120(state);
  break;
 case 121 : act121(state);
  break;
 case 122 : act122(state);
  break;
 case 123 : act123(state);
  break;
 case 124 : act124(state);
  break;
 case 125 : act125(state);
  break;
 case 126 : act126(state);
  break;
 case 127 : act127(state);
  break;
 case 128 : act128(state);
  break;
 case 129 : act129(state);
  break;
 case 130 : act130(state);
  break;
 case 131 : act131(state);
  break;
 case 132 : act132(state);
  break;
 case 133 : act133(state);
  break;
 case 134 : act134(state);
  break;
 case 135 : act135(state);
  break;
 case 136 : act136(state);
  break;
 case 137 : act137(state);
  break;
 case 138 : act138(state);
  break;
 case 139 : act139(state);
  break;
 case 140 : act140(state);
  break;
 case 141 : act141(state);
  break;
 case 142 : act142(state);
  break;
 case 143 : act143(state);
  break;
 case 144 : act144(state);
  break;
 case 145 : act145(state);
  break;
 case 146 : act146(state);
  break;
 case 147 : act147(state);
  break;
 case 148 : act148(state);
  break;
 case 149 : act149(state);
  break;
 case 150 : act150(state);
  break;
 case 151 : act151(state);
  break;
 case 152 : act152(state);
  break;
 case 153 : act153(state);
  break;
 case 154 : act154(state);
  break;
 case 155 : act155(state);
  break;
 case 156 : act156(state);
  break;
 case 157 : act157(state);
  break;
 case 158 : act158(state);
  break;
 case 159 : act159(state);
  break;
 case 160 : act160(state);
  break;
 case 161 : act161(state);
  break;
 case 162 : act162(state);
  break;
 case 163 : act163(state);
  break;
 case 164 : act164(state);
  break;
 case 165 : act165(state);
  break;
 case 166 : act166(state);
  break;
 case 167 : act167(state);
  break;
 case 168 : act168(state);
  break;
 case 169 : act169(state);
  break;
 case 170 : act170(state);
  break;
 case 171 : act171(state);
  break;
 case 172 : act172(state);
  break;
 case 173 : act173(state);
  break;
 case 174 : act174(state);
  break;
 case 175 : act175(state);
  break;
 case 176 : act176(state);
  break;
 case 177 : act177(state);
  break;
 case 178 : act178(state);
  break;
 case 179 : act179(state);
  break;
 case 180 : act180(state);
  break;
 case 181 : act181(state);
  break;
 case 182 : act182(state);
  break;
 case 183 : act183(state);
  break;
 case 184 : act184(state);
  break;
 case 185 : act185(state);
  break;
 case 186 : act186(state);
  break;
 case 187 : act187(state);
  break;
 case 188 : act188(state);
  break;
 case 189 : act189(state);
  break;
 case 190 : act190(state);
  break;
 case 191 : act191(state);
  break;
 case 192 : act192(state);
  break;
 case 193 : act193(state);
  break;
 case 194 : act194(state);
  break;
 case 195 : act195(state);
  break;
 case 196 : act196(state);
  break;
 case 197 : act197(state);
  break;
 case 198 : act198(state);
  break;
 case 199 : act199(state);
  break;
 case 200 : act200(state);
  break;
 case 201 : act201(state);
  break;
 case 202 : act202(state);
  break;
 case 203 : act203(state);
  break;
 case 204 : act204(state);
  break;
 case 205 : act205(state);
  break;
 case 206 : act206(state);
  break;
 case 207 : act207(state);
  break;
 case 208 : act208(state);
  break;
 case 209 : act209(state);
  break;
 case 210 : act210(state);
  break;
 case 211 : act211(state);
  break;
 case 212 : act212(state);
  break;
 case 213 : act213(state);
  break;
 case 214 : act214(state);
  break;
 case 215 : act215(state);
  break;
 case 216 : act216(state);
  break;
 case 217 : act217(state);
  break;
 case 218 : act218(state);
  break;
 case 219 : act219(state);
  break;
 case 220 : act220(state);
  break;
 case 221 : act221(state);
  break;
 case 222 : act222(state);
  break;
 case 223 : act223(state);
  break;
 case 224 : act224(state);
  break;
 case 225 : act225(state);
  break;
 case 226 : act226(state);
  break;
 case 227 : act227(state);
  break;
 case 228 : act228(state);
  break;
 case 229 : act229(state);
  break;
 case 230 : act230(state);
  break;
 case 231 : act231(state);
  break;
 case 232 : act232(state);
  break;
 case 233 : act233(state);
  break;
 case 234 : act234(state);
  break;
 case 235 : act235(state);
  break;
 case 236 : act236(state);
  break;
 case 237 : act237(state);
  break;
 case 238 : act238(state);
  break;
 case 239 : act239(state);
  break;
 case 240 : act240(state);
  break;
 case 241 : act241(state);
  break;
 case 242 : act242(state);
  break;
 case 243 : act243(state);
  break;
 case 244 : act244(state);
  break;
 case 245 : act245(state);
  break;
 case 246 : act246(state);
  break;
 case 247 : act247(state);
  break;
 case 248 : act248(state);
  break;
 case 249 : act249(state);
  break;
 case 250 : act250(state);
  break;
 case 251 : act251(state);
  break;
 case 252 : act252(state);
  break;
 case 253 : act253(state);
  break;
 case 254 : act254(state);
  break;
 case 255 : act255(state);
  break;
 case 256 : act256(state);
  break;
 case 257 : act257(state);
  break;
 case 258 : act258(state);
  break;
 case 259 : act259(state);
  break;
 case 260 : act260(state);
  break;
 case 261 : act261(state);
  break;
 case 262 : act262(state);
  break;
 case 263 : act263(state);
  break;
 case 264 : act264(state);
  break;
 case 265 : act265(state);
  break;
 case 266 : act266(state);
  break;
 case 267 : act267(state);
  break;
 case 268 : act268(state);
  break;
 case 269 : act269(state);
  break;
 case 270 : act270(state);
  break;
 case 271 : act271(state);
  break;
 case 272 : act272(state);
  break;
 case 273 : act273(state);
  break;
 case 274 : act274(state);
  break;
 case 275 : act275(state);
  break;
 case 276 : act276(state);
  break;
 case 277 : act277(state);
  break;
 case 278 : act278(state);
  break;
 case 279 : act279(state);
  break;
 case 280 : act280(state);
  break;
 case 281 : act281(state);
  break;
 case 282 : act282(state);
  break;
 case 283 : act283(state);
  break;
 case 284 : act284(state);
  break;
 case 285 : act285(state);
  break;
 case 286 : act286(state);
  break;
 case 287 : act287(state);
  break;
 case 288 : act288(state);
  break;
 case 289 : act289(state);
  break;
 case 290 : act290(state);
  break;
 case 291 : act291(state);
  break;
 case 292 : act292(state);
  break;
 case 293 : act293(state);
  break;
 case 294 : act294(state);
  break;
 case 295 : act295(state);
  break;
 case 296 : act296(state);
  break;
 case 297 : act297(state);
  break;
 case 298 : act298(state);
  break;
 case 299 : act299(state);
  break;
 case 300 : act300(state);
  break;
 case 301 : act301(state);
  break;
 case 302 : act302(state);
  break;
 case 303 : act303(state);
  break;
 case 304 : act304(state);
  break;
 case 305 : act305(state);
  break;
 case 306 : act306(state);
  break;
 case 307 : act307(state);
  break;
 case 308 : act308(state);
  break;
 case 309 : act309(state);
  break;
 case 310 : act310(state);
  break;
 case 311 : act311(state);
  break;
 case 312 : act312(state);
  break;
 case 313 : act313(state);
  break;
 case 314 : act314(state);
  break;
 case 315 : act315(state);
  break;
 case 316 : act316(state);
  break;
 case 317 : act317(state);
  break;
 case 318 : act318(state);
  break;
 case 319 : act319(state);
  break;
 case 320 : act320(state);
  break;
 case 321 : act321(state);
  break;
 case 322 : act322(state);
  break;
 case 323 : act323(state);
  break;
 case 324 : act324(state);
  break;
 case 325 : act325(state);
  break;
 case 326 : act326(state);
  break;
 case 327 : act327(state);
  break;
 case 328 : act328(state);
  break;
 case 329 : act329(state);
  break;
 case 330 : act330(state);
  break;
 case 331 : act331(state);
  break;
 case 332 : act332(state);
  break;
 case 333 : act333(state);
  break;
 case 334 : act334(state);
  break;
 case 335 : act335(state);
  break;
 case 336 : act336(state);
  break;
 case 337 : act337(state);
  break;
 case 338 : act338(state);
  break;
 case 339 : act339(state);
  break;
 case 340 : act340(state);
  break;
 case 341 : act341(state);
  break;
 case 342 : act342(state);
  break;
 case 343 : act343(state);
  break;
 case 344 : act344(state);
  break;
 case 345 : act345(state);
  break;
 case 346 : act346(state);
  break;
 case 347 : act347(state);
  break;
 case 348 : act348(state);
  break;
 case 349 : act349(state);
  break;
 case 350 : act350(state);
  break;
 case 351 : act351(state);
  break;
 case 352 : act352(state);
  break;
 case 353 : act353(state);
  break;
 case 354 : act354(state);
  break;
 case 355 : act355(state);
  break;
 case 356 : act356(state);
  break;
 case 357 : act357(state);
  break;
 case 358 : act358(state);
  break;
 case 359 : act359(state);
  break;
 case 360 : act360(state);
  break;
 case 361 : act361(state);
  break;
 case 362 : act362(state);
  break;
 case 363 : act363(state);
  break;
 case 364 : act364(state);
  break;
 case 365 : act365(state);
  break;
 case 366 : act366(state);
  break;
 case 367 : act367(state);
  break;
 case 368 : act368(state);
  break;
 case 369 : act369(state);
  break;
 case 370 : act370(state);
  break;
 case 371 : act371(state);
  break;
 case 372 : act372(state);
  break;
 case 373 : act373(state);
  break;
 case 374 : act374(state);
  break;
 case 375 : act375(state);
  break;
 case 376 : act376(state);
  break;
 case 377 : act377(state);
  break;
 case 378 : act378(state);
  break;
 case 379 : act379(state);
  break;
 case 380 : act380(state);
  break;
 case 381 : act381(state);
  break;
 case 382 : act382(state);
  break;
 case 383 : act383(state);
  break;
 case 384 : act384(state);
  break;
 case 385 : act385(state);
  break;
 case 386 : act386(state);
  break;
 case 387 : act387(state);
  break;
 case 388 : act388(state);
  break;
 case 389 : act389(state);
  break;
 case 390 : act390(state);
  break;
 case 391 : act391(state);
  break;
 case 392 : act392(state);
  break;
 case 393 : act393(state);
  break;
 case 394 : act394(state);
  break;
 case 395 : act395(state);
  break;
 case 396 : act396(state);
  break;
 case 397 : act397(state);
  break;
 case 398 : act398(state);
  break;
 case 399 : act399(state);
  break;
 case 400 : act400(state);
  break;
 case 401 : act401(state);
  break;
 case 402 : act402(state);
  break;
 case 403 : act403(state);
  break;
 case 404 : act404(state);
  break;
 case 405 : act405(state);
  break;
 case 406 : act406(state);
  break;
 case 407 : act407(state);
  break;
 case 408 : act408(state);
  break;
 case 409 : act409(state);
  break;
 case 410 : act410(state);
  break;
 case 411 : act411(state);
  break;
 case 412 : act412(state);
  break;
 case 413 : act413(state);
  break;
 case 414 : act414(state);
  break;
 case 415 : act415(state);
  break;
 case 416 : act416(state);
  break;
 case 417 : act417(state);
  break;
 case 418 : act418(state);
  break;
 case 419 : act419(state);
  break;
 case 420 : act420(state);
  break;
 case 421 : act421(state);
  break;
 case 422 : act422(state);
  break;
 case 423 : act423(state);
  break;
 case 424 : act424(state);
  break;
 case 425 : act425(state);
  break;
 case 426 : act426(state);
  break;
 case 427 : act427(state);
  break;
 case 428 : act428(state);
  break;
 case 429 : act429(state);
  break;
 case 430 : act430(state);
  break;
 case 431 : act431(state);
  break;
 case 432 : act432(state);
  break;
 case 433 : act433(state);
  break;
 case 434 : act434(state);
  break;
 case 435 : act435(state);
  break;
 case 436 : act436(state);
  break;
 case 437 : act437(state);
  break;
 case 438 : act438(state);
  break;
 case 439 : act439(state);
  break;
 case 440 : act440(state);
  break;
 case 441 : act441(state);
  break;
 case 442 : act442(state);
  break;
 case 443 : act443(state);
  break;
 case 444 : act444(state);
  break;
 case 445 : act445(state);
  break;
 case 446 : act446(state);
  break;
 case 447 : act447(state);
  break;
 case 448 : act448(state);
  break;
 case 449 : act449(state);
  break;
 case 450 : act450(state);
  break;
 case 451 : act451(state);
  break;
 case 452 : act452(state);
  break;
 case 453 : act453(state);
  break;
 case 454 : act454(state);
  break;
 case 455 : act455(state);
  break;
 case 456 : act456(state);
  break;
 case 457 : act457(state);
  break;
 case 458 : act458(state);
  break;
 case 459 : act459(state);
  break;
 case 460 : act460(state);
  break;
 case 461 : act461(state);
  break;
 case 462 : act462(state);
  break;
 case 463 : act463(state);
  break;
 case 464 : act464(state);
  break;
 case 465 : act465(state);
  break;
 case 466 : act466(state);
  break;
 case 467 : act467(state);
  break;
 case 468 : act468(state);
  break;
 case 469 : act469(state);
  break;
 case 470 : act470(state);
  break;
 case 471 : act471(state);
  break;
 case 472 : act472(state);
  break;
 case 473 : act473(state);
  break;
 case 474 : act474(state);
  break;
 case 475 : act475(state);
  break;
 case 476 : act476(state);
  break;
 case 477 : act477(state);
  break;
 case 478 : act478(state);
  break;
 case 479 : act479(state);
  break;
 case 480 : act480(state);
  break;
 case 481 : act481(state);
  break;
 case 482 : act482(state);
  break;
 case 483 : act483(state);
  break;
 case 484 : act484(state);
  break;
 case 485 : act485(state);
  break;
 case 486 : act486(state);
  break;
 case 487 : act487(state);
  break;
 case 488 : act488(state);
  break;
 case 489 : act489(state);
  break;
 case 490 : act490(state);
  break;
 case 491 : act491(state);
  break;
 case 492 : act492(state);
  break;
 case 493 : act493(state);
  break;
 case 494 : act494(state);
  break;
 case 495 : act495(state);
  break;
 case 496 : act496(state);
  break;
 case 497 : act497(state);
  break;
 case 498 : act498(state);
  break;
 case 499 : act499(state);
  break;
 case 500 : act500(state);
  break;
 case 501 : act501(state);
  break;
 case 502 : act502(state);
  break;
 case 503 : act503(state);
  break;
 case 504 : act504(state);
  break;
 case 505 : act505(state);
  break;
 case 506 : act506(state);
  break;
 case 507 : act507(state);
  break;
 case 508 : act508(state);
  break;
 case 509 : act509(state);
  break;
 case 510 : act510(state);
  break;
 case 511 : act511(state);
  break;
 case 512 : act512(state);
  break;
 case 513 : act513(state);
  break;
 case 514 : act514(state);
  break;
 case 515 : act515(state);
  break;
 case 516 : act516(state);
  break;
 case 517 : act517(state);
  break;
 case 518 : act518(state);
  break;
 case 519 : act519(state);
  break;
 case 520 : act520(state);
  break;
 case 521 : act521(state);
  break;
 case 522 : act522(state);
  break;
 case 523 : act523(state);
  break;
 case 524 : act524(state);
  break;
 case 525 : act525(state);
  break;
 case 526 : act526(state);
  break;
 case 527 : act527(state);
  break;
 case 528 : act528(state);
  break;
 case 529 : act529(state);
  break;
 case 530 : act530(state);
  break;
 case 531 : act531(state);
  break;
 case 532 : act532(state);
  break;
 case 533 : act533(state);
  break;
 case 534 : act534(state);
  break;
 case 535 : act535(state);
  break;
 case 536 : act536(state);
  break;
 case 537 : act537(state);
  break;
 case 538 : act538(state);
  break;
 case 539 : act539(state);
  break;
 case 540 : act540(state);
  break;
 case 541 : act541(state);
  break;
 case 542 : act542(state);
  break;
 case 543 : act543(state);
  break;
 case 544 : act544(state);
  break;
 case 545 : act545(state);
  break;
 case 546 : act546(state);
  break;
 case 547 : act547(state);
  break;
 case 548 : act548(state);
  break;
 case 549 : act549(state);
  break;
 case 550 : act550(state);
  break;
 case 551 : act551(state);
  break;
 case 552 : act552(state);
  break;
 case 553 : act553(state);
  break;
 case 554 : act554(state);
  break;
 case 555 : act555(state);
  break;
 case 556 : act556(state);
  break;
 case 557 : act557(state);
  break;
 case 558 : act558(state);
  break;
 case 559 : act559(state);
  break;
 case 560 : act560(state);
  break;
 case 561 : act561(state);
  break;
 case 562 : act562(state);
  break;
 case 563 : act563(state);
  break;
 case 564 : act564(state);
  break;
 case 565 : act565(state);
  break;
 case 566 : act566(state);
  break;
 case 567 : act567(state);
  break;
 case 568 : act568(state);
  break;
 case 569 : act569(state);
  break;
 case 570 : act570(state);
  break;
 case 571 : act571(state);
  break;
 case 572 : act572(state);
  break;
 case 573 : act573(state);
  break;
 case 574 : act574(state);
  break;
 case 575 : act575(state);
  break;
 case 576 : act576(state);
  break;
 case 577 : act577(state);
  break;
 case 578 : act578(state);
  break;
 case 579 : act579(state);
  break;
 case 580 : act580(state);
  break;
 case 581 : act581(state);
  break;
 case 582 : act582(state);
  break;
 case 583 : act583(state);
  break;
 case 584 : act584(state);
  break;
 case 585 : act585(state);
  break;
 case 586 : act586(state);
  break;
 case 587 : act587(state);
  break;
 case 588 : act588(state);
  break;
 case 589 : act589(state);
  break;
 case 590 : act590(state);
  break;
 case 591 : act591(state);
  break;
 case 592 : act592(state);
  break;
 case 593 : act593(state);
  break;
 case 594 : act594(state);
  break;
 case 595 : act595(state);
  break;
 case 596 : act596(state);
  break;
 case 597 : act597(state);
  break;
 case 598 : act598(state);
  break;
 case 599 : act599(state);
  break;
 case 600 : act600(state);
  break;
 case 601 : act601(state);
  break;
 case 602 : act602(state);
  break;
 case 603 : act603(state);
  break;
 case 604 : act604(state);
  break;
 case 605 : act605(state);
  break;
 case 606 : act606(state);
  break;
 case 607 : act607(state);
  break;
 case 608 : act608(state);
  break;
 case 609 : act609(state);
  break;
 case 610 : act610(state);
  break;
 case 611 : act611(state);
  break;
 case 612 : act612(state);
  break;
 case 613 : act613(state);
  break;
 case 614 : act614(state);
  break;
 case 615 : act615(state);
  break;
 case 616 : act616(state);
  break;
 case 617 : act617(state);
  break;
 case 618 : act618(state);
  break;
 case 619 : act619(state);
  break;
 case 620 : act620(state);
  break;
 case 621 : act621(state);
  break;
 case 622 : act622(state);
  break;
 case 623 : act623(state);
  break;
 case 624 : act624(state);
  break;
 case 625 : act625(state);
  break;
 case 626 : act626(state);
  break;
 case 627 : act627(state);
  break;
 case 628 : act628(state);
  break;
 case 629 : act629(state);
  break;
 case 630 : act630(state);
  break;
 case 631 : act631(state);
  break;
 case 632 : act632(state);
  break;
 case 633 : act633(state);
  break;
 case 634 : act634(state);
  break;
 case 635 : act635(state);
  break;
 case 636 : act636(state);
  break;
 case 637 : act637(state);
  break;
 case 638 : act638(state);
  break;
 case 639 : act639(state);
  break;
 case 640 : act640(state);
  break;
 case 641 : act641(state);
  break;
 case 642 : act642(state);
  break;
 case 643 : act643(state);
  break;
 case 644 : act644(state);
  break;
 case 645 : act645(state);
  break;
 case 646 : act646(state);
  break;
 case 647 : act647(state);
  break;
 case 648 : act648(state);
  break;
 case 649 : act649(state);
  break;
 case 650 : act650(state);
  break;
 case 651 : act651(state);
  break;
 case 652 : act652(state);
  break;
 case 653 : act653(state);
  break;
 case 654 : act654(state);
  break;
 case 655 : act655(state);
  break;
 case 656 : act656(state);
  break;
 case 657 : act657(state);
  break;
 case 658 : act658(state);
  break;
 case 659 : act659(state);
  break;
 case 660 : act660(state);
  break;
 case 661 : act661(state);
  break;
 case 662 : act662(state);
  break;
 case 663 : act663(state);
  break;
 case 664 : act664(state);
  break;
 case 665 : act665(state);
  break;
 case 666 : act666(state);
  break;
 case 667 : act667(state);
  break;
 case 668 : act668(state);
  break;
 case 669 : act669(state);
  break;
 case 670 : act670(state);
  break;
 case 671 : act671(state);
  break;
 case 672 : act672(state);
  break;
 case 673 : act673(state);
  break;
 case 674 : act674(state);
  break;
 case 675 : act675(state);
  break;
 case 676 : act676(state);
  break;
 case 677 : act677(state);
  break;
 case 678 : act678(state);
  break;
 case 679 : act679(state);
  break;
 case 680 : act680(state);
  break;
 case 681 : act681(state);
  break;
 case 682 : act682(state);
  break;
 case 683 : act683(state);
  break;
 case 684 : act684(state);
  break;
 case 685 : act685(state);
  break;
 case 686 : act686(state);
  break;
 case 687 : act687(state);
  break;
 case 688 : act688(state);
  break;
 case 689 : act689(state);
  break;
 case 690 : act690(state);
  break;
 case 691 : act691(state);
  break;
 case 692 : act692(state);
  break;
 case 693 : act693(state);
  break;
 case 694 : act694(state);
  break;
 case 695 : act695(state);
  break;
 case 696 : act696(state);
  break;
 case 697 : act697(state);
  break;
 case 698 : act698(state);
  break;
 case 699 : act699(state);
  break;
 case 700 : act700(state);
  break;
 case 701 : act701(state);
  break;
 case 702 : act702(state);
  break;
 case 703 : act703(state);
  break;
 case 704 : act704(state);
  break;
 case 705 : act705(state);
  break;
 case 706 : act706(state);
  break;
 case 707 : act707(state);
  break;
 case 708 : act708(state);
  break;
 case 709 : act709(state);
  break;
 case 710 : act710(state);
  break;
 case 711 : act711(state);
  break;
 case 712 : act712(state);
  break;
 case 713 : act713(state);
  break;
 case 714 : act714(state);
  break;
 case 715 : act715(state);
  break;
 case 716 : act716(state);
  break;
 case 717 : act717(state);
  break;
 case 718 : act718(state);
  break;
 case 719 : act719(state);
  break;
 case 720 : act720(state);
  break;
 case 721 : act721(state);
  break;
 case 722 : act722(state);
  break;
 case 723 : act723(state);
  break;
 case 724 : act724(state);
  break;
 case 725 : act725(state);
  break;
 case 726 : act726(state);
  break;
 case 727 : act727(state);
  break;
 case 728 : act728(state);
  break;
 case 729 : act729(state);
  break;
 case 730 : act730(state);
  break;
 case 731 : act731(state);
  break;
 case 732 : act732(state);
  break;
 case 733 : act733(state);
  break;
 case 734 : act734(state);
  break;
 case 735 : act735(state);
  break;
 case 736 : act736(state);
  break;
 case 737 : act737(state);
  break;
 case 738 : act738(state);
  break;
 case 739 : act739(state);
  break;
 case 740 : act740(state);
  break;
 case 741 : act741(state);
  break;
 case 742 : act742(state);
  break;
 case 743 : act743(state);
  break;
 case 744 : act744(state);
  break;
 case 745 : act745(state);
  break;
 case 746 : act746(state);
  break;
 case 747 : act747(state);
  break;
 case 748 : act748(state);
  break;
 case 749 : act749(state);
  break;
 case 750 : act750(state);
  break;
 case 751 : act751(state);
  break;
 case 752 : act752(state);
  break;
 case 753 : act753(state);
  break;
 case 754 : act754(state);
  break;
 case 755 : act755(state);
  break;
 case 756 : act756(state);
  break;
 case 757 : act757(state);
  break;
 case 758 : act758(state);
  break;
 case 759 : act759(state);
  break;
 case 760 : act760(state);
  break;
 case 761 : act761(state);
  break;
 case 762 : act762(state);
  break;
 case 763 : act763(state);
  break;
 case 764 : act764(state);
  break;
 case 765 : act765(state);
  break;
 case 766 : act766(state);
  break;
 case 767 : act767(state);
  break;
 case 768 : act768(state);
  break;
 case 769 : act769(state);
  break;
 case 770 : act770(state);
  break;
 case 771 : act771(state);
  break;
 case 772 : act772(state);
  break;
 case 773 : act773(state);
  break;
 case 774 : act774(state);
  break;
 case 775 : act775(state);
  break;
 case 776 : act776(state);
  break;
 case 777 : act777(state);
  break;
 case 778 : act778(state);
  break;
 case 779 : act779(state);
  break;
 case 780 : act780(state);
  break;
 case 781 : act781(state);
  break;
 case 782 : act782(state);
  break;
 case 783 : act783(state);
  break;
 case 784 : act784(state);
  break;
 case 785 : act785(state);
  break;
 case 786 : act786(state);
  break;
 case 787 : act787(state);
  break;
 case 788 : act788(state);
  break;
 case 789 : act789(state);
  break;
 case 790 : act790(state);
  break;
 case 791 : act791(state);
  break;
 case 792 : act792(state);
  break;
 case 793 : act793(state);
  break;
 case 794 : act794(state);
  break;
 case 795 : act795(state);
  break;
 case 796 : act796(state);
  break;
 case 797 : act797(state);
  break;
 case 798 : act798(state);
  break;
 case 799 : act799(state);
  break;
 case 800 : act800(state);
  break;
 case 801 : act801(state);
  break;
 case 802 : act802(state);
  break;
 case 803 : act803(state);
  break;
 case 804 : act804(state);
  break;
 case 805 : act805(state);
  break;
 case 806 : act806(state);
  break;
 case 807 : act807(state);
  break;
 case 808 : act808(state);
  break;
 case 809 : act809(state);
  break;
 case 810 : act810(state);
  break;
 case 811 : act811(state);
  break;
 case 812 : act812(state);
  break;
 case 813 : act813(state);
  break;
 case 814 : act814(state);
  break;
 case 815 : act815(state);
  break;
 case 816 : act816(state);
  break;
 case 817 : act817(state);
  break;
 case 818 : act818(state);
  break;
 case 819 : act819(state);
  break;
 case 820 : act820(state);
  break;
 case 821 : act821(state);
  break;
 case 822 : act822(state);
  break;
 case 823 : act823(state);
  break;
 case 824 : act824(state);
  break;
 case 825 : act825(state);
  break;
 case 826 : act826(state);
  break;
 case 827 : act827(state);
  break;
 case 828 : act828(state);
  break;
 case 829 : act829(state);
  break;
 case 830 : act830(state);
  break;
 case 831 : act831(state);
  break;
 case 832 : act832(state);
  break;
 case 833 : act833(state);
  break;
 case 834 : act834(state);
  break;
 case 835 : act835(state);
  break;
 case 836 : act836(state);
  break;
 case 837 : act837(state);
  break;
 case 838 : act838(state);
  break;
 case 839 : act839(state);
  break;
 case 840 : act840(state);
  break;
 case 841 : act841(state);
  break;
 case 842 : act842(state);
  break;
 case 843 : act843(state);
  break;
 case 844 : act844(state);
  break;
 case 845 : act845(state);
  break;
 case 846 : act846(state);
  break;
 case 847 : act847(state);
  break;
 case 848 : act848(state);
  break;
 case 849 : act849(state);
  break;
 case 850 : act850(state);
  break;
 case 851 : act851(state);
  break;
 case 852 : act852(state);
  break;
 case 853 : act853(state);
  break;
 case 854 : act854(state);
  break;
 case 855 : act855(state);
  break;
 case 856 : act856(state);
  break;
 case 857 : act857(state);
  break;
 case 858 : act858(state);
  break;
 case 859 : act859(state);
  break;
 case 860 : act860(state);
  break;
 case 861 : act861(state);
  break;
 case 862 : act862(state);
  break;
 case 863 : act863(state);
  break;
 case 864 : act864(state);
  break;
 case 865 : act865(state);
  break;
 case 866 : act866(state);
  break;
 case 867 : act867(state);
  break;
 case 868 : act868(state);
  break;
 case 869 : act869(state);
  break;
 case 870 : act870(state);
  break;
 case 871 : act871(state);
  break;
 case 872 : act872(state);
  break;
 case 873 : act873(state);
  break;
 case 874 : act874(state);
  break;
 case 875 : act875(state);
  break;
 case 876 : act876(state);
  break;
 case 877 : act877(state);
  break;
 case 878 : act878(state);
  break;
 case 879 : act879(state);
  break;
 case 880 : act880(state);
  break;
 case 881 : act881(state);
  break;
 case 882 : act882(state);
  break;
 case 883 : act883(state);
  break;
 case 884 : act884(state);
  break;
 case 885 : act885(state);
  break;
 case 886 : act886(state);
  break;
 case 887 : act887(state);
  break;
 case 888 : act888(state);
  break;
 case 889 : act889(state);
  break;
 case 890 : act890(state);
  break;
 case 891 : act891(state);
  break;
 case 892 : act892(state);
  break;
 case 893 : act893(state);
  break;
 case 894 : act894(state);
  break;
 case 895 : act895(state);
  break;
 case 896 : act896(state);
  break;
 case 897 : act897(state);
  break;
 case 898 : act898(state);
  break;
 case 899 : act899(state);
  break;
 case 900 : act900(state);
  break;
 case 901 : act901(state);
  break;
 case 902 : act902(state);
  break;
 case 903 : act903(state);
  break;
 case 904 : act904(state);
  break;
 case 905 : act905(state);
  break;
 case 906 : act906(state);
  break;
 case 907 : act907(state);
  break;
 case 908 : act908(state);
  break;
 case 909 : act909(state);
  break;
 case 910 : act910(state);
  break;
 case 911 : act911(state);
  break;
 case 912 : act912(state);
  break;
 case 913 : act913(state);
  break;
 case 914 : act914(state);
  break;
 case 915 : act915(state);
  break;
 case 916 : act916(state);
  break;
 case 917 : act917(state);
  break;
 case 918 : act918(state);
  break;
 case 919 : act919(state);
  break;
 case 920 : act920(state);
  break;
 case 921 : act921(state);
  break;
 case 922 : act922(state);
  break;
 case 923 : act923(state);
  break;
 case 924 : act924(state);
  break;
 case 925 : act925(state);
  break;
 case 926 : act926(state);
  break;
 case 927 : act927(state);
  break;
 case 928 : act928(state);
  break;
 case 929 : act929(state);
  break;
 case 930 : act930(state);
  break;
 case 931 : act931(state);
  break;
 case 932 : act932(state);
  break;
 case 933 : act933(state);
  break;
 case 934 : act934(state);
  break;
 case 935 : act935(state);
  break;
 case 936 : act936(state);
  break;
 case 937 : act937(state);
  break;
 case 938 : act938(state);
  break;
 case 939 : act939(state);
  break;
 case 940 : act940(state);
  break;
 case 941 : act941(state);
  break;
 case 942 : act942(state);
  break;
 case 943 : act943(state);
  break;
 case 944 : act944(state);
  break;
 case 945 : act945(state);
  break;
 case 946 : act946(state);
  break;
 case 947 : act947(state);
  break;
 case 948 : act948(state);
  break;
 case 949 : act949(state);
  break;
 case 950 : act950(state);
  break;
 case 951 : act951(state);
  break;
 case 952 : act952(state);
  break;
 case 953 : act953(state);
  break;
 case 954 : act954(state);
  break;
 case 955 : act955(state);
  break;
 case 956 : act956(state);
  break;
 case 957 : act957(state);
  break;
 case 958 : act958(state);
  break;
 case 959 : act959(state);
  break;
 case 960 : act960(state);
  break;
 case 961 : act961(state);
  break;
 case 962 : act962(state);
  break;
 case 963 : act963(state);
  break;
 case 964 : act964(state);
  break;
 case 965 : act965(state);
  break;
 case 966 : act966(state);
  break;
 case 967 : act967(state);
  break;
 case 968 : act968(state);
  break;
 case 969 : act969(state);
  break;
 case 970 : act970(state);
  break;
 case 971 : act971(state);
  break;
 case 972 : act972(state);
  break;
 case 973 : act973(state);
  break;
 case 974 : act974(state);
  break;
 case 975 : act975(state);
  break;
 case 976 : act976(state);
  break;
 case 977 : act977(state);
  break;
 case 978 : act978(state);
  break;
 case 979 : act979(state);
  break;
 case 980 : act980(state);
  break;
 case 981 : act981(state);
  break;
 case 982 : act982(state);
  break;
 case 983 : act983(state);
  break;
 case 984 : act984(state);
  break;
 case 985 : act985(state);
  break;
 case 986 : act986(state);
  break;
 case 987 : act987(state);
  break;
 case 988 : act988(state);
  break;
 case 989 : act989(state);
  break;
 case 990 : act990(state);
  break;
 case 991 : act991(state);
  break;
 case 992 : act992(state);
  break;
 case 993 : act993(state);
  break;
 case 994 : act994(state);
  break;
 case 995 : act995(state);
  break;
 case 996 : act996(state);
  break;
 case 997 : act997(state);
  break;
 case 998 : act998(state);
  break;
 case 999 : act999(state);
  break;
 case 1000 : act1000(state);
  break;
 case 1001 : act1001(state);
  break;
 case 1002 : act1002(state);
  break;
 case 1003 : act1003(state);
  break;
 case 1004 : act1004(state);
  break;
 case 1005 : act1005(state);
  break;
 case 1006 : act1006(state);
  break;
 case 1007 : act1007(state);
  break;
 case 1008 : act1008(state);
  break;
 case 1009 : act1009(state);
  break;
 case 1010 : act1010(state);
  break;
 case 1011 : act1011(state);
  break;
 case 1012 : act1012(state);
  break;
 case 1013 : act1013(state);
  break;
 case 1014 : act1014(state);
  break;
 case 1015 : act1015(state);
  break;
 case 1016 : act1016(state);
  break;
 case 1017 : act1017(state);
  break;
 case 1018 : act1018(state);
  break;
 case 1019 : act1019(state);
  break;
 case 1020 : act1020(state);
  break;
 case 1021 : act1021(state);
  break;
 case 1022 : act1022(state);
  break;
 case 1023 : act1023(state);
  break;
 case 1024 : act1024(state);
  break;
 case 1025 : act1025(state);
  break;
 case 1026 : act1026(state);
  break;
 case 1027 : act1027(state);
  break;
 case 1028 : act1028(state);
  break;
 case 1029 : act1029(state);
  break;
 case 1030 : act1030(state);
  break;
 case 1031 : act1031(state);
  break;
 case 1032 : act1032(state);
  break;
 case 1033 : act1033(state);
  break;
 case 1034 : act1034(state);
  break;
 case 1035 : act1035(state);
  break;
 case 1036 : act1036(state);
  break;
 case 1037 : act1037(state);
  break;
 case 1038 : act1038(state);
  break;
 case 1039 : act1039(state);
  break;
 case 1040 : act1040(state);
  break;
 case 1041 : act1041(state);
  break;
 case 1042 : act1042(state);
  break;
 case 1043 : act1043(state);
  break;
 case 1044 : act1044(state);
  break;
 case 1045 : act1045(state);
  break;
 case 1046 : act1046(state);
  break;
 case 1047 : act1047(state);
  break;
 case 1048 : act1048(state);
  break;
 case 1049 : act1049(state);
  break;
 case 1050 : act1050(state);
  break;
 case 1051 : act1051(state);
  break;
 case 1052 : act1052(state);
  break;
 case 1053 : act1053(state);
  break;
 case 1054 : act1054(state);
  break;
 case 1055 : act1055(state);
  break;
 case 1056 : act1056(state);
  break;
 case 1057 : act1057(state);
  break;
 case 1058 : act1058(state);
  break;
 case 1059 : act1059(state);
  break;
 case 1060 : act1060(state);
  break;
 case 1061 : act1061(state);
  break;
 case 1062 : act1062(state);
  break;
 case 1063 : act1063(state);
  break;
 case 1064 : act1064(state);
  break;
 case 1065 : act1065(state);
  break;
 case 1066 : act1066(state);
  break;
 case 1067 : act1067(state);
  break;
 case 1068 : act1068(state);
  break;
 case 1069 : act1069(state);
  break;
 case 1070 : act1070(state);
  break;
 case 1071 : act1071(state);
  break;
 case 1072 : act1072(state);
  break;
 case 1073 : act1073(state);
  break;
 case 1074 : act1074(state);
  break;
 case 1075 : act1075(state);
  break;
 case 1076 : act1076(state);
  break;
 case 1077 : act1077(state);
  break;
 case 1078 : act1078(state);
  break;
 case 1079 : act1079(state);
  break;
 case 1080 : act1080(state);
  break;
 case 1081 : act1081(state);
  break;
 case 1082 : act1082(state);
  break;
 case 1083 : act1083(state);
  break;
 case 1084 : act1084(state);
  break;
 case 1085 : act1085(state);
  break;
 case 1086 : act1086(state);
  break;
 case 1087 : act1087(state);
  break;
 case 1088 : act1088(state);
  break;
 case 1089 : act1089(state);
  break;
 case 1090 : act1090(state);
  break;
 case 1091 : act1091(state);
  break;
 case 1092 : act1092(state);
  break;
 case 1093 : act1093(state);
  break;
 case 1094 : act1094(state);
  break;
 case 1095 : act1095(state);
  break;
 case 1096 : act1096(state);
  break;
 case 1097 : act1097(state);
  break;
 case 1098 : act1098(state);
  break;
 case 1099 : act1099(state);
  break;
 case 1100 : act1100(state);
  break;
 case 1101 : act1101(state);
  break;
 case 1102 : act1102(state);
  break;
 case 1103 : act1103(state);
  break;
 case 1104 : act1104(state);
  break;
 case 1105 : act1105(state);
  break;
 case 1106 : act1106(state);
  break;
 case 1107 : act1107(state);
  break;
 case 1108 : act1108(state);
  break;
 case 1109 : act1109(state);
  break;
 case 1110 : act1110(state);
  break;
 case 1111 : act1111(state);
  break;
 case 1112 : act1112(state);
  break;
 case 1113 : act1113(state);
  break;
 case 1114 : act1114(state);
  break;
 case 1115 : act1115(state);
  break;
 case 1116 : act1116(state);
  break;
 case 1117 : act1117(state);
  break;
 case 1118 : act1118(state);
  break;
 case 1119 : act1119(state);
  break;
 case 1120 : act1120(state);
  break;
 case 1121 : act1121(state);
  break;
 case 1122 : act1122(state);
  break;
 case 1123 : act1123(state);
  break;
 case 1124 : act1124(state);
  break;
 case 1125 : act1125(state);
  break;
 case 1126 : act1126(state);
  break;
 case 1127 : act1127(state);
  break;
 case 1128 : act1128(state);
  break;
 case 1129 : act1129(state);
  break;
 case 1130 : act1130(state);
  break;
 case 1131 : act1131(state);
  break;
 case 1132 : act1132(state);
  break;
 case 1133 : act1133(state);
  break;
 case 1134 : act1134(state);
  break;
 case 1135 : act1135(state);
  break;
 case 1136 : act1136(state);
  break;
 case 1137 : act1137(state);
  break;
 case 1138 : act1138(state);
  break;
 case 1139 : act1139(state);
  break;
 case 1140 : act1140(state);
  break;
 case 1141 : act1141(state);
  break;
 case 1142 : act1142(state);
  break;
 case 1143 : act1143(state);
  break;
 case 1144 : act1144(state);
  break;
 case 1145 : act1145(state);
  break;
 case 1146 : act1146(state);
  break;
 case 1147 : act1147(state);
  break;
 case 1148 : act1148(state);
  break;
 case 1149 : act1149(state);
  break;
 case 1150 : act1150(state);
  break;
 case 1151 : act1151(state);
  break;
 case 1152 : act1152(state);
  break;
 case 1153 : act1153(state);
  break;
 case 1154 : act1154(state);
  break;
 case 1155 : act1155(state);
  break;
 case 1156 : act1156(state);
  break;
 case 1157 : act1157(state);
  break;
 case 1158 : act1158(state);
  break;
 case 1159 : act1159(state);
  break;
 case 1160 : act1160(state);
  break;
 case 1161 : act1161(state);
  break;
 case 1162 : act1162(state);
  break;
 case 1163 : act1163(state);
  break;
 case 1164 : act1164(state);
  break;
 case 1165 : act1165(state);
  break;
 case 1166 : act1166(state);
  break;
 case 1167 : act1167(state);
  break;
 case 1168 : act1168(state);
  break;
 case 1169 : act1169(state);
  break;
 case 1170 : act1170(state);
  break;
 case 1171 : act1171(state);
  break;
 case 1172 : act1172(state);
  break;
 case 1173 : act1173(state);
  break;
 case 1174 : act1174(state);
  break;
 case 1175 : act1175(state);
  break;
 case 1176 : act1176(state);
  break;
 case 1177 : act1177(state);
  break;
 case 1178 : act1178(state);
  break;
 case 1179 : act1179(state);
  break;
 case 1180 : act1180(state);
  break;
 case 1181 : act1181(state);
  break;
 case 1182 : act1182(state);
  break;
 case 1183 : act1183(state);
  break;
 case 1184 : act1184(state);
  break;
 case 1185 : act1185(state);
  break;
 case 1186 : act1186(state);
  break;
 case 1187 : act1187(state);
  break;
 case 1188 : act1188(state);
  break;
 case 1189 : act1189(state);
  break;
 case 1190 : act1190(state);
  break;
 case 1191 : act1191(state);
  break;
 case 1192 : act1192(state);
  break;
 case 1193 : act1193(state);
  break;
 case 1194 : act1194(state);
  break;
 case 1195 : act1195(state);
  break;
 case 1196 : act1196(state);
  break;
 case 1197 : act1197(state);
  break;
 case 1198 : act1198(state);
  break;
 case 1199 : act1199(state);
  break;
 case 1200 : act1200(state);
  break;
 case 1201 : act1201(state);
  break;
 case 1202 : act1202(state);
  break;
 case 1203 : act1203(state);
  break;
 case 1204 : act1204(state);
  break;
 case 1205 : act1205(state);
  break;
 case 1206 : act1206(state);
  break;
 case 1207 : act1207(state);
  break;
 case 1208 : act1208(state);
  break;
 case 1209 : act1209(state);
  break;
 case 1210 : act1210(state);
  break;
 case 1211 : act1211(state);
  break;
 case 1212 : act1212(state);
  break;
 case 1213 : act1213(state);
  break;
 case 1214 : act1214(state);
  break;
 case 1215 : act1215(state);
  break;
 case 1216 : act1216(state);
  break;
 case 1217 : act1217(state);
  break;
 case 1218 : act1218(state);
  break;
 case 1219 : act1219(state);
  break;
 case 1220 : act1220(state);
  break;
 case 1221 : act1221(state);
  break;
 case 1222 : act1222(state);
  break;
 case 1223 : act1223(state);
  break;
 case 1224 : act1224(state);
  break;
 case 1225 : act1225(state);
  break;
 case 1226 : act1226(state);
  break;
 case 1227 : act1227(state);
  break;
 case 1228 : act1228(state);
  break;
 case 1229 : act1229(state);
  break;
 case 1230 : act1230(state);
  break;
 case 1231 : act1231(state);
  break;
 case 1232 : act1232(state);
  break;
 case 1233 : act1233(state);
  break;
 case 1234 : act1234(state);
  break;
 case 1235 : act1235(state);
  break;
 case 1236 : act1236(state);
  break;
 case 1237 : act1237(state);
  break;
 case 1238 : act1238(state);
  break;
 case 1239 : act1239(state);
  break;
 case 1240 : act1240(state);
  break;
 case 1241 : act1241(state);
  break;
 case 1242 : act1242(state);
  break;
 case 1243 : act1243(state);
  break;
 case 1244 : act1244(state);
  break;
 case 1245 : act1245(state);
  break;
 case 1246 : act1246(state);
  break;
 case 1247 : act1247(state);
  break;
 case 1248 : act1248(state);
  break;
 case 1249 : act1249(state);
  break;
 case 1250 : act1250(state);
  break;
 case 1251 : act1251(state);
  break;
 case 1252 : act1252(state);
  break;
 case 1253 : act1253(state);
  break;
 case 1254 : act1254(state);
  break;
 case 1255 : act1255(state);
  break;
 case 1256 : act1256(state);
  break;
 case 1257 : act1257(state);
  break;
 case 1258 : act1258(state);
  break;
 case 1259 : act1259(state);
  break;
 case 1260 : act1260(state);
  break;
 case 1261 : act1261(state);
  break;
 case 1262 : act1262(state);
  break;
 case 1263 : act1263(state);
  break;
 case 1264 : act1264(state);
  break;
 case 1265 : act1265(state);
  break;
 case 1266 : act1266(state);
  break;
 case 1267 : act1267(state);
  break;
 case 1268 : act1268(state);
  break;
 case 1269 : act1269(state);
  break;
 case 1270 : act1270(state);
  break;
 case 1271 : act1271(state);
  break;
 case 1272 : act1272(state);
  break;
 case 1273 : act1273(state);
  break;
 case 1274 : act1274(state);
  break;
 case 1275 : act1275(state);
  break;
 case 1276 : act1276(state);
  break;
 case 1277 : act1277(state);
  break;
 case 1278 : act1278(state);
  break;
 case 1279 : act1279(state);
  break;
 case 1280 : act1280(state);
  break;
 case 1281 : act1281(state);
  break;
 case 1282 : act1282(state);
  break;
 case 1283 : act1283(state);
  break;
 case 1284 : act1284(state);
  break;
 case 1285 : act1285(state);
  break;
 case 1286 : act1286(state);
  break;
 case 1287 : act1287(state);
  break;
 case 1288 : act1288(state);
  break;
 case 1289 : act1289(state);
  break;
 case 1290 : act1290(state);
  break;
 case 1291 : act1291(state);
  break;
 case 1292 : act1292(state);
  break;
 case 1293 : act1293(state);
  break;
 case 1294 : act1294(state);
  break;
 case 1295 : act1295(state);
  break;
 case 1296 : act1296(state);
  break;
 case 1297 : act1297(state);
  break;
 case 1298 : act1298(state);
  break;
 case 1299 : act1299(state);
  break;
 case 1300 : act1300(state);
  break;
 case 1301 : act1301(state);
  break;
 case 1302 : act1302(state);
  break;
 case 1303 : act1303(state);
  break;
 case 1304 : act1304(state);
  break;
 case 1305 : act1305(state);
  break;
 case 1306 : act1306(state);
  break;
 case 1307 : act1307(state);
  break;
 case 1308 : act1308(state);
  break;
 case 1309 : act1309(state);
  break;
 case 1310 : act1310(state);
  break;
 case 1311 : act1311(state);
  break;
 case 1312 : act1312(state);
  break;
 case 1313 : act1313(state);
  break;
 case 1314 : act1314(state);
  break;
 case 1315 : act1315(state);
  break;
 case 1316 : act1316(state);
  break;
 case 1317 : act1317(state);
  break;
 case 1318 : act1318(state);
  break;
 case 1319 : act1319(state);
  break;
 case 1320 : act1320(state);
  break;
 case 1321 : act1321(state);
  break;
 case 1322 : act1322(state);
  break;
 case 1323 : act1323(state);
  break;
 case 1324 : act1324(state);
  break;
 case 1325 : act1325(state);
  break;
 case 1326 : act1326(state);
  break;
 case 1327 : act1327(state);
  break;
 case 1328 : act1328(state);
  break;
 case 1329 : act1329(state);
  break;
 case 1330 : act1330(state);
  break;
 case 1331 : act1331(state);
  break;
 case 1332 : act1332(state);
  break;
 case 1333 : act1333(state);
  break;
 case 1334 : act1334(state);
  break;
 case 1335 : act1335(state);
  break;
 case 1336 : act1336(state);
  break;
 case 1337 : act1337(state);
  break;
 case 1338 : act1338(state);
  break;
 case 1339 : act1339(state);
  break;
 case 1340 : act1340(state);
  break;
 case 1341 : act1341(state);
  break;
 case 1342 : act1342(state);
  break;
 case 1343 : act1343(state);
  break;
 case 1344 : act1344(state);
  break;
 case 1345 : act1345(state);
  break;
 case 1346 : act1346(state);
  break;
 case 1347 : act1347(state);
  break;
 case 1348 : act1348(state);
  break;
 case 1349 : act1349(state);
  break;
 case 1350 : act1350(state);
  break;
 case 1351 : act1351(state);
  break;
 case 1352 : act1352(state);
  break;
 case 1353 : act1353(state);
  break;
 case 1354 : act1354(state);
  break;
 case 1355 : act1355(state);
  break;
 case 1356 : act1356(state);
  break;
 case 1357 : act1357(state);
  break;
 case 1358 : act1358(state);
  break;
 case 1359 : act1359(state);
  break;
 case 1360 : act1360(state);
  break;
 case 1361 : act1361(state);
  break;
 case 1362 : act1362(state);
  break;
 case 1363 : act1363(state);
  break;
 case 1364 : act1364(state);
  break;
 case 1365 : act1365(state);
  break;
 case 1366 : act1366(state);
  break;
 case 1367 : act1367(state);
  break;
 case 1368 : act1368(state);
  break;
 case 1369 : act1369(state);
  break;
 case 1370 : act1370(state);
  break;
 case 1371 : act1371(state);
  break;
 case 1372 : act1372(state);
  break;
 case 1373 : act1373(state);
  break;
 case 1374 : act1374(state);
  break;
 case 1375 : act1375(state);
  break;
 case 1376 : act1376(state);
  break;
 case 1377 : act1377(state);
  break;
 case 1378 : act1378(state);
  break;
 case 1379 : act1379(state);
  break;
 case 1380 : act1380(state);
  break;
 case 1381 : act1381(state);
  break;
 case 1382 : act1382(state);
  break;
 case 1383 : act1383(state);
  break;
 case 1384 : act1384(state);
  break;
 case 1385 : act1385(state);
  break;
 case 1386 : act1386(state);
  break;
 case 1387 : act1387(state);
  break;
 case 1388 : act1388(state);
  break;
 case 1389 : act1389(state);
  break;
 case 1390 : act1390(state);
  break;
 case 1391 : act1391(state);
  break;
 case 1392 : act1392(state);
  break;
 case 1393 : act1393(state);
  break;
 case 1394 : act1394(state);
  break;
 case 1395 : act1395(state);
  break;
 case 1396 : act1396(state);
  break;
 case 1397 : act1397(state);
  break;
 case 1398 : act1398(state);
  break;
 case 1399 : act1399(state);
  break;
 case 1400 : act1400(state);
  break;
 case 1401 : act1401(state);
  break;
 case 1402 : act1402(state);
  break;
 case 1403 : act1403(state);
  break;
 case 1404 : act1404(state);
  break;
 case 1405 : act1405(state);
  break;
 case 1406 : act1406(state);
  break;
 case 1407 : act1407(state);
  break;
 case 1408 : act1408(state);
  break;
 case 1409 : act1409(state);
  break;
 case 1410 : act1410(state);
  break;
 case 1411 : act1411(state);
  break;
 case 1412 : act1412(state);
  break;
 case 1413 : act1413(state);
  break;
 case 1414 : act1414(state);
  break;
 case 1415 : act1415(state);
  break;
 case 1416 : act1416(state);
  break;
 case 1417 : act1417(state);
  break;
 case 1418 : act1418(state);
  break;
 case 1419 : act1419(state);
  break;
 case 1420 : act1420(state);
  break;
 case 1421 : act1421(state);
  break;
 case 1422 : act1422(state);
  break;
 case 1423 : act1423(state);
  break;
 case 1424 : act1424(state);
  break;
 case 1425 : act1425(state);
  break;
 case 1426 : act1426(state);
  break;
 case 1427 : act1427(state);
  break;
 case 1428 : act1428(state);
  break;
 case 1429 : act1429(state);
  break;
 case 1430 : act1430(state);
  break;
 case 1431 : act1431(state);
  break;
 case 1432 : act1432(state);
  break;
 case 1433 : act1433(state);
  break;
 case 1434 : act1434(state);
  break;
 case 1435 : act1435(state);
  break;
 case 1436 : act1436(state);
  break;
 case 1437 : act1437(state);
  break;
 case 1438 : act1438(state);
  break;
 case 1439 : act1439(state);
  break;
 case 1440 : act1440(state);
  break;
 case 1441 : act1441(state);
  break;
 case 1442 : act1442(state);
  break;
 case 1443 : act1443(state);
  break;
 case 1444 : act1444(state);
  break;
 case 1445 : act1445(state);
  break;
 case 1446 : act1446(state);
  break;
 case 1447 : act1447(state);
  break;
 case 1448 : act1448(state);
  break;
 case 1449 : act1449(state);
  break;
 case 1450 : act1450(state);
  break;
 case 1451 : act1451(state);
  break;
 case 1452 : act1452(state);
  break;
 case 1453 : act1453(state);
  break;
 case 1454 : act1454(state);
  break;
 case 1455 : act1455(state);
  break;
 case 1456 : act1456(state);
  break;
 case 1457 : act1457(state);
  break;
 case 1458 : act1458(state);
  break;
 case 1459 : act1459(state);
  break;
 case 1460 : act1460(state);
  break;
 case 1461 : act1461(state);
  break;
 case 1462 : act1462(state);
  break;
 case 1463 : act1463(state);
  break;
 case 1464 : act1464(state);
  break;
 case 1465 : act1465(state);
  break;
 case 1466 : act1466(state);
  break;
 case 1467 : act1467(state);
  break;
 case 1468 : act1468(state);
  break;
 case 1469 : act1469(state);
  break;
 case 1470 : act1470(state);
  break;
 case 1471 : act1471(state);
  break;
 case 1472 : act1472(state);
  break;
 case 1473 : act1473(state);
  break;
 case 1474 : act1474(state);
  break;
 case 1475 : act1475(state);
  break;
 case 1476 : act1476(state);
  break;
 case 1477 : act1477(state);
  break;
 case 1478 : act1478(state);
  break;
 case 1479 : act1479(state);
  break;
 case 1480 : act1480(state);
  break;
 case 1481 : act1481(state);
  break;
 case 1482 : act1482(state);
  break;
 case 1483 : act1483(state);
  break;
 case 1484 : act1484(state);
  break;
 case 1485 : act1485(state);
  break;
 case 1486 : act1486(state);
  break;
 case 1487 : act1487(state);
  break;
 case 1488 : act1488(state);
  break;
 case 1489 : act1489(state);
  break;
 case 1490 : act1490(state);
  break;
 case 1491 : act1491(state);
  break;
 case 1492 : act1492(state);
  break;
 case 1493 : act1493(state);
  break;
 case 1494 : act1494(state);
  break;
 case 1495 : act1495(state);
  break;
 case 1496 : act1496(state);
  break;
 case 1497 : act1497(state);
  break;
 case 1498 : act1498(state);
  break;
 case 1499 : act1499(state);
  break;
 case 1500 : act1500(state);
  break;
 case 1501 : act1501(state);
  break;
 case 1502 : act1502(state);
  break;
 case 1503 : act1503(state);
  break;
 case 1504 : act1504(state);
  break;
 case 1505 : act1505(state);
  break;
 case 1506 : act1506(state);
  break;
 case 1507 : act1507(state);
  break;
 case 1508 : act1508(state);
  break;
 case 1509 : act1509(state);
  break;
 case 1510 : act1510(state);
  break;
 case 1511 : act1511(state);
  break;
 case 1512 : act1512(state);
  break;
 case 1513 : act1513(state);
  break;
 case 1514 : act1514(state);
  break;
 case 1515 : act1515(state);
  break;
 case 1516 : act1516(state);
  break;
 case 1517 : act1517(state);
  break;
 case 1518 : act1518(state);
  break;
 case 1519 : act1519(state);
  break;
 case 1520 : act1520(state);
  break;
 case 1521 : act1521(state);
  break;
 case 1522 : act1522(state);
  break;
 case 1523 : act1523(state);
  break;
 case 1524 : act1524(state);
  break;
 case 1525 : act1525(state);
  break;
 case 1526 : act1526(state);
  break;
 case 1527 : act1527(state);
  break;
 case 1528 : act1528(state);
  break;
 case 1529 : act1529(state);
  break;
 case 1530 : act1530(state);
  break;
 case 1531 : act1531(state);
  break;
 case 1532 : act1532(state);
  break;
 case 1533 : act1533(state);
  break;
 case 1534 : act1534(state);
  break;
 case 1535 : act1535(state);
  break;
 case 1536 : act1536(state);
  break;
 case 1537 : act1537(state);
  break;
 case 1538 : act1538(state);
  break;
 case 1539 : act1539(state);
  break;
 case 1540 : act1540(state);
  break;
 case 1541 : act1541(state);
  break;
 case 1542 : act1542(state);
  break;
 case 1543 : act1543(state);
  break;
 case 1544 : act1544(state);
  break;
 case 1545 : act1545(state);
  break;
 case 1546 : act1546(state);
  break;
 case 1547 : act1547(state);
  break;
 case 1548 : act1548(state);
  break;
 case 1549 : act1549(state);
  break;
 case 1550 : act1550(state);
  break;
 case 1551 : act1551(state);
  break;
 case 1552 : act1552(state);
  break;
 case 1553 : act1553(state);
  break;
 case 1554 : act1554(state);
  break;
 case 1555 : act1555(state);
  break;
 case 1556 : act1556(state);
  break;
 case 1557 : act1557(state);
  break;
 case 1558 : act1558(state);
  break;
 case 1559 : act1559(state);
  break;
 case 1560 : act1560(state);
  break;
 case 1561 : act1561(state);
  break;
 case 1562 : act1562(state);
  break;
 case 1563 : act1563(state);
  break;
 case 1564 : act1564(state);
  break;
 case 1565 : act1565(state);
  break;
 case 1566 : act1566(state);
  break;
 case 1567 : act1567(state);
  break;
 case 1568 : act1568(state);
  break;
 case 1569 : act1569(state);
  break;
 case 1570 : act1570(state);
  break;
 case 1571 : act1571(state);
  break;
 case 1572 : act1572(state);
  break;
 case 1573 : act1573(state);
  break;
 case 1574 : act1574(state);
  break;
 case 1575 : act1575(state);
  break;
 case 1576 : act1576(state);
  break;
 case 1577 : act1577(state);
  break;
 case 1578 : act1578(state);
  break;
 case 1579 : act1579(state);
  break;
 case 1580 : act1580(state);
  break;
 case 1581 : act1581(state);
  break;
 case 1582 : act1582(state);
  break;
 case 1583 : act1583(state);
  break;
 case 1584 : act1584(state);
  break;
 case 1585 : act1585(state);
  break;
 case 1586 : act1586(state);
  break;
 case 1587 : act1587(state);
  break;
 case 1588 : act1588(state);
  break;
 case 1589 : act1589(state);
  break;
 case 1590 : act1590(state);
  break;
 case 1591 : act1591(state);
  break;
 case 1592 : act1592(state);
  break;
 case 1593 : act1593(state);
  break;
 case 1594 : act1594(state);
  break;
 case 1595 : act1595(state);
  break;
 case 1596 : act1596(state);
  break;
 case 1597 : act1597(state);
  break;
 case 1598 : act1598(state);
  break;
 case 1599 : act1599(state);
  break;
 case 1600 : act1600(state);
  break;
 case 1601 : act1601(state);
  break;
 case 1602 : act1602(state);
  break;
 case 1603 : act1603(state);
  break;
 case 1604 : act1604(state);
  break;
 case 1605 : act1605(state);
  break;
 case 1606 : act1606(state);
  break;
 case 1607 : act1607(state);
  break;
 case 1608 : act1608(state);
  break;
 case 1609 : act1609(state);
  break;
 case 1610 : act1610(state);
  break;
 case 1611 : act1611(state);
  break;
 case 1612 : act1612(state);
  break;
 case 1613 : act1613(state);
  break;
 case 1614 : act1614(state);
  break;
 case 1615 : act1615(state);
  break;
 case 1616 : act1616(state);
  break;
 case 1617 : act1617(state);
  break;
 case 1618 : act1618(state);
  break;
 case 1619 : act1619(state);
  break;
 case 1620 : act1620(state);
  break;
 case 1621 : act1621(state);
  break;
 case 1622 : act1622(state);
  break;
 case 1623 : act1623(state);
  break;
 case 1624 : act1624(state);
  break;
 case 1625 : act1625(state);
  break;
 case 1626 : act1626(state);
  break;
 case 1627 : act1627(state);
  break;
 case 1628 : act1628(state);
  break;
 case 1629 : act1629(state);
  break;
 case 1630 : act1630(state);
  break;
 case 1631 : act1631(state);
  break;
 case 1632 : act1632(state);
  break;
 case 1633 : act1633(state);
  break;
 case 1634 : act1634(state);
  break;
 case 1635 : act1635(state);
  break;
 case 1636 : act1636(state);
  break;
 case 1637 : act1637(state);
  break;
 case 1638 : act1638(state);
  break;
 case 1639 : act1639(state);
  break;
 case 1640 : act1640(state);
  break;
 case 1641 : act1641(state);
  break;
 case 1642 : act1642(state);
  break;
 case 1643 : act1643(state);
  break;
 case 1644 : act1644(state);
  break;
 case 1645 : act1645(state);
  break;
 case 1646 : act1646(state);
  break;
 case 1647 : act1647(state);
  break;
 case 1648 : act1648(state);
  break;
 case 1649 : act1649(state);
  break;
 case 1650 : act1650(state);
  break;
 case 1651 : act1651(state);
  break;
 case 1652 : act1652(state);
  break;
 case 1653 : act1653(state);
  break;
 case 1654 : act1654(state);
  break;
 case 1655 : act1655(state);
  break;
 case 1656 : act1656(state);
  break;
 case 1657 : act1657(state);
  break;
 case 1658 : act1658(state);
  break;
 case 1659 : act1659(state);
  break;
 case 1660 : act1660(state);
  break;
 case 1661 : act1661(state);
  break;
 case 1662 : act1662(state);
  break;
 case 1663 : act1663(state);
  break;
 case 1664 : act1664(state);
  break;
 case 1665 : act1665(state);
  break;
 case 1666 : act1666(state);
  break;
 case 1667 : act1667(state);
  break;
 case 1668 : act1668(state);
  break;
 default :
  debug("undefined clause number " + clauseNumber);
  break;
 }
}


// end of Lisp-generated acts

  /**
   * Method for initializing this MorphEngine with a Lexicon to use.
   */

  public void initialize(Lexicon dictionary) {

    if (dict != null) { //already initialized
      if (dictionary != dict)
        if (authorFlag)
          debug("** error ** trying to initialize Morph_en with a new Lexicon: " +
                dictionary);
      return;
    }
    else dict = dictionary;

// Set values for variables bound in MorphEngine and MorphEngFrame:

    atom_penalties = dict.makeAtom("penalties");
    atom_penalty = dict.makeAtom("penalty");
    atom_root = dict.makeAtom("root");
    atom_form = dict.makeAtom("form");
    atom_derivation = dict.makeAtom("derivation");
    word_un = dict.makeWord("un");

    atom_true = dict.makeAtom("true");
    atom_false = dict.makeAtom("false");
    atom_known = dict.makeAtom("known");
    atom_syllabic = dict.makeAtom("syllabic");
    atom_polysyllabic = dict.makeAtom("polysyllabic");
    atom_archaic = dict.makeAtom("archaic");
    atom_abbrev = dict.makeAtom("abbrev");
    atom_hypothesized = dict.makeAtom("hypothesized");
    atom_leftCompoundException = dict.makeAtom("left-compound-exception");
    atom_rightCompoundException = dict.makeAtom("right-compound-exception");
    atom_illegalRoot = dict.makeAtom("illegal-root");
//    atom_compoundProperty = dict.makeAtom("compound-of"); //set up compoundProperty

    atom_iCode = dict.makeAtom("i-code");
    atom_number = dict.makeAtom("number");
    atom_sg = dict.makeAtom("sg");
    atom_pl = dict.makeAtom("pl");
    atom_sgSlashPl = dict.makeAtom("sg/pl");
    atom_tns = dict.makeAtom("tns");
    atom_present = dict.makeAtom("present");
    atom_not3sg = dict.makeAtom("not3sg");
    atom_not13sg = dict.makeAtom("not13sg");
    atom_3sg = dict.makeAtom("3sg");
    atom_2sg = dict.makeAtom("2sg");
    atom_1sg = dict.makeAtom("1sg");
    atom_past = dict.makeAtom("past");
    atom_pastpart = dict.makeAtom("pastpart");
    atom_prespart = dict.makeAtom("prespart");
    atom_guessed = dict.makeAtom("guessed");

    atom_morphDispatch = dict.makeAtom("morph-dispatch");
    atom_sBlock = dict.makeAtom("s-block");
    atom_dBlock = dict.makeAtom("d-block");
    atom_eBlock = dict.makeAtom("e-block");
    atom_gBlock = dict.makeAtom("g-block");
    atom_lBlock = dict.makeAtom("l-block");
    atom_mBlock = dict.makeAtom("m-block");
    atom_nBlock = dict.makeAtom("n-block");
    atom_rBlock = dict.makeAtom("r-block");
    atom_tBlock = dict.makeAtom("t-block");
    atom_yBlock = dict.makeAtom("y-block");
    atom_cBlock = dict.makeAtom("c-block");
    atom_miscBlock = dict.makeAtom("misc-block");
    atom_tionBlock = dict.makeAtom("tion-block");
    atom_estBlock = dict.makeAtom("est-block");
    atom_iformBlock = dict.makeAtom("iform-block");
    atom_defaultRule = dict.makeAtom("default-rule");
    atom_prefixDispatch = dict.makeAtom("prefix-dispatch");
    atom_aPrefixes = dict.makeAtom("a-prefixes");
    atom_bPrefixes = dict.makeAtom("b-prefixes");
    atom_cPrefixes = dict.makeAtom("c-prefixes");
    atom_dPrefixes = dict.makeAtom("d-prefixes");
    atom_ePrefixes = dict.makeAtom("e-prefixes");
    atom_hPrefixes = dict.makeAtom("h-prefixes");
    atom_iPrefixes = dict.makeAtom("i-prefixes");
    atom_mPrefixes = dict.makeAtom("m-prefixes");
    atom_nPrefixes = dict.makeAtom("n-prefixes");
    atom_oPrefixes = dict.makeAtom("o-prefixes");
    atom_pPrefixes = dict.makeAtom("p-prefixes");
    atom_rPrefixes = dict.makeAtom("r-prefixes");
    atom_sPrefixes = dict.makeAtom("s-prefixes");
    atom_tPrefixes = dict.makeAtom("t-prefixes");
    atom_uPrefixes = dict.makeAtom("u-prefixes");
    atom_miscPrefixes = dict.makeAtom("misc-prefixes");
    atom_lexicalPrefixRules = dict.makeAtom("lexical-prefix-rules");
    atom_morphCompoundRules = dict.makeAtom("morph-compound-rules");
    atom_ordinalRules = dict.makeAtom("ordinal-rules");
    atom_pluralRule = dict.makeAtom("plural-rule");
    atom_thirdSingRule = dict.makeAtom("third-sing-rule");
    atom_pastRule = dict.makeAtom("past-rule");
    atom_ingRule = dict.makeAtom("ing-rule");
    atom_doerRule = dict.makeAtom("doer-rule");
    atom_comparativeRule = dict.makeAtom("comparative-rule");
    atom_superlativeRule = dict.makeAtom("superlative-rule");
    atom_adverbRule = dict.makeAtom("adverb-rule");
    atom_nessRule = dict.makeAtom("ness-rule");
    atom_ableRule = dict.makeAtom("able-rule");

    atom_prefix = dict.makeAtom("prefix");
    atom_hasPrefix = dict.makeAtom("has-prefix");
    atom_suffix = dict.makeAtom("suffix");
    atom_hasSuffix = dict.makeAtom("has-suffix");

    atom_dashApostropheDashS = dict.makeAtom("-apostrophe-s");
    atom_dashStarES = dict.makeAtom("-*es");
    atom_dashES = dict.makeAtom("-es");
    atom_dashS = dict.makeAtom("-s");
    atom_dashIES = dict.makeAtom("-ies");
    atom_dashMen = dict.makeAtom("-men");
    atom_dashIrr = dict.makeAtom("-irr");
    atom_sDashD = dict.makeAtom("s-d");
    atom_sDashEd = dict.makeAtom("s-ed");
    atom_sDashStarEd = dict.makeAtom("s-*ed");
    atom_esDashEd = dict.makeAtom("es-ed");
    atom_sDashEdDashStarEd = dict.makeAtom("s-ed-*ed");
    atom_rDashSt = dict.makeAtom("r-st");
    atom_ierDashIest =  dict.makeAtom("ier-iest");
    atom_erDashEst =  dict.makeAtom("er-est");

    cat_name = dict.makeCategory("name");
    cat_citySlashCountry = dict.makeCategory("city/country");
    cat_nvadjadvprefsuff = dict.makeCategory("n/v/adj/adv/prefix/suffix");
    cat_anynvadjadvprefsuff = dict.makeCategory("anyn/v/adj/adv/prefix/suffix");
    cat_nnvadjadvprefsuff = dict.makeCategory("nn/v/adj/adv/prefix/suffix");
    cat_punct = dict.makeCategory("punct");
    cat_npr = dict.makeCategory("npr");
    cat_nm = dict.makeCategory("nm");
    cat_nn = dict.makeCategory("nn");

    cat_n = dict.makeCategory("n");
    cat_v = dict.makeCategory("v");
    cat_adj = dict.makeCategory("adj");
    cat_prefix = dict.makeCategory("prefix");

    cat_ppp = dict.makeCategory("past/pastpart");
    cat_nplpp = dict.makeCategory("npl/pastpart");

    cat_npl = dict.makeCategory("npl");
    cat_nsp = dict.makeCategory("nsp");
    cat_past2sg = dict.makeCategory("past/2sg");
    cat_past3sg = dict.makeCategory("past/3sg");
    cat_pastnot13sg = dict.makeCategory("past/not13sg");
    cat_past = dict.makeCategory("past");
    cat_3sg = dict.makeCategory("3sg");
    cat_2sg = dict.makeCategory("2sg");
    cat_1sg = dict.makeCategory("1sg");
    cat_not13sg = dict.makeCategory("not13sg");
    cat_not3sg = dict.makeCategory("not3sg");
    cat_pastpart = dict.makeCategory("pastpart");
    cat_prespart = dict.makeCategory("prespart");

    word_0 = dict.makeWord(0);
    word_1 = dict.makeWord(1);
    word_2 = dict.makeWord(2);
    word_3 = dict.makeWord(3);

    wordSet_Ise_Ize = dict.makeWordSet("ise/ize");


// insert Lisp-generated variable assignments here

  word_a = dict.makeWord("a");
  word_ab = dict.makeWord("ab");
  word_able = dict.makeWord("able");
  word_aceous = dict.makeWord("aceous");
  word_ad = dict.makeWord("ad");
  word_adeno = dict.makeWord("adeno");
  word_aero = dict.makeWord("aero");
  word_age = dict.makeWord("age");
  word_all = dict.makeWord("all");
  word_allo = dict.makeWord("allo");
  word_an = dict.makeWord("an");
  word_ana = dict.makeWord("ana");
  word_ance = dict.makeWord("ance");
  word_aneous = dict.makeWord("aneous");
  word_ante = dict.makeWord("ante");
  word_anti = dict.makeWord("anti");
  word_ata = dict.makeWord("ata");
  word_ative = dict.makeWord("ative");
  word_auto = dict.makeWord("auto");
  word_back = dict.makeWord("back");
  word_bare = dict.makeWord("bare");
  word_be = dict.makeWord("be");
  word_bi = dict.makeWord("bi");
  word_bio = dict.makeWord("bio");
  word_chemo = dict.makeWord("chemo");
  word_co = dict.makeWord("co");
  word_coco = dict.makeWord("coco");
  word_contra = dict.makeWord("contra");
  word_counter = dict.makeWord("counter");
  word_de = dict.makeWord("de");
  word_demi = dict.makeWord("demi");
  word_di = dict.makeWord("di");
  word_dia = dict.makeWord("dia");
  word_dino = dict.makeWord("dino");
  word_dis = dict.makeWord("dis");
  word_disco = dict.makeWord("disco");
  word_down = dict.makeWord("down");
  word_ed = dict.makeWord("ed");
  word_ee = dict.makeWord("ee");
  word_eer = dict.makeWord("eer");
  word_em = dict.makeWord("em");
  word_en = dict.makeWord("en");
  word_ence = dict.makeWord("ence");
  word_er = dict.makeWord("er");
  word_esque = dict.makeWord("esque");
  word_ess = dict.makeWord("ess");
  word_est = dict.makeWord("est");
  word_ex = dict.makeWord("ex");
  word_extra = dict.makeWord("extra");
  word_fold = dict.makeWord("fold");
  word_fore = dict.makeWord("fore");
  word_gastro = dict.makeWord("gastro");
  word_geo = dict.makeWord("geo");
  word_hemi = dict.makeWord("hemi");
  word_here = dict.makeWord("here");
  word_hyper = dict.makeWord("hyper");
  word_hypno = dict.makeWord("hypno");
  word_hypo = dict.makeWord("hypo");
  word_ian = dict.makeWord("ian");
  word_ic = dict.makeWord("ic");
  word_ics = dict.makeWord("ics");
  word_id = dict.makeWord("id");
  word_ier = dict.makeWord("ier");
  word_il = dict.makeWord("il");
  word_im = dict.makeWord("im");
  word_in = dict.makeWord("in");
  word_ing = dict.makeWord("ing");
  word_inner = dict.makeWord("inner");
  word_inter = dict.makeWord("inter");
  word_intra = dict.makeWord("intra");
  word_ir = dict.makeWord("ir");
  word_ish = dict.makeWord("ish");
  word_iso = dict.makeWord("iso");
  word_ista = dict.makeWord("ista");
  word_itious = dict.makeWord("itious");
  word_ive = dict.makeWord("ive");
  word_less = dict.makeWord("less");
  word_like = dict.makeWord("like");
  word_ling = dict.makeWord("ling");
  word_litho = dict.makeWord("litho");
  word_mac = dict.makeWord("mac");
  word_mal = dict.makeWord("mal");
  word_maxi = dict.makeWord("maxi");
  word_mc = dict.makeWord("mc");
  word_ment = dict.makeWord("ment");
  word_meso = dict.makeWord("meso");
  word_mid = dict.makeWord("mid");
  word_mini = dict.makeWord("mini");
  word_mis = dict.makeWord("mis");
  word_mono = dict.makeWord("mono");
  word_multi = dict.makeWord("multi");
  word_neo = dict.makeWord("neo");
  word_ness = dict.makeWord("ness");
  word_neuro = dict.makeWord("neuro");
  word_no = dict.makeWord("no");
  word_non = dict.makeWord("non");
  word_o = dict.makeWord("o");
  word_octo = dict.makeWord("octo");
  word_off = dict.makeWord("off");
  word_on = dict.makeWord("on");
  word_or = dict.makeWord("or");
  word_ortho = dict.makeWord("ortho");
  word_ose = dict.makeWord("ose");
  word_ous = dict.makeWord("ous");
  word_out = dict.makeWord("out");
  word_outer = dict.makeWord("outer");
  word_over = dict.makeWord("over");
  word_oxy = dict.makeWord("oxy");
  word_paleo = dict.makeWord("paleo");
  word_pan = dict.makeWord("pan");
  word_para = dict.makeWord("para");
  word_petro = dict.makeWord("petro");
  word_photo = dict.makeWord("photo");
  word_poly = dict.makeWord("poly");
  word_post = dict.makeWord("post");
  word_pre = dict.makeWord("pre");
  word_pro = dict.makeWord("pro");
  word_pseudo = dict.makeWord("pseudo");
  word_pyro = dict.makeWord("pyro");
  word_quadri = dict.makeWord("quadri");
  word_quasi = dict.makeWord("quasi");
  word_re = dict.makeWord("re");
  word_ress = dict.makeWord("ress");
  word_s = dict.makeWord("s");
  word_semi = dict.makeWord("semi");
  word_some = dict.makeWord("some");
  word_step = dict.makeWord("step");
  word_sub = dict.makeWord("sub");
  word_super = dict.makeWord("super");
  word_supra = dict.makeWord("supra");
  word_there = dict.makeWord("there");
  word_tive = dict.makeWord("tive");
  word_trans = dict.makeWord("trans");
  word_tri = dict.makeWord("tri");
  word_ule = dict.makeWord("ule");
  word_ultra = dict.makeWord("ultra");
  word_under = dict.makeWord("under");
  word_uni = dict.makeWord("uni");
  word_up = dict.makeWord("up");
  word_ure = dict.makeWord("ure");
  word_vari = dict.makeWord("vari");
  word_ward = dict.makeWord("ward");
  word_wards = dict.makeWord("wards");
  word_wise = dict.makeWord("wise");

illegalBeginnings = new HashSet(100);
LexiconUtil.hashArray(illegalBeginnings, new String[]{
   "-", "cc", "dd", "ifa", "ifi", "ifo", "ila", "imo", "ltr", "mb", "mm",
   "nfl", "nt", "mp", "rc", "rn", "rr", "sts", "tt"});
illegalBeginningsMax = 3;
 
illegalEndings = new HashSet(100);
LexiconUtil.hashArray(illegalEndings, new String[]{
   "-", "br", "cc", "cn", "cst", "cr", "dp", "dr", "dv", "gb", "mr", "mv",
   "np", "oov", "rw", "tr", "tf", "tw", "sn", "wb", "zym", "br", "cr",
   "dr", "fr", "gr", "hr", "jr", "kr", "lr", "mr", "nr", "pr", "qr", "sr",
   "tr", "vr", "wr", "xr", "zr", "cl", "gl", "sl", "bl", "jl", "kl", "ml",
   "nl", "pl", "ql"});
illegalEndingsMax = 3;
 
leftCompoundExceptions = new HashSet(800);
LexiconUtil.hashArray(leftCompoundExceptions, new String[]{
   "ab", "aba", "abo", "ac", "acy", "ade", "adv", "ag", "agy", "ail",
   "ain", "al", "am", "ani", "ant", "apt", "ar", "as", "at", "au", "ba",
   "bas", "bos", "ca", "cab", "cal", "can", "car", "ce", "ceil", "chi",
   "chic", "ci", "col", "cor", "cro", "cu", "da", "der", "des", "dy",
   "epic", "era", "ere", "ese", "eve", "fa", "fe", "fes", "ga", "gal",
   "ge", "ha", "he", "her", "heres", "hers", "hes", "hi", "him", "hims",
   "his", "ho", "hon", "inc", "it", "its", "ko", "lab", "la", "le", "lib",
   "lu", "ma", "mas", "me", "mil", "mo", "mon", "mos", "mu", "mus", "my",
   "na", "nas", "ne", "nes", "ni", "nil", "nis", "nod", "nor", "oh", "orb",
   "os", "ot", "our", "pa", "pal", "pat", "pi", "pic", "po", "prep", "ra",
   "ras", "ref", "res", "rev", "ri", "ris", "ru", "rus", "se", "sen",
   "sev", "seve", "sh", "she", "shes", "si", "sis", "ta", "tas", "te",
   "tes", "the", "them", "thems", "there", "theres", "they", "theys",
   "tho", "ti", "tis", "us", "vi", "we", "you", "your", "yous", "ack",
   "ad", "adel", "adi", "ains", "ak", "aker", "ala", "alb", "albar", "alf",
   "alis", "alli", "ally", "alo", "alver", "aly", "ame", "and", "ander",
   "ange", "annam", "ara", "ard", "ari", "asp", "astra", "ata", "au",
   "aun", "av", "avra", "azar", "baal", "bael", "bah", "bail", "bain",
   "bal", "balf", "bara", "bary", "baum", "beau", "beaut", "bel", "ben",
   "benn", "ber", "bergh", "berl", "bern", "bev", "bian", "bic", "bick",
   "birk", "bis", "bitt", "bitten", "bo", "bob", "bona", "bor", "bot",
   "braw", "brid", "brit", "britt", "bron", "bry", "bub", "bur", "burg",
   "burk", "busk", "but", "cad", "cai", "cam", "cant", "cas", "cass",
   "cer", "chas", "chema", "chil", "christa", "chu", "cic", "cit", "cleo",
   "cleve", "coh", "cris", "cur", "cy", "cyn", "dag", "dard", "daven",
   "deb", "del", "dela", "demit", "deni", "denn", "der", "dev", "diar",
   "dib", "dibb", "dins", "dod", "doers", "dom", "don", "dori", "doro",
   "dos", "dow", "doy", "dru", "dug", "dun", "dur", "durr", "eb", "ed",
   "ede", "edi", "el", "elia", "elian", "elis", "ell", "elo", "elon",
   "els", "ema", "eph", "er", "erl", "erle", "ern", "erna", "esma", "est",
   "ethe", "eudo", "eula", "ev", "evan", "ez", "fab", "falk", "farl",
   "farr", "fed", "feing", "fell", "fem", "feo", "fernan", "fi", "fied",
   "fins", "for", "fra", "fri", "fried", "frier", "fris", "fro", "fu",
   "fur", "gam", "gari", "gasp", "gat", "gaut", "gaye", "gee", "gel",
   "gens", "georg", "ger", "gerri", "ges", "gian", "gib", "gies", "giff",
   "gior", "gip", "git", "golds", "goth", "grani", "grus", "gu", "ha",
   "had", "halli", "hama", "han", "hana", "harl", "harri", "harv", "has",
   "hau", "haw", "hein", "helge", "hent", "hew", "hey", "hila", "hilda",
   "hilde", "ho", "hoo", "houri", "howl", "hu", "hun", "hux", "hy", "ia",
   "ib", "idel", "im", "in", "ing", "io", "ir", "isid", "isle", "ive",
   "jaco", "jae", "jami", "jamie", "jan", "jann", "jans", "jar", "jari",
   "jea", "jean", "jen", "jer", "jerri", "jess", "jessa", "jez", "jos",
   "joss", "jot", "jul", "juli", "kai", "kal", "kam", "kama", "kara",
   "kass", "kat", "kata", "kath", "kei", "ken", "keni", "kenn", "ker",
   "kerri", "kers", "kev", "ki", "kiers", "kimber", "kins", "kip", "kirk",
   "kirsch", "kiss", "kneel", "koer", "koh", "koo", "koren", "kris",
   "kristo", "kus", "kylan", "lac", "lal", "lam", "lan", "lat", "lath",
   "lau", "launce", "le", "lea", "lech", "lei", "leic", "leo", "leod",
   "ler", "less", "lev", "lewi", "li", "lia", "linds", "lins", "lipp",
   "lit", "liv", "liza", "lon", "longe", "lora", "loth", "lowen", "luza",
   "ly", "lyn", "lynd", "mab", "mac", "mack", "mada", "made", "madi",
   "magda", "mal", "mala", "malar", "mana", "mar", "mara", "marcel",
   "marga", "margar", "mari", "marin", "martin", "massar", "mathe",
   "maura", "mauri", "maxa", "mccli", "meg", "mei", "mell", "men", "merc",
   "mere", "meri", "merri", "mi", "mic", "mica", "mich", "miche", "mika",
   "milli", "mils", "min", "mir", "mira", "miri", "mit", "mitchi", "mon",
   "mont", "monte", "mor", "more", "mose", "mou", "moyna", "mun", "mungo",
   "mur", "nada", "nam", "nata", "nath", "nea", "nee", "ner", "neu", "nev",
   "nich", "nicker", "nicko", "nico", "niko", "nov", "nu", "nun", "obe",
   "obel", "ober", "ode", "om", "on", "onis", "ons", "or", "ora", "ori",
   "ors", "othe", "palla", "pars", "pary", "pas", "patt", "paws", "pe",
   "perl", "perr", "pers", "phi", "philipi", "philo", "phip", "phyl",
   "pier", "plantage", "pli", "pol", "pont", "pres", "pric", "prima",
   "pris", "pros", "pru", "prud", "pug", "pul", "puts", "quacken", "quin",
   "quint", "rab", "rad", "raf", "rafa", "rafae", "raff", "rai", "ran",
   "rea", "reb", "rein", "rentsch", "ress", "rho", "rian", "ric", "ricar",
   "rick", "rid", "rie", "riors", "ro", "rober", "roch", "rog", "ron",
   "ros", "rosa", "rosel", "roz", "rut", "sa", "sac", "sad", "sals",
   "sank", "satter", "saunder", "schou", "sen", "sept", "sera", "sever",
   "sewel", "shana", "shay", "shel", "shep", "sher", "sheri", "sherr",
   "shim", "shir", "shive", "shus", "sic", "sid", "sig", "sigism", "sil",
   "silva", "sim", "sou", "spat", "stav", "stepha", "stol", "su", "suk",
   "sunder", "sus", "swain", "swig", "sy", "syd", "syl", "tak", "tal",
   "tam", "tama", "tani", "tara", "tav", "tay", "ted", "thad", "tham",
   "theo", "this", "thom", "thoma", "thor", "thorr", "thors", "thur",
   "tid", "tie", "tiers", "tiff", "tod", "tol", "toma", "tor", "torr",
   "tref", "ty", "ul", "ult", "ur", "urba", "ut", "uti", "va", "val",
   "vala", "vale", "vari", "vas", "vasi", "vasy", "ver", "vers", "vic",
   "vin", "vince", "virg", "viv", "vlad", "vlada", "wades", "wald", "wan",
   "war", "wein", "weis", "wend", "wenda", "wende", "wi", "wie", "wil",
   "wilter", "wither", "woo", "wun", "wy", "xe", "yon", "yvon", "zach",
   "zeb", "zel", "zi", "zsa"});
 
rightCompoundExceptions = new HashSet(1200);
LexiconUtil.hashArray(rightCompoundExceptions, new String[]{
   "aba", "abas", "abies", "abilities", "ability", "able", "ableness",
   "ables", "ably", "aby", "ac", "aced", "aces", "ach", "achs", "ack",
   "acks", "acied", "acies", "acy", "ade", "aded", "ades", "adia", "adias",
   "ae", "age", "aged", "ages", "ago", "ail", "aile", "ailed", "ailes",
   "aim", "aims", "ain", "ains", "ais", "aise", "aised", "aises", "ake",
   "aked", "akes", "al", "ala", "alas", "aho", "ahos", "als", "alcies",
   "alcy", "ale", "aled", "ales", "aline", "alines", "alist", "alities",
   "ality", "allies", "ally", "aly", "amies", "amy", "ana", "anas", "ance",
   "anced", "ances", "ancies", "ancy", "ane", "aned", "anes", "anile",
   "aniled", "aniles", "anise", "ano", "anos", "anoic", "anoics", "ant",
   "ants", "anus", "are", "ared", "ares", "arian", "arianism", "aries",
   "ary", "ata", "atas", "ate", "ated", "ates", "ative", "atives", "aver",
   "avers", "axies", "axy", "bah", "bahs", "ban", "bans", "bate", "bated",
   "bates", "bel", "bled", "bol", "bole", "boles", "bols", "borne",
   "bornes", "bot", "bots", "bred", "breds", "cal", "cao", "cate", "cated",
   "cates", "cation", "ced", "ces", "che", "ched", "ches", "cid", "cide",
   "cided", "cides", "cie", "cies", "cive", "cived", "cives", "cked",
   "con", "cons", "cos", "cose", "cosed", "coses", "dia", "daric",
   "darics", "das", "den", "des", "dess", "det", "detic", "detically",
   "dge", "dges", "dier", "din", "dine", "dines", "dins", "dion", "dions",
   "dis", "dist", "dit", "don", "dons", "dred", "ea", "ean", "ed", "ee",
   "eed", "eel", "el", "ele", "ell", "elope", "elves", "em", "eme", "en",
   "ence", "ency", "ene", "ened", "ening", "ens", "ento", "eon", "epic",
   "era", "eral", "erar", "erate", "ere", "ers", "erse", "es", "ese",
   "ess", "est", "estry", "et", "eta", "etas", "ete", "eted", "etes",
   "eus", "euses", "ext", "exts", "eyed", "fe", "fic", "fie", "fri",
   "fris", "full", "fully", "gal", "gals", "gam", "gams", "gamy", "gamies",
   "gan", "gans", "gar", "gars", "ged", "geds", "ges", "get", "gets",
   "git", "gits", "goric", "graphy", "had", "hads", "hae", "haes", "hal",
   "hals", "hath", "hats", "has", "her", "here", "heres", "hers", "hes",
   "heth", "heths", "hey", "heys", "hie", "hied", "hies", "him", "hims",
   "his", "hood", "hoods", "ia", "iac", "ian", "ianism", "iat", "ible",
   "ic", "ical", "ically", "ice", "ices", "ics", "id", "idae", "ide", "ie",
   "ied", "ien", "ies", "ifish", "ify", "iless", "ill", "illid", "illidae",
   "ital", "in", "ina", "ine", "iness", "ing", "ings", "inia", "inian",
   "inize", "inule", "ion", "ionate", "is", "ish", "ism", "ist", "ite",
   "ited", "ites", "its", "ity", "ive", "ived", "ives", "ize", "jam",
   "jams", "ke", "ked", "keds", "ken", "kens", "kes", "kin", "kins",
   "lacy", "lah", "lahs", "lain", "lap", "laps", "lar", "lat", "late",
   "later", "lati", "lax", "leaves", "led", "leds", "leen", "leh", "lehs",
   "les", "less", "let", "lets", "lie", "lied", "lies", "like", "lim",
   "ling", "lith", "logies", "logy", "lop", "lops", "manship", "mar",
   "met", "mete", "meter", "mia", "mic", "min", "mon", "mons", "most",
   "mum", "nee", "ness", "nia", "nias", "nine", "nio", "nis", "nne",
   "nock", "non", "nor", "ock", "ode", "ogy", "oid", "ology", "ological",
   "oloogically", "ood", "oma", "ony", "ope", "ory", "ors", "os", "ose",
   "osome", "otid", "otidae", "our", "ours", "ous", "ovic", "own", "pathy",
   "pet", "philous", "ping", "phore", "pod", "poda", "pre", "proof",
   "racy", "reed", "res", "rest", "rid", "rids", "rim", "rine", "roi",
   "ropic", "ropy", "row", "rows", "rum", "rums", "rus", "sal", "sam",
   "samic", "sat", "sats", "sation", "sed", "sen", "sens", "ses", "she",
   "shes", "sic", "sin", "sins", "sion", "sions", "sis", "sity", "sive",
   "sky", "sly", "sol", "sols", "some", "son", "sone", "sons", "sse",
   "sses", "ssive", "ssives", "strum", "stum", "sun", "suns", "sup",
   "sups", "sus", "ta", "tably", "tal", "tam", "tams", "tas", "tat", "te",
   "ted", "tedly", "ten", "tens", "ter", "tes", "that", "thats", "them",
   "thems", "they", "theys", "thu", "thur", "thurs", "tia", "tic", "tical",
   "tically", "tid", "tie", "ties", "ting", "tion", "tin", "tine", "tined",
   "tines", "tis", "tive", "tize", "toda", "torial", "tue", "tues",
   "tomize", "tomy", "ton", "tor", "tory", "try", "tum", "tura", "ugh",
   "ule", "ules", "ult", "union", "ups", "ural", "urge", "urgic", "us",
   "usa", "use", "used", "uses", "uti", "val", "ves", "vian", "ward",
   "wards", "ware", "wares", "wed", "weds", "wes", "wise", "xi", "xis",
   "xive", "yde", "yed", "yes", "ying", "you", "your", "yours", "yous",
   "yte", "zed", "zes", "abbas", "abet", "ace", "achy", "adee", "adi",
   "adina", "adis", "ado", "ads", "aga", "ager", "agna", "agon", "ahl",
   "aid", "aint", "alba", "alda", "aldo", "aldus", "alee", "alie", "alis",
   "all", "alla", "alo", "amar", "amas", "ame", "ames", "amund", "ana",
   "and", "ander", "andes", "andra", "andry", "anetta", "aney", "ange",
   "anger", "ani", "anian", "anie", "anil", "anta", "ante", "anty", "ara",
   "aran", "ard", "arda", "ardine", "arella", "aret", "argee", "ari",
   "arie", "arin", "ario", "arra", "art", "arta", "arte", "arty", "aryn",
   "asa", "ase", "ashia", "asia", "asias", "asky", "aun", "ava", "avi",
   "avon", "away", "aye", "babas", "bai", "bak", "bal", "bald", "bao",
   "bas", "batha", "baugh", "baum", "becca", "beck", "bein", "belle",
   "benia", "ber", "bers", "bes", "beth", "bey", "bil", "bina", "blat",
   "bling", "bonneau", "bonnier", "bourne", "bra", "bray", "bree",
   "bridge", "brill", "brook", "bur", "burgh", "burne", "bury", "but",
   "bye", "cale", "cci", "celin", "cell", "celle", "cent", "centa", "chak",
   "champ", "chan", "chas", "chaw", "chen", "cher", "cheria", "chert",
   "chester", "chet", "chi", "chia", "chings", "cho", "chon", "chu", "cia",
   "cilla", "coe", "combe", "croft", "dad", "dais", "dal", "dale", "dall",
   "dam", "dama", "dard", "dars", "del", "dell", "den", "dena", "dene",
   "der", "deth", "deus", "dicta", "die", "dike", "dina", "ding", "dink",
   "doc", "dolf", "don", "donell", "doner", "dore", "dric", "dyl", "eal",
   "eary", "eban", "eda", "ede", "edee", "eke", "ekes", "ela", "elba",
   "elbert", "elene", "elia", "elis", "elka", "elki", "elle", "elli",
   "elly", "elo", "ely", "elyn", "emar", "emus", "enie", "eno", "eny",
   "eri", "erian", "erica", "erick", "erie", "erina", "erine", "erle",
   "erlin", "ern", "erna", "eryn", "essa", "esta", "ethe", "etta", "etz",
   "evan", "eve", "ferd", "fina", "fine", "finn", "for", "ford", "fore",
   "freda", "frid", "fuss", "gall", "gel", "gena", "geno", "ger", "gin",
   "gins", "gio", "golda", "han", "hana", "hance", "hani", "hanks",
   "hannie", "hany", "hear", "heim", "hett", "hew", "hick", "hier",
   "hilda", "hilde", "hocki", "hum", "hun", "ial", "iene", "ilia", "illa",
   "ima", "imar", "iner", "inga", "inge", "inna", "ira", "iras", "irk",
   "isa", "isola", "ita", "itan", "ito", "itt", "iva", "ive", "ivo", "ivy",
   "jan", "jana", "jer", "kal", "kam", "kan", "kany", "ker", "key", "kirk",
   "knell", "kos", "kus", "lac", "lad", "lai", "laine", "lais", "lam",
   "lamina", "lan", "laos", "lari", "lase", "lath", "lau", "lavy", "lei",
   "lek", "lem", "lena", "ler", "letta", "lette", "lev", "ley", "lia",
   "lida", "lier", "lieu", "ligan", "lina", "linger", "lini", "lipp",
   "lissa", "lita", "liu", "lling", "lon", "loo", "lough", "low", "lows",
   "lula", "lum", "lund", "lvi", "lyn", "lynd", "mad", "main", "maine",
   "mal", "mana", "mans", "mara", "mari", "marin", "may", "mena", "merer",
   "mert", "mid", "milla", "mir", "mit", "mmi", "mond", "mora", "mot",
   "mun", "mur", "naby", "naha", "nanie", "nary", "nata", "nay", "neas",
   "nel", "nella", "ner", "ners", "nes", "nice", "nick", "nini", "nit",
   "nita", "nos", "ntia", "ntic", "nus", "ola", "old", "ole", "ona", "one",
   "ong", "onic", "onis", "ono", "ons", "oon", "oper", "ora", "oran",
   "oree", "orie", "osian", "otto", "ouch", "ova", "ozen", "par", "pas",
   "patra", "pentier", "pero", "pert", "pes", "phi", "phina", "phira",
   "pia", "pin", "pont", "port", "pro", "rad", "raff", "raic", "ran",
   "rang", "rant", "rao", "ras", "rca", "rea", "real", "red", "ree",
   "rester", "rey", "ria", "riac", "rian", "ric", "rica", "rie", "rilee",
   "roa", "ros", "ruella", "rus", "sen", "sep", "ser", "sham", "sheba",
   "shire", "sin", "sine", "sis", "sou", "spina", "suss", "tali", "tansy",
   "tany", "taro", "tel", "ten", "tensen", "then", "thus", "tonia",
   "trice", "troy", "trude", "udo", "ula", "una", "undo", "ure", "uta",
   "vain", "vas", "ver", "vester", "vie", "vons", "wan", "wee", "weigh",
   "win", "wot", "wrick", "yah", "yak", "yen", "yon", "zsa"});
 
illegalRoots = new HashSet(200);
LexiconUtil.hashArray(illegalRoots, new String[]{
   "a", "aec", "am", "amp", "bos", "cal", "cer", "cia", "com", "der", "e",
   "ere", "est", "fe", "fini", "hel", "heli", "hist", "i", "ial", "imb",
   "imbra", "ind", "ine", "int", "ker", "ler", "lim", "loc", "mer", "mia",
   "mon", "mor", "mou", "o", "obi", "ode", "ole", "oma", "ona", "oniser",
   "onise", "onus", "ost", "par", "pe", "pli", "pum", "rad", "roi", "sal",
   "se", "seve", "si", "simul", "sis", "stre", "sty", "sub", "ter", "tia",
   "th", "thu", "thur", "thurs", "tical", "tor", "tre", "trin", "tum", "u",
   "urus", "ury", "uti", "vac"});
 
legalRoots = new HashSet(100);
LexiconUtil.hashArray(legalRoots, new String[]{
   "dad", "daddy", "home", "mom", "mommy", "mum", "mummy", "shorty", "ack",
   "app", "bet", "car", "com", "con", "doe", "ed", "fab", "fem", "gal",
   "gen", "hex", "lan", "man", "max", "mod", "opt", "rad", "red", "ref",
   "reg", "rem", "rep", "ret", "rev", "sax", "sin", "sub", "sun", "tan",
   "tit", "vat", "vet", "yes"});
 
shortYWordStrings = new HashSet(100);
LexiconUtil.hashArray(shortYWordStrings, new String[]{
   "cry", "dry", "fry", "kry", "pry", "sly", "sty", "try", "wry"});
 
sp_adjFormingPrefixes = new HashSet(100);
LexiconUtil.hashArray(sp_adjFormingPrefixes, new String[]{
   "adeno", "all", "ante", "anti", "bi", "bio", "back", "bare", "chemo",
   "counter", "contra", "down", "inter", "intra", "maxi", "mid", "meso",
   "mon", "mono", "multi", "no", "non", "octo", "on", "ortho", "oxy",
   "paleo", "pan", "para", "poly", "post", "pre", "pro", "trans", "tri",
   "under", "uni"});
 
sp_adjPrefixes = new HashSet(100);
LexiconUtil.hashArray(sp_adjPrefixes, new String[]{
   "a", "all", "an", "anti", "bi", "contra", "deca", "deci", "deka",
   "demi", "di", "dia", "hemi", "hexa", "hyper", "hypo", "il", "inter",
   "intra", "in", "im", "ir", "iso", "maxi", "meso", "mini", "mono",
   "multi", "neo", "no", "non", "nona", "octa", "octo", "para", "per",
   "penta", "petri", "petro", "photo", "poly", "pseudo", "pyro", "quadri",
   "quadru", "quin", "quinque", "septi", "tri", "uni"});
 
sp_quantityPrefixes = new HashSet(100);
LexiconUtil.hashArray(sp_quantityPrefixes, new String[]{
   "bi", "deca", "deci", "deka", "di", "hexa", "multi", "nona", "octa",
   "octo", "penta", "poly", "quadri", "quadru", "quin", "quinque", "septi",
   "tri", "uni"});
 
sp_rulePrefixes = new HashSet(200);
LexiconUtil.hashArray(sp_rulePrefixes, new String[]{
   "a", "ab", "ad", "adeno", "aero", "all", "allo", "an", "ana", "ante",
   "anti", "auto", "back", "bare", "be", "bi", "bio", "chemo", "co",
   "coco", "contra", "counter", "de", "demi", "di", "dia", "dino", "dis",
   "disco", "down", "em", "en", "ex", "extra", "fore", "gastro", "geo",
   "hemi", "here", "hyper", "hypno", "hypo", "il", "im", "in", "inner",
   "inter", "intra", "ir", "iso", "litho", "mac", "mal", "maxi", "mc",
   "meso", "mid", "mini", "mis", "mono", "multi", "neo", "neuro", "no",
   "non", "o", "octo", "off", "on", "ortho", "out", "outer", "over", "oxy",
   "paleo", "pan", "para", "petro", "photo", "poly", "post", "pre", "pro",
   "pseudo", "pyro", "quadri", "quasi", "re", "semi", "step", "sub",
   "super", "supra", "there", "trans", "tri", "ultra", "un", "under",
   "uni", "up", "vari"});
 
nonChemicalConstituents = new HashSet(300);
LexiconUtil.hashArray(nonChemicalConstituents, new String[]{
   "ac", "ag", "age", "agene", "alum", "am", "ar", "as", "at", "ation",
   "au", "b", "ba", "bar", "be", "bi", "bon", "br", "c", "ca", "car", "cd",
   "ce", "chrome", "cl", "cm", "co", "cr", "cs", "cu", "d", "de", "dew",
   "dis", "dy", "e", "ed", "en", "ener", "er", "erg", "eu", "f", "fe",
   "fr", "ga", "gd", "ge", "gen", "gene", "glut", "glutin", "h", "he",
   "hf", "hg", "ho", "i", "ink", "ir", "it", "k", "kr", "la", "li", "line",
   "list", "lu", "ly", "mag", "man", "mat", "me", "men", "ment", "mg",
   "mine", "mis", "mn", "mo", "mum", "mut", "n", "n2", "na", "nb", "nd",
   "ne", "ness", "ni", "no", "none", "o", "os", "out", "over", "p", "pa",
   "pb", "pd", "pm", "po", "pr", "pre", "ra", "ram", "rb", "re", "reg",
   "rep", "rh", "ri", "rn", "ru", "s", "sb", "sc", "se", "si", "sm", "sn",
   "solute", "sr", "t", "ta", "tat", "tb", "tc", "te", "tet", "th", "ti",
   "tin", "tion", "tl", "tm", "tram", "u", "un", "under", "v", "w", "wo",
   "xe", "y", "yb", "zn", "zr", "platy", "chemical", "radical", "scent"});
 
chemPrefixes = new HashSet(200);
LexiconUtil.hashArray(chemPrefixes, new String[]{
   "a", "ab", "ad", "all", "an", "anti", "bi", "bis", "contra", "demi",
   "dis", "di", "dia", "hemi", "hexa", "hyper", "hypo", "il", "inter",
   "intra", "in", "im", "ir", "iso", "maxi", "meso", "mini", "mis", "mono",
   "multi", "neo", "no", "non", "octo", "para", "per", "petro", "photo",
   "poly", "post", "pre", "pro", "pseudo", "pyro", "quadra", "quadri",
   "quasi", "semi", "septi", "sub", "super", "supra", "trans", "tri",
   "uni", "un"});
 
chemicalSuffixes = new HashSet(100);
LexiconUtil.hashArray(chemicalSuffixes, new String[]{
   "ate", "ene", "gen", "ide", "ine"});
 
  cat_adjSlashN = dict.makeCategory("adj/n");
  cat_adv = dict.makeCategory("adv");
  cat_advSlashAdjSlashInteger = dict.makeCategory("adv/adj/integer");
  cat_advSlashAdjSlashPrep = dict.makeCategory("adv/adj/prep");
  cat_advSlashN = dict.makeCategory("adv/n");
  cat_advSlashPrepSlashDet = dict.makeCategory("adv/prep/det");
  cat_conj = dict.makeCategory("conj");
  cat_det = dict.makeCategory("det");
  cat_digits = dict.makeCategory("digits");
  cat_firstname = dict.makeCategory("firstname");
  cat_integer = dict.makeCategory("integer");
  cat_nSlashAdjSlashAdvSlashPrefix = dict.makeCategory("n/adj/adv/prefix");
  cat_nSlashVSlashAdj = dict.makeCategory("n/v/adj");
  cat_nSlashVSlashAdjSlashAdv = dict.makeCategory("n/v/adj/adv");
  cat_nSlashVSlashAdjSlashAdvSlashPrefixSlashPrep = dict.makeCategory("n/v/adj/adv/prefix/prep");
  cat_nnSlashVSlashAdj = dict.makeCategory("nn/v/adj");
  cat_nnSlashVSlashAdjSlashAdvSlashPrefixSlashPrep = dict.makeCategory("nn/v/adj/adv/prefix/prep");
  cat_nnSlashVSlashAdjSlashAdvSlashPrefixSlashPrepSlashConj = dict.makeCategory("nn/v/adj/adv/prefix/prep/conj");
  cat_nnSlashVSlashAdjSlashPrefixSlashPrepSlashConj = dict.makeCategory("nn/v/adj/prefix/prep/conj");
  cat_number = dict.makeCategory("number");
  cat_numberSlashNSlashNpr = dict.makeCategory("number/n/npr");
  cat_prep = dict.makeCategory("prep");
  cat_prespartSlashPastpart = dict.makeCategory("prespart/pastpart");
  cat_pro = dict.makeCategory("pro");
  cat_qword = dict.makeCategory("qword");
  cat_suffix = dict.makeCategory("suffix");
  cat_tens = dict.makeCategory("tens");
  cat_vi = dict.makeCategory("vi");
  cat_vt = dict.makeCategory("vt");




  sp_wordListCheckFlag  =  false ;
  sp_recognizeInitialPlusLastnameFlag  =  false ;
  sp_makeGerundFlag  =  true ;
  sp_tryCompoundParticiples  =  true ;
  boolRuleSet_$$E_E$$$$$Q_U_I_Etc  =  new BoolRule[] { new BoolRule( new String[] { "e" ,  "e" },  false ),  new BoolRule( new String[] { "q" ,  "u" ,  "i" ,  "t" ,  "e" },  true ),  new BoolRule( new String[] { "f" ,  "i" ,  "t" ,  "e" },  false ),  new BoolRule( new String[] { "aeiou??????????????????????????" ,  "s/x" ,  "i" ,  "t" ,  "e" },  false ),  new BoolRule( new String[] { "i" ,  "c/r" ,  "i" ,  "t" ,  "e" },  false ),  new BoolRule( new String[] { "c" ,  "r" ,  "e" ,  "d" ,  "i" ,  "t" ,  "e" },  false ),  new BoolRule( new String[] { "h" ,  "a/i" ,  "b" ,  "i" ,  "t" ,  "e" },  false ),  new BoolRule( new String[] { "bcdfghjklmnpqrstvwxyz???" ,  "&" ,  "i" ,  "t" ,  "e" },  false ),  new BoolRule( new String[] { "i" ,  "p" ,  "i" ,  "t" ,  "e" },  false ),  new BoolRule( new String[] { "bcdfghjklmnpqrstvwxyz???" ,  "i" ,  "t" ,  "e" },  true ),  new BoolRule( new String[] { "t" ,  "h" ,  "e" ,  "r" ,  "e" },  false ),  new BoolRule( new String[] { "h" ,  "e" ,  "r" ,  "e" },  true ),  new BoolRule( new String[] { "e" ,  "n/r" ,  "e" },  false ),  new BoolRule( new String[] { "bcdfghjklmnpqrstvwxyz???" ,  "a/e/i/o/u/y" ,  "b/d/g/k/l/m/n/p/r/s/t" ,  "e" },  true ),  new BoolRule( new String[] { "bcdfghjklmnpqrstvwxyz???" ,  "a/e/i/o/u/y" ,  "c/g/s/v/z" ,  "e" },  true ),  new BoolRule( new String[] { "s/z" ,  "&" ,  "e" },  false ),  new BoolRule( new String[] { "bcdfghjklmnpqrstvwxyz???" ,  "&" ,  "e" },  false ),  new BoolRule( new String[] { "bcdfghjklmnpqrstvwxyz???" ,  "c/l/s/u/v" ,  "e" },  true ),  new BoolRule( new String[] { "bcdfghjklmnpqrstvwxyz???" ,  "aeiou??????????????????????????" ,  "&" ,  "b/d/f/k/l/m/n/p/r/t" ,  "e" },  false ),  new BoolRule( new String[] { "aeiou??????????????????????????" ,  "d" ,  "g" ,  "e" },  true ),  new BoolRule( new String[] { "a" ,  "n" ,  "g" ,  "e" },  true ),  new BoolRule( new String[] { "aeiou??????????????????????????" ,  "n" ,  "g" ,  "e" },  false ),  new BoolRule( new String[] { "c" ,  "e" },  true ),  new BoolRule( new String[] { "i" ,  "a" ,  "s/z" ,  "e" },  false ),  new BoolRule( new String[] { "aeiou??????????????????????????" ,  "s/v/z" ,  "e" },  true ),  new BoolRule( new String[] { "bcdfghjklmnpqrstvwxyz???" ,  "i" ,  "e" },  true ),  new BoolRule( new String[] { "h" ,  "e" ,  "a" ,  "t" ,  "e" },  false ),  new BoolRule( new String[] { "r" ,  "e" ,  "p" ,  "e" ,  "a" ,  "t" ,  "e" },  false ),  new BoolRule( new String[] { "p" ,  "l" ,  "e" ,  "a" ,  "t" ,  "e" },  false ),  new BoolRule( new String[] { "s" ,  "e" ,  "a" ,  "t" ,  "e" },  false ),  new BoolRule( new String[] { "s" ,  "w" ,  "e" ,  "a" ,  "t" ,  "e" },  false ),  new BoolRule( new String[] { "t" ,  "r" ,  "e" ,  "a" ,  "t" ,  "e" },  false ),  new BoolRule( new String[] { "d" ,  "e" ,  "f" ,  "e" ,  "a" ,  "t" ,  "e" },  false ),  new BoolRule( new String[] { "n" ,  "a" ,  "u" ,  "s" ,  "e" ,  "a" ,  "t" ,  "e" },  true ),  new BoolRule( new String[] { "n" ,  "u" ,  "c" ,  "l" ,  "e" ,  "a" ,  "t" ,  "e" },  true ),  new BoolRule( new String[] { "i" ,  "a" ,  "t" ,  "e" },  true ),  new BoolRule( new String[] { "bcdfghjklmnpqrstvwxyz???" ,  "aeiou??????????????????????????" ,  "l/s/z" ,  "&" ,  "e" },  false ),  new BoolRule( new String[] { "aeiou??????????????????????????" ,  "l/r" ,  "s/v" ,  "e" },  true ),  new BoolRule( new String[] { "bcdfghjklmnpqrstvwxyz???" ,  "aeiou??????????????????????????" ,  "b/d/f/g/k/l/m/n/p/r/s/t/v/z" ,  "e" },  true ),  new BoolRule( new String[] { "q" ,  "u" ,  "a/i/o/u" ,  "b/d/f/g/k/l/m/n/p/r/s/t/v/z" ,  "e" },  true ),  new BoolRule( new String[] { "r" ,  "v" ,  "e" },  true ),  new BoolRule( new String[] { "u" ,  "e" },  true ),  new BoolRule( new String[] { "bcdfghjklmnpqrstvwxyz???" ,  "aeiou??????????????????????????" ,  "&" ,  "b/d/f/g/k/l/m/n/p/r/s/t/v/z" ,  "e" },  false ),  new BoolRule( new String[] { "bcdfghjklmnpqrstvwxyz???" ,  "aeiou??????????????????????????" ,  "b/c/d/f/g/k/l/m/n/p/q/r/t/v" ,  "e" },  true ),  new BoolRule( new String[] { "i" ,  "n" ,  "g" ,  "e" },  false ),  new BoolRule( new String[] { "aeiou??????????????????????????" ,  "c/g" ,  "e" },  true ),  new BoolRule( new String[] { "n" ,  "c" ,  "e" },  true ),  new BoolRule( new String[] { "l/r" ,  "g" ,  "e" },  true ),  new BoolRule( new String[] { "c/s" ,  "h" ,  "e" },  false ),  new BoolRule( new String[] { "l/r" ,  "s/v" ,  "e" },  true ),  new BoolRule( new String[] { "s/z/x" ,  "e" },  false ),  new BoolRule( new String[] { "y" ,  "e" },  false ),  new BoolRule( new String[] { "bcdfghjklmnpqrstvwxyz???" ,  "l" ,  "e" },  true ),  new BoolRule( new String[] { "bcdfghjklmnpqrstvwxyz???" ,  "s" ,  "h" ,  "o" ,  "e" },  true ),  new BoolRule( new String[] { "o" ,  "o" ,  "v" },  true ),  new BoolRule( new String[] { "u" ,  "a" ,  "bcdfghjklmnpqrstvwxyz???" ,  "e" },  true )};
  sp_needsFinalE  =  boolRuleSet_$$E_E$$$$$Q_U_I_Etc ;
  boolRuleSet_$$Consonant_Vow_Etc  =  new BoolRule[] { new BoolRule( new String[] { "bcdfghjklmnpqrstvwxyz???" ,  "aeiou??????????????????????????" ,  "b/d/f/g/k/l/m/n/p/r/s/t/z" },  true ),  new BoolRule( new String[] { "q" ,  "u" ,  "aeiou??????????????????????????" ,  "b/d/f/g/k/l/m/n/p/r/s/t/z" },  true ),  new BoolRule( new String[] { "c" },  false )};
  sp_needsDoubleLetter  =  boolRuleSet_$$Consonant_Vow_Etc ;
  category_N  = dict.makeCategory( "N" );
  categorySet_Nnc  = dict.makeCategory( "NNC" );
  categorySet_Nc  = dict.makeCategory( "NC" );
  categorySet_Nm  = dict.makeCategory( "NM" );
  categorySet_Nn  = dict.makeCategory( "NN" );
  category_Adj  = dict.makeCategory( "ADJ" );
  atomSet_Nonscalar  =  new Atom[] {dict.makeAtom( "nonscalar" )};
  charSet_$$$$$$$$$$$$$$$  = "&\'-./:#*".toCharArray();
  sp_internalHyphenChars  =  charSet_$$$$$$$$$$$$$$$ ;
  charSet_$$$$$$$$$$$$$$$_Etc  = "!\"&\'()+,-./:;<>?^@$#*=~_`[\\]{}%|".toCharArray();
  sp_punctuationChars  =  charSet_$$$$$$$$$$$$$$$_Etc ;
  atomSet_$Ces  =  new Atom[] {dict.makeAtom( "-ces" )};
  atom_Number  = dict.makeAtom( "number" );
  atom_Pl  = dict.makeAtom( "pl" );
  atomSet_$Des  =  new Atom[] {dict.makeAtom( "-des" )};
  categorySet_V  = dict.makeCategory( "V" );
  atom_Tns  = dict.makeAtom( "tns" );
  atom_Present  = dict.makeAtom( "present" );
  atom_Agr  = dict.makeAtom( "agr" );
  atom_3sg  = dict.makeAtom( "3sg" );
  category_V  = dict.makeCategory( "V" );
  atomSet_$S  =  new Atom[] {dict.makeAtom( "-s" )};
  atomSet_$Ves  =  new Atom[] {dict.makeAtom( "-ves" )};
  categorySet_Anyn  = dict.makeCategory( "ANYN" );
  word_Science  = dict.makeWord( "science" );
  atom_Mass$Pure  = dict.makeAtom( "mass/pure" );
  atom_True  = dict.makeAtom( "true" );
  atom_Mass  = dict.makeAtom( "mass" );
  atom_Icode  = dict.makeAtom( "icode" );
  atom_Nopl  = dict.makeAtom( "nopl" );
  category_Nm  = dict.makeCategory( "NM" );
  categorySet_Adj  = dict.makeCategory( "ADJ" );
  category_Prefix  = dict.makeCategory( "PREFIX" );
  word_Animal  = dict.makeWord( "animal" );
  word_Family_Of_Anima_Etc  = dict.makeWord( "family_of_animal" );
  atom_Sg  = dict.makeAtom( "sg" );
  atom_$Es  = dict.makeAtom( "-es" );
  categorySet_Adj$Prefix  = dict.makeCategory( "ADJ/PREFIX" );
  wordSet_Pus  = dict.makeTabWordSet( "PUS" );
  atom_Derived$From  = dict.makeAtom( "derived-from" );
  word_Pus  = dict.makeWord( "pus" );
  word_Festival  = dict.makeWord( "festival" );
  wordSet_Mas  = dict.makeTabWordSet( "MAS" );
  atomSet_S$D  =  new Atom[] {dict.makeAtom( "s-d" )};
  atomSet_$Ies$$Es$$$Es$N_Etc  =  new Atom[] {dict.makeAtom( "-ies" ), dict.makeAtom( "-es" ), dict.makeAtom( "-*es" ), dict.makeAtom( "nopl" ), dict.makeAtom( "unique" ), dict.makeAtom( "pl" ), dict.makeAtom( "mass/pure" )};
  atomSet_Ies$Ied  =  new Atom[] {dict.makeAtom( "ies-ied" )};
  atomSet_$S$$Es$$S$Es$$$_Etc  =  new Atom[] {dict.makeAtom( "-s" ), dict.makeAtom( "-es" ), dict.makeAtom( "-s/es" ), dict.makeAtom( "-*es" ), dict.makeAtom( "nopl" ), dict.makeAtom( "unique" ), dict.makeAtom( "pl" ), dict.makeAtom( "mass/pure" )};
  atomSet_$Ies$$Es$$S$Es$_Etc  =  new Atom[] {dict.makeAtom( "-ies" ), dict.makeAtom( "-es" ), dict.makeAtom( "-s/es" ), dict.makeAtom( "-*es" )};
  atomSet_Es$Ed$Es$$Ed$Es_Etc  =  new Atom[] {dict.makeAtom( "es-ed" ), dict.makeAtom( "es-*ed" ), dict.makeAtom( "es-ed-*ed" ), dict.makeAtom( "s/es-ed" )};
  pattern_E  =  new String[] { "e" };
  atomSet_$Ies$$S$$$Es  =  new Atom[] {dict.makeAtom( "-ies" ), dict.makeAtom( "-s" ), dict.makeAtom( "-*es" )};
  pattern_S$I$S  =  new String[] { "s" ,  "i" ,  "s" };
  atomSet_Is$Es  =  new Atom[] {dict.makeAtom( "is-es" )};
  categorySet_Anyn$V  = dict.makeCategory( "ANYN/V" );
  word_Mental_Somethin_Etc  = dict.makeWord( "mental_something" );
  atom_Root  = dict.makeAtom( "root" );
  atom_Suffix  = dict.makeAtom( "suffix" );
  categorySet_Det  = dict.makeCategory( "DET" );
  categorySet_Adj$Det  = dict.makeCategory( "ADJ/DET" );
  categorySet_V$Anyn  = dict.makeCategory( "V/ANYN" );
  category_Adv  = dict.makeCategory( "ADV" );
  feature_Compound$Of  = dict.makeAtom( "compound-of" );
  atom_Feminine  = dict.makeAtom( "feminine" );
  pattern_D  =  new String[] { "d" };
  pattern_$S_X_Z$  =  new String[] { "s/x/z" };
  atomSet_S$Ed$S$D$S$$Ed$_Etc  =  new Atom[] {dict.makeAtom( "s-ed" ), dict.makeAtom( "s-d" ), dict.makeAtom( "s-*ed" ), dict.makeAtom( "s-ed-*ed" ), dict.makeAtom( "s/es-ed" )};
  pattern_$S_Z_X$  =  new String[] { "s/z/x" };
  atomSet_Es$Ed$Es$$Ed$Es_Etc$  =  new Atom[] {dict.makeAtom( "es-ed" ), dict.makeAtom( "es-*ed" ), dict.makeAtom( "es-ed-*ed" ), dict.makeAtom( "*es-*ed" )};
  atomSet_$S$$Es$$S$Es$No_Etc  =  new Atom[] {dict.makeAtom( "-s" ), dict.makeAtom( "-es" ), dict.makeAtom( "-s/es" ), dict.makeAtom( "nopl" ), dict.makeAtom( "unique" ), dict.makeAtom( "pl" ), dict.makeAtom( "mass/pure" )};
  atomSet_S$D$S$Ed$Es$Ed$_Etc  =  new Atom[] {dict.makeAtom( "s-d" ), dict.makeAtom( "s-ed" ), dict.makeAtom( "es-ed" ), dict.makeAtom( "es-*ed" ), dict.makeAtom( "es-ed-*ed" ), dict.makeAtom( "*es-*ed" ), dict.makeAtom( "s/es-ed" )};
  atomSet_$Ies  =  new Atom[] {dict.makeAtom( "-ies" )};
  atomSet_$S$$S$Es$Mass$M_Etc  =  new Atom[] {dict.makeAtom( "-s" ), dict.makeAtom( "-s/es" ), dict.makeAtom( "mass" ), dict.makeAtom( "mass/sg" ), dict.makeAtom( "mass/pl" ), dict.makeAtom( "mass/sg/pl" )};
  atomSet_Es$Ed$Ies$Ied$E_Etc  =  new Atom[] {dict.makeAtom( "es-ed" ), dict.makeAtom( "ies-ied" ), dict.makeAtom( "es-*ed" ), dict.makeAtom( "es-ed-*ed" ), dict.makeAtom( "*es-*ed" )};
  atomSet_$Es$$S$Es  =  new Atom[] {dict.makeAtom( "-es" ), dict.makeAtom( "-s/es" )};
  atomSet_Mass$Mass$Sg$Ma_Etc  =  new Atom[] {dict.makeAtom( "mass" ), dict.makeAtom( "mass/sg" ), dict.makeAtom( "mass/sg/pl" )};
  pattern_$C_S$$H  =  new String[] { "c/s" ,  "h" };
  pattern_$X_S_Z$  =  new String[] { "x/s/z" };
  pattern_Consonant$O  =  new String[] { "bcdfghjklmnpqrstvwxyz???" ,  "o" };
  atomSet_S$D$S$Ed$S$$Ed$_Etc  =  new Atom[] {dict.makeAtom( "s-d" ), dict.makeAtom( "s-ed" ), dict.makeAtom( "s-*ed" ), dict.makeAtom( "s-ed-*ed" ), dict.makeAtom( "*es-*ed" )};
  atomSet_$S$$S$Es  =  new Atom[] {dict.makeAtom( "-s" ), dict.makeAtom( "-s/es" )};
  atomSet_Es$Ed$Es$$Ed$Es_Etc$$  =  new Atom[] {dict.makeAtom( "es-ed" ), dict.makeAtom( "es-*ed" ), dict.makeAtom( "es-ed-*ed" ), dict.makeAtom( "*es-*ed" ), dict.makeAtom( "ies-ied" ), dict.makeAtom( "s-ked" ), dict.makeAtom( "s/es-ed" )};
  atomSet_$Apostrophe$S  =  new Atom[] {dict.makeAtom( "-apostrophe-s" )};
  atom_$Apostrophe$S  = dict.makeAtom( "-apostrophe-s" );
  categorySet_Number  = dict.makeCategory( "NUMBER" );
  atom_Poss  = dict.makeAtom( "poss" );
  atom_Penalty  = dict.makeAtom( "penalty" );
  word_1  = dict.makeWord( 1 );
  atomSet_S$D$S$Ed$S$$Ed$_Etc$  =  new Atom[] {dict.makeAtom( "s-d" ), dict.makeAtom( "s-ed" ), dict.makeAtom( "s-*ed" ), dict.makeAtom( "s-ed-*ed" ), dict.makeAtom( "es-ed" ), dict.makeAtom( "es-ed-*ed" ), dict.makeAtom( "es-*ed" ), dict.makeAtom( "*es-*ed" ), dict.makeAtom( "ies-ied" ), dict.makeAtom( "s-ked" ), dict.makeAtom( "s/es-ed" )};
  atomSet_$Ies$$S$$$Es$No_Etc  =  new Atom[] {dict.makeAtom( "-ies" ), dict.makeAtom( "-s" ), dict.makeAtom( "-*es" ), dict.makeAtom( "nopl" ), dict.makeAtom( "unique" ), dict.makeAtom( "pl" ), dict.makeAtom( "mass/pure" )};
  atomSet_$Ies$$S$$S$Es$$_Etc  =  new Atom[] {dict.makeAtom( "-ies" ), dict.makeAtom( "-s" ), dict.makeAtom( "-s/es" ), dict.makeAtom( "-es" ), dict.makeAtom( "-*es" ), dict.makeAtom( "nopl" ), dict.makeAtom( "unique" ), dict.makeAtom( "pl" ), dict.makeAtom( "mass/pure" )};
  pattern_A  =  new String[] { "a" };
  atomSet_$A  =  new Atom[] {dict.makeAtom( "-a" )};
  pattern_I  =  new String[] { "i" };
  atomSet_$I  =  new Atom[] {dict.makeAtom( "-i" )};
  atomSet_$$Es  =  new Atom[] {dict.makeAtom( "-*es" )};
  atomSet_$Es$$Ed  =  new Atom[] {dict.makeAtom( "*es-*ed" )};
  categorySet_Prefix  = dict.makeCategory( "PREFIX" );
  word_Modifier  = dict.makeWord( "modifier" );
  wordSequence_Relation$With  = dict.makeTabWordSequence( "RELATION	WITH" );
  word_Object  = dict.makeWord( "object" );
  word_Offspring  = dict.makeWord( "offspring" );
  word_Mod  = dict.makeWord( "mod" );
  atom_Adj  = dict.makeAtom( "adj" );
  wordSet_$  = dict.makeTabWordSet( "*" );
  wordSet_Parous  = dict.makeTabWordSet( "PAROUS" );
  word_Parous  = dict.makeWord( "parous" );
  categorySet_Anyn$Prefix  = dict.makeCategory( "ANYN/PREFIX" );
  wordSet_Iferous  = dict.makeTabWordSet( "IFEROUS" );
  categorySet_Anyn$V$Adj$Pref_Etc  = dict.makeCategory( "ANYN/V/ADJ/PREFIX" );
  pattern_$A_E_I_O$  =  new String[] { "a/e/i/o" };
  categorySet_Nn$V  = dict.makeCategory( "NN/V" );
  categorySet_Nn$Adj$Prefix  = dict.makeCategory( "NN/ADJ/PREFIX" );
  categorySet_Anyn$Adj$Prefix  = dict.makeCategory( "ANYN/ADJ/PREFIX" );
  wordSet_Aceous  = dict.makeTabWordSet( "ACEOUS" );
  word_Aceous  = dict.makeWord( "aceous" );
  word_Condition  = dict.makeWord( "condition" );
  wordSet_Osis  = dict.makeTabWordSet( "OSIS" );
  atom_Is$Es  = dict.makeAtom( "is-es" );
  categorySet_Adj$Anyn  = dict.makeCategory( "ADJ/ANYN" );
  word_2  = dict.makeWord( 2 );
  atomSet_Nopl$Unique$Pl$_Etc  =  new Atom[] {dict.makeAtom( "nopl" ), dict.makeAtom( "unique" ), dict.makeAtom( "pl" ), dict.makeAtom( "mass/pure" ), dict.makeAtom( "mass/pl" )};
  category_Lastname  = dict.makeCategory( "LASTNAME" );
  atom_Mass$Pl  = dict.makeAtom( "mass/pl" );
  atom_$Des  = dict.makeAtom( "-des" );
  atom_Guessed  = dict.makeAtom( "guessed" );
  wordSet_T  = dict.makeTabWordSet( "T" );
  atom_Known  = dict.makeAtom( "known" );
  category_Npr  = dict.makeCategory( "NPR" );
  categorySet_Npr  = dict.makeCategory( "NPR" );
  atomSet_$Es$$$Es$$Ies$$_Etc  =  new Atom[] {dict.makeAtom( "-es" ), dict.makeAtom( "-*es" ), dict.makeAtom( "-ies" ), dict.makeAtom( "-men" ), dict.makeAtom( "-ves" )};
  atom_Past  = dict.makeAtom( "past" );
  atom_Pastpart  = dict.makeAtom( "pastpart" );
  categorySet_Prefix$Anyn  = dict.makeCategory( "PREFIX/ANYN" );
  word_Fed  = dict.makeWord( "fed" );
  word_Feed  = dict.makeWord( "feed" );
  atomSet_Es$Ed$Ies$Ied  =  new Atom[] {dict.makeAtom( "es-ed" ), dict.makeAtom( "ies-ied" )};
  atomSet_S$Ed$Es$Ed$S$Ed_Etc  =  new Atom[] {dict.makeAtom( "s-ed" ), dict.makeAtom( "es-ed" ), dict.makeAtom( "s-ed-*ed" ), dict.makeAtom( "es-ed-*ed" )};
  atom_U$Prefixes  = dict.makeAtom( "u-prefixes" );
  pattern_U$N  =  new String[] { "u" ,  "n" };
  categorySet_Adj$Nn  = dict.makeCategory( "ADJ/NN" );
  wordSet_Oid  = dict.makeTabWordSet( "OID" );
  atom_$S  = dict.makeAtom( "-s" );
  word_Oid  = dict.makeWord( "oid" );
  atomSet_S$$Ed$Es$$Ed$$E_Etc  =  new Atom[] {dict.makeAtom( "s-*ed" ), dict.makeAtom( "es-*ed" ), dict.makeAtom( "*es-*ed" ), dict.makeAtom( "s-ed-*ed" ), dict.makeAtom( "es-ed-*ed" )};
  atomSet_S$Ed$S$Ked$Irrv_Etc  =  new Atom[] {dict.makeAtom( "s-ed" ), dict.makeAtom( "s-ked" ), dict.makeAtom( "irrv" ), dict.makeAtom( "irrv" )};
  word_With  = dict.makeWord( "with" );
  wordSet_Ed  = dict.makeTabWordSet( "ED" );
  word_Breed  = dict.makeWord( "breed" );
  atom_Not3sg  = dict.makeAtom( "not3sg" );
  atom_Untensed  = dict.makeAtom( "untensed" );
  atom_S$Ed  = dict.makeAtom( "s-ed" );
  category_Vti  = dict.makeCategory( "VTI" );
  categorySet_Anyn$Adj$V  = dict.makeCategory( "ANYN/ADJ/V" );
  word_Seed  = dict.makeWord( "seed" );
  category_Vt  = dict.makeCategory( "VT" );
  word_Speed  = dict.makeWord( "speed" );
  category_Vit  = dict.makeCategory( "VIT" );
  word_Weed  = dict.makeWord( "weed" );
  categorySet_Integer  = dict.makeCategory( "INTEGER" );
  atom_Kindof  = dict.makeAtom( "kindof" );
  word_Multiple  = dict.makeWord( "multiple" );
  word_$Adv$Multiply  = dict.makeWord( "!adv/multiply" );
  categorySet_Anyn$Adj$Adv$Pr_Etc  = dict.makeCategory( "ANYN/ADJ/ADV/PREP" );
  word_Bred  = dict.makeWord( "bred" );
  atom_Prefix  = dict.makeAtom( "prefix" );
  word_Ied  = dict.makeWord( "ied" );
  word_Modified_By  = dict.makeWord( "modified_by" );
  word_D  = dict.makeWord( "d" );
  word_Ed  = dict.makeWord( "ed" );
  word_By  = dict.makeWord( "by" );
  pattern_Consonant$Vowel_Etc  =  new String[] { "bcdfghjklmnpqrstvwxyz???" ,  "aeiou??????????????????????????" ,  "c/g/s/v/z" };
  category_N$V  = dict.makeCategory( "N/V" );
  categorySet_Nn$Adj  = dict.makeCategory( "NN/ADJ" );
  category_City  = dict.makeCategory( "CITY" );
  word_Eyed  = dict.makeWord( "eyed" );
  word_Eye  = dict.makeWord( "eye" );
  atom_Has$Prefix  = dict.makeAtom( "has-prefix" );
  atomSet_$Ae  =  new Atom[] {dict.makeAtom( "-ae" )};
  wordSet_Ese  = dict.makeTabWordSet( "ESE" );
  atom_Sg$Pl  = dict.makeAtom( "sg/pl" );
  category_Nmsp  = dict.makeCategory( "NMSP" );
  word_Language  = dict.makeWord( "language" );
  atom_Features  = dict.makeAtom( "features" );
  wordSet_British  = dict.makeTabWordSet( "BRITISH" );
  pattern_S$E  =  new String[] { "s" ,  "e" };
  pattern_Y$$S_Z$$E  =  new String[] { "y" ,  "s/z" ,  "e" };
  wordSet_Ize  = dict.makeTabWordSet( "IZE" );
  atom_S$D  = dict.makeAtom( "s-d" );
  word_Substance  = dict.makeWord( "substance" );
  word_Enzyme  = dict.makeWord( "enzyme" );
  wordSet_Ase  = dict.makeTabWordSet( "ASE" );
  atom_Domain  = dict.makeAtom( "domain" );
  wordSet_Chemistry  = dict.makeTabWordSet( "CHEMISTRY" );
  word_Ase  = dict.makeWord( "ase" );
  word_Side  = dict.makeWord( "side" );
  word_Beside  = dict.makeWord( "beside" );
  word_Of  = dict.makeWord( "of" );
  word_Wide  = dict.makeWord( "wide" );
  word_Throughout  = dict.makeWord( "throughout" );
  word_Size  = dict.makeWord( "size" );
  wordSet_Some  = dict.makeTabWordSet( "SOME" );
  word_Body  = dict.makeWord( "body" );
  categorySet_Digits  = dict.makeCategory( "DIGITS" );
  word_Group  = dict.makeWord( "group" );
  categorySet_Anyn$V$Adj  = dict.makeCategory( "ANYN/V/ADJ" );
  atom_Irr  = dict.makeAtom( "irr" );
  word_Drive  = dict.makeWord( "drive" );
  category_Nmc  = dict.makeCategory( "NMC" );
  categorySet_Adv  = dict.makeCategory( "ADV" );
  word_Phile  = dict.makeWord( "phile" );
  word_Person  = dict.makeWord( "person" );
  pattern_E$E  =  new String[] { "e" ,  "e" };
  atom_Misspelling$Of  = dict.makeAtom( "misspelling-of" );
  pattern_$L_N$  =  new String[] { "l/n" };
  word_Place  = dict.makeWord( "place" );
  wordSet_Ite  = dict.makeTabWordSet( "ITE" );
  pattern_$L_N$$E  =  new String[] { "l/n" ,  "e" };
  categorySet_Lastname  = dict.makeCategory( "LASTNAME" );
  word_Chemical  = dict.makeWord( "chemical" );
  wordSet_Ate  = dict.makeTabWordSet( "ATE" );
  wordSet_Trans$Passive  = dict.makeTabWordSet( "TRANS	PASSIVE" );
  categorySet_V$Adj$Nn  = dict.makeCategory( "V/ADJ/NN" );
  categorySet_Nn$Adj$V  = dict.makeCategory( "NN/ADJ/V" );
  word_Utensil  = dict.makeWord( "utensil" );
  wordSet_Ware  = dict.makeTabWordSet( "WARE" );
  wordSet_Phage  = dict.makeTabWordSet( "PHAGE" );
  word_Phage  = dict.makeWord( "phage" );
  category_Nc  = dict.makeCategory( "NC" );
  word_Poison  = dict.makeWord( "poison" );
  wordSet_Icide  = dict.makeTabWordSet( "ICIDE" );
  pattern_D$I$S  =  new String[] { "d" ,  "i" ,  "s" };
  pattern_A$B$J$U$R$E  =  new String[] { "a" ,  "b" ,  "j" ,  "u" ,  "r" ,  "e" };
  pattern_A$D$J$U$R$E  =  new String[] { "a" ,  "d" ,  "j" ,  "u" ,  "r" ,  "e" };
  pattern_A$L$L$U$R$E  =  new String[] { "a" ,  "l" ,  "l" ,  "u" ,  "r" ,  "e" };
  pattern_A$S$S$U$R$E  =  new String[] { "a" ,  "s" ,  "s" ,  "u" ,  "r" ,  "e" };
  pattern_C$A$P$T$U$R$E  =  new String[] { "c" ,  "a" ,  "p" ,  "t" ,  "u" ,  "r" ,  "e" };
  pattern_C$A$R$I$C$A$T$U_Etc  =  new String[] { "c" ,  "a" ,  "r" ,  "i" ,  "c" ,  "a" ,  "t" ,  "u" ,  "r" ,  "e" };
  pattern_C$E$N$S$U$R$E  =  new String[] { "c" ,  "e" ,  "n" ,  "s" ,  "u" ,  "r" ,  "e" };
  pattern_C$I$N$C$T$U$R$E  =  new String[] { "c" ,  "i" ,  "n" ,  "c" ,  "t" ,  "u" ,  "r" ,  "e" };
  pattern_C$L$O$S$U$R$E  =  new String[] { "c" ,  "l" ,  "o" ,  "s" ,  "u" ,  "r" ,  "e" };
  pattern_C$L$O$T$U$R$E  =  new String[] { "c" ,  "l" ,  "o" ,  "t" ,  "u" ,  "r" ,  "e" };
  pattern_C$O$I$F$F$U$R$E  =  new String[] { "c" ,  "o" ,  "i" ,  "f" ,  "f" ,  "u" ,  "r" ,  "e" };
  pattern_C$O$N$J$E$C$T$U_Etc  =  new String[] { "c" ,  "o" ,  "n" ,  "j" ,  "e" ,  "c" ,  "t" ,  "u" ,  "r" ,  "e" };
  pattern_C$O$N$J$U$R$E  =  new String[] { "c" ,  "o" ,  "n" ,  "j" ,  "u" ,  "r" ,  "e" };
  pattern_C$U$L$T$U$R$E  =  new String[] { "c" ,  "u" ,  "l" ,  "t" ,  "u" ,  "r" ,  "e" };
  pattern_C$U$R$E  =  new String[] { "c" ,  "u" ,  "r" ,  "e" };
  pattern_E$N$D$U$R$E  =  new String[] { "e" ,  "n" ,  "d" ,  "u" ,  "r" ,  "e" };
  pattern_E$N$S$U$R$E  =  new String[] { "e" ,  "n" ,  "s" ,  "u" ,  "r" ,  "e" };
  pattern_E$N$U$R$E  =  new String[] { "e" ,  "n" ,  "u" ,  "r" ,  "e" };
  pattern_F$E$A$T$U$R$E  =  new String[] { "f" ,  "e" ,  "a" ,  "t" ,  "u" ,  "r" ,  "e" };
  pattern_F$I$G$U$R$E  =  new String[] { "f" ,  "i" ,  "g" ,  "u" ,  "r" ,  "e" };
  pattern_F$I$S$S$U$R$E  =  new String[] { "f" ,  "i" ,  "s" ,  "s" ,  "u" ,  "r" ,  "e" };
  pattern_F$R$A$C$T$U$R$E  =  new String[] { "f" ,  "r" ,  "a" ,  "c" ,  "t" ,  "u" ,  "r" ,  "e" };
  pattern_G$E$S$T$U$R$E  =  new String[] { "g" ,  "e" ,  "s" ,  "t" ,  "u" ,  "r" ,  "e" };
  pattern_H$A$C$H$U$R$E  =  new String[] { "h" ,  "a" ,  "c" ,  "h" ,  "u" ,  "r" ,  "e" };
  pattern_I$M$M$U$R$E  =  new String[] { "i" ,  "m" ,  "m" ,  "u" ,  "r" ,  "e" };
  pattern_I$N$D$E$N$T$U$R_Etc  =  new String[] { "i" ,  "n" ,  "d" ,  "e" ,  "n" ,  "t" ,  "u" ,  "r" ,  "e" };
  pattern_I$N$J$U$R$E  =  new String[] { "i" ,  "n" ,  "j" ,  "u" ,  "r" ,  "e" };
  pattern_I$N$S$U$R$E  =  new String[] { "i" ,  "n" ,  "s" ,  "u" ,  "r" ,  "e" };
  pattern_I$N$U$R$E  =  new String[] { "i" ,  "n" ,  "u" ,  "r" ,  "e" };
  pattern_L$E$C$T$U$R$E  =  new String[] { "l" ,  "e" ,  "c" ,  "t" ,  "u" ,  "r" ,  "e" };
  pattern_L$I$G$A$T$U$R$E  =  new String[] { "l" ,  "i" ,  "g" ,  "a" ,  "t" ,  "u" ,  "r" ,  "e" };
  pattern_M$A$N$U$F$A$C$T_Etc  =  new String[] { "m" ,  "a" ,  "n" ,  "u" ,  "f" ,  "a" ,  "c" ,  "t" ,  "u" ,  "r" ,  "e" };
  pattern_M$A$N$U$R$E  =  new String[] { "m" ,  "a" ,  "n" ,  "u" ,  "r" ,  "e" };
  pattern_M$E$A$S$U$R$E  =  new String[] { "m" ,  "e" ,  "a" ,  "s" ,  "u" ,  "r" ,  "e" };
  pattern_M$U$R$E  =  new String[] { "m" ,  "u" ,  "r" ,  "e" };
  pattern_N$A$T$U$R$E  =  new String[] { "n" ,  "a" ,  "t" ,  "u" ,  "r" ,  "e" };
  pattern_N$U$R$T$U$R$E  =  new String[] { "n" ,  "u" ,  "r" ,  "t" ,  "u" ,  "r" ,  "e" };
  pattern_O$V$E$R$T$U$R$E  =  new String[] { "o" ,  "v" ,  "e" ,  "r" ,  "t" ,  "u" ,  "r" ,  "e" };
  pattern_P$A$S$T$U$R$E  =  new String[] { "p" ,  "a" ,  "s" ,  "t" ,  "u" ,  "r" ,  "e" };
  pattern_P$E$R$D$U$R$E  =  new String[] { "p" ,  "e" ,  "r" ,  "d" ,  "u" ,  "r" ,  "e" };
  pattern_P$E$R$J$U$R$E  =  new String[] { "p" ,  "e" ,  "r" ,  "j" ,  "u" ,  "r" ,  "e" };
  pattern_P$I$C$T$U$R$E  =  new String[] { "p" ,  "i" ,  "c" ,  "t" ,  "u" ,  "r" ,  "e" };
  pattern_P$L$E$A$S$U$R$E  =  new String[] { "p" ,  "l" ,  "e" ,  "a" ,  "s" ,  "u" ,  "r" ,  "e" };
  pattern_P$O$S$T$U$R$E  =  new String[] { "p" ,  "o" ,  "s" ,  "t" ,  "u" ,  "r" ,  "e" };
  pattern_P$R$E$S$S$U$R$E  =  new String[] { "p" ,  "r" ,  "e" ,  "s" ,  "s" ,  "u" ,  "r" ,  "e" };
  pattern_P$U$N$C$T$U$R$E  =  new String[] { "p" ,  "u" ,  "n" ,  "c" ,  "t" ,  "u" ,  "r" ,  "e" };
  pattern_R$A$P$T$U$R$E  =  new String[] { "r" ,  "a" ,  "p" ,  "t" ,  "u" ,  "r" ,  "e" };
  pattern_S$C$U$L$P$T$U$R_Etc  =  new String[] { "s" ,  "c" ,  "u" ,  "l" ,  "p" ,  "t" ,  "u" ,  "r" ,  "e" };
  pattern_S$E$C$U$R$E  =  new String[] { "s" ,  "e" ,  "c" ,  "u" ,  "r" ,  "e" };
  pattern_S$T$A$T$U$R$E  =  new String[] { "s" ,  "t" ,  "a" ,  "t" ,  "u" ,  "r" ,  "e" };
  pattern_S$T$R$I$C$T$U$R_Etc  =  new String[] { "s" ,  "t" ,  "r" ,  "i" ,  "c" ,  "t" ,  "u" ,  "r" ,  "e" };
  pattern_S$T$R$U$C$T$U$R_Etc  =  new String[] { "s" ,  "t" ,  "r" ,  "u" ,  "c" ,  "t" ,  "u" ,  "r" ,  "e" };
  pattern_S$U$T$U$R$E  =  new String[] { "s" ,  "u" ,  "t" ,  "u" ,  "r" ,  "e" };
  pattern_T$E$X$T$U$R$E  =  new String[] { "t" ,  "e" ,  "x" ,  "t" ,  "u" ,  "r" ,  "e" };
  pattern_T$I$N$C$T$U$R$E  =  new String[] { "t" ,  "i" ,  "n" ,  "c" ,  "t" ,  "u" ,  "r" ,  "e" };
  pattern_T$O$R$T$U$R$E  =  new String[] { "t" ,  "o" ,  "r" ,  "t" ,  "u" ,  "r" ,  "e" };
  pattern_T$R$E$A$S$U$R$E  =  new String[] { "t" ,  "r" ,  "e" ,  "a" ,  "s" ,  "u" ,  "r" ,  "e" };
  pattern_V$E$L$U$R$E  =  new String[] { "v" ,  "e" ,  "l" ,  "u" ,  "r" ,  "e" };
  pattern_V$E$N$T$U$R$E  =  new String[] { "v" ,  "e" ,  "n" ,  "t" ,  "u" ,  "r" ,  "e" };
  pattern_V$E$S$T$U$R$E  =  new String[] { "v" ,  "e" ,  "s" ,  "t" ,  "u" ,  "r" ,  "e" };
  categorySet_Adj$V$Anyn  = dict.makeCategory( "ADJ/V/ANYN" );
  atom_Variant$Of  = dict.makeAtom( "variant-of" );
  wordSet_Aceae  = dict.makeTabWordSet( "ACEAE" );
  wordSet_Idae  = dict.makeTabWordSet( "IDAE" );
  word_$N$Plant$Vegeta_Etc  = dict.makeWord( "!n/plant/vegetation" );
  word_Family_Of_Plant  = dict.makeWord( "family_of_plant" );
  wordSet_Ae  = dict.makeTabWordSet( "AE" );
  categorySet_Femalefirstname  = dict.makeCategory( "FEMALEFIRSTNAME" );
  word_Nickname  = dict.makeWord( "nickname" );
  category_Femalefirstname  = dict.makeCategory( "FEMALEFIRSTNAME" );
  categorySet_Firstname  = dict.makeCategory( "FIRSTNAME" );
  wordSet_Ie  = dict.makeTabWordSet( "IE" );
  wordSet_Ose  = dict.makeTabWordSet( "OSE" );
  wordSet_Phyceae  = dict.makeTabWordSet( "PHYCEAE" );
  word_Subfamily_Of_An_Etc  = dict.makeWord( "subfamily_of_animal" );
  wordSet_Inae  = dict.makeTabWordSet( "INAE" );
  word_Borne  = dict.makeWord( "borne" );
  wordSet_Phile  = dict.makeTabWordSet( "PHILE" );
  wordSet_Cide  = dict.makeTabWordSet( "CIDE" );
  wordSet_Ine  = dict.makeTabWordSet( "INE" );
  word_Female  = dict.makeWord( "female" );
  wordSet_One  = dict.makeTabWordSet( "ONE" );
  atom_Prespart  = dict.makeAtom( "prespart" );
  atomSet_S$D$S$Ed$Irrv$I_Etc  =  new Atom[] {dict.makeAtom( "s-d" ), dict.makeAtom( "s-ed" ), dict.makeAtom( "irrv" ), dict.makeAtom( "irrv" )};
  atomSet_S$D$S$Ed$Es$Ed$_Etc$  =  new Atom[] {dict.makeAtom( "s-d" ), dict.makeAtom( "s-ed" ), dict.makeAtom( "es-ed" ), dict.makeAtom( "ies-ied" ), dict.makeAtom( "s-ed-*ed" ), dict.makeAtom( "es-ed-*ed" ), dict.makeAtom( "irrv" ), dict.makeAtom( "irrv" )};
  atomSet_S$D$Irrv$Irrv  =  new Atom[] {dict.makeAtom( "s-d" ), dict.makeAtom( "irrv" ), dict.makeAtom( "irrv" )};
  word_Singe  = dict.makeWord( "singe" );
  atomSet_S$$Ed$Es$$Ed$$E_Etc$  =  new Atom[] {dict.makeAtom( "s-*ed" ), dict.makeAtom( "es-*ed" ), dict.makeAtom( "*es-*ed" ), dict.makeAtom( "s-ed-*ed" ), dict.makeAtom( "es-ed-*ed" ), dict.makeAtom( "irrv" ), dict.makeAtom( "irrv" )};
  atomSet_S$Ed$$Ed$Es$Ed$_Etc  =  new Atom[] {dict.makeAtom( "s-ed-*ed" ), dict.makeAtom( "es-ed-*ed" )};
  atom_Sense$Kinds  = dict.makeAtom( "sense-kinds" );
  word_Owning  = dict.makeWord( "owning" );
  word_Ing  = dict.makeWord( "ing" );
  wordSet_Tie$Die$Lie$Unt_Etc  = dict.makeTabWordSet( "TIE	DIE	LIE	UNTIE	RETIE" );
  category_V$N  = dict.makeCategory( "V/N" );
  categorySet_Prespart$Pastpa_Etc  = dict.makeCategory( "PRESPART/PASTPART" );
  word_Ial  = dict.makeWord( "ial" );
  word_Eal  = dict.makeWord( "eal" );
  word_Al  = dict.makeWord( "al" );
  word_Ical  = dict.makeWord( "ical" );
  word_Petal  = dict.makeWord( "petal" );
  wordSet_Re  = dict.makeTabWordSet( "RE" );
  pattern_O$U$S  =  new String[] { "o" ,  "u" ,  "s" };
  atom_Prob  = dict.makeAtom( "prob" );
  word_50  = dict.makeWord( 50 );
  word_Ful  = dict.makeWord( "ful" );
  atomSet_$S$$Es$$S$Es$$$_Etc$  =  new Atom[] {dict.makeAtom( "-s" ), dict.makeAtom( "-es" ), dict.makeAtom( "-s/es" ), dict.makeAtom( "-*es" )};
  word_Full  = dict.makeWord( "full" );
  atom_N$Takes$Preps  = dict.makeAtom( "n-takes-preps" );
  word_Container  = dict.makeWord( "container" );
  word_Unit_Of_Measure  = dict.makeWord( "unit_of_measure" );
  word_Amount  = dict.makeWord( "amount" );
  atom_Instanceof  = dict.makeAtom( "instanceof" );
  categorySet_Ncm  = dict.makeCategory( "NCM" );
  word_Physical_Someth_Etc  = dict.makeWord( "physical_something" );
  wordSet_Ful  = dict.makeTabWordSet( "FUL" );
  word_Abstract_Someth_Etc  = dict.makeWord( "abstract_something" );
  word_60  = dict.makeWord( 60 );
  feature_Guessed  = dict.makeAtom( "guessed" );
  word_40  = dict.makeWord( 40 );
  categorySet_Anyn$V$Adj$Adv  = dict.makeCategory( "ANYN/V/ADJ/ADV" );
  categorySet_Nm$Adj$Prefix  = dict.makeCategory( "NM/ADJ/PREFIX" );
  word_Dactyl  = dict.makeWord( "dactyl" );
  word_Yl  = dict.makeWord( "yl" );
  word_Chemistry  = dict.makeWord( "chemistry" );
  wordSet_Phil  = dict.makeTabWordSet( "PHIL" );
  word_Dom  = dict.makeWord( "dom" );
  categorySet_Nn$V$Adj  = dict.makeCategory( "NN/V/ADJ" );
  wordSet_Ism  = dict.makeTabWordSet( "ISM" );
  categorySet_Nn$Prefix  = dict.makeCategory( "NN/PREFIX" );
  word_Ism  = dict.makeWord( "ism" );
  word_Atism  = dict.makeWord( "atism" );
  atomSet_$En  =  new Atom[] {dict.makeAtom( "-en" )};
  atomSet_$Men  =  new Atom[] {dict.makeAtom( "-men" )};
  category_N$V$Adj$Det  = dict.makeCategory( "N/V/ADJ/DET" );
  word_Human  = dict.makeWord( "human" );
  word_Woman  = dict.makeWord( "woman" );
  atom_$Men  = dict.makeAtom( "-men" );
  word_Man  = dict.makeWord( "man" );
  wordSet_Gen  = dict.makeTabWordSet( "GEN" );
  wordSet_Biology  = dict.makeTabWordSet( "BIOLOGY" );
  word_Gen  = dict.makeWord( "gen" );
  pattern_A$N$T$I  =  new String[] { "a" ,  "n" ,  "t" ,  "i" };
  wordSet_Anticipation$An_Etc  = dict.makeTabWordSet( "ANTICIPATION	ANTIPOSITION	ANTIQUATION	ANTISEPTION" );
  pattern_A$N$T$E  =  new String[] { "a" ,  "n" ,  "t" ,  "e" };
  pattern_P$R$E  =  new String[] { "p" ,  "r" ,  "e" };
  wordSet_Prereconstructi_Etc  = dict.makeTabWordSet( "PRERECONSTRUCTION	PREREDEMPTION	PREREDUCTION	PREREFORMATION	PRERESTORATION	PREREVOLUTION" );
  pattern_P$R$O  =  new String[] { "p" ,  "r" ,  "o" };
  wordSet_Probation$Produ_Etc  = dict.makeTabWordSet( "PROBATION	PRODUCTION	PROFESSION	PROHIBITION	PROJECTION	PROMOTION	PRONATION	PRONUNCIATION	PROPORTION	PROPAGATION	PROPORTION	PROPOSITION	PROSCRIPTION	PROTECTION	PROVOCATION" );
  pattern_S$E$M$I  =  new String[] { "s" ,  "e" ,  "m" ,  "i" };
  pattern_A$M$B$I$T$I$O$N  =  new String[] { "a" ,  "m" ,  "b" ,  "i" ,  "t" ,  "i" ,  "o" ,  "n" };
  pattern_A$U$C$T$I$O$N  =  new String[] { "a" ,  "u" ,  "c" ,  "t" ,  "i" ,  "o" ,  "n" };
  pattern_A$U$D$I$T$I$O$N  =  new String[] { "a" ,  "u" ,  "d" ,  "i" ,  "t" ,  "i" ,  "o" ,  "n" };
  pattern_C$A$P$T$I$O$N  =  new String[] { "c" ,  "a" ,  "p" ,  "t" ,  "i" ,  "o" ,  "n" };
  pattern_C$A$U$T$I$O$N  =  new String[] { "c" ,  "a" ,  "u" ,  "t" ,  "i" ,  "o" ,  "n" };
  pattern_C$O$N$D$I$T$I$O_Etc  =  new String[] { "c" ,  "o" ,  "n" ,  "d" ,  "i" ,  "t" ,  "i" ,  "o" ,  "n" };
  pattern_C$O$N$F$E$C$T$I_Etc  =  new String[] { "c" ,  "o" ,  "n" ,  "f" ,  "e" ,  "c" ,  "t" ,  "i" ,  "o" ,  "n" };
  pattern_F$R$A$C$T$I$O$N  =  new String[] { "f" ,  "r" ,  "a" ,  "c" ,  "t" ,  "i" ,  "o" ,  "n" };
  pattern_F$U$N$C$T$I$O$N  =  new String[] { "f" ,  "u" ,  "n" ,  "c" ,  "t" ,  "i" ,  "o" ,  "n" };
  pattern_M$E$N$T$I$O$N  =  new String[] { "m" ,  "e" ,  "n" ,  "t" ,  "i" ,  "o" ,  "n" };
  pattern_M$O$T$I$O$N  =  new String[] { "m" ,  "o" ,  "t" ,  "i" ,  "o" ,  "n" };
  pattern_M$U$N$I$T$I$O$N  =  new String[] { "m" ,  "u" ,  "n" ,  "i" ,  "t" ,  "i" ,  "o" ,  "n" };
  pattern_P$A$R$T$I$T$I$O_Etc  =  new String[] { "p" ,  "a" ,  "r" ,  "t" ,  "i" ,  "t" ,  "i" ,  "o" ,  "n" };
  pattern_P$E$T$I$T$I$O$N  =  new String[] { "p" ,  "e" ,  "t" ,  "i" ,  "t" ,  "i" ,  "o" ,  "n" };
  pattern_P$O$R$T$I$O$N  =  new String[] { "p" ,  "o" ,  "r" ,  "t" ,  "i" ,  "o" ,  "n" };
  pattern_P$O$S$I$T$I$O$N  =  new String[] { "p" ,  "o" ,  "s" ,  "i" ,  "t" ,  "i" ,  "o" ,  "n" };
  pattern_Q$U$E$S$T$I$O$N  =  new String[] { "q" ,  "u" ,  "e" ,  "s" ,  "t" ,  "i" ,  "o" ,  "n" };
  pattern_R$E$Q$U$I$S$I$T_Etc  =  new String[] { "r" ,  "e" ,  "q" ,  "u" ,  "i" ,  "s" ,  "i" ,  "t" ,  "i" ,  "o" ,  "n" };
  pattern_S$A$N$C$T$I$O$N  =  new String[] { "s" ,  "a" ,  "n" ,  "c" ,  "t" ,  "i" ,  "o" ,  "n" };
  pattern_S$T$A$T$I$O$N  =  new String[] { "s" ,  "t" ,  "a" ,  "t" ,  "i" ,  "o" ,  "n" };
  pattern_V$A$C$A$T$I$O$N  =  new String[] { "v" ,  "a" ,  "c" ,  "a" ,  "t" ,  "i" ,  "o" ,  "n" };
  word_Tion  = dict.makeWord( "tion" );
  wordSet_Un$Non  = dict.makeTabWordSet( "UN	NON" );
  wordSet_En  = dict.makeTabWordSet( "EN" );
  wordSet_Ician  = dict.makeTabWordSet( "ICIAN" );
  wordSet_Ian  = dict.makeTabWordSet( "IAN" );
  wordSet_Arian  = dict.makeTabWordSet( "ARIAN" );
  wordSet_An  = dict.makeTabWordSet( "AN" );
  word_Age  = dict.makeWord( "age" );
  word_Generation  = dict.makeWord( "generation" );
  word_Ian  = dict.makeWord( "ian" );
  categorySet_Nn$V$Adj$Pron  = dict.makeCategory( "NN/V/ADJ/PRON" );
  wordSet_Er  = dict.makeTabWordSet( "ER" );
  word_An  = dict.makeWord( "an" );
  categorySet_Malefirstname$L_Etc  = dict.makeCategory( "MALEFIRSTNAME/LASTNAME" );
  wordSet_Son  = dict.makeTabWordSet( "SON" );
  word_Son  = dict.makeWord( "son" );
  wordSet_Sen  = dict.makeTabWordSet( "SEN" );
  word_Sen  = dict.makeWord( "sen" );
  word_Don  = dict.makeWord( "don" );
  wordSet_In  = dict.makeTabWordSet( "IN" );
  word_In  = dict.makeWord( "in" );
  pattern_V$E$R$M  =  new String[] { "v" ,  "e" ,  "r" ,  "m" };
  categorySet_Prefix$Adj$Anyn  = dict.makeCategory( "PREFIX/ADJ/ANYN" );
  category_Unit  = dict.makeCategory( "UNIT" );
  atom_Ntakespreps  = dict.makeAtom( "ntakespreps" );
  wordSet_Of  = dict.makeTabWordSet( "OF" );
  word_Unit  = dict.makeWord( "unit" );
  word_Unit_Of_Countin_Etc  = dict.makeWord( "unit_of_counting" );
  wordSet_Illion  = dict.makeTabWordSet( "ILLION" );
  atomSet_Ier$Iest  =  new Atom[] {dict.makeAtom( "ier-iest" )};
  atomSet_Ier$Iest$Er$Est_Etc  =  new Atom[] {dict.makeAtom( "ier-iest" ), dict.makeAtom( "er-est" ), dict.makeAtom( "r-st" ), dict.makeAtom( "*er-*est" ), dict.makeAtom( "ker-kest" ), dict.makeAtom( "more-most" ), dict.makeAtom( "nonscalar" ), dict.makeAtom( "irradj" ), dict.makeAtom( "irradj" )};
  atom_Comparative  = dict.makeAtom( "comparative" );
  atomSet_Ier$Iest$Er$Est_Etc$  =  new Atom[] {dict.makeAtom( "ier-iest" ), dict.makeAtom( "er-est" ), dict.makeAtom( "r-st" ), dict.makeAtom( "*er-*est" ), dict.makeAtom( "ker-kest" ), dict.makeAtom( "more-most" ), dict.makeAtom( "nonscalar" ), dict.makeAtom( "irradv" ), dict.makeAtom( "irradj" )};
  word_30  = dict.makeWord( 30 );
  atom_From  = dict.makeAtom( "from" );
  word_Ier  = dict.makeWord( "ier" );
  categorySet_Adj$Nn$Prefix  = dict.makeCategory( "ADJ/NN/PREFIX" );
  wordSet_Opter  = dict.makeTabWordSet( "OPTER" );
  category_Ncm  = dict.makeCategory( "NCM" );
  word_Flyer  = dict.makeWord( "flyer" );
  wordSet_Bacter  = dict.makeTabWordSet( "BACTER" );
  word_Bacterium  = dict.makeWord( "bacterium" );
  wordSet_Mer  = dict.makeTabWordSet( "MER" );
  word_Molecule  = dict.makeWord( "molecule" );
  word_Owner  = dict.makeWord( "owner" );
  word_Setter  = dict.makeWord( "setter" );
  atom_Entails  = dict.makeAtom( "entails" );
  word_Meter  = dict.makeWord( "meter" );
  categorySet_Malefirstname$F_Etc  = dict.makeCategory( "MALEFIRSTNAME/FEMALEFIRSTNAME/LASTNAME" );
  wordSet_Dotter  = dict.makeTabWordSet( "DOTTER" );
  word_Dotter  = dict.makeWord( "dotter" );
  categorySet_Lastname$Name  = dict.makeCategory( "LASTNAME/NAME" );
  wordSet_Heimer  = dict.makeTabWordSet( "HEIMER" );
  word_Heimer  = dict.makeWord( "heimer" );
  wordSet_Macher  = dict.makeTabWordSet( "MACHER" );
  pattern_A$N$A  =  new String[] { "a" ,  "n" ,  "a" };
  pattern_C$O$N  =  new String[] { "c" ,  "o" ,  "n" };
  pattern_D$E  =  new String[] { "d" ,  "e" };
  pattern_D$I  =  new String[] { "d" ,  "i" };
  pattern_E$X  =  new String[] { "e" ,  "x" };
  category_Nn  = dict.makeCategory( "NN" );
  categorySet_Adv$Adj  = dict.makeCategory( "ADV/ADJ" );
  categorySet_Vt  = dict.makeCategory( "VT" );
  word_R  = dict.makeWord( "r" );
  word_Er  = dict.makeWord( "er" );
  word_Ster  = dict.makeWord( "ster" );
  categorySet_V$Nn  = dict.makeCategory( "V/NN" );
  atomSet_$Er$$Est$Er$Est  =  new Atom[] {dict.makeAtom( "*er-*est" ), dict.makeAtom( "er-est" )};
  atomSet_S$$Ed$S$Ed$$Ed$_Etc  =  new Atom[] {dict.makeAtom( "s-*ed" ), dict.makeAtom( "s-ed-*ed" ), dict.makeAtom( "es-*ed" ), dict.makeAtom( "*es-*ed" )};
  word_Eer  = dict.makeWord( "eer" );
  pattern_I$E  =  new String[] { "i" ,  "e" };
  atomSet_Er$Est  =  new Atom[] {dict.makeAtom( "er-est" )};
  atomSet_Ier$Iest$Er$Est_Etc$$  =  new Atom[] {dict.makeAtom( "ier-iest" ), dict.makeAtom( "er-est" ), dict.makeAtom( "r-st" ), dict.makeAtom( "*er-*est" ), dict.makeAtom( "ker-kest" ), dict.makeAtom( "more-most" ), dict.makeAtom( "nonscalar" ), dict.makeAtom( "irradv" ), dict.makeAtom( "irradv" )};
  atomSet_R$St  =  new Atom[] {dict.makeAtom( "r-st" )};
  atomSet_Ker$Kest$Er$Est  =  new Atom[] {dict.makeAtom( "ker-kest" ), dict.makeAtom( "er-est" )};
  pattern_Any$$$Any  =  new String[] { "abcdefghijklmnopqrstuvwxyz?????????????????????????????-'/.:," ,  "&" ,  "abcdefghijklmnopqrstuvwxyz?????????????????????????????-'/.:," };
  pattern_E$Y  =  new String[] { "e" ,  "y" };
  atom_British  = dict.makeAtom( "british" );
  word_Color  = dict.makeWord( "color" );
  word_$N$Color  = dict.makeWord( "!n/color" );
  word_$V$Color  = dict.makeWord( "!v/color" );
  word_$Adj$Colored  = dict.makeWord( "!adj/colored" );
  word_Ar  = dict.makeWord( "ar" );
  word_Eur  = dict.makeWord( "eur" );
  word_Or  = dict.makeWord( "or" );
  word_Tor  = dict.makeWord( "tor" );
  word_Error  = dict.makeWord( "error" );
  word_Manager  = dict.makeWord( "manager" );
  category_V$Nn  = dict.makeCategory( "V/NN" );
  atom_2sg  = dict.makeAtom( "2sg" );
  atom_Archaic  = dict.makeAtom( "archaic" );
  categorySet_Past  = dict.makeCategory( "PAST" );
  word_Ment  = dict.makeWord( "ment" );
  word_Most  = dict.makeWord( "most" );
  wordSet_Anti$Over$Pro$U_Etc  = dict.makeTabWordSet( "ANTI	OVER	PRO	UNDER	SUB	SUPER" );
  word_Ant  = dict.makeWord( "ant" );
  categorySet_V$Adj  = dict.makeCategory( "V/ADJ" );
  word_Ent  = dict.makeWord( "ent" );
  pattern_$R_S$  =  new String[] { "r/s" };
  word_Ient  = dict.makeWord( "ient" );
  categorySet_Anyn$Adj$Prep$C_Etc  = dict.makeCategory( "ANYN/ADJ/PREP/CONJ" );
  word_Left  = dict.makeWord( "left" );
  wordSet_Left  = dict.makeTabWordSet( "LEFT" );
  categorySet_Nsg  = dict.makeCategory( "NSG" );
  wordSet_Naut  = dict.makeTabWordSet( "NAUT" );
  word_Naut  = dict.makeWord( "naut" );
  wordSet_Stat  = dict.makeTabWordSet( "STAT" );
  word_Stat  = dict.makeWord( "stat" );
  word_Ist  = dict.makeWord( "ist" );
  categorySet_Anyn$Adj$Anyn  = dict.makeCategory( "ANYN/ADJ/ANYN" );
  pattern_Y$Y  =  new String[] { "y" ,  "y" };
  categorySet_Anyn$Adj$V$Prep_Etc  = dict.makeCategory( "ANYN/ADJ/V/PREP/CONJ" );
  word_List  = dict.makeWord( "list" );
  word_Let  = dict.makeWord( "let" );
  category_N$V$Adj  = dict.makeCategory( "N/V/ADJ" );
  category_Adj$N  = dict.makeCategory( "ADJ/N" );
  wordSet_Russian  = dict.makeTabWordSet( "RUSSIAN" );
  word_Cy  = dict.makeWord( "cy" );
  wordSet_Morphy  = dict.makeTabWordSet( "MORPHY" );
  atom_$Ies  = dict.makeAtom( "-ies" );
  wordSet_Pathy  = dict.makeTabWordSet( "PATHY" );
  wordSet_Trophy  = dict.makeTabWordSet( "TROPHY" );
  wordSet_Y  = dict.makeTabWordSet( "Y" );
  wordSet_Phagy  = dict.makeTabWordSet( "PHAGY" );
  word_Phagy  = dict.makeWord( "phagy" );
  wordSet_Phony  = dict.makeTabWordSet( "PHONY" );
  wordSet_Megaly  = dict.makeTabWordSet( "MEGALY" );
  wordSet_Cephaly  = dict.makeTabWordSet( "CEPHALY" );
  word_Y  = dict.makeWord( "y" );
  word_Ry  = dict.makeWord( "ry" );
  wordSet_Ography  = dict.makeTabWordSet( "OGRAPHY" );
  wordSet_Graphy  = dict.makeTabWordSet( "GRAPHY" );
  wordSet_Ology  = dict.makeTabWordSet( "OLOGY" );
  categorySet_Npl  = dict.makeCategory( "NPL" );
  word_Shape  = dict.makeWord( "shape" );
  wordSet_Ognomy  = dict.makeTabWordSet( "OGNOMY" );
  wordSet_Nomy  = dict.makeTabWordSet( "NOMY" );
  word_Ognomy  = dict.makeWord( "ognomy" );
  word_Operation  = dict.makeWord( "operation" );
  wordSet_Otomy  = dict.makeTabWordSet( "OTOMY" );
  word_Otomy  = dict.makeWord( "otomy" );
  wordSet_Ostomy  = dict.makeTabWordSet( "OSTOMY" );
  word_Ostomy  = dict.makeWord( "ostomy" );
  wordSet_Ectomy  = dict.makeTabWordSet( "ECTOMY" );
  wordSet_Tropy  = dict.makeTabWordSet( "TROPY" );
  word_Examination  = dict.makeWord( "examination" );
  wordSet_Oscopy  = dict.makeTabWordSet( "OSCOPY" );
  wordSet_Scopy  = dict.makeTabWordSet( "SCOPY" );
  wordSet_Gamy  = dict.makeTabWordSet( "GAMY" );
  wordSet_Taxy  = dict.makeTabWordSet( "TAXY" );
  wordSet_De$Non$Re$Un  = dict.makeTabWordSet( "DE	NON	RE	UN" );
  categorySet_Nn$V$Adj$Prefix  = dict.makeCategory( "NN/V/ADJ/PREFIX" );
  word_Gamy  = dict.makeWord( "gamy" );
  word_Taxy  = dict.makeWord( "taxy" );
  wordSet_Ogony  = dict.makeTabWordSet( "OGONY" );
  wordSet_Ogeny  = dict.makeTabWordSet( "OGENY" );
  word_Ogeny  = dict.makeWord( "ogeny" );
  word_Worship  = dict.makeWord( "worship" );
  wordSet_Olatry  = dict.makeTabWordSet( "OLATRY" );
  word_Marital_Practic_Etc  = dict.makeWord( "marital_practice" );
  wordSet_Andry  = dict.makeTabWordSet( "ANDRY" );
  word_Measurement  = dict.makeWord( "measurement" );
  wordSet_Metry  = dict.makeTabWordSet( "METRY" );
  word_Ly  = dict.makeWord( "ly" );
  wordSet_Anti$Over$Pro$U_Etc$  = dict.makeTabWordSet( "ANTI	OVER	PRO	UNDER" );
  word_Ery  = dict.makeWord( "ery" );
  wordSet_Ify  = dict.makeTabWordSet( "IFY" );
  atom_Ies$Ied  = dict.makeAtom( "ies-ied" );
  wordSet_Un$Non$Over$Und_Etc  = dict.makeTabWordSet( "UN	NON	OVER	UNDER" );
  categorySet_Prespart  = dict.makeCategory( "PRESPART" );
  wordSet_Able$Al$Ant$Ar$_Etc  = dict.makeTabWordSet( "ABLE	AL	ANT	AR	ENT	FUL	IC	ICAL" );
  word_Ity  = dict.makeWord( "ity" );
  word_Ability  = dict.makeWord( "ability" );
  word_Icity  = dict.makeWord( "icity" );
  word_Ality  = dict.makeWord( "ality" );
  word_Ility  = dict.makeWord( "ility" );
  pattern_Y  =  new String[] { "y" };
  wordSet_Berry$$N$Plant$_Etc  = dict.makeTabWordSet( "BERRY	!N/PLANT/VEGETATION" );
  word_Berry  = dict.makeWord( "berry" );
  category_Firstname  = dict.makeCategory( "FIRSTNAME" );
  word_Ency  = dict.makeWord( "ency" );
  categorySet_Adj$V  = dict.makeCategory( "ADJ/V" );
  word_Ary  = dict.makeWord( "ary" );
  pattern_C$T  =  new String[] { "c" ,  "t" };
  word_Metry  = dict.makeWord( "metry" );
  pattern_A$E$R  =  new String[] { "a" ,  "e" ,  "r" };
  word_Sy  = dict.makeWord( "sy" );
  word_Ory  = dict.makeWord( "ory" );
  word_Atory  = dict.makeWord( "atory" );
  wordSet_Ply  = dict.makeTabWordSet( "PLY" );
  category_V$Adj$N  = dict.makeCategory( "V/ADJ/N" );
  word_$N$Fly  = dict.makeWord( "!n/fly" );
  word_Family  = dict.makeWord( "family" );
  word_Ancy  = dict.makeWord( "ancy" );
  word_$N$Oscopy$Exami_Etc  = dict.makeWord( "!n/oscopy/examination" );
  atom_Scalar  = dict.makeAtom( "scalar" );
  atom_Ier$Iest  = dict.makeAtom( "ier-iest" );
  wordSet_Ity  = dict.makeTabWordSet( "ITY" );
  wordSet_A$An$Dis$In$Im$_Etc  = dict.makeTabWordSet( "A	AN	DIS	IN	IM	NON	UN" );
  word_Antic  = dict.makeWord( "antic" );
  word_Etic  = dict.makeWord( "etic" );
  word_Acetic  = dict.makeWord( "acetic" );
  wordSet_Acetic  = dict.makeTabWordSet( "ACETIC" );
  word_Atic  = dict.makeWord( "atic" );
  word_Istic  = dict.makeWord( "istic" );
  word_Otic  = dict.makeWord( "otic" );
  categorySet_Np  = dict.makeCategory( "NP" );
  wordSet_Otic  = dict.makeTabWordSet( "OTIC" );
  wordSet_In$Im$Non$Un  = dict.makeTabWordSet( "IN	IM	NON	UN" );
  wordSet_Iac  = dict.makeTabWordSet( "IAC" );
  word_Scope  = dict.makeWord( "scope" );
  word_Scopic  = dict.makeWord( "scopic" );
  categorySet_Prefix$Adj  = dict.makeCategory( "PREFIX/ADJ" );
  wordSet_Tropic  = dict.makeTabWordSet( "TROPIC" );
  wordSet_Zoic  = dict.makeTabWordSet( "ZOIC" );
  word_$N$Era$Time_Per_Etc  = dict.makeWord( "!n/era/time_period" );
  atom_Unique  = dict.makeAtom( "unique" );
  atomSet_$Ata  =  new Atom[] {dict.makeAtom( "-ata" )};
  categorySet_Country$Npr  = dict.makeCategory( "COUNTRY/NPR" );
  wordSet_I  = dict.makeTabWordSet( "I" );
  wordSet_Alum$Bum$Bunkum_Etc  = dict.makeTabWordSet( "ALUM	BUM	BUNKUM	CRUM	DINKUM	DRUM	DUM	GLUM	GUM	HOKUM	HOODLUM	HUM	LINOLEUM	LOOKUM	PLUM	MUM	OAKUM	OPIUM	OPOSSUM	PETROLATUM	PETROLEUM	PLUM	PODIUM	POSSUM	PREMIUM	RHEUM	RUM	SCARUM	SCUM	SLUM	STICKUM	STRUM	STUM	SUM	SWUM	TANTRUM	THRUM	TRINKUM	TUM	UUM" );
  pattern_T$I$O$N  =  new String[] { "t" ,  "i" ,  "o" ,  "n" };
  word_Fish  = dict.makeWord( "fish" );
  word_Skill  = dict.makeWord( "skill" );
  wordSet_Ship  = dict.makeTabWordSet( "SHIP" );
  word_Role  = dict.makeWord( "role" );
  word_Proof  = dict.makeWord( "proof" );
  wordSet_Proof  = dict.makeTabWordSet( "PROOF" );
  word_Speak  = dict.makeWord( "speak" );
  wordSet_Speak  = dict.makeTabWordSet( "SPEAK" );
  word_Technical_Langu_Etc  = dict.makeWord( "technical_language" );
  word_Talk  = dict.makeWord( "talk" );
  word_Jargon  = dict.makeWord( "jargon" );
  wordSet_Ia  = dict.makeTabWordSet( "IA" );
  wordSet_Zoa  = dict.makeTabWordSet( "ZOA" );
  word_Zoa  = dict.makeWord( "zoa" );
  wordSet_Trix  = dict.makeTabWordSet( "TRIX" );
  atom_$Ces  = dict.makeAtom( "-ces" );
  wordSet_Branch  = dict.makeTabWordSet( "BRANCH" );
  word_Branch  = dict.makeWord( "branch" );
  category_Ord  = dict.makeCategory( "ORD" );
  word_Ordinal  = dict.makeWord( "ordinal" );
  wordSet_Th  = dict.makeTabWordSet( "TH" );
  word_Position  = dict.makeWord( "position" );
  categorySet_City$Country  = dict.makeCategory( "CITY/COUNTRY" );
  word_Country  = dict.makeWord( "country" );
  atom_Has$Root  = dict.makeAtom( "has-root" );
  atomSet_$Apostrophe$S$$_Etc  =  new Atom[] {dict.makeAtom( "-apostrophe-s" ), dict.makeAtom( "-*es" ), dict.makeAtom( "-a" ), dict.makeAtom( "-ae" ), dict.makeAtom( "-ata" ), dict.makeAtom( "-en" ), dict.makeAtom( "-es" ), dict.makeAtom( "-ies" ), dict.makeAtom( "-men" ), dict.makeAtom( "-s" ), dict.makeAtom( "-s/es" ), dict.makeAtom( "-ves" ), dict.makeAtom( "is-es" ), dict.makeAtom( "nopl" )};
  atom_$I  = dict.makeAtom( "-i" );
  wordSet_Tion  = dict.makeTabWordSet( "TION" );
  wordSet_Ation  = dict.makeTabWordSet( "ATION" );
  categorySet_V$Adj$Anyn  = dict.makeCategory( "V/ADJ/ANYN" );
  word_Ication  = dict.makeWord( "ication" );
  category_V$Adj  = dict.makeCategory( "V/ADJ" );
  atom_Superlative  = dict.makeAtom( "superlative" );
  wordSet_Iform  = dict.makeTabWordSet( "IFORM" );
  wordSet_Anti$Bi$Centi$D_Etc  = dict.makeTabWordSet( "ANTI	BI	CENTI	DECI	DEMI	DI	HEMI	HI	MAXI	MEDI	MILLI	MINI	QUADRI	QUASI	SEMI	SESQUI	TRI	UNI" );
  word_Bodypart  = dict.makeWord( "bodypart" );
  wordSet_Itis  = dict.makeTabWordSet( "ITIS" );
  atom_Es$Ed  = dict.makeAtom( "es-ed" );
  atom_S$$Ed  = dict.makeAtom( "s-*ed" );
  atom_More$Most  = dict.makeAtom( "more-most" );
  atom_S$Ked  = dict.makeAtom( "s-ked" );
  category_Name  = dict.makeCategory( "NAME" );
  wordSet_An$Ism$Ist$Ity$_Etc  = dict.makeTabWordSet( "AN	ISM	IST	ITY	TION	ATION	NESS	MENT	RY	Y	ER	OR" );
  categorySet_Adj$N  = dict.makeCategory( "ADJ/N" );
  wordSet_Ism$Ist$Ity$Tio_Etc  = dict.makeTabWordSet( "ISM	IST	ITY	TION	ATION	NESS	MENT	RY	ERY	Y	ER	OR" );
  categorySet_Vi  = dict.makeCategory( "VI" );
  categorySet_Special$Qword$D_Etc  = dict.makeCategory( "SPECIAL/QWORD/DET/PREP/CONJ" );
  feature_Abbrev  = dict.makeAtom( "abbrev" );
  category_Vi  = dict.makeCategory( "VI" );
  categorySet_Special$Qword$D_Etc$  = dict.makeCategory( "SPECIAL/QWORD/DET/PREP/ADV/CONJ" );
  categorySet_N  = dict.makeCategory( "N" );
  wordSet_Ic$Atic$Al$Ar$O_Etc  = dict.makeTabWordSet( "IC	ATIC	AL	AR	OSE	OUS	Y	RY" );
  wordSet_Ic$Atic  = dict.makeTabWordSet( "IC	ATIC" );
  categorySet_Unit  = dict.makeCategory( "UNIT" );
  pattern_I$C  =  new String[] { "i" ,  "c" };
  pattern_A$$L_R$  =  new String[] { "a" ,  "l/r" };
  pattern_O$S$E  =  new String[] { "o" ,  "s" ,  "e" };
  wordSet_Ache  = dict.makeTabWordSet( "ACHE" );
  categorySet_Prep  = dict.makeCategory( "PREP" );
  categorySet_Adj$Nn$Suffix  = dict.makeCategory( "ADJ/NN/SUFFIX" );
  categorySet_Adj$N$Suffix  = dict.makeCategory( "ADJ/N/SUFFIX" );
  categorySet_Prespart$Pastpa_Etc$  = dict.makeCategory( "PRESPART/PASTPART/ADJ/ANYN" );
  wordSet_Fish  = dict.makeTabWordSet( "FISH" );
  word_Fish_Bodypart  = dict.makeWord( "fish_bodypart" );
  wordSet_Bird  = dict.makeTabWordSet( "BIRD" );
  word_Bird_Bodypart  = dict.makeWord( "bird_bodypart" );
  categorySet_Suffix  = dict.makeCategory( "SUFFIX" );
  wordSet_Bodypart  = dict.makeTabWordSet( "BODYPART" );
  wordSet_Animal  = dict.makeTabWordSet( "ANIMAL" );
  categorySet_Pastpart  = dict.makeCategory( "PASTPART" );
  wordSet_A$Co$De$In$No$U_Etc  = dict.makeTabWordSet( "A	CO	DE	IN	NO	UN" );
  word_Separate  = dict.makeWord( "separate" );
  word_From  = dict.makeWord( "from" );
  wordSet_E$Ve$En  = dict.makeTabWordSet( "E	VE	EN" );
  word_$Adv$Down  = dict.makeWord( "!adv/down" );
  categorySet_Pastpart$Prespa_Etc  = dict.makeCategory( "PASTPART/PRESPART" );
  word_En  = dict.makeWord( "en" );
  word_$Vt$Change  = dict.makeWord( "!vt/change" );
  pattern_E$N  =  new String[] { "e" ,  "n" };
  wordSet_Em  = dict.makeTabWordSet( "EM" );
  wordSet_Ter  = dict.makeTabWordSet( "TER" );
  pattern_C$I$T$Y  =  new String[] { "c" ,  "i" ,  "t" ,  "y" };
  pattern_E$S$Q$U$E  =  new String[] { "e" ,  "s" ,  "q" ,  "u" ,  "e" };
  wordSet_Ism$Ist$Ity$Tio_Etc$  = dict.makeTabWordSet( "ISM	IST	ITY	TION	ATION	NESS	MENT	RY	Y" );
  categorySet_Adv$Anyn  = dict.makeCategory( "ADV/ANYN" );
  categorySet_Adv$N  = dict.makeCategory( "ADV/N" );
  word_Not  = dict.makeWord( "not" );
  categorySet_Adj$N$Adv  = dict.makeCategory( "ADJ/N/ADV" );
  categorySet_N$V$Adj  = dict.makeCategory( "N/V/ADJ" );
  word_Surpass  = dict.makeWord( "surpass" );
  wordSet_Al  = dict.makeTabWordSet( "AL" );
  wordSet_Ism$Ist$Ity$Tio_Etc$$  = dict.makeTabWordSet( "ISM	IST	ITY	TION	ATION	NESS	MENT	RY	ERY	ER	OR" );
  categorySet_Nn$Adj$Adv  = dict.makeCategory( "NN/ADJ/ADV" );
  word_Exceed  = dict.makeWord( "exceed" );
  categorySet_Adv$Nn  = dict.makeCategory( "ADV/NN" );
  categorySet_Adj$Adv$Nn$V  = dict.makeCategory( "ADJ/ADV/NN/V" );
  wordSet_Ness  = dict.makeTabWordSet( "NESS" );
  categorySet_Name  = dict.makeCategory( "NAME" );
  wordSet_Ise$Ize$Ate$En$_Etc  = dict.makeTabWordSet( "ISE	IZE	ATE	EN	E" );
  pattern_I$$S_Z$$E  =  new String[] { "i" ,  "s/z" ,  "e" };
  pattern_A$T$E  =  new String[] { "a" ,  "t" ,  "e" };
  word_$V$Redo  = dict.makeWord( "!v/redo" );
  word_$V$Repeat  = dict.makeWord( "!v/repeat" );
  word_Re$  = dict.makeWord( "re-" );
  wordSet_$V$Redo$$V$Repe_Etc  = dict.makeTabWordSet( "!V/REDO	!V/REPEAT" );
  categorySet_N$Adj  = dict.makeCategory( "N/ADJ" );
  word_Semi  = dict.makeWord( "semi" );
  dictStruct_$Prob_50$  =  new Value[] { atom_Prob ,  word_50 };
  word_$N$Relative$Per_Etc  = dict.makeWord( "!n/relative/person" );
  word_Half  = dict.makeWord( "half" );
  wordSet_Ar  = dict.makeTabWordSet( "AR" );
  word_$V$Separate  = dict.makeWord( "!v/separate" );
  word_Non  = dict.makeWord( "non" );
  wordSet_Ism$Ist$Ity$Tio_Etc$$$  = dict.makeTabWordSet( "ISM	IST	ITY	TION	ATION	NESS	MENT	RY	Y	ER" );
  word_$Adv$Up  = dict.makeWord( "!adv/up" );
  pattern_T$Y  =  new String[] { "t" ,  "y" };
  wordSet_Fitz  = dict.makeTabWordSet( "FITZ" );
  word_Fitz  = dict.makeWord( "fitz" );
  category_Integer  = dict.makeCategory( "INTEGER" );
  category_Prep  = dict.makeCategory( "PREP" );
  wordSet_A$Ad$Ar$De$En$E_Etc  = dict.makeTabWordSet( "A	AD	AR	DE	EN	EX	RE	VS" );
  word_To  = dict.makeWord( "to" );
  wordSet_For  = dict.makeTabWordSet( "FOR" );
  wordSet_Be$Have  = dict.makeTabWordSet( "BE	HAVE" );
  word_Type  = dict.makeWord( "type" );
  categorySet_Npr$Adj  = dict.makeCategory( "NPR/ADJ" );
  wordSet_And$Or  = dict.makeTabWordSet( "AND	OR" );
  wordSet_De$Re  = dict.makeTabWordSet( "DE	RE" );
  categorySet_Prespart$Nm  = dict.makeCategory( "PRESPART/NM" );
  wordSet_Self  = dict.makeTabWordSet( "SELF" );
  wordSet_All$Many$So$Too  = dict.makeTabWordSet( "ALL	MANY	SO	TOO" );
  categorySet_Comparative  = dict.makeCategory( "COMPARATIVE" );
  wordSet_East$North$Sout_Etc  = dict.makeTabWordSet( "EAST	NORTH	SOUTH	WEST" );
  word_Compass_Directi_Etc  = dict.makeWord( "compass_direction" );
  wordSet_North$South  = dict.makeTabWordSet( "NORTH	SOUTH" );
  wordSet_East$West  = dict.makeTabWordSet( "EAST	WEST" );
  category_Adj$Pred  = dict.makeCategory( "ADJ-PRED" );
  category_Adv$Pred  = dict.makeCategory( "ADV-PRED" );
  word_To$Be  = dict.makeWord( "to-be" );
  word_Future  = dict.makeWord( "future" );
  wordSet_To$Be  = dict.makeTabWordSet( "TO-BE" );
  wordSet_To  = dict.makeTabWordSet( "TO" );
  word_Out  = dict.makeWord( "out" );
  atom_Inflects$At  = dict.makeAtom( "inflects-at" );
  atom_Able$Rule  = dict.makeAtom( "able-rule" );
  wordSet_Who$What$When$W_Etc  = dict.makeTabWordSet( "WHO	WHAT	WHEN	WHERE	WHY	HOW	WHILE" );
  stringArray_$$_  =  new String[] { "-" ,  "_" };
  categorySet_Anyn$Adj  = dict.makeCategory( "ANYN/ADJ" );
  categorySet_Adj$Adv  = dict.makeCategory( "ADJ/ADV" );
  wordSet_Man$Is$Are$Am$W_Etc  = dict.makeTabWordSet( "MAN	IS	ARE	AM	WAS	WERE	BE	BEEN	HAS	HAVE	HAD" );
  wordSet_As$Bare  = dict.makeTabWordSet( "AS	BARE" );
  wordSet_See$Saw  = dict.makeTabWordSet( "SEE	SAW" );
  wordSet_$N$Fish  = dict.makeTabWordSet( "!N/FISH" );
  wordSet_$N$Bird  = dict.makeTabWordSet( "!N/BIRD" );
  wordSet_$Nc$Plant$Veget_Etc  = dict.makeTabWordSet( "!NC/PLANT/VEGETATION" );
  word_Part_Of_Plant  = dict.makeWord( "part_of_plant" );
  pattern_S  =  new String[] { "s" };
  wordSet_$N$Animal  = dict.makeTabWordSet( "!N/ANIMAL" );
  categorySet_Npr$Number  = dict.makeCategory( "NPR/NUMBER" );
  pattern_L$Y  =  new String[] { "l" ,  "y" };
  categorySet_Adv$Prep  = dict.makeCategory( "ADV/PREP" );
  categorySet_Anyn$V$Adj$Adv$_Etc  = dict.makeCategory( "ANYN/V/ADJ/ADV/PREFIX/PREP" );
  categorySet_Nn$V$Adj$Prefix_Etc  = dict.makeCategory( "NN/V/ADJ/PREFIX/PREP/CONJ" );
  wordSet_Bare  = dict.makeTabWordSet( "BARE" );
  wordSet_Man  = dict.makeTabWordSet( "MAN" );
  categorySet_V$Adj$Prefix  = dict.makeCategory( "V/ADJ/PREFIX" );
  categorySet_Prespart$Pastpa_Etc$$  = dict.makeCategory( "PRESPART/PASTPART/ADJ" );
  categorySet_Anyn$Prespart  = dict.makeCategory( "ANYN/PRESPART" );
  categorySet_Comparative$Sup_Etc  = dict.makeCategory( "COMPARATIVE/SUPERLATIVE" );
  categorySet_Malefirstname  = dict.makeCategory( "MALEFIRSTNAME" );
  category_Malefirstname  = dict.makeCategory( "MALEFIRSTNAME" );
  word_Fraction  = dict.makeWord( "fraction" );
  atom_Denominator  = dict.makeAtom( "denominator" );
  wordSet_Ndth  = dict.makeTabWordSet( "NDTH" );
  category_Number  = dict.makeCategory( "NUMBER" );
  wordSet_St  = dict.makeTabWordSet( "ST" );
  wordSet_Nd  = dict.makeTabWordSet( "ND" );
  wordSet_Rd  = dict.makeTabWordSet( "RD" );
  wordSet_Ndths  = dict.makeTabWordSet( "NDTHS" );
  wordSet_Ths  = dict.makeTabWordSet( "THS" );
  wordSet_Sts  = dict.makeTabWordSet( "STS" );
  wordSet_Nds  = dict.makeTabWordSet( "NDS" );
  wordSet_Rds  = dict.makeTabWordSet( "RDS" );
  atomSet_$Es  =  new Atom[] {dict.makeAtom( "-es" )};
  atomSet_Nopl$Unique  =  new Atom[] {dict.makeAtom( "nopl" ), dict.makeAtom( "unique" )};
  categorySet_Npr$Lastname$Fi_Etc  = dict.makeCategory( "NPR/LASTNAME/FIRSTNAME/CITY/COUNTRY" );
  atomSet_S$D$S$Ed$S$Ked$_Etc  =  new Atom[] {dict.makeAtom( "s-d" ), dict.makeAtom( "s-ed" ), dict.makeAtom( "s-ked" ), dict.makeAtom( "s-*ed" ), dict.makeAtom( "s-ed-*ed" )};
  atomSet_Es$Ed$Es$$Ed$Es_Etc$$$  =  new Atom[] {dict.makeAtom( "es-ed" ), dict.makeAtom( "es-*ed" ), dict.makeAtom( "es-ed-*ed" )};
  atomSet_S$Ked  =  new Atom[] {dict.makeAtom( "s-ked" )};
  atomSet_S$Ed$Es$Ed  =  new Atom[] {dict.makeAtom( "s-ed" ), dict.makeAtom( "es-ed" )};
  atomSet_S$$Ed$Es$$Ed$$E_Etc$$  =  new Atom[] {dict.makeAtom( "s-*ed" ), dict.makeAtom( "es-*ed" ), dict.makeAtom( "*es-*ed" )};
  categorySet_V$Anyn$Adj  = dict.makeCategory( "V/ANYN/ADJ" );
  atomSet_Es$Ed$S$Ed  =  new Atom[] {dict.makeAtom( "es-ed" ), dict.makeAtom( "s-ed" )};
  atomSet_$Es$$Ed$Es$$Ed$_Etc  =  new Atom[] {dict.makeAtom( "*es-*ed" ), dict.makeAtom( "es-*ed" ), dict.makeAtom( "s-*ed" )};
  atomSet_Ker$Kest  =  new Atom[] {dict.makeAtom( "ker-kest" )};
  atomSet_$Er$$Est  =  new Atom[] {dict.makeAtom( "*er-*est" )};
// fake assignments to "globals" for morph
// initially written pmartin 8 may 01 -- 
//
// waw 2004-05-13 commented out assignment of sp_adjPrefixes, etc.
// waw 2004-05-09 commented out assignment of sp_chemicalSuffixes
// last changed pm 26 apr 04 to rename some hash sets
// pm 06 apr 04 making wordSets into HashSets
// waw 03-29-04 moved some variables to MorphEngFns and Morph_Template_en
// prev 12 Aug 02

/*
// fixed to use HashSets .. pm 06apr04
////// sp_adjPrefixes = new Lexicon.Word[]{dict.makeWord("someAdjPrefix")};
sp_adjPrefixes = new HashSet(100);
  Lexicon.hashArray(sp_adjPrefixes,
   new String[]{
   "a", "all", "an", "anti", "bi", 
   "contra", "deca", "deci", "deka", "demi", "di", "dia", 
   "hemi", "hexa", "hyper", "hypo",
   "il", "inter", "intra", "in", "im", "ir", "iso", 
   "maxi", "meso", "mini", "mono", "multi",
   "neo", "no", "non", "nona", "octa", "octo", 
   "para", "per", "penta", "petri", "petro", "photo", "poly", "pseudo", "pyro",
   "quadri", "quadru", "quin", "quinque", 
   "septi", "tri", "uni"});
//////sp_quantityPrefixes = new Lexicon.Word[]{dict.makeWord("someQuantPrefix")};
sp_quantityPrefixes = new HashSet(100); 
  Lexicon.hashArray(sp_quantityPrefixes,
   new String[]{
   "bi", "deca", "deci", "deka", "di", 
   "hexa", "multi", "nona", "octa", "octo", 
   "penta", "poly", "quadri", "quadru", "quin", "quinque", 
   "septi", "tri", "uni"});
*/

sp_guessVerbFlag = false;
sp_minimumCompoundLength = 3;

// plus more 16may01

/// sp_rulePrefixes = new Lexicon.Word[]{};
// changed pm 06apr04
//sp_rulePrefixes = new HashSet(200); 
//  Lexicon.hashArray(sp_rulePrefixes,
//   new String[]{
//   "a", "ab", "ad", "adeno", "aero", "all", "allo", "an", "ana", "ante", 
//   "anti", "auto", 
//   "back", "bare", "be", "bi", "bio", 
//   "chemo", "co", "coco", "contra", "counter", 
//   "de", "demi", "di", "dia", "dino", "dis", "disco", "down", 
//   "em", "en",  "ex", "extra", "fore", 
//   "gastro", "geo",
//   "hemi", "hyper", "hypno", "hypo", 
//   "il", "inner", "inter", "intra", "im", "in", "ir", "iso", "litho", 
//   "mac", "mal", "maxi", "mc", "meso", "mid", "mini", "mis", "mono", "multi",
//   "neo", "neuro", "no", "non", 
//   "o", "octo", "off", "on", "ortho", "out", "outer", "over", "oxy",
//   "paleo", "pan", "para",  "petro", "photo", "poly", "post", "pre", 
//   "pro", "pseudo", "pyro",
//   "quadri", "quasi", "re", 
//   "semi", "step", "sub", "super", "supra", 
//   "there", "trans", "tri", 
//   "ultra", "under", "uni", "un", "up", 
//   "vari"});

// plus 17may01 additions
sp_skipVerbForHyphenatedParticiples = false;

/*
//sp_adjFormingPrefixes = new Lexicon.Word[]{dict.makeWord("someAdjFormingPrefix")};
sp_adjFormingPrefixes = new HashSet(100); 
  Lexicon.hashArray(sp_adjFormingPrefixes,
   new String[]{
   "adeno", "all", "ante", "anti", 
   "bi", "bio", "back", "bare", 
   "chemo", "counter", "contra", "down",
   "inter", "intra", 
   "maxi", "mid", "meso", "mono", "mon", "multi",
   "non", "no", "octo", "on", "ortho", "oxy",
   "paleo", "pan", "para", "poly", "post", "pre", "pro",
   "trans", "tri", "under", "uni"});
*/

sp_inflectManMenFlag = true;


/// plus more from "chemistrySet" 18july01

sp_strongChemTestFlag  =  false;

// words not allowed as chemical constituents   

//sp_nonChemicalConstituents  = dict.makeWordSet( "AC/AG/AGE/AGENE/ALUM/AM/AR/AS/AT/ATION/AU/B/BA/BAR/BE/BI/BON/BR/C/CA/CAR/CD/CE/CHROME/CL/CM/CO/CR/CS/CU/D/DE/DEW/DIS/DY/E/ED/EN/ENER/ER/ERG/EU/F/FE/FR/GA/GD/GE/GEN/GENE/GLUT/GLUTIN/H/HE/HF/HG/HO/I/INK/IR/IT/K/KR/LA/LI/LINE/LIST/LU/LY/MAG/MAT/ME/MEN/MENT/MG/MINE/MIS/MN/MO/MUM/MUT/N/N2/NA/NB/ND/NE/NESS/NI/NO/NONE/O/OS/OUT/OVER/P/PA/PB/PD/PM/PO/PR/PRE/RA/RAM/RB/RE/REG/REP/RH/RI/RN/RU/S/SB/SC/SE/SI/SM/SN/SOLUTE/SR/T/TA/TAT/TB/TC/TE/TET/TH/TI/TIN/TION/TL/TM/TRAM/U/UN/UNDER/V/W/WO/XE/Y/YB/ZN/ZR/PLATY/CHEMICAL/RADICAL/SCENT" );
// sp_nonChemicalConstituents = new HashSet(200); 
//   Lexicon.hashArray(sp_nonChemicalConstituents,
//    new String[]{
//    "ac","ag", "age", "agene", "alum", "am","ar", "as", "at", "ation",
//    "au",
//    "b", "ba", "bar", "be", "bi","bon", "br", 
//    "c", "ca", "car", "cd", "ce", "chrome", "cl", "cm", "co", "cr", "cs",
//    "cu",
//    "d", "de", "dew", "dis", "dy", 
//    "e", "ed", "en", "ener", "er", "erg", "eu", 
//    "f", "fe", "fr", 
//    "ga", "gd", "ge", "gen", "gene", "glut", "glutin", 
//    "h", "he", "hf", "hg", "ho", 
//    "i", "ink", "ir", "it",
//    "k", "kr", "la", 
//    "li", "line", "list", "lu", "ly", 
//    "mag", "mat", "me", "men", "ment", "mg", "mine", "mis", "mn", "mo",
//    "mum", "mut", 
//    "n", "n2", "na", "nb", "nd", "ne", "ness", "ni", "no", "none", 
//    "o", "os", "out", "over", 
//    "p", "pa", "pb", "pd", "pm", "po", "pr", "pre", 
//    "ra", "ram", "rb", "re", "reg", "rep", "rh", "ri", "rn", "ru",
//    "s", "sb", "sc", "se", "si", "sm", "sn", "solute", "sr",
//    "t", "ta", "tat", "tb", "tc", "te", "tet", "th", "ti", "tin", "tion",
//    "tl", "tm", "tram", 
//    "u", "un", "under", "v", "w", "wo", "xe",
//    "y", "yb", "zn", "zr", 
//    "platy", "chemical", "radical", "scent"});

//sp_chemPrefixes  =  dict.makeWordSet(
//"A/AB/AD/ALL/AN/ANTI/BI/CONTRA/DEMI/DIS/DI/DIA/HEMI/HEXA/HYPER/HYPO/"
//  + "IL/INTER/INTRA/IN/IM/IR/ISO/MAXI/MESO/MINI/MIS/MONO/MULTI/NEO/NO/"
//  + "NON/OCTO/PARA/PER/PETRO/PHOTO/POLY/POST/PRE/PRO/PSEUDO/PYRO/"
//  + "QUADRA/QUADRI/QUASI/SEMI/SEPTI/SUB/SUPER/SUPRA/TRANS/TRI/UNI/UN"
//);
//  sp_chemPrefixes = new HashSet(200); 
//   Lexicon.hashArray(sp_chemPrefixes,
//    new String[]{
//    "a", "ab", "ad", "all", "an", "anti",
//    "bi", "bis", 
//    "contra", "demi", "dis", "di", "dia", 
//    "hemi", "hexa", "hyper", "hypo",
//    "il", "inter", "intra", "in", "im", "ir", "iso", 
//    "maxi", "meso", "mini", "mis", "mono", "multi", 
//    "neo", "no", "non",
//    "octo", "para", "per", "petro", "photo", "poly", "post", "pre", "pro",
//    "pseudo", "pyro", 
//    "quadra", "quadri", "quasi", 
//    "semi", "septi", "sub", "super", "supra", 
//    "trans", "tri", 
//    "uni", "un"});


//sp_chemicalSuffixes  =  dict.makeWordSet( "ATE/ENE/GEN/IDE/INE" );
//sp_chemicalSuffixes = new HashSet(10); 
//  Lexicon.hashArray(sp_chemicalSuffixes,
//         new String[]{"ate", "ene", "gen", "ide", "ine"});

word_Ate  = dict.makeWord("ate");
/// word_Chemical  = dict.makeWord("chemical");
/// word_Chemistry  = dict.makeWord( "chemistry" );
word_ChemNamePart  = dict.makeWord( "chemNamePart" );
feature_Sense$Kinds  = dict.makeAtom( "sense-kinds" );
wholeChemicalWords = dict.makeSpaceWordSet( 
  "CHEMICAL CHEMICAL_ELEMENT !N/CHEMICAL_ELEMENT ISOTOPE" );
majorChemicalWords  = dict.makeSpaceWordSet(
  "CHEMICAL CHEMICAL_ELEMENT !N/CHEMICAL_ELEMENT CHEM-NAME-PART ISOTOPE" );
feature_Derivation  = dict.makeAtom( "derivation" );
feature_Domain  = dict.makeAtom( "domain" );
atom_ChemicalNameTest = dict.makeAtom( "chemicalNametest" );
atomSet_S$D$$S = new Atom[]{dict.makeAtom("s-d"), dict.makeAtom("-s")};

category_Past = dict.makeCategory("Past");
category_PastPart = dict.makeCategory("Pastpart");
category_Suffix = dict.makeCategory( "Suffix" );
category_Prefix$Suffix =  dict.makeCategory( "Prefix/Suffix" );
category_N$Adj$Prefix$Suffix = dict.makeCategory( "N/Adj/Prefix/Suffix" );

/// added pmartin 12 aug 02 for optimzing category subsumption
dict.setCategoryBits();

//pm 8apr04
LexiconUtil.hashArray(assimilatedPrefixes, new String[]
        {"ac", "af", "ag", "al", "ap", "as", "at"});

sp_barredChemicalEndings = new String[] {
    "ing", "ed", "s", 
    // "i|y  s|z ing",  // allomerizing
    // "i|y  s|z e d|s ",
    "y", // blocks quicksilvery
    // "fy, 
    // "ate", // thiocynanate .. use suffix rule
    //"al", "an", // polyvinylformal
    // "ating", "ated", "ates", 
    // "fying", "fied", "fies",
    "ise", "ize", "yse", "yze",  
    // "ide" // transactinide, but * trioxide
    "ous", "ic", // blocks diaminopropionic, trichloroacetic -- complex adj
    "able", // blocks alkalisable
    "tion", // blocks alkalisation 
};

////////////
////////// plus constants needed for inflection code choosers
//////////////////////////////

//sp_consonantChars = "bcdfghjklmnpqrstvwxyz???";
//sp_vowelChars = "aeiou??????????????????????????";


///////////////////////////////////////////////////////
// plus a hack to cover "word" til it becomes "lex"
word = dict.makeWord("fakeword");

// end of Lisp-generated variable assignments


    // Set morphCompoundRules, after converting temporary compound rules to MorphCompoundRule
    // objects using this Lexicon (dict) (and storing the result on the static variable
    // convertedMorphCompoundRules).  This allows multiple instances of Morph_en, but they
    // will all use the same lexicon (dict) and the same converted rules.
    if (tempMorphCompoundRules != null) {
      convertedMorphCompoundRules = convertCompoundRules(tempMorphCompoundRules,
                                                         ":morph-compound-rules", dict);
      tempMorphCompoundRules = null; //free up the space used for temporary rules
    }
    morphCompoundRules = convertedMorphCompoundRules;
  }

// insert Lisp-generated word binding declarations here

// binding definitions for literals

 protected Category cat_adjSlashN;
 protected Category cat_adv;
 protected Category cat_advSlashAdjSlashInteger;
 protected Category cat_advSlashAdjSlashPrep;
 protected Category cat_advSlashN;
 protected Category cat_advSlashPrepSlashDet;
 protected Category cat_conj;
 protected Category cat_det;
 protected Category cat_digits;
 protected Category cat_firstname;
 protected Category cat_integer;
 protected Category cat_nSlashAdjSlashAdvSlashPrefix;
 protected Category cat_nSlashVSlashAdj;
 protected Category cat_nSlashVSlashAdjSlashAdv;
 protected Category cat_nSlashVSlashAdjSlashAdvSlashPrefixSlashPrep;
 protected Category cat_nnSlashVSlashAdj;
 protected Category cat_nnSlashVSlashAdjSlashAdvSlashPrefixSlashPrep;
 protected Category cat_nnSlashVSlashAdjSlashAdvSlashPrefixSlashPrepSlashConj;
 protected Category cat_nnSlashVSlashAdjSlashPrefixSlashPrepSlashConj;
 protected Category cat_number;
 protected Category cat_numberSlashNSlashNpr;
 protected Category cat_prep;
 protected Category cat_prespartSlashPastpart;
 protected Category cat_pro;
 protected Category cat_qword;
 protected Category cat_suffix;
 protected Category cat_tens;
 protected Category cat_vi;
 protected Category cat_vt;


 protected Word word_a;
 protected Word word_ab;
 protected Word word_able;
 protected Word word_aceous;
 protected Word word_ad;
 protected Word word_adeno;
 protected Word word_aero;
 protected Word word_age;
 protected Word word_all;
 protected Word word_allo;
 protected Word word_an;
 protected Word word_ana;
 protected Word word_ance;
 protected Word word_aneous;
 protected Word word_ante;
 protected Word word_anti;
 protected Word word_ata;
 protected Word word_ative;
 protected Word word_auto;
 protected Word word_back;
 protected Word word_bare;
 protected Word word_be;
 protected Word word_bi;
 protected Word word_bio;
 protected Word word_chemo;
 protected Word word_co;
 protected Word word_coco;
 protected Word word_contra;
 protected Word word_counter;
 protected Word word_de;
 protected Word word_demi;
 protected Word word_di;
 protected Word word_dia;
 protected Word word_dino;
 protected Word word_dis;
 protected Word word_disco;
 protected Word word_down;
 protected Word word_ed;
 protected Word word_ee;
 protected Word word_eer;
 protected Word word_em;
 protected Word word_en;
 protected Word word_ence;
 protected Word word_er;
 protected Word word_esque;
 protected Word word_ess;
 protected Word word_est;
 protected Word word_ex;
 protected Word word_extra;
 protected Word word_fold;
 protected Word word_fore;
 protected Word word_gastro;
 protected Word word_geo;
 protected Word word_hemi;
 protected Word word_here;
 protected Word word_hyper;
 protected Word word_hypno;
 protected Word word_hypo;
 protected Word word_ian;
 protected Word word_ic;
 protected Word word_ics;
 protected Word word_id;
 protected Word word_ier;
 protected Word word_il;
 protected Word word_im;
 protected Word word_in;
 protected Word word_ing;
 protected Word word_inner;
 protected Word word_inter;
 protected Word word_intra;
 protected Word word_ir;
 protected Word word_ish;
 protected Word word_iso;
 protected Word word_ista;
 protected Word word_itious;
 protected Word word_ive;
 protected Word word_less;
 protected Word word_like;
 protected Word word_ling;
 protected Word word_litho;
 protected Word word_mac;
 protected Word word_mal;
 protected Word word_maxi;
 protected Word word_mc;
 protected Word word_ment;
 protected Word word_meso;
 protected Word word_mid;
 protected Word word_mini;
 protected Word word_mis;
 protected Word word_mono;
 protected Word word_multi;
 protected Word word_neo;
 protected Word word_ness;
 protected Word word_neuro;
 protected Word word_no;
 protected Word word_non;
 protected Word word_o;
 protected Word word_octo;
 protected Word word_off;
 protected Word word_on;
 protected Word word_or;
 protected Word word_ortho;
 protected Word word_ose;
 protected Word word_ous;
 protected Word word_out;
 protected Word word_outer;
 protected Word word_over;
 protected Word word_oxy;
 protected Word word_paleo;
 protected Word word_pan;
 protected Word word_para;
 protected Word word_petro;
 protected Word word_photo;
 protected Word word_poly;
 protected Word word_post;
 protected Word word_pre;
 protected Word word_pro;
 protected Word word_pseudo;
 protected Word word_pyro;
 protected Word word_quadri;
 protected Word word_quasi;
 protected Word word_re;
 protected Word word_ress;
 protected Word word_s;
 protected Word word_semi;
 protected Word word_some;
 protected Word word_step;
 protected Word word_sub;
 protected Word word_super;
 protected Word word_supra;
 protected Word word_there;
 protected Word word_tive;
 protected Word word_trans;
 protected Word word_tri;
 protected Word word_ule;
 protected Word word_ultra;
 protected Word word_under;
 protected Word word_uni;
 protected Word word_up;
 protected Word word_ure;
 protected Word word_vari;
 protected Word word_ward;
 protected Word word_wards;
 protected Word word_wise;



 /* Next 7 items from /lab/indexing/java/morph-trans/morphNumberedClauseVars.lisp
 */
 /* turn on the check wordlists */
  boolean  sp_wordListCheckFlag ;
 /* choose name rules */
  boolean  sp_recognizeInitialPlusLastnameFlag ;
 /* true to add this case to dict */
  boolean  sp_makeGerundFlag ;
  boolean  sp_tryCompoundParticiples ;
 /* Next 0 items from /lab/indexing/java/morph-trans/morphMorphStructs.lisp
 */
 /* Next 16 items from /lab/indexing/java/morph-trans/morphMorphTransFns.lisp
 */
  BoolRule[]  boolRuleSet_$$E_E$$$$$Q_U_I_Etc ;
  BoolRule[]  sp_needsFinalE ;
  BoolRule[]  boolRuleSet_$$Consonant_Vow_Etc ;
  BoolRule[]  sp_needsDoubleLetter ;
  Category  category_N ;
  Category  categorySet_Nnc ;
  Category  categorySet_Nc ;
  Category  categorySet_Nm ;
  Category  categorySet_Nn ;
  Category  category_Adj ;
  Atom[]  atomSet_Nonscalar ;
  char[]  charSet_$$$$$$$$$$$$$$$ ;
 /* characters that can occur in hyphenated words */
  char[]  sp_internalHyphenChars ;
  char[]  charSet_$$$$$$$$$$$$$$$_Etc ;
  char[]  sp_punctuationChars ;
 /* Next 808 items from /lab/indexing/java/morph-trans/scratch/numbered-clause-rules59.lisp
 */
  Atom[]  atomSet_$Ces ;
  Atom  atom_Number ;
  Atom  atom_Pl ;
  Atom[]  atomSet_$Des ;
  Category  categorySet_V ;
  Atom  atom_Tns ;
  Atom  atom_Present ;
  Atom  atom_Agr ;
  Atom  atom_3sg ;
  Category  category_V ;
  Atom[]  atomSet_$S ;
  Atom[]  atomSet_$Ves ;
  Category  categorySet_Anyn ;
  Word  word_Science ;
  Atom  atom_Mass$Pure ;
  Atom  atom_True ;
  Atom  atom_Mass ;
  Atom  atom_Icode ;
  Atom  atom_Nopl ;
  Category  category_Nm ;
  Category  categorySet_Adj ;
  Category  category_Prefix ;
  Word  word_Animal ;
  Word  word_Family_Of_Anima_Etc ;
  Atom  atom_Sg ;
  Atom  atom_$Es ;
  Category  categorySet_Adj$Prefix ;
  Word[]  wordSet_Pus ;
  Atom  atom_Derived$From ;
  Word  word_Pus ;
  Word  word_Festival ;
  Word[]  wordSet_Mas ;
  Atom[]  atomSet_S$D ;
  Atom[]  atomSet_$Ies$$Es$$$Es$N_Etc ;
  Atom[]  atomSet_Ies$Ied ;
  Atom[]  atomSet_$S$$Es$$S$Es$$$_Etc ;
  Atom[]  atomSet_$Ies$$Es$$S$Es$_Etc ;
  Atom[]  atomSet_Es$Ed$Es$$Ed$Es_Etc ;
  String[]  pattern_E ;
  Atom[]  atomSet_$Ies$$S$$$Es ;
  String[]  pattern_S$I$S ;
  Atom[]  atomSet_Is$Es ;
  Category  categorySet_Anyn$V ;
  Word  word_Mental_Somethin_Etc ;
  Atom  atom_Root ;
  Atom  atom_Suffix ;
  Category  categorySet_Det ;
  Category  categorySet_Adj$Det ;
  Category  categorySet_V$Anyn ;
  Category  category_Adv ;
  Atom  feature_Compound$Of ;
  Atom  atom_Feminine ;
  String[]  pattern_D ;
  String[]  pattern_$S_X_Z$ ;
  Atom[]  atomSet_S$Ed$S$D$S$$Ed$_Etc ;
  String[]  pattern_$S_Z_X$ ;
  Atom[]  atomSet_Es$Ed$Es$$Ed$Es_Etc$ ;
  Atom[]  atomSet_$S$$Es$$S$Es$No_Etc ;
  Atom[]  atomSet_S$D$S$Ed$Es$Ed$_Etc ;
  Atom[]  atomSet_$Ies ;
  Atom[]  atomSet_$S$$S$Es$Mass$M_Etc ;
  Atom[]  atomSet_Es$Ed$Ies$Ied$E_Etc ;
  Atom[]  atomSet_$Es$$S$Es ;
  Atom[]  atomSet_Mass$Mass$Sg$Ma_Etc ;
  String[]  pattern_$C_S$$H ;
  String[]  pattern_$X_S_Z$ ;
  String[]  pattern_Consonant$O ;
  Atom[]  atomSet_S$D$S$Ed$S$$Ed$_Etc ;
  Atom[]  atomSet_$S$$S$Es ;
  Atom[]  atomSet_Es$Ed$Es$$Ed$Es_Etc$$ ;
  Atom[]  atomSet_$Apostrophe$S ;
  Atom  atom_$Apostrophe$S ;
  Category  categorySet_Number ;
  Atom  atom_Poss ;
  Atom  atom_Penalty ;
  Word  word_1 ;
  Atom[]  atomSet_S$D$S$Ed$S$$Ed$_Etc$ ;
  Atom[]  atomSet_$Ies$$S$$$Es$No_Etc ;
  Atom[]  atomSet_$Ies$$S$$S$Es$$_Etc ;
  String[]  pattern_A ;
  Atom[]  atomSet_$A ;
  String[]  pattern_I ;
  Atom[]  atomSet_$I ;
  Atom[]  atomSet_$$Es ;
  Atom[]  atomSet_$Es$$Ed ;
  Category  categorySet_Prefix ;
  Word  word_Modifier ;
  Word[]  wordSequence_Relation$With ;
  Word  word_Object ;
  Word  word_Offspring ;
  Word  word_Mod ;
  Atom  atom_Adj ;
  Word[]  wordSet_$ ;
  Word[]  wordSet_Parous ;
  Word  word_Parous ;
  Category  categorySet_Anyn$Prefix ;
  Word[]  wordSet_Iferous ;
  Category  categorySet_Anyn$V$Adj$Pref_Etc ;
  String[]  pattern_$A_E_I_O$ ;
  Category  categorySet_Nn$V ;
  Category  categorySet_Nn$Adj$Prefix ;
  Category  categorySet_Anyn$Adj$Prefix ;
  Word[]  wordSet_Aceous ;
  Word  word_Aceous ;
  Word  word_Condition ;
  Word[]  wordSet_Osis ;
  Atom  atom_Is$Es ;
  Category  categorySet_Adj$Anyn ;
  Word  word_2 ;
  Atom[]  atomSet_Nopl$Unique$Pl$_Etc ;
  Category  category_Lastname ;
  Atom  atom_Mass$Pl ;
  Atom  atom_$Des ;
  Atom  atom_Guessed ;
  Word[]  wordSet_T ;
  Atom  atom_Known ;
  Category  category_Npr ;
  Category  categorySet_Npr ;
  Atom[]  atomSet_$Es$$$Es$$Ies$$_Etc ;
  Atom  atom_Past ;
  Atom  atom_Pastpart ;
  Category  categorySet_Prefix$Anyn ;
  Word  word_Fed ;
  Word  word_Feed ;
  Atom[]  atomSet_Es$Ed$Ies$Ied ;
  Atom[]  atomSet_S$Ed$Es$Ed$S$Ed_Etc ;
  Atom  atom_U$Prefixes ;
  String[]  pattern_U$N ;
  Category  categorySet_Adj$Nn ;
  Word[]  wordSet_Oid ;
  Atom  atom_$S ;
  Word  word_Oid ;
  Atom[]  atomSet_S$$Ed$Es$$Ed$$E_Etc ;
  Atom[]  atomSet_S$Ed$S$Ked$Irrv_Etc ;
  Word  word_With ;
  Word[]  wordSet_Ed ;
  Word  word_Breed ;
  Atom  atom_Not3sg ;
  Atom  atom_Untensed ;
  Atom  atom_S$Ed ;
  Category  category_Vti ;
  Category  categorySet_Anyn$Adj$V ;
  Word  word_Seed ;
  Category  category_Vt ;
  Word  word_Speed ;
  Category  category_Vit ;
  Word  word_Weed ;
  Category  categorySet_Integer ;
  Atom  atom_Kindof ;
  Word  word_Multiple ;
  Word  word_$Adv$Multiply ;
  Category  categorySet_Anyn$Adj$Adv$Pr_Etc ;
  Word  word_Bred ;
  Atom  atom_Prefix ;
  Word  word_Ied ;
  Word  word_Modified_By ;
  Word  word_D ;
  Word  word_Ed ;
  Word  word_By ;
  String[]  pattern_Consonant$Vowel_Etc ;
  Category  category_N$V ;
  Category  categorySet_Nn$Adj ;
  Category  category_City ;
  Word  word_Eyed ;
  Word  word_Eye ;
  Atom  atom_Has$Prefix ;
  Atom[]  atomSet_$Ae ;
  Word[]  wordSet_Ese ;
  Atom  atom_Sg$Pl ;
  Category  category_Nmsp ;
  Word  word_Language ;
  Atom  atom_Features ;
  Word[]  wordSet_British ;
  String[]  pattern_S$E ;
  String[]  pattern_Y$$S_Z$$E ;
  Word[]  wordSet_Ize ;
  Atom  atom_S$D ;
  Word  word_Substance ;
  Word  word_Enzyme ;
  Word[]  wordSet_Ase ;
  Atom  atom_Domain ;
  Word[]  wordSet_Chemistry ;
  Word  word_Ase ;
  Word  word_Side ;
  Word  word_Beside ;
  Word  word_Of ;
  Word  word_Wide ;
  Word  word_Throughout ;
  Word  word_Size ;
  Word[]  wordSet_Some ;
  Word  word_Body ;
  Category  categorySet_Digits ;
  Word  word_Group ;
  Category  categorySet_Anyn$V$Adj ;
  Atom  atom_Irr ;
  Word  word_Drive ;
  Category  category_Nmc ;
  Category  categorySet_Adv ;
  Word  word_Phile ;
  Word  word_Person ;
  String[]  pattern_E$E ;
  Atom  atom_Misspelling$Of ;
  String[]  pattern_$L_N$ ;
  Word  word_Place ;
  Word[]  wordSet_Ite ;
  String[]  pattern_$L_N$$E ;
  Category  categorySet_Lastname ;
  Word  word_Chemical ;
  Word[]  wordSet_Ate ;
  Word[]  wordSet_Trans$Passive ;
  Category  categorySet_V$Adj$Nn ;
  Category  categorySet_Nn$Adj$V ;
  Word  word_Utensil ;
  Word[]  wordSet_Ware ;
  Word[]  wordSet_Phage ;
  Word  word_Phage ;
  Category  category_Nc ;
  Word  word_Poison ;
  Word[]  wordSet_Icide ;
  String[]  pattern_D$I$S ;
  String[]  pattern_A$B$J$U$R$E ;
  String[]  pattern_A$D$J$U$R$E ;
  String[]  pattern_A$L$L$U$R$E ;
  String[]  pattern_A$S$S$U$R$E ;
  String[]  pattern_C$A$P$T$U$R$E ;
  String[]  pattern_C$A$R$I$C$A$T$U_Etc ;
  String[]  pattern_C$E$N$S$U$R$E ;
  String[]  pattern_C$I$N$C$T$U$R$E ;
  String[]  pattern_C$L$O$S$U$R$E ;
  String[]  pattern_C$L$O$T$U$R$E ;
  String[]  pattern_C$O$I$F$F$U$R$E ;
  String[]  pattern_C$O$N$J$E$C$T$U_Etc ;
  String[]  pattern_C$O$N$J$U$R$E ;
  String[]  pattern_C$U$L$T$U$R$E ;
  String[]  pattern_C$U$R$E ;
  String[]  pattern_E$N$D$U$R$E ;
  String[]  pattern_E$N$S$U$R$E ;
  String[]  pattern_E$N$U$R$E ;
  String[]  pattern_F$E$A$T$U$R$E ;
  String[]  pattern_F$I$G$U$R$E ;
  String[]  pattern_F$I$S$S$U$R$E ;
  String[]  pattern_F$R$A$C$T$U$R$E ;
  String[]  pattern_G$E$S$T$U$R$E ;
  String[]  pattern_H$A$C$H$U$R$E ;
  String[]  pattern_I$M$M$U$R$E ;
  String[]  pattern_I$N$D$E$N$T$U$R_Etc ;
  String[]  pattern_I$N$J$U$R$E ;
  String[]  pattern_I$N$S$U$R$E ;
  String[]  pattern_I$N$U$R$E ;
  String[]  pattern_L$E$C$T$U$R$E ;
  String[]  pattern_L$I$G$A$T$U$R$E ;
  String[]  pattern_M$A$N$U$F$A$C$T_Etc ;
  String[]  pattern_M$A$N$U$R$E ;
  String[]  pattern_M$E$A$S$U$R$E ;
  String[]  pattern_M$U$R$E ;
  String[]  pattern_N$A$T$U$R$E ;
  String[]  pattern_N$U$R$T$U$R$E ;
  String[]  pattern_O$V$E$R$T$U$R$E ;
  String[]  pattern_P$A$S$T$U$R$E ;
  String[]  pattern_P$E$R$D$U$R$E ;
  String[]  pattern_P$E$R$J$U$R$E ;
  String[]  pattern_P$I$C$T$U$R$E ;
  String[]  pattern_P$L$E$A$S$U$R$E ;
  String[]  pattern_P$O$S$T$U$R$E ;
  String[]  pattern_P$R$E$S$S$U$R$E ;
  String[]  pattern_P$U$N$C$T$U$R$E ;
  String[]  pattern_R$A$P$T$U$R$E ;
  String[]  pattern_S$C$U$L$P$T$U$R_Etc ;
  String[]  pattern_S$E$C$U$R$E ;
  String[]  pattern_S$T$A$T$U$R$E ;
  String[]  pattern_S$T$R$I$C$T$U$R_Etc ;
  String[]  pattern_S$T$R$U$C$T$U$R_Etc ;
  String[]  pattern_S$U$T$U$R$E ;
  String[]  pattern_T$E$X$T$U$R$E ;
  String[]  pattern_T$I$N$C$T$U$R$E ;
  String[]  pattern_T$O$R$T$U$R$E ;
  String[]  pattern_T$R$E$A$S$U$R$E ;
  String[]  pattern_V$E$L$U$R$E ;
  String[]  pattern_V$E$N$T$U$R$E ;
  String[]  pattern_V$E$S$T$U$R$E ;
  Category  categorySet_Adj$V$Anyn ;
  Atom  atom_Variant$Of ;
  Word[]  wordSet_Aceae ;
  Word[]  wordSet_Idae ;
  Word  word_$N$Plant$Vegeta_Etc ;
  Word  word_Family_Of_Plant ;
  Word[]  wordSet_Ae ;
  Category  categorySet_Femalefirstname ;
  Word  word_Nickname ;
  Category  category_Femalefirstname ;
  Category  categorySet_Firstname ;
  Word[]  wordSet_Ie ;
  Word[]  wordSet_Ose ;
  Word[]  wordSet_Phyceae ;
  Word  word_Subfamily_Of_An_Etc ;
  Word[]  wordSet_Inae ;
  Word  word_Borne ;
  Word[]  wordSet_Phile ;
  Word[]  wordSet_Cide ;
  Word[]  wordSet_Ine ;
  Word  word_Female ;
  Word[]  wordSet_One ;
  Atom  atom_Prespart ;
  Atom[]  atomSet_S$D$S$Ed$Irrv$I_Etc ;
  Atom[]  atomSet_S$D$S$Ed$Es$Ed$_Etc$ ;
  Atom[]  atomSet_S$D$Irrv$Irrv ;
  Word  word_Singe ;
  Atom[]  atomSet_S$$Ed$Es$$Ed$$E_Etc$ ;
  Atom[]  atomSet_S$Ed$$Ed$Es$Ed$_Etc ;
  Atom  atom_Sense$Kinds ;
  Word  word_Owning ;
  Word  word_Ing ;
  Word[]  wordSet_Tie$Die$Lie$Unt_Etc ;
  Category  category_V$N ;
  Category  categorySet_Prespart$Pastpa_Etc ;
  Word  word_Ial ;
  Word  word_Eal ;
  Word  word_Al ;
  Word  word_Ical ;
  Word  word_Petal ;
  Word[]  wordSet_Re ;
  String[]  pattern_O$U$S ;
  Atom  atom_Prob ;
  Word  word_50 ;
  Word  word_Ful ;
  Atom[]  atomSet_$S$$Es$$S$Es$$$_Etc$ ;
  Word  word_Full ;
  Atom  atom_N$Takes$Preps ;
  Word  word_Container ;
  Word  word_Unit_Of_Measure ;
  Word  word_Amount ;
  Atom  atom_Instanceof ;
  Category  categorySet_Ncm ;
  Word  word_Physical_Someth_Etc ;
  Word[]  wordSet_Ful ;
  Word  word_Abstract_Someth_Etc ;
  Word  word_60 ;
  Atom  feature_Guessed ;
  Word  word_40 ;
  Category  categorySet_Anyn$V$Adj$Adv ;
  Category  categorySet_Nm$Adj$Prefix ;
  Word  word_Dactyl ;
  Word  word_Yl ;
  Word  word_Chemistry ;
  Word[]  wordSet_Phil ;
  Word  word_Dom ;
  Category  categorySet_Nn$V$Adj ;
  Word[]  wordSet_Ism ;
  Category  categorySet_Nn$Prefix ;
  Word  word_Ism ;
  Word  word_Atism ;
  Atom[]  atomSet_$En ;
  Atom[]  atomSet_$Men ;
  Category  category_N$V$Adj$Det ;
  Word  word_Human ;
  Word  word_Woman ;
  Atom  atom_$Men ;
  Word  word_Man ;
  Word[]  wordSet_Gen ;
  Word[]  wordSet_Biology ;
  Word  word_Gen ;
  String[]  pattern_A$N$T$I ;
  Word[]  wordSet_Anticipation$An_Etc ;
  String[]  pattern_A$N$T$E ;
  String[]  pattern_P$R$E ;
  Word[]  wordSet_Prereconstructi_Etc ;
  String[]  pattern_P$R$O ;
  Word[]  wordSet_Probation$Produ_Etc ;
  String[]  pattern_S$E$M$I ;
  String[]  pattern_A$M$B$I$T$I$O$N ;
  String[]  pattern_A$U$C$T$I$O$N ;
  String[]  pattern_A$U$D$I$T$I$O$N ;
  String[]  pattern_C$A$P$T$I$O$N ;
  String[]  pattern_C$A$U$T$I$O$N ;
  String[]  pattern_C$O$N$D$I$T$I$O_Etc ;
  String[]  pattern_C$O$N$F$E$C$T$I_Etc ;
  String[]  pattern_F$R$A$C$T$I$O$N ;
  String[]  pattern_F$U$N$C$T$I$O$N ;
  String[]  pattern_M$E$N$T$I$O$N ;
  String[]  pattern_M$O$T$I$O$N ;
  String[]  pattern_M$U$N$I$T$I$O$N ;
  String[]  pattern_P$A$R$T$I$T$I$O_Etc ;
  String[]  pattern_P$E$T$I$T$I$O$N ;
  String[]  pattern_P$O$R$T$I$O$N ;
  String[]  pattern_P$O$S$I$T$I$O$N ;
  String[]  pattern_Q$U$E$S$T$I$O$N ;
  String[]  pattern_R$E$Q$U$I$S$I$T_Etc ;
  String[]  pattern_S$A$N$C$T$I$O$N ;
  String[]  pattern_S$T$A$T$I$O$N ;
  String[]  pattern_V$A$C$A$T$I$O$N ;
  Word  word_Tion ;
  Word[]  wordSet_Un$Non ;
  Word[]  wordSet_En ;
  Word[]  wordSet_Ician ;
  Word[]  wordSet_Ian ;
  Word[]  wordSet_Arian ;
  Word[]  wordSet_An ;
  Word  word_Age ;
  Word  word_Generation ;
  Word  word_Ian ;
  Category  categorySet_Nn$V$Adj$Pron ;
  Word[]  wordSet_Er ;
  Word  word_An ;
  Category  categorySet_Malefirstname$L_Etc ;
  Word[]  wordSet_Son ;
  Word  word_Son ;
  Word[]  wordSet_Sen ;
  Word  word_Sen ;
  Word  word_Don ;
  Word[]  wordSet_In ;
  Word  word_In ;
  String[]  pattern_V$E$R$M ;
  Category  categorySet_Prefix$Adj$Anyn ;
  Category  category_Unit ;
  Atom  atom_Ntakespreps ;
  Word[]  wordSet_Of ;
  Word  word_Unit ;
  Word  word_Unit_Of_Countin_Etc ;
  Word[]  wordSet_Illion ;
  Atom[]  atomSet_Ier$Iest ;
  Atom[]  atomSet_Ier$Iest$Er$Est_Etc ;
  Atom  atom_Comparative ;
  Atom[]  atomSet_Ier$Iest$Er$Est_Etc$ ;
  Word  word_30 ;
  Atom  atom_From ;
  Word  word_Ier ;
  Category  categorySet_Adj$Nn$Prefix ;
  Word[]  wordSet_Opter ;
  Category  category_Ncm ;
  Word  word_Flyer ;
  Word[]  wordSet_Bacter ;
  Word  word_Bacterium ;
  Word[]  wordSet_Mer ;
  Word  word_Molecule ;
  Word  word_Owner ;
  Word  word_Setter ;
  Atom  atom_Entails ;
  Word  word_Meter ;
  Category  categorySet_Malefirstname$F_Etc ;
  Word[]  wordSet_Dotter ;
  Word  word_Dotter ;
  Category  categorySet_Lastname$Name ;
  Word[]  wordSet_Heimer ;
  Word  word_Heimer ;
  Word[]  wordSet_Macher ;
  String[]  pattern_A$N$A ;
  String[]  pattern_C$O$N ;
  String[]  pattern_D$E ;
  String[]  pattern_D$I ;
  String[]  pattern_E$X ;
  Category  category_Nn ;
  Category  categorySet_Adv$Adj ;
  Category  categorySet_Vt ;
  Word  word_R ;
  Word  word_Er ;
  Word  word_Ster ;
  Category  categorySet_V$Nn ;
  Atom[]  atomSet_$Er$$Est$Er$Est ;
  Atom[]  atomSet_S$$Ed$S$Ed$$Ed$_Etc ;
  Word  word_Eer ;
  String[]  pattern_I$E ;
  Atom[]  atomSet_Er$Est ;
  Atom[]  atomSet_Ier$Iest$Er$Est_Etc$$ ;
  Atom[]  atomSet_R$St ;
  Atom[]  atomSet_Ker$Kest$Er$Est ;
  String[]  pattern_Any$$$Any ;
  String[]  pattern_E$Y ;
  Atom  atom_British ;
  Word  word_Color ;
  Word  word_$N$Color ;
  Word  word_$V$Color ;
  Word  word_$Adj$Colored ;
  Word  word_Ar ;
  Word  word_Eur ;
  Word  word_Or ;
  Word  word_Tor ;
  Word  word_Error ;
  Word  word_Manager ;
  Category  category_V$Nn ;
  Atom  atom_2sg ;
  Atom  atom_Archaic ;
  Category  categorySet_Past ;
  Word  word_Ment ;
  Word  word_Most ;
  Word[]  wordSet_Anti$Over$Pro$U_Etc ;
  Word  word_Ant ;
  Category  categorySet_V$Adj ;
  Word  word_Ent ;
  String[]  pattern_$R_S$ ;
  Word  word_Ient ;
  Category  categorySet_Anyn$Adj$Prep$C_Etc ;
  Word  word_Left ;
  Word[]  wordSet_Left ;
  Category  categorySet_Nsg ;
  Word[]  wordSet_Naut ;
  Word  word_Naut ;
  Word[]  wordSet_Stat ;
  Word  word_Stat ;
  Word  word_Ist ;
  Category  categorySet_Anyn$Adj$Anyn ;
  String[]  pattern_Y$Y ;
  Category  categorySet_Anyn$Adj$V$Prep_Etc ;
  Word  word_List ;
  Word  word_Let ;
  Category  category_N$V$Adj ;
  Category  category_Adj$N ;
  Word[]  wordSet_Russian ;
  Word  word_Cy ;
  Word[]  wordSet_Morphy ;
  Atom  atom_$Ies ;
  Word[]  wordSet_Pathy ;
  Word[]  wordSet_Trophy ;
  Word[]  wordSet_Y ;
  Word[]  wordSet_Phagy ;
  Word  word_Phagy ;
  Word[]  wordSet_Phony ;
  Word[]  wordSet_Megaly ;
  Word[]  wordSet_Cephaly ;
  Word  word_Y ;
  Word  word_Ry ;
  Word[]  wordSet_Ography ;
  Word[]  wordSet_Graphy ;
  Word[]  wordSet_Ology ;
  Category  categorySet_Npl ;
  Word  word_Shape ;
  Word[]  wordSet_Ognomy ;
  Word[]  wordSet_Nomy ;
  Word  word_Ognomy ;
  Word  word_Operation ;
  Word[]  wordSet_Otomy ;
  Word  word_Otomy ;
  Word[]  wordSet_Ostomy ;
  Word  word_Ostomy ;
  Word[]  wordSet_Ectomy ;
  Word[]  wordSet_Tropy ;
  Word  word_Examination ;
  Word[]  wordSet_Oscopy ;
  Word[]  wordSet_Scopy ;
  Word[]  wordSet_Gamy ;
  Word[]  wordSet_Taxy ;
  Word[]  wordSet_De$Non$Re$Un ;
  Category  categorySet_Nn$V$Adj$Prefix ;
  Word  word_Gamy ;
  Word  word_Taxy ;
  Word[]  wordSet_Ogony ;
  Word[]  wordSet_Ogeny ;
  Word  word_Ogeny ;
  Word  word_Worship ;
  Word[]  wordSet_Olatry ;
  Word  word_Marital_Practic_Etc ;
  Word[]  wordSet_Andry ;
  Word  word_Measurement ;
  Word[]  wordSet_Metry ;
  Word  word_Ly ;
  Word[]  wordSet_Anti$Over$Pro$U_Etc$ ;
  Word  word_Ery ;
  Word[]  wordSet_Ify ;
  Atom  atom_Ies$Ied ;
  Word[]  wordSet_Un$Non$Over$Und_Etc ;
  Category  categorySet_Prespart ;
  Word[]  wordSet_Able$Al$Ant$Ar$_Etc ;
  Word  word_Ity ;
  Word  word_Ability ;
  Word  word_Icity ;
  Word  word_Ality ;
  Word  word_Ility ;
  String[]  pattern_Y ;
  Word[]  wordSet_Berry$$N$Plant$_Etc ;
  Word  word_Berry ;
  Category  category_Firstname ;
  Word  word_Ency ;
  Category  categorySet_Adj$V ;
  Word  word_Ary ;
  String[]  pattern_C$T ;
  Word  word_Metry ;
  String[]  pattern_A$E$R ;
  Word  word_Sy ;
  Word  word_Ory ;
  Word  word_Atory ;
  Word[]  wordSet_Ply ;
  Category  category_V$Adj$N ;
  Word  word_$N$Fly ;
  Word  word_Family ;
  Word  word_Ancy ;
  Word  word_$N$Oscopy$Exami_Etc ;
  Atom  atom_Scalar ;
  Atom  atom_Ier$Iest ;
  Word[]  wordSet_Ity ;
  Word[]  wordSet_A$An$Dis$In$Im$_Etc ;
  Word  word_Antic ;
  Word  word_Etic ;
  Word  word_Acetic ;
  Word[]  wordSet_Acetic ;
  Word  word_Atic ;
  Word  word_Istic ;
  Word  word_Otic ;
  Category  categorySet_Np ;
  Word[]  wordSet_Otic ;
  Word[]  wordSet_In$Im$Non$Un ;
  Word[]  wordSet_Iac ;
  Word  word_Scope ;
  Word  word_Scopic ;
  Category  categorySet_Prefix$Adj ;
  Word[]  wordSet_Tropic ;
  Word[]  wordSet_Zoic ;
  Word  word_$N$Era$Time_Per_Etc ;
  Atom  atom_Unique ;
  Atom[]  atomSet_$Ata ;
  Category  categorySet_Country$Npr ;
  Word[]  wordSet_I ;
  Word[]  wordSet_Alum$Bum$Bunkum_Etc ;
  String[]  pattern_T$I$O$N ;
  Word  word_Fish ;
  Word  word_Skill ;
  Word[]  wordSet_Ship ;
  Word  word_Role ;
  Word  word_Proof ;
  Word[]  wordSet_Proof ;
  Word  word_Speak ;
  Word[]  wordSet_Speak ;
  Word  word_Technical_Langu_Etc ;
  Word  word_Talk ;
  Word  word_Jargon ;
  Word[]  wordSet_Ia ;
  Word[]  wordSet_Zoa ;
  Word  word_Zoa ;
  Word[]  wordSet_Trix ;
  Atom  atom_$Ces ;
  Word[]  wordSet_Branch ;
  Word  word_Branch ;
  Category  category_Ord ;
  Word  word_Ordinal ;
  Word[]  wordSet_Th ;
  Word  word_Position ;
  Category  categorySet_City$Country ;
  Word  word_Country ;
  Atom  atom_Has$Root ;
  Atom[]  atomSet_$Apostrophe$S$$_Etc ;
  Atom  atom_$I ;
  Word[]  wordSet_Tion ;
  Word[]  wordSet_Ation ;
  Category  categorySet_V$Adj$Anyn ;
  Word  word_Ication ;
  Category  category_V$Adj ;
  Atom  atom_Superlative ;
  Word[]  wordSet_Iform ;
  Word[]  wordSet_Anti$Bi$Centi$D_Etc ;
  Word  word_Bodypart ;
  Word[]  wordSet_Itis ;
  Atom  atom_Es$Ed ;
  Atom  atom_S$$Ed ;
  Atom  atom_More$Most ;
  Atom  atom_S$Ked ;
  Category  category_Name ;
  Word[]  wordSet_An$Ism$Ist$Ity$_Etc ;
  Category  categorySet_Adj$N ;
  Word[]  wordSet_Ism$Ist$Ity$Tio_Etc ;
  Category  categorySet_Vi ;
  Category  categorySet_Special$Qword$D_Etc ;
  Atom  feature_Abbrev ;
  Category  category_Vi ;
  Category  categorySet_Special$Qword$D_Etc$ ;
  Category  categorySet_N ;
  Word[]  wordSet_Ic$Atic$Al$Ar$O_Etc ;
  Word[]  wordSet_Ic$Atic ;
  Category  categorySet_Unit ;
  String[]  pattern_I$C ;
  String[]  pattern_A$$L_R$ ;
  String[]  pattern_O$S$E ;
  Word[]  wordSet_Ache ;
  Category  categorySet_Prep ;
  Category  categorySet_Adj$Nn$Suffix ;
  Category  categorySet_Adj$N$Suffix ;
  Category  categorySet_Prespart$Pastpa_Etc$ ;
  Word[]  wordSet_Fish ;
  Word  word_Fish_Bodypart ;
  Word[]  wordSet_Bird ;
  Word  word_Bird_Bodypart ;
  Category  categorySet_Suffix ;
  Word[]  wordSet_Bodypart ;
  Word[]  wordSet_Animal ;
  Category  categorySet_Pastpart ;
  Word[]  wordSet_A$Co$De$In$No$U_Etc ;
  Word  word_Separate ;
  Word  word_From ;
  Word[]  wordSet_E$Ve$En ;
  Word  word_$Adv$Down ;
  Category  categorySet_Pastpart$Prespa_Etc ;
  Word  word_En ;
  Word  word_$Vt$Change ;
  String[]  pattern_E$N ;
  Word[]  wordSet_Em ;
  Word[]  wordSet_Ter ;
  String[]  pattern_C$I$T$Y ;
  String[]  pattern_E$S$Q$U$E ;
  Word[]  wordSet_Ism$Ist$Ity$Tio_Etc$ ;
  Category  categorySet_Adv$Anyn ;
  Category  categorySet_Adv$N ;
  Word  word_Not ;
  Category  categorySet_Adj$N$Adv ;
  Category  categorySet_N$V$Adj ;
  Word  word_Surpass ;
  Word[]  wordSet_Al ;
  Word[]  wordSet_Ism$Ist$Ity$Tio_Etc$$ ;
  Category  categorySet_Nn$Adj$Adv ;
  Word  word_Exceed ;
  Category  categorySet_Adv$Nn ;
  Category  categorySet_Adj$Adv$Nn$V ;
  Word[]  wordSet_Ness ;
  Category  categorySet_Name ;
  Word[]  wordSet_Ise$Ize$Ate$En$_Etc ;
  String[]  pattern_I$$S_Z$$E ;
  String[]  pattern_A$T$E ;
  Word  word_$V$Redo ;
  Word  word_$V$Repeat ;
  Word  word_Re$ ;
  Word[]  wordSet_$V$Redo$$V$Repe_Etc ;
  Category  categorySet_N$Adj ;
  Word  word_Semi ;
  Value[]  dictStruct_$Prob_50$ ;
  Word  word_$N$Relative$Per_Etc ;
  Word  word_Half ;
  Word[]  wordSet_Ar ;
  Word  word_$V$Separate ;
  Word  word_Non ;
  Word[]  wordSet_Ism$Ist$Ity$Tio_Etc$$$ ;
  Word  word_$Adv$Up ;
  String[]  pattern_T$Y ;
  Word[]  wordSet_Fitz ;
  Word  word_Fitz ;
  Category  category_Integer ;
  Category  category_Prep ;
  Word[]  wordSet_A$Ad$Ar$De$En$E_Etc ;
  Word  word_To ;
  Word[]  wordSet_For ;
  Word[]  wordSet_Be$Have ;
  Word  word_Type ;
  Category  categorySet_Npr$Adj ;
  Word[]  wordSet_And$Or ;
  Word[]  wordSet_De$Re ;
  Category  categorySet_Prespart$Nm ;
  Word[]  wordSet_Self ;
  Word[]  wordSet_All$Many$So$Too ;
  Category  categorySet_Comparative ;
  Word[]  wordSet_East$North$Sout_Etc ;
  Word  word_Compass_Directi_Etc ;
  Word[]  wordSet_North$South ;
  Word[]  wordSet_East$West ;
  Category  category_Adj$Pred ;
  Category  category_Adv$Pred ;
  Word  word_To$Be ;
  Word  word_Future ;
  Word[]  wordSet_To$Be ;
  Word[]  wordSet_To ;
  Word  word_Out ;
  Atom  atom_Inflects$At ;
  Atom  atom_Able$Rule ;
  Word[]  wordSet_Who$What$When$W_Etc ;
  String[]  stringArray_$$_ ;
  Category  categorySet_Anyn$Adj ;
  Category  categorySet_Adj$Adv ;
  Word[]  wordSet_Man$Is$Are$Am$W_Etc ;
  Word[]  wordSet_As$Bare ;
  Word[]  wordSet_See$Saw ;
  Word[]  wordSet_$N$Fish ;
  Word[]  wordSet_$N$Bird ;
  Word[]  wordSet_$Nc$Plant$Veget_Etc ;
  Word  word_Part_Of_Plant ;
  String[]  pattern_S ;
  Word[]  wordSet_$N$Animal ;
  Category  categorySet_Npr$Number ;
  String[]  pattern_L$Y ;
  Category  categorySet_Adv$Prep ;
  Category  categorySet_Anyn$V$Adj$Adv$_Etc ;
  Category  categorySet_Nn$V$Adj$Prefix_Etc ;
  Word[]  wordSet_Bare ;
  Word[]  wordSet_Man ;
  Category  categorySet_V$Adj$Prefix ;
  Category  categorySet_Prespart$Pastpa_Etc$$ ;
  Category  categorySet_Anyn$Prespart ;
  Category  categorySet_Comparative$Sup_Etc ;
  Category  categorySet_Malefirstname ;
  Category  category_Malefirstname ;
  Word  word_Fraction ;
  Atom  atom_Denominator ;
  Word[]  wordSet_Ndth ;
  Category  category_Number ;
  Word[]  wordSet_St ;
  Word[]  wordSet_Nd ;
  Word[]  wordSet_Rd ;
  Word[]  wordSet_Ndths ;
  Word[]  wordSet_Ths ;
  Word[]  wordSet_Sts ;
  Word[]  wordSet_Nds ;
  Word[]  wordSet_Rds ;
  Atom[]  atomSet_$Es ;
  Atom[]  atomSet_Nopl$Unique ;
  Category  categorySet_Npr$Lastname$Fi_Etc ;
  Atom[]  atomSet_S$D$S$Ed$S$Ked$_Etc ;
  Atom[]  atomSet_Es$Ed$Es$$Ed$Es_Etc$$$ ;
  Atom[]  atomSet_S$Ked ;
  Atom[]  atomSet_S$Ed$Es$Ed ;
  Atom[]  atomSet_S$$Ed$Es$$Ed$$E_Etc$$ ;
  Category  categorySet_V$Anyn$Adj ;
  Atom[]  atomSet_Es$Ed$S$Ed ;
  Atom[]  atomSet_$Es$$Ed$Es$$Ed$_Etc ;
  Atom[]  atomSet_Ker$Kest ;
  Atom[]  atomSet_$Er$$Est ;
//  fake morph variable bindings
// pmartin 8 may 01

// waw 2004-05-13 commented out bindings of sp_consonantChars and sp_vowelChars
// waw 2004-05-10 commented out binding of sp_adjPrefixes and sp_quantityPrefixes
//  and sp_adjFormingPrefixes and sp_rulePrefixes
// waw 2004-05-09 commented out binding of sp_chemPrefixes and sp_chemicalSuffixes
// waw&pm 2004-04-08 merged two diverged versions
// adjusted to use HashSet -- pm 06apr04
// waw 03-29-04 moves some variables to MorphEngFns and Morph_Template_en

/* prefixes that form adjectives and not verbs. */
//protected static HashSet sp_adjPrefixes; //waw 05-10-04 bound in MorphEngFrame
//static Lexicon.Word[] sp_adjPrefixes;
//protected static HashSet sp_quantityPrefixes = new HashSet(100); 
///static Lexicon.Word[] sp_quantityPrefixes; //waw 05-10-04 bound in MorphEngFrame

static boolean sp_guessVerbFlag;

/** minimum length for a component of a lexical compound.*/
static int sp_minimumCompoundLength; 


// plus more 16may01


//protected HashSet sp_rulePrefixes; waw bound in MorphEngFrame 04-08-04
//static Lexicon.Word[] sp_rulePrefixes;

// plus 17may01 additions
static boolean sp_skipVerbForHyphenatedParticiples;

/**  prefixes that turn nouns into adjectives */
//protected HashSet sp_adjFormingPrefixes; 
//static Lexicon.Word[] sp_adjFormingPrefixes;

static boolean sp_inflectManMenFlag;

/// plus more from "chemistrySet" 18july01

static boolean  sp_strongChemTestFlag;

/* common garden path or misleading words when analyzing chemical names. */
//protected static HashSet sp_nonChemicalConstituents;
///static Lexicon.Word[]  sp_nonChemicalConstituents;

/* prefixes that force adjectives in chemical-name-test. */
//protected static HashSet sp_chemPrefixes; //was 05-09-04 now use chemPrefixes
////static Lexicon.Word[]  sp_chemPrefixes;

/* suffixes permitted as rightmost in chemical names. */
//protected static HashSet sp_chemicalSuffixes;
////static Lexicon.Word[]  sp_chemicalSuffixes;

static  Word  word_Ate;
/////static  Lexicon.Word  word_Chemical;
/////static  Lexicon.Word  word_Chemistry;
static  Word  word_ChemNamePart;
static  Word[]  wholeChemicalWords;
static  Word[]  majorChemicalWords;

static  Atom  atom_ChemicalNameTest;
static  Atom  feature_Derivation;
static  Atom  feature_Domain;
static  Atom  feature_Sense$Kinds;

static Category category_Past;
static Category category_PastPart;
static Category category_Suffix;
static Category category_Prefix$Suffix;
static Category category_N$Adj$Prefix$Suffix;

static Atom[] atomSet_S$D$$S;
static String[] sp_barredChemicalEndings;

////////////
////////// plus constants needed for inflection code choosers
//////////////////////////////


//static String sp_consonantChars;
//static String sp_vowelChars;

///////////////////////////////////////////////////////
// plus a hack to cover "word" which should be "lex"

static Word word;

//// plus new atoms to label the switching in handmade morph base code...
//// 2feb03  Pmartin
//////////////////
// protected Lexicon.Atom atom_ableRule;
// protected Lexicon.Atom atom_adverbRule;
// protected Lexicon.Atom atom_comparativeRule;
// protected Lexicon.Atom atom_defaultRule;
// protected Lexicon.Atom atom_doerRule;
// protected Lexicon.Atom atom_ingRule;
// protected Lexicon.Atom atom_lexicalPrefixRules;
// protected Lexicon.Atom atom_morphCompoundRules;
// protected Lexicon.Atom atom_nessRule;
// protected Lexicon.Atom atom_ordinalRules;
// protected Lexicon.Atom atom_pastRule;
// protected Lexicon.Atom atom_pluralRule;
// protected Lexicon.Atom atom_superlativeRule;
// protected Lexicon.Atom atom_thirdSingRule;

// protected Lexicon.Atom atom_morphDispatch;
// protected Lexicon.Atom atom_prefixDispatch;

// protected Lexicon.Atom atom_aPrefixes;
// protected Lexicon.Atom atom_bPrefixes;
// protected Lexicon.Atom atom_cPrefixes;
// protected Lexicon.Atom atom_dPrefixes;
// protected Lexicon.Atom atom_ePrefixes;
// protected Lexicon.Atom atom_hPrefixes;
// protected Lexicon.Atom atom_iPrefixes;
// protected Lexicon.Atom atom_mPrefixes;
// protected Lexicon.Atom atom_miscPrefixes;
// protected Lexicon.Atom atom_oPrefixes;
// protected Lexicon.Atom atom_nPrefixes;
// protected Lexicon.Atom atom_pPrefixes;
// protected Lexicon.Atom atom_rPrefixes;
// protected Lexicon.Atom atom_sPrefixes;
// protected Lexicon.Atom atom_tPrefixes;
// protected Lexicon.Atom atom_uPrefixes;

// protected Lexicon.Atom atom_cBlock;
// protected Lexicon.Atom atom_dBlock;
// protected Lexicon.Atom atom_eBlock;
// protected Lexicon.Atom atom_estBlock;
// protected Lexicon.Atom atom_gBlock;
// protected Lexicon.Atom atom_iformBlock;
// protected Lexicon.Atom atom_lBlock;
// protected Lexicon.Atom atom_mBlock;
// protected Lexicon.Atom atom_miscBlock;
// protected Lexicon.Atom atom_nBlock;
// protected Lexicon.Atom atom_rBlock;
// protected Lexicon.Atom atom_sBlock;
// protected Lexicon.Atom atom_tBlock;
// protected Lexicon.Atom atom_tionBlock;
// protected Lexicon.Atom atom_yBlock;

///// end of new atoms from 2feb03
/////////////////////////////////////////
// end of Lisp-generated word binding declarations


  /**
   * For identifying class when debugging or tracing rules.
   */

  protected static String className = "Morph_en";

} // end of Morph_en class
