/*
 * Copyright 2007-2008 Sun Microsystems, Inc. All Rights Reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER
 * 
 * This code is free software; you can redistribute it and/or modify
 * it under the terms of the GNU General Public License version 2
 * only, as published by the Free Software Foundation.
 * 
 * This code is distributed in the hope that it will be useful, but
 * WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
 * General Public License version 2 for more details (a copy is
 * included in the LICENSE file that accompanied this code).
 * 
 * You should have received a copy of the GNU General Public License
 * version 2 along with this work; if not, write to the Free Software
 * Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA
 * 02110-1301 USA
 * 
 * Please contact Sun Microsystems, Inc., 16 Network Circle, Menlo
 * Park, CA 94025 or visit www.sun.com if you need additional
 * information or have any questions.
 */

package com.sun.labs.minion.retrieval;

import com.sun.labs.minion.indexer.postings.PostingsIterator;

/**
 * A subclass of ArrayGroup that is used to represent negative results
 * sets. That is, a set where the contents of the set is everything except
 * the documents contained in the array. Such a set can be generated by a
 * <code>&lt;not&gt;</code> operator, or by combining negative and
 * non-negative sets using certain boolean operators.
 *
 * <p>
 *
 * Negative sets do not have any scores associated with the documents they
 * contain.
 */
public class NegativeGroup extends ArrayGroup {

    protected NegativeGroup() {
    }
    
    /**
     * Constructs a negative group from the given group.
     */
    protected NegativeGroup(ArrayGroup ag) {
        init(ag);
    } // NegativeGroup constructor

    /**
     * Constructs a negative group from the given set of documents.  This
     * should be used only for testing purposes!
     */
    protected NegativeGroup(int[] docs, int l) {
        super(docs, l);
    }

    /**
     * Gets a strict version of this array group, which just returns this
     * group as an array group.
     *
     * @return A strict group containing the same documents as this group.
     */
    @Override
    public ArrayGroup getStrict() {
        return new ArrayGroup(this);
    }

    /**
     * Gets a negative version of this group.
     *
     * @return A negative version of this group, which must therefore be
     * positive.  We return an instance of <code>ArrayGroup</code>, since
     * there are no scores associated with the documents in a negative set.
     */
    @Override
    public ArrayGroup getNegative() {
        return new ArrayGroup(this);
    }
    
    /**
     * Returns the size of this set.
     */
    @Override
    public int getSize() {
        return part.getNDocs() - size;
    }

    /**
     * Intersects the documents generated by the term with the ones in this
     * group.
     *
     * @param t The term to intersect with the current set.
     * @return The result of intersecting the given term with this set.
     * The static type of the result is determined by a combination of the
     * types of the groups being combined and the current query status.
     */
    @Override
    public ArrayGroup intersect(QueryTerm t) {

        //
        // Since we'll need to look at mostly everything anyways, go ahead
        // and eval the set for the term and then do the intersection.
        boolean saveStrict = t.strictEval;
        t.strictEval = true;
        ArrayGroup ret = intersect(t.eval(null));
        t.strictEval = saveStrict;
        return ret;
    }

    /**
     * Intersects a postings iterator with this group, destructively.  This
     * needs to switch the polarity of the group.
     */
    @Override
    public ArrayGroup destructiveIntersect(PostingsIterator pi) {
        ArrayGroup ag = new ArrayGroup(pi);
        return ag.intersect(this);
    }

    /**
     * Union a strict group with this group.
     *
     * @param ag The scored group to union with this group.
     * @return The result of unioning the given group with this group.
     */
    @Override
    public ArrayGroup agUnion(ArrayGroup ag) {
        return ag.union(this);
    }
    
    /**
     * Union a scored group with this group.  We'll use DeMorgan's Laws to
     * turn this into an intersection.
     *
     * @param ag The scored group to union with this group.
     * @return The result of unioning the given group with this group.
     */
    @Override
    public ArrayGroup union(ScoredGroup ag) {
        return getStrict().intersect(ag.getNegative()).getNegative();
    }	

    /**
     * Union a negative group with this group.  We'll use DeMorgan's Laws
     * to turn this into an intersection.
     *
     * @param ag The scored group to union with this group.
     * @return The result of unioning the given group with this group.
     */
    @Override
    public ArrayGroup union(NegativeGroup ag) {
        return getStrict().intersect(ag.getStrict()).getNegative();
    }
    
    /**
     * Intersects a strict group with this group.  We simply use the
     * intersect method from <code>StrictGroup</code>.
     *
     * @param ag The scored group to intersect with this group.
     * @return The result of intersecting the given group with this group.
     * An instance of <code>StrictGroup</code> is returned.
     */
    @Override
    public ArrayGroup agIntersect(ArrayGroup ag) {
        return ag.intersect(this);
    }
	
    /**
     * Intersects a scored group with this group.  We simply use the scored
     * group intersection.
     *
     * @param ag The scored group to intersect with this group.
     * @return The result of intersecting the given group with this group.
     * An instance of <code>ScoredGroup</code> is returned.
     */
    @Override
    public ArrayGroup intersect(ScoredGroup ag) {
        return ag.intersect(this);
    }	
	
    /**
     * Intersect a negative group with this group.  Uses DeMorgan's Law to
     * transform this into a union operation.
     *
     * @param ag The scored group to intersect with this group.
     * @return The result of intersecting the given group with this group.
     * An instance of <code>NegativeGroup</code> is returned.
     */
    @Override
    public ArrayGroup intersect(NegativeGroup ag) {
        return getStrict().union(ag.getStrict()).getNegative();
    }
    

    /**
     * Gets an iterator that will return each document in the set.
     */
    @Override
    public DocIterator iterator() {
        return new NegativeDocIterator();
    }

    /**
     * Tests two negative groups for equality.  Two groups are equal if
     * they contain exactly the same set of documents.  A negative group
     * can only be equal to another negative group.
     *
     * @return <code>true</code> if the groups contain the same documents,
     * <code>false</code> otherwise.
     */
    @Override
    public boolean equals(Object o) {
        if(!(o instanceof NegativeGroup)) {
            return false;
        }
        return super.equals(o);
    }
    
    @Override
    public String toString() {
        return super.toString() + " (negative)";
    }

    /**
     * A class containing an iterator for the documents in this group.  Or,
     * more to the point, the documents <em>not</em> in this group.
     */
    protected class NegativeDocIterator extends DocIterator {

        /**
         * The current document.
         */
        protected int currDoc;

        /**
         * The number of docs in the partition.
         */
        protected int partDocs;

        public NegativeDocIterator() {
            pos = 0;
            currDoc = 0;
            partDocs = part.getMaxDocumentID();
        }
        
        /**
         * Advance to the next document ID in the set, skipping deleted
         * documents.
         *
         * @return <code>true</code> if there is a next position,
         * <code>false</code> otherwise.
         */
        @Override
        public boolean next() {
            currDoc++;
            
            //
            // Special case when there are no documents in the set.
            if(docs == null) {
                while(currDoc <= partDocs && part.isDeleted(currDoc)) {
                    currDoc++;
                }
                
                return currDoc <= partDocs;
            }
            
            //
            // Loop through the documents that we have looking for a non-deleted 
            // one that's in the set.
            while(currDoc <= partDocs && pos < size) {
                
                while(pos < size &&
                      currDoc == docs[pos]) {
                    currDoc++;
                    pos++;
                }

                while((pos < size && currDoc < docs[pos]) ||
                      currDoc <= partDocs) {
                    if(!part.isDeleted(currDoc)) {
                        return true;
                    }
                    currDoc++;
                }
            }

            return false;
        }

        /**
         * Gets the document at the head of the iterator.
         */
        @Override
        public int getDoc() {
            return currDoc;
        }
    }
} // NegativeGroup
